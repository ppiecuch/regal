#!/usr/bin/python -B

from string import Template, upper, replace

from ApiUtil import outputCode
from ApiUtil import toLong
from ApiUtil import hexValue

tokenSourceTemplate = Template( '''${AUTOGENERATED}
${LICENSE}

#include "pch.h" /* For MS precompiled header support */

#include "RegalUtil.h"

REGAL_GLOBAL_BEGIN

#include "RegalPrivate.h"
#include "RegalToken.h"

#include <boost/print/string_list.hpp>
#include <boost/print/print_string.hpp>

using namespace ::boost::print;

REGAL_GLOBAL_END

REGAL_NAMESPACE_BEGIN

namespace Token {

  const char * GLbooleanToString(GLboolean v)
  {
    return v==GL_FALSE ? "GL_FALSE" : "GL_TRUE";
  }

  const char * internalFormatToString(GLint v)
  {
    const char *integer[5] = { "", "1", "2", "3", "4" };
    return 1<=v && v<=4 ? integer[v] : GLenumToString(v);
  }

  std::string
  GLtextureToString(GLenum v)
  {
    if (v>=GL_TEXTURE0 && v<=GL_TEXTURE31)
      return GLenumToString(v);

    return print_string("0x",hex(v));
  }

  std::string
  GLmodeToString(GLenum primitive)
  {
    switch (primitive)
    {
      case GL_AMBIENT:
      case GL_AMBIENT_AND_DIFFUSE:
      case GL_BACK:
      case GL_BACK_LEFT:
      case GL_BACK_RIGHT:
      case GL_CCW:
      case GL_COLOR:
      case GL_COLOR_ATTACHMENT0:
      case GL_COLOR_ATTACHMENT1:
      case GL_COLOR_ATTACHMENT10:
      case GL_COLOR_ATTACHMENT11:
      case GL_COLOR_ATTACHMENT12:
      case GL_COLOR_ATTACHMENT13:
      case GL_COLOR_ATTACHMENT14:
      case GL_COLOR_ATTACHMENT15:
      case GL_COLOR_ATTACHMENT2:
      case GL_COLOR_ATTACHMENT3:
      case GL_COLOR_ATTACHMENT4:
      case GL_COLOR_ATTACHMENT5:
      case GL_COLOR_ATTACHMENT6:
      case GL_COLOR_ATTACHMENT7:
      case GL_COLOR_ATTACHMENT8:
      case GL_COLOR_ATTACHMENT9:
      case GL_COMPILE:
      case GL_COMPILE_AND_EXECUTE:
      case GL_CONTINUOUS_AMD:
      case GL_CW:
      case GL_DIFFUSE:
      case GL_DISCRETE_AMD:
      case GL_DONT_CARE:
      case GL_EMISSION:
      case GL_FASTEST:
      case GL_FEEDBACK:
      case GL_FILL:
      case GL_FIRST_VERTEX_CONVENTION:
      case GL_FLAT:
      case GL_FRAGMENT_COLOR_EXT:
      case GL_FRAGMENT_MATERIAL_EXT:
      case GL_FRAGMENT_NORMAL_EXT:
      case GL_FRONT:
      case GL_FRONT_AND_BACK:
      case GL_FRONT_LEFT:
      case GL_FRONT_RIGHT:
      case GL_FUNC_ADD:
      case GL_FUNC_REVERSE_SUBTRACT:
      case GL_FUNC_SUBTRACT:
      case GL_INDEX_OFFSET:
      case GL_LAST_VERTEX_CONVENTION:
      case GL_LEFT:
      case GL_LINE:
      case GL_LINE_LOOP:
      case GL_LINE_STRIP:
      case GL_LINE_STRIP_ADJACENCY:
      case GL_LINES_ADJACENCY:
      case GL_MAX:
      case GL_MIN:
      case GL_MODELVIEW:
      case GL_NATIVE_GRAPHICS_BEGIN_HINT_PGI:
      case GL_NATIVE_GRAPHICS_END_HINT_PGI:
      case GL_NATIVE_GRAPHICS_HANDLE_PGI:
      case GL_NICEST:
      case GL_PATCHES:
      case GL_PERTURB_EXT:
      case GL_POINT:
      case GL_POLYGON:
      case GL_PREFER_DOUBLEBUFFER_HINT_PGI:
      case GL_PROJECTION:
      case GL_QUAD_MESH_SUN:
      case GL_QUAD_STRIP:
      case GL_QUADS:
      case GL_QUERY_BY_REGION_NO_WAIT:
      case GL_QUERY_BY_REGION_WAIT:
      case GL_QUERY_NO_WAIT:
      case GL_QUERY_WAIT:
      case GL_RECLAIM_MEMORY_HINT_PGI:
      case GL_RENDER:
      case GL_RIGHT:
      case GL_SELECT:
      case GL_SMOOTH:
      case GL_SPECULAR:
      case GL_TEXTURE:
      case GL_TEXTURE0:
      case GL_TEXTURE1:
      case GL_TEXTURE10:
      case GL_TEXTURE11:
      case GL_TEXTURE12:
      case GL_TEXTURE13:
      case GL_TEXTURE14:
      case GL_TEXTURE15:
      case GL_TEXTURE16:
      case GL_TEXTURE17:
      case GL_TEXTURE18:
      case GL_TEXTURE19:
      case GL_TEXTURE2:
      case GL_TEXTURE20:
      case GL_TEXTURE21:
      case GL_TEXTURE22:
      case GL_TEXTURE23:
      case GL_TEXTURE24:
      case GL_TEXTURE25:
      case GL_TEXTURE26:
      case GL_TEXTURE27:
      case GL_TEXTURE28:
      case GL_TEXTURE29:
      case GL_TEXTURE3:
      case GL_TEXTURE30:
      case GL_TEXTURE31:
      case GL_TEXTURE4:
      case GL_TEXTURE5:
      case GL_TEXTURE6:
      case GL_TEXTURE7:
      case GL_TEXTURE8:
      case GL_TEXTURE9:
      case GL_TRIANGLE_FAN:
      case GL_TRIANGLE_LIST_SUN:
      case GL_TRIANGLE_MESH_SUN:
      case GL_TRIANGLE_STRIP:
      case GL_TRIANGLE_STRIP_ADJACENCY:
      case GL_TRIANGLES:
      case GL_TRIANGLES_ADJACENCY:
                                       return GLenumToString(primitive);

      case GL_POINTS:                   return "GL_POINTS";
      case GL_LINES:                    return "GL_LINES";
      case GL_LOGIC_OP:                 return "GL_LOGIC_OP";

      default:                          return print_string("0x",hex(primitive));
    }
  }

  std::string GLblitFramebufferToString(GLbitfield v)
  {
    const GLbitfield other = v & ~(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);

    string_list<std::string> tmp;
    if (v & GL_COLOR_BUFFER_BIT)   { if (tmp.size()) tmp += " | "; tmp += "GL_COLOR_BUFFER_BIT"; }
    if (v & GL_DEPTH_BUFFER_BIT)   { if (tmp.size()) tmp += " | "; tmp += "GL_DEPTH_BUFFER_BIT"; }
    if (v & GL_STENCIL_BUFFER_BIT) { if (tmp.size()) tmp += " | "; tmp += "GL_STENCIL_BUFFER_BIT"; }
    if (other || v==0)             { if (tmp.size()) tmp += " | "; tmp += size_t(other); }

    return tmp.str();
  }

  // http://www.opengl.org/sdk/docs/man3/xhtml/glMapBufferRange.xml

  std::string GLbufferAccessToString(GLbitfield v)
  {
    const GLbitfield other = v & ~(GL_MAP_READ_BIT | GL_MAP_WRITE_BIT | GL_MAP_INVALIDATE_RANGE_BIT | GL_MAP_INVALIDATE_BUFFER_BIT | GL_MAP_FLUSH_EXPLICIT_BIT | GL_MAP_UNSYNCHRONIZED_BIT);

    string_list<std::string> tmp;
    if (v & GL_MAP_READ_BIT)              { if (tmp.size()) tmp += " | "; tmp += "GL_MAP_READ_BIT"; }
    if (v & GL_MAP_WRITE_BIT)             { if (tmp.size()) tmp += " | "; tmp += "GL_MAP_WRITE_BIT"; }
    if (v & GL_MAP_INVALIDATE_RANGE_BIT)  { if (tmp.size()) tmp += " | "; tmp += "GL_MAP_INVALIDATE_RANGE_BIT"; }
    if (v & GL_MAP_INVALIDATE_BUFFER_BIT) { if (tmp.size()) tmp += " | "; tmp += "GL_MAP_INVALIDATE_BUFFER_BIT"; }
    if (v & GL_MAP_FLUSH_EXPLICIT_BIT)    { if (tmp.size()) tmp += " | "; tmp += "GL_MAP_FLUSH_EXPLICIT_BIT"; }
    if (v & GL_MAP_UNSYNCHRONIZED_BIT)    { if (tmp.size()) tmp += " | "; tmp += "GL_MAP_UNSYNCHRONIZED_BIT"; }
    if (other || v==0)                    { if (tmp.size()) tmp += " | "; tmp += size_t(other); }

    return tmp.str();
  }

  std::string GLbufferStorageToString(GLbitfield v)
  {
    const GLbitfield other = v & ~(GL_DYNAMIC_STORAGE_BIT | GL_MAP_READ_BIT | GL_MAP_WRITE_BIT | GL_MAP_PERSISTENT_BIT | GL_MAP_COHERENT_BIT | GL_CLIENT_STORAGE_BIT);

    string_list<std::string> tmp;
    if (v & GL_DYNAMIC_STORAGE_BIT) { if (tmp.size()) tmp += " | "; tmp += "GL_DYNAMIC_STORAGE_BIT"; }
    if (v & GL_MAP_READ_BIT)        { if (tmp.size()) tmp += " | "; tmp += "GL_MAP_READ_BIT"; }
    if (v & GL_MAP_WRITE_BIT)       { if (tmp.size()) tmp += " | "; tmp += "GL_MAP_WRITE_BIT"; }
    if (v & GL_MAP_PERSISTENT_BIT)  { if (tmp.size()) tmp += " | "; tmp += "GL_MAP_PERSISTENT_BIT"; }
    if (v & GL_MAP_COHERENT_BIT)    { if (tmp.size()) tmp += " | "; tmp += "GL_MAP_COHERENT_BIT"; }
    if (v & GL_CLIENT_STORAGE_BIT)  { if (tmp.size()) tmp += " | "; tmp += "GL_CLIENT_STORAGE_BIT"; }
    if (other || v==0)              { if (tmp.size()) tmp += " | "; tmp += size_t(other); }

    return tmp.str();
  }

  std::string GLclearToString(GLbitfield v)
  {
    const GLbitfield other = v & ~(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);

    string_list<std::string> tmp;
    if (v & GL_COLOR_BUFFER_BIT)   { if (tmp.size()) tmp += " | "; tmp += "GL_COLOR_BUFFER_BIT"; }
    if (v & GL_DEPTH_BUFFER_BIT)   { if (tmp.size()) tmp += " | "; tmp += "GL_DEPTH_BUFFER_BIT"; }
    if (v & GL_STENCIL_BUFFER_BIT) { if (tmp.size()) tmp += " | "; tmp += "GL_STENCIL_BUFFER_BIT"; }
    if (other || v==0)             { if (tmp.size()) tmp += " | "; tmp += size_t(other); }

    return tmp.str();
  }

  std::string GLclientWaitSyncToString(GLbitfield v)
  {
    const GLbitfield other = v & ~(GL_SYNC_FLUSH_COMMANDS_BIT);

    string_list<std::string> tmp;
    if (v &  GL_SYNC_FLUSH_COMMANDS_BIT) { if (tmp.size()) tmp += " | "; tmp += " GL_SYNC_FLUSH_COMMANDS_BIT"; }
    if (other || v==0)                   { if (tmp.size()) tmp += " | "; tmp += size_t(other); }

    return tmp.str();
  }

  std::string GLfenceSyncToString(GLbitfield v)
  {
    const GLbitfield other = v & ~(GL_ZERO);

    string_list<std::string> tmp;
    if (v & GL_ZERO)   { if (tmp.size()) tmp += " | "; tmp += "GL_ZERO"; }
    if (other || v==0) { if (tmp.size()) tmp += " | "; tmp += size_t(other); }

    return tmp.str();
  }

  std::string GLmapBufferRangeToString(GLbitfield v)
  {
    const GLbitfield other = v & ~(GL_MAP_READ_BIT | GL_MAP_WRITE_BIT  | GL_MAP_INVALIDATE_RANGE_BIT | GL_MAP_INVALIDATE_BUFFER_BIT | GL_MAP_FLUSH_EXPLICIT_BIT | GL_MAP_UNSYNCHRONIZED_BIT);

    string_list<std::string> tmp;
    if (v & GL_MAP_READ_BIT)              { if (tmp.size()) tmp += " | "; tmp += "GL_MAP_READ_BIT"; }
    if (v & GL_MAP_WRITE_BIT)             { if (tmp.size()) tmp += " | "; tmp += "GL_MAP_WRITE_BIT"; }
    if (v & GL_MAP_INVALIDATE_RANGE_BIT)  { if (tmp.size()) tmp += " | "; tmp += "GL_MAP_INVALIDATE_RANGE_BIT"; }
    if (v & GL_MAP_INVALIDATE_BUFFER_BIT) { if (tmp.size()) tmp += " | "; tmp += "GL_MAP_INVALIDATE_BUFFER_BIT"; }
    if (v & GL_MAP_FLUSH_EXPLICIT_BIT)    { if (tmp.size()) tmp += " | "; tmp += "GL_MAP_FLUSH_EXPLICIT_BIT"; }
    if (v & GL_MAP_UNSYNCHRONIZED_BIT)    { if (tmp.size()) tmp += " | "; tmp += "GL_MAP_UNSYNCHRONIZED_BIT"; }
    if (other || v==0)                    { if (tmp.size()) tmp += " | "; tmp += size_t(other); }

    return tmp.str();
  }

  std::string GLmemoryBarrierToString(GLbitfield v)
  {
    if (v == GL_ALL_BARRIER_BITS)
      return std::string("GL_ALL_BARRIER_BITS");

    const GLbitfield other = v & ~(GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT | GL_ELEMENT_ARRAY_BARRIER_BIT |
                                   GL_UNIFORM_BARRIER_BIT | GL_TEXTURE_FETCH_BARRIER_BIT | GL_SHADER_IMAGE_ACCESS_BARRIER_BIT |
                                   GL_COMMAND_BARRIER_BIT | GL_PIXEL_BUFFER_BARRIER_BIT | GL_TEXTURE_UPDATE_BARRIER_BIT |
                                   GL_BUFFER_UPDATE_BARRIER_BIT | GL_FRAMEBUFFER_BARRIER_BIT | GL_TRANSFORM_FEEDBACK_BARRIER_BIT |
                                   GL_ATOMIC_COUNTER_BARRIER_BIT | GL_SHADER_STORAGE_BARRIER_BIT);

    string_list<std::string> tmp;
    if (v & GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT) { if (tmp.size()) tmp += " | "; tmp += "GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT"; }
    if (v & GL_ELEMENT_ARRAY_BARRIER_BIT)       { if (tmp.size()) tmp += " | "; tmp += "GL_ELEMENT_ARRAY_BARRIER_BIT"; }
    if (v & GL_UNIFORM_BARRIER_BIT)             { if (tmp.size()) tmp += " | "; tmp += "GL_UNIFORM_BARRIER_BIT"; }
    if (v & GL_TEXTURE_FETCH_BARRIER_BIT)       { if (tmp.size()) tmp += " | "; tmp += "GL_TEXTURE_FETCH_BARRIER_BIT"; }
    if (v & GL_SHADER_IMAGE_ACCESS_BARRIER_BIT) { if (tmp.size()) tmp += " | "; tmp += "GL_SHADER_IMAGE_ACCESS_BARRIER_BIT"; }
    if (v & GL_COMMAND_BARRIER_BIT)             { if (tmp.size()) tmp += " | "; tmp += "GL_COMMAND_BARRIER_BIT"; }
    if (v & GL_PIXEL_BUFFER_BARRIER_BIT)        { if (tmp.size()) tmp += " | "; tmp += "GL_PIXEL_BUFFER_BARRIER_BIT"; }
    if (v & GL_TEXTURE_UPDATE_BARRIER_BIT)      { if (tmp.size()) tmp += " | "; tmp += "GL_TEXTURE_UPDATE_BARRIER_BIT"; }
    if (v & GL_BUFFER_UPDATE_BARRIER_BIT)       { if (tmp.size()) tmp += " | "; tmp += "GL_BUFFER_UPDATE_BARRIER_BIT"; }
    if (v & GL_FRAMEBUFFER_BARRIER_BIT)         { if (tmp.size()) tmp += " | "; tmp += "GL_FRAMEBUFFER_BARRIER_BIT"; }
    if (v & GL_TRANSFORM_FEEDBACK_BARRIER_BIT)  { if (tmp.size()) tmp += " | "; tmp += "GL_TRANSFORM_FEEDBACK_BARRIER_BIT"; }
    if (v & GL_ATOMIC_COUNTER_BARRIER_BIT)      { if (tmp.size()) tmp += " | "; tmp += "GL_ATOMIC_COUNTER_BARRIER_BIT"; }
    if (v & GL_SHADER_STORAGE_BARRIER_BIT)      { if (tmp.size()) tmp += " | "; tmp += "GL_SHADER_STORAGE_BARRIER_BIT"; }
    if (other || v==0)                          { if (tmp.size()) tmp += " | "; tmp += size_t(other); }

    return tmp.str();
  }

  // http://www.opengl.org/sdk/docs/man2/xhtml/glPushAttrib.xml

  std::string GLpushAttribToString(GLbitfield v)
  {
    if (v == GL_ALL_ATTRIB_BITS)
      return std::string("GL_ALL_ATTRIB_BITS");

    const GLbitfield other = v & ~(GL_ACCUM_BUFFER_BIT | GL_COLOR_BUFFER_BIT | GL_CURRENT_BIT | GL_DEPTH_BUFFER_BIT | GL_ENABLE_BIT | GL_EVAL_BIT | GL_FOG_BIT | GL_HINT_BIT | GL_LIGHTING_BIT | GL_LINE_BIT | GL_LIST_BIT | GL_MULTISAMPLE_BIT | GL_PIXEL_MODE_BIT | GL_POINT_BIT | GL_POLYGON_BIT | GL_POLYGON_STIPPLE_BIT | GL_SCISSOR_BIT | GL_STENCIL_BUFFER_BIT | GL_TEXTURE_BIT | GL_TRANSFORM_BIT | GL_VIEWPORT_BIT);

    string_list<std::string> tmp;
    if (v & GL_ACCUM_BUFFER_BIT)          { if (tmp.size()) tmp += " | "; tmp += "GL_ACCUM_BUFFER_BIT"; }
    if (v & GL_COLOR_BUFFER_BIT)          { if (tmp.size()) tmp += " | "; tmp += "GL_COLOR_BUFFER_BIT"; }
    if (v & GL_CURRENT_BIT)               { if (tmp.size()) tmp += " | "; tmp += "GL_CURRENT_BIT"; }
    if (v & GL_DEPTH_BUFFER_BIT)          { if (tmp.size()) tmp += " | "; tmp += "GL_DEPTH_BUFFER_BIT"; }
    if (v & GL_ENABLE_BIT)                { if (tmp.size()) tmp += " | "; tmp += "GL_ENABLE_BIT"; }
    if (v & GL_EVAL_BIT)                  { if (tmp.size()) tmp += " | "; tmp += "GL_EVAL_BIT"; }
    if (v & GL_FOG_BIT)                   { if (tmp.size()) tmp += " | "; tmp += "GL_FOG_BIT"; }
    if (v & GL_HINT_BIT)                  { if (tmp.size()) tmp += " | "; tmp += "GL_HINT_BIT"; }
    if (v & GL_LIGHTING_BIT)              { if (tmp.size()) tmp += " | "; tmp += "GL_LIGHTING_BIT"; }
    if (v & GL_LINE_BIT)                  { if (tmp.size()) tmp += " | "; tmp += "GL_LINE_BIT"; }
    if (v & GL_LIST_BIT)                  { if (tmp.size()) tmp += " | "; tmp += "GL_LIST_BIT"; }
    if (v & GL_MULTISAMPLE_BIT)           { if (tmp.size()) tmp += " | "; tmp += "GL_MULTISAMPLE_BIT"; }
    if (v & GL_PIXEL_MODE_BIT)            { if (tmp.size()) tmp += " | "; tmp += "GL_PIXEL_MODE_BIT"; }
    if (v & GL_POINT_BIT)                 { if (tmp.size()) tmp += " | "; tmp += "GL_POINT_BIT"; }
    if (v & GL_POLYGON_BIT)               { if (tmp.size()) tmp += " | "; tmp += "GL_POLYGON_BIT"; }
    if (v & GL_POLYGON_STIPPLE_BIT)       { if (tmp.size()) tmp += " | "; tmp += "GL_POLYGON_STIPPLE_BIT"; }
    if (v & GL_SCISSOR_BIT)               { if (tmp.size()) tmp += " | "; tmp += "GL_SCISSOR_BIT"; }
    if (v & GL_STENCIL_BUFFER_BIT)        { if (tmp.size()) tmp += " | "; tmp += "GL_STENCIL_BUFFER_BIT"; }
    if (v & GL_TEXTURE_BIT)               { if (tmp.size()) tmp += " | "; tmp += "GL_TEXTURE_BIT"; }
    if (v & GL_TRANSFORM_BIT)             { if (tmp.size()) tmp += " | "; tmp += "GL_TRANSFORM_BIT"; }
    if (v & GL_VIEWPORT_BIT)              { if (tmp.size()) tmp += " | "; tmp += "GL_VIEWPORT_BIT"; }
    if (other || v==0)                    { if (tmp.size()) tmp += " | "; tmp += size_t(other); }

    return tmp.str();
  }

  std::string GLpushClientAttribToString(GLbitfield v)
  {
    if (v == GL_CLIENT_ALL_ATTRIB_BITS)
      return std::string("GL_CLIENT_ALL_ATTRIB_BITS");

    const GLbitfield other = v & ~(GL_CLIENT_PIXEL_STORE_BIT | GL_CLIENT_VERTEX_ARRAY_BIT );

    string_list<std::string> tmp;
    if (v & GL_CLIENT_PIXEL_STORE_BIT)    { if (tmp.size()) tmp += " | "; tmp += "GL_CLIENT_PIXEL_STORE_BIT"; }
    if (v & GL_CLIENT_VERTEX_ARRAY_BIT)   { if (tmp.size()) tmp += " | "; tmp += "GL_CLIENT_VERTEX_ARRAY_BIT"; }
    if (other || v==0)                    { if (tmp.size()) tmp += " | "; tmp += size_t(other); }

    return tmp.str();
  }

  std::string GLuseProgramStagesToString(GLbitfield v)
  {
    if (v == GL_ALL_SHADER_BITS)
      return std::string("GL_ALL_SHADER_BITS");

    const GLbitfield other = v & ~(GL_VERTEX_SHADER_BIT | GL_TESS_CONTROL_SHADER_BIT | GL_TESS_EVALUATION_SHADER_BIT | GL_GEOMETRY_SHADER_BIT | GL_FRAGMENT_SHADER_BIT | GL_COMPUTE_SHADER_BIT);

    string_list<std::string> tmp;
    if (v & GL_VERTEX_SHADER_BIT)          { if (tmp.size()) tmp += " | "; tmp += "GL_VERTEX_SHADER_BIT"; }
    if (v & GL_TESS_CONTROL_SHADER_BIT)    { if (tmp.size()) tmp += " | "; tmp += "GL_TESS_CONTROL_SHADER_BIT"; }
    if (v & GL_TESS_EVALUATION_SHADER_BIT) { if (tmp.size()) tmp += " | "; tmp += "GL_TESS_EVALUATION_SHADER_BIT"; }
    if (v & GL_GEOMETRY_SHADER_BIT)        { if (tmp.size()) tmp += " | "; tmp += "GL_GEOMETRY_SHADER_BIT"; }
    if (v & GL_FRAGMENT_SHADER_BIT)        { if (tmp.size()) tmp += " | "; tmp += "GL_FRAGMENT_SHADER_BIT"; }
    if (v & GL_COMPUTE_SHADER_BIT)         { if (tmp.size()) tmp += " | "; tmp += "GL_COMPUTE_SHADER_BIT"; }
    if (other || v==0)                     { if (tmp.size()) tmp += " | "; tmp += size_t(other); }

    return tmp.str();
  }

  std::string GLwaitSyncToString(GLbitfield v)
  {
    const GLbitfield other = v & ~(GL_ZERO);

    string_list<std::string> tmp;
    if (v & GL_ZERO)   { if (tmp.size()) tmp += " | "; tmp += "GL_ZERO"; }
    if (other || v==0) { if (tmp.size()) tmp += " | "; tmp += size_t(other); }

    return tmp.str();
  }

  std::string GLcreateSyncFromCLeventARBToString(GLbitfield v)
  {
    const GLbitfield other = v & ~(GL_ZERO);

    string_list<std::string> tmp;
    if (v & GL_ZERO)   { if (tmp.size()) tmp += " | "; tmp += "GL_ZERO"; }
    if (other || v==0) { if (tmp.size()) tmp += " | "; tmp += size_t(other); }

    return tmp.str();
  }

  std::string GLimportSyncEXTToString(GLbitfield v)
  {
    const GLbitfield other = v & ~(GL_ZERO);

    string_list<std::string> tmp;
    if (v & GL_ZERO)   { if (tmp.size()) tmp += " | "; tmp += "GL_ZERO"; }
    if (other || v==0) { if (tmp.size()) tmp += " | "; tmp += size_t(other); }

    return tmp.str();
  }

  std::string GLgetPathMetricsNVToString(GLbitfield v)
  {
    const GLbitfield other = v & ~(GL_GLYPH_WIDTH_BIT_NV | GL_GLYPH_HEIGHT_BIT_NV | GL_GLYPH_HORIZONTAL_BEARING_X_BIT_NV |
                                   GL_GLYPH_HORIZONTAL_BEARING_Y_BIT_NV | GL_GLYPH_HORIZONTAL_BEARING_ADVANCE_BIT_NV |
                                   GL_GLYPH_VERTICAL_BEARING_X_BIT_NV | GL_GLYPH_VERTICAL_BEARING_Y_BIT_NV |
                                   GL_GLYPH_VERTICAL_BEARING_ADVANCE_BIT_NV | GL_GLYPH_HAS_KERNING_BIT_NV | GL_FONT_X_MIN_BOUNDS_BIT_NV |
                                   GL_FONT_Y_MIN_BOUNDS_BIT_NV | GL_FONT_X_MAX_BOUNDS_BIT_NV | GL_FONT_Y_MAX_BOUNDS_BIT_NV |
                                   GL_FONT_UNITS_PER_EM_BIT_NV | GL_FONT_ASCENDER_BIT_NV | GL_FONT_DESCENDER_BIT_NV | GL_FONT_HEIGHT_BIT_NV |
                                   GL_FONT_MAX_ADVANCE_WIDTH_BIT_NV | GL_FONT_MAX_ADVANCE_HEIGHT_BIT_NV | GL_FONT_UNDERLINE_POSITION_BIT_NV |
                                   GL_FONT_UNDERLINE_THICKNESS_BIT_NV | GL_FONT_HAS_KERNING_BIT_NV);

    string_list<std::string> tmp;
    if (v & GL_GLYPH_WIDTH_BIT_NV)                      { if (tmp.size()) tmp += " | "; tmp += "GL_GLYPH_WIDTH_BIT_NV"; }
    if (v & GL_GLYPH_HEIGHT_BIT_NV)                     { if (tmp.size()) tmp += " | "; tmp += "GL_GLYPH_HEIGHT_BIT_NV"; }
    if (v & GL_GLYPH_HORIZONTAL_BEARING_X_BIT_NV)       { if (tmp.size()) tmp += " | "; tmp += "GL_GLYPH_HORIZONTAL_BEARING_X_BIT_NV"; }
    if (v & GL_GLYPH_HORIZONTAL_BEARING_Y_BIT_NV)       { if (tmp.size()) tmp += " | "; tmp += "GL_GLYPH_HORIZONTAL_BEARING_Y_BIT_NV"; }
    if (v & GL_GLYPH_HORIZONTAL_BEARING_ADVANCE_BIT_NV) { if (tmp.size()) tmp += " | "; tmp += "GL_GLYPH_HORIZONTAL_BEARING_ADVANCE_BIT_NV"; }
    if (v & GL_GLYPH_VERTICAL_BEARING_X_BIT_NV)         { if (tmp.size()) tmp += " | "; tmp += "GL_GLYPH_VERTICAL_BEARING_X_BIT_NV"; }
    if (v & GL_GLYPH_VERTICAL_BEARING_Y_BIT_NV)         { if (tmp.size()) tmp += " | "; tmp += "GL_GLYPH_VERTICAL_BEARING_Y_BIT_NV"; }
    if (v & GL_GLYPH_VERTICAL_BEARING_ADVANCE_BIT_NV)   { if (tmp.size()) tmp += " | "; tmp += "GL_GLYPH_VERTICAL_BEARING_ADVANCE_BIT_NV"; }
    if (v & GL_GLYPH_HAS_KERNING_BIT_NV)                { if (tmp.size()) tmp += " | "; tmp += "GL_GLYPH_HAS_KERNING_BIT_NV"; }
    if (v & GL_FONT_X_MIN_BOUNDS_BIT_NV)                { if (tmp.size()) tmp += " | "; tmp += "GL_FONT_X_MIN_BOUNDS_BIT_NV"; }
    if (v & GL_FONT_Y_MIN_BOUNDS_BIT_NV)                { if (tmp.size()) tmp += " | "; tmp += "GL_FONT_Y_MIN_BOUNDS_BIT_NV"; }
    if (v & GL_FONT_X_MAX_BOUNDS_BIT_NV)                { if (tmp.size()) tmp += " | "; tmp += "GL_FONT_X_MAX_BOUNDS_BIT_NV"; }
    if (v & GL_FONT_Y_MAX_BOUNDS_BIT_NV)                { if (tmp.size()) tmp += " | "; tmp += "GL_FONT_Y_MAX_BOUNDS_BIT_NV"; }
    if (v & GL_FONT_UNITS_PER_EM_BIT_NV)                { if (tmp.size()) tmp += " | "; tmp += "GL_FONT_UNITS_PER_EM_BIT_NV"; }
    if (v & GL_FONT_ASCENDER_BIT_NV)                    { if (tmp.size()) tmp += " | "; tmp += "GL_FONT_ASCENDER_BIT_NV"; }
    if (v & GL_FONT_DESCENDER_BIT_NV)                   { if (tmp.size()) tmp += " | "; tmp += "GL_FONT_DESCENDER_BIT_NV"; }
    if (v & GL_FONT_HEIGHT_BIT_NV)                      { if (tmp.size()) tmp += " | "; tmp += "GL_FONT_HEIGHT_BIT_NV"; }
    if (v & GL_FONT_MAX_ADVANCE_WIDTH_BIT_NV)           { if (tmp.size()) tmp += " | "; tmp += "GL_FONT_MAX_ADVANCE_WIDTH_BIT_NV"; }
    if (v & GL_FONT_MAX_ADVANCE_HEIGHT_BIT_NV)          { if (tmp.size()) tmp += " | "; tmp += "GL_FONT_MAX_ADVANCE_HEIGHT_BIT_NV"; }
    if (v & GL_FONT_UNDERLINE_POSITION_BIT_NV)          { if (tmp.size()) tmp += " | "; tmp += "GL_FONT_UNDERLINE_POSITION_BIT_NV"; }
    if (v & GL_FONT_UNDERLINE_THICKNESS_BIT_NV)         { if (tmp.size()) tmp += " | "; tmp += "GL_FONT_UNDERLINE_THICKNESS_BIT_NV"; }
    if (v & GL_FONT_HAS_KERNING_BIT_NV)                 { if (tmp.size()) tmp += " | "; tmp += "GL_FONT_HAS_KERNING_BIT_NV"; }
    if (other || v==0)                                  { if (tmp.size()) tmp += " | "; tmp += size_t(other); }

    return tmp.str();
  }

  std::string GLpathGlyphsNVToString(GLbitfield v)
  {
    if (v == GL_NONE)
      return std::string("GL_NONE");

    const GLbitfield other = v & ~(GL_BOLD_BIT_NV | GL_ITALIC_BIT_NV);

    string_list<std::string> tmp;
    if (v & GL_BOLD_BIT_NV)   { if (tmp.size()) tmp += " | "; tmp += "GL_BOLD_BIT_NV"; }
    if (v & GL_ITALIC_BIT_NV) { if (tmp.size()) tmp += " | "; tmp += "GL_ITALIC_BIT_NV"; }
    if (other || v==0)        { if (tmp.size()) tmp += " | "; tmp += size_t(other); }

    return tmp.str();
  }

  std::string GLtexStorageSparseAMDToString(GLbitfield v)
  {
    const GLbitfield other = v & ~(GL_TEXTURE_STORAGE_SPARSE_BIT_AMD);

    string_list<std::string> tmp;
    if (v & GL_TEXTURE_STORAGE_SPARSE_BIT_AMD) { if (tmp.size()) tmp += " | "; tmp += "GL_TEXTURE_STORAGE_SPARSE_BIT_AMD"; }
    if (other || v==0)                         { if (tmp.size()) tmp += " | "; tmp += size_t(other); }

    return tmp.str();
  }

  std::string GLmapTexture2DINTELToString(GLbitfield v)
  {
    const GLbitfield other = v & ~(GL_MAP_READ_BIT | GL_MAP_WRITE_BIT);

    string_list<std::string> tmp;
    if (v & GL_MAP_READ_BIT)  { if (tmp.size()) tmp += " | "; tmp += "GL_MAP_READ_BIT"; }
    if (v & GL_MAP_WRITE_BIT) { if (tmp.size()) tmp += " | "; tmp += "GL_MAP_WRITE_BIT"; }
    if (other || v==0)        { if (tmp.size()) tmp += " | "; tmp += size_t(other); }

    return tmp.str();
  }

  std::string GLstartTilingQCOMToString(GLbitfield v)
  {
    const GLbitfield other = v & ~(GL_COLOR_BUFFER_BIT0_QCOM | GL_COLOR_BUFFER_BIT1_QCOM | GL_COLOR_BUFFER_BIT2_QCOM |
                                   GL_COLOR_BUFFER_BIT3_QCOM | GL_COLOR_BUFFER_BIT4_QCOM | GL_COLOR_BUFFER_BIT5_QCOM |
                                   GL_COLOR_BUFFER_BIT6_QCOM | GL_COLOR_BUFFER_BIT7_QCOM | GL_DEPTH_BUFFER_BIT0_QCOM |
                                   GL_DEPTH_BUFFER_BIT1_QCOM | GL_DEPTH_BUFFER_BIT2_QCOM | GL_DEPTH_BUFFER_BIT3_QCOM |
                                   GL_DEPTH_BUFFER_BIT4_QCOM | GL_DEPTH_BUFFER_BIT5_QCOM | GL_DEPTH_BUFFER_BIT6_QCOM |
                                   GL_DEPTH_BUFFER_BIT7_QCOM | GL_STENCIL_BUFFER_BIT0_QCOM | GL_STENCIL_BUFFER_BIT1_QCOM |
                                   GL_STENCIL_BUFFER_BIT2_QCOM | GL_STENCIL_BUFFER_BIT3_QCOM | GL_STENCIL_BUFFER_BIT4_QCOM |
                                   GL_STENCIL_BUFFER_BIT5_QCOM | GL_STENCIL_BUFFER_BIT6_QCOM | GL_STENCIL_BUFFER_BIT7_QCOM |
                                   GL_MULTISAMPLE_BUFFER_BIT0_QCOM | GL_MULTISAMPLE_BUFFER_BIT1_QCOM | GL_MULTISAMPLE_BUFFER_BIT2_QCOM |
                                   GL_MULTISAMPLE_BUFFER_BIT3_QCOM | GL_MULTISAMPLE_BUFFER_BIT4_QCOM | GL_MULTISAMPLE_BUFFER_BIT5_QCOM |
                                   GL_MULTISAMPLE_BUFFER_BIT6_QCOM | GL_MULTISAMPLE_BUFFER_BIT7_QCOM);

    string_list<std::string> tmp;
    if (v & GL_COLOR_BUFFER_BIT0_QCOM)  { if (tmp.size()) tmp += " | "; tmp += "GL_COLOR_BUFFER_BIT0_QCOM"; }
    if (v & GL_COLOR_BUFFER_BIT1_QCOM)  { if (tmp.size()) tmp += " | "; tmp += "GL_COLOR_BUFFER_BIT1_QCOM"; }
    if (v & GL_COLOR_BUFFER_BIT2_QCOM)  { if (tmp.size()) tmp += " | "; tmp += "GL_COLOR_BUFFER_BIT2_QCOM"; }
    if (v & GL_COLOR_BUFFER_BIT3_QCOM)  { if (tmp.size()) tmp += " | "; tmp += "GL_COLOR_BUFFER_BIT3_QCOM"; }
    if (v & GL_COLOR_BUFFER_BIT4_QCOM)  { if (tmp.size()) tmp += " | "; tmp += "GL_COLOR_BUFFER_BIT4_QCOM"; }
    if (v & GL_COLOR_BUFFER_BIT5_QCOM)  { if (tmp.size()) tmp += " | "; tmp += "GL_COLOR_BUFFER_BIT5_QCOM"; }
    if (v & GL_COLOR_BUFFER_BIT6_QCOM)  { if (tmp.size()) tmp += " | "; tmp += "GL_COLOR_BUFFER_BIT6_QCOM"; }
    if (v & GL_COLOR_BUFFER_BIT7_QCOM)  { if (tmp.size()) tmp += " | "; tmp += "GL_COLOR_BUFFER_BIT7_QCOM"; }
    if (v & GL_DEPTH_BUFFER_BIT0_QCOM)  { if (tmp.size()) tmp += " | "; tmp += "GL_DEPTH_BUFFER_BIT0_QCOM"; }
    if (v & GL_DEPTH_BUFFER_BIT1_QCOM)  { if (tmp.size()) tmp += " | "; tmp += "GL_DEPTH_BUFFER_BIT1_QCOM"; }
    if (v & GL_DEPTH_BUFFER_BIT2_QCOM)  { if (tmp.size()) tmp += " | "; tmp += "GL_DEPTH_BUFFER_BIT2_QCOM"; }
    if (v & GL_DEPTH_BUFFER_BIT3_QCOM)  { if (tmp.size()) tmp += " | "; tmp += "GL_DEPTH_BUFFER_BIT3_QCOM"; }
    if (v & GL_DEPTH_BUFFER_BIT4_QCOM)  { if (tmp.size()) tmp += " | "; tmp += "GL_DEPTH_BUFFER_BIT4_QCOM"; }
    if (v & GL_DEPTH_BUFFER_BIT5_QCOM)  { if (tmp.size()) tmp += " | "; tmp += "GL_DEPTH_BUFFER_BIT5_QCOM"; }
    if (v & GL_DEPTH_BUFFER_BIT6_QCOM)  { if (tmp.size()) tmp += " | "; tmp += "GL_DEPTH_BUFFER_BIT6_QCOM"; }
    if (v & GL_DEPTH_BUFFER_BIT7_QCOM)  { if (tmp.size()) tmp += " | "; tmp += "GL_DEPTH_BUFFER_BIT7_QCOM"; }
    if (v & GL_STENCIL_BUFFER_BIT0_QCOM)  { if (tmp.size()) tmp += " | "; tmp += "GL_STENCIL_BUFFER_BIT0_QCOM"; }
    if (v & GL_STENCIL_BUFFER_BIT1_QCOM)  { if (tmp.size()) tmp += " | "; tmp += "GL_STENCIL_BUFFER_BIT1_QCOM"; }
    if (v & GL_STENCIL_BUFFER_BIT2_QCOM)  { if (tmp.size()) tmp += " | "; tmp += "GL_STENCIL_BUFFER_BIT2_QCOM"; }
    if (v & GL_STENCIL_BUFFER_BIT3_QCOM)  { if (tmp.size()) tmp += " | "; tmp += "GL_STENCIL_BUFFER_BIT3_QCOM"; }
    if (v & GL_STENCIL_BUFFER_BIT4_QCOM)  { if (tmp.size()) tmp += " | "; tmp += "GL_STENCIL_BUFFER_BIT4_QCOM"; }
    if (v & GL_STENCIL_BUFFER_BIT5_QCOM)  { if (tmp.size()) tmp += " | "; tmp += "GL_STENCIL_BUFFER_BIT5_QCOM"; }
    if (v & GL_STENCIL_BUFFER_BIT6_QCOM)  { if (tmp.size()) tmp += " | "; tmp += "GL_STENCIL_BUFFER_BIT6_QCOM"; }
    if (v & GL_STENCIL_BUFFER_BIT7_QCOM)  { if (tmp.size()) tmp += " | "; tmp += "GL_STENCIL_BUFFER_BIT7_QCOM"; }
    if (v & GL_MULTISAMPLE_BUFFER_BIT0_QCOM)  { if (tmp.size()) tmp += " | "; tmp += "GL_MULTISAMPLE_BUFFER_BIT0_QCOM"; }
    if (v & GL_MULTISAMPLE_BUFFER_BIT1_QCOM)  { if (tmp.size()) tmp += " | "; tmp += "GL_MULTISAMPLE_BUFFER_BIT1_QCOM"; }
    if (v & GL_MULTISAMPLE_BUFFER_BIT2_QCOM)  { if (tmp.size()) tmp += " | "; tmp += "GL_MULTISAMPLE_BUFFER_BIT2_QCOM"; }
    if (v & GL_MULTISAMPLE_BUFFER_BIT3_QCOM)  { if (tmp.size()) tmp += " | "; tmp += "GL_MULTISAMPLE_BUFFER_BIT3_QCOM"; }
    if (v & GL_MULTISAMPLE_BUFFER_BIT4_QCOM)  { if (tmp.size()) tmp += " | "; tmp += "GL_MULTISAMPLE_BUFFER_BIT4_QCOM"; }
    if (v & GL_MULTISAMPLE_BUFFER_BIT5_QCOM)  { if (tmp.size()) tmp += " | "; tmp += "GL_MULTISAMPLE_BUFFER_BIT5_QCOM"; }
    if (v & GL_MULTISAMPLE_BUFFER_BIT6_QCOM)  { if (tmp.size()) tmp += " | "; tmp += "GL_MULTISAMPLE_BUFFER_BIT6_QCOM"; }
    if (v & GL_MULTISAMPLE_BUFFER_BIT7_QCOM)  { if (tmp.size()) tmp += " | "; tmp += "GL_MULTISAMPLE_BUFFER_BIT7_QCOM"; }
    if (other || v==0)        { if (tmp.size()) tmp += " | "; tmp += size_t(other); }

    return tmp.str();
  }

  std::string GLTexParameterToString(GLenum pname, const GLfloat param)
  {
    switch (pname)
    {
      case GL_DEPTH_STENCIL_TEXTURE_MODE:
      case GL_TEXTURE_COMPARE_FUNC:
      case GL_TEXTURE_COMPARE_MODE:
      case GL_TEXTURE_MIN_FILTER:
      case GL_TEXTURE_MAG_FILTER:
      case GL_TEXTURE_SWIZZLE_R:
      case GL_TEXTURE_SWIZZLE_G:
      case GL_TEXTURE_SWIZZLE_B:
      case GL_TEXTURE_SWIZZLE_A:
      case GL_TEXTURE_WRAP_S:
      case GL_TEXTURE_WRAP_T:
      case GL_TEXTURE_WRAP_R:
        return GLenumToString(static_cast<GLenum>(param));

      default:
        return print_string(param);
    }
  }

  std::string GLTexParameterToString(GLenum pname, const GLint param)
  {
    switch (pname)
    {
      case GL_DEPTH_STENCIL_TEXTURE_MODE:
      case GL_TEXTURE_COMPARE_FUNC:
      case GL_TEXTURE_COMPARE_MODE:
      case GL_TEXTURE_MIN_FILTER:
      case GL_TEXTURE_MAG_FILTER:
      case GL_TEXTURE_SWIZZLE_R:
      case GL_TEXTURE_SWIZZLE_G:
      case GL_TEXTURE_SWIZZLE_B:
      case GL_TEXTURE_SWIZZLE_A:
      case GL_TEXTURE_WRAP_S:
      case GL_TEXTURE_WRAP_T:
      case GL_TEXTURE_WRAP_R:
        return GLenumToString(static_cast<GLenum>(param));

      default:
        return print_string(param);
    }
  }

  std::string GLTexParameterToString(GLenum pname, const GLfloat *params)
  {
    switch (pname)
    {
      case GL_DEPTH_STENCIL_TEXTURE_MODE:
      case GL_TEXTURE_COMPARE_FUNC:
      case GL_TEXTURE_COMPARE_MODE:
      case GL_TEXTURE_MIN_FILTER:
      case GL_TEXTURE_MAG_FILTER:
      case GL_TEXTURE_SWIZZLE_R:
      case GL_TEXTURE_SWIZZLE_G:
      case GL_TEXTURE_SWIZZLE_B:
      case GL_TEXTURE_SWIZZLE_A:
      case GL_TEXTURE_WRAP_S:
      case GL_TEXTURE_WRAP_T:
      case GL_TEXTURE_WRAP_R:
        return GLenumToString(static_cast<GLenum>(params[0]));

      case GL_TEXTURE_SWIZZLE_RGBA:
        return print_string(
          GLenumToString(static_cast<GLenum>(params[0])), " ",
          GLenumToString(static_cast<GLenum>(params[1])), " ",
          GLenumToString(static_cast<GLenum>(params[2])), " ",
          GLenumToString(static_cast<GLenum>(params[3])));

      default:
        return print_string(params[0]);
    }
  }

  std::string GLTexParameterToString(GLenum pname, const GLint *params)
  {
    switch (pname)
    {
      case GL_DEPTH_STENCIL_TEXTURE_MODE:
      case GL_TEXTURE_COMPARE_FUNC:
      case GL_TEXTURE_COMPARE_MODE:
      case GL_TEXTURE_MIN_FILTER:
      case GL_TEXTURE_MAG_FILTER:
      case GL_TEXTURE_SWIZZLE_R:
      case GL_TEXTURE_SWIZZLE_G:
      case GL_TEXTURE_SWIZZLE_B:
      case GL_TEXTURE_SWIZZLE_A:
      case GL_TEXTURE_WRAP_S:
      case GL_TEXTURE_WRAP_T:
      case GL_TEXTURE_WRAP_R:
        return GLenumToString(static_cast<GLenum>(params[0]));

      case GL_TEXTURE_SWIZZLE_RGBA:
        return print_string(
          GLenumToString(static_cast<GLenum>(params[0])), " ",
          GLenumToString(static_cast<GLenum>(params[1])), " ",
          GLenumToString(static_cast<GLenum>(params[2])), " ",
          GLenumToString(static_cast<GLenum>(params[3])));

      default:
        return print_string(params[0]);
    }
  }

  std::string GLTexParameterToString(GLenum pname, const GLuint *params)
  {
    switch (pname)
    {
      case GL_DEPTH_STENCIL_TEXTURE_MODE:
      case GL_TEXTURE_COMPARE_FUNC:
      case GL_TEXTURE_COMPARE_MODE:
      case GL_TEXTURE_MIN_FILTER:
      case GL_TEXTURE_MAG_FILTER:
      case GL_TEXTURE_SWIZZLE_R:
      case GL_TEXTURE_SWIZZLE_G:
      case GL_TEXTURE_SWIZZLE_B:
      case GL_TEXTURE_SWIZZLE_A:
      case GL_TEXTURE_WRAP_S:
      case GL_TEXTURE_WRAP_T:
      case GL_TEXTURE_WRAP_R:
        return GLenumToString(static_cast<GLenum>(params[0]));

      case GL_TEXTURE_SWIZZLE_RGBA:
        return print_string(
          GLenumToString(static_cast<GLenum>(params[0])), " ",
          GLenumToString(static_cast<GLenum>(params[1])), " ",
          GLenumToString(static_cast<GLenum>(params[2])), " ",
          GLenumToString(static_cast<GLenum>(params[3])));

      default:
        return print_string(params[0]);
    }
  }

${CODE}

}

REGAL_NAMESPACE_END

''')

# Filter out extension duplicates

def filterTokens(tokens):

  suffixes  = ['_ARB','_KHR','_EXT','_NV','_ATI','_PGI','_OES','_IBM','_SUN','_SGI','_SGIX','_SGIS','_APPLE','_QCOM','_ANGLE','INTEL']
  suffixes2 = ['_BIT','_BITS','_BIT_NV','_BITS_NV','_BIT_PGI','_BITS_PGI','_BIT_EXT','_BITS_EXT','_BIT_SGIX','_BITS_SGIX']

  def suffixCompare(i,j):

    # Prefer anything to _BIT, _BITS

    im = [ 1 for k in suffixes2 if i.endswith(k) ]
    jm = [ 1 for k in suffixes2 if j.endswith(k) ]

    if len(im)>0 and len(jm)==0:
        return 1

    if len(im)==0 and len(jm)>0:
        return -1

    # prefer the string with none of the above suffixes

    im = [ 1 for k in suffixes if i.endswith(k) ]
    jm = [ 1 for k in suffixes if j.endswith(k) ]

    if len(im)>0 and len(jm)==0:
        return 1

    if len(im)==0 and len(jm)>0:
        return -1

    # prefer the string with earliest of the above suffixes

    for k in suffixes:
      if i.endswith(k):
        if j.endswith(k):
          return 0
        else:
          return -1
      else:
        if j.endswith(k):
          return 1

    return 0

  # Sort names into preferred suffix order

  tokens = [ (j[0], sorted(j[1],cmp=suffixCompare)) for j in tokens ]

  u = tokens

  for i in suffixes:
    u = [ (j[0], [ k for k in j[1] if not k.endswith(i)  ]) for j in u ]

  # Filter out _BIT duplicates

  for i in ['_BIT','_BITS']:
    u = [ (j[0], [ k for k in j[1] if not k.endswith(i)  ]) for j in u ]

  u = [ (i[0], [ j for j in i[1] if not j.startswith('GL_KTX_') ]) for i in u  ]

  # Form tuple of value, filtered names, all names, per GLenum

  return [ (tokens[i][0], u[i][1], tokens[i][1]) for i in xrange(len(tokens)) ]

def generateTokenSource(apis, args):

  code = []

  code.append('  const char * GLenumToString( GLenum e ) {')
  code.append('    #if REGAL_ENUM_TO_STRING')
  code.append('    switch( e ) {')

  for i in apis:
    if i.name != 'gl':
      continue
    e = {}
    for j in i.enums:
      if j.name != 'defines':
        continue
      for k in j.enumerantsByName:
        value = toLong(k.value)
        if value != None:
          if not value in e:
            e[value] = set()
          e[value].add(k.name)

    e = sorted([ (i,sorted(list(e[i]))) for i in e.iterkeys() ])
    e = [ i for i in e if i[0] < 0xfffffffff ]
    e = filterTokens(e)

    for i in e:
      value = i[0]
      if len(i[1]):
        name = i[1][0]
      else:
        name = i[2][0]

      if value==0:
        name = 'GL_ZERO'
      if value==1:
        name = 'GL_ONE'

      code.append('      case %s: return "%s";'%(hexValue(value,'0x%08x'),name))

  code.append('      default: break;')
  code.append('    }')
  code.append('    #endif // REGAL_ENUM_TO_STRING')
  code.append('    return "unknown_gl_enum";')
  code.append('  }')

  # GLerrorToString

  code.append('')
  code.append('  const char * GLerrorToString( GLenum e ) {')
  code.append('    #if REGAL_ENUM_TO_STRING')
  code.append('    switch( e ) {')
  for i in apis:
    if i.name != 'gl':
      continue
    for j in i.enums:
      if j.name != 'defines':
        continue
      for k in j.enumerantsByName:
        if getattr(k,'gluErrorString',None):
          code.append('      case %s: return "%s";'%(k.name,k.gluErrorString))
  code.append('      default: break;')
  code.append('    }')
  code.append('    #endif // REGAL_ENUM_TO_STRING')
  code.append('    return NULL;')
  code.append('  }')

  # GLX_VERSION

  code.append('')
  code.append('#if REGAL_SYS_GLX')
  code.append('  const char * GLXenumToString(int v) {')
  code.append('    #if REGAL_ENUM_TO_STRING')
  code.append('    switch( v ) {')

  for i in apis:
    if i.name != 'glx':
      continue
    e = {}
    for j in i.enums:
      if j.name != 'defines':
        continue
      for k in j.enumerants:
        value = toLong(k.value)
        if value != None:
          if not value in e:
            e[value] = set()
          e[value].add(k.name)

    e = sorted([ (i,sorted(list(e[i]))) for i in e.iterkeys() ])
    e = [ i for i in e if i[0] < 0xfffffffff ]
    e = filterTokens(e)

    for i in e:
      value = i[0]
      if len(i[1]):
        name = i[1][0]
      else:
        name = i[2][0]

      code.append('      case %s: return "%s";'%(hexValue(value,'0x%08x'),name))

  code.append('      default: break;')
  code.append('    }')
  code.append('    #endif // REGAL_ENUM_TO_STRING')
  code.append('    return "unknown_glx_enum";')
  code.append('  }')
  code.append('#endif // REGAL_SYS_GLX')

  # EGL version

  code.append('')
  code.append('#if REGAL_SYS_EGL')
  code.append('  const char * EGLenumToString(int v) {')
  code.append('    #if REGAL_ENUM_TO_STRING')
  code.append('    switch( v ) {')

  for i in apis:
    if i.name != 'egl':
      continue
    e = {}
    for j in i.enums:
      if j.name != 'defines':
        continue
      for k in j.enumerantsByName:
        value = toLong(k.value)
        if value != None:
          if not value in e:
            e[value] = set()
          e[value].add(k.name)

    e = sorted([ (i,sorted(list(e[i]))) for i in e.iterkeys() ])
    e = [ i for i in e if i[0] < 0xfffffffff ]
    e = filterTokens(e)

    for i in e:
      value = i[0]
      if len(i[1]):
        name = i[1][0]
      else:
        name = i[2][0]

      if value==0:
        name = 'EGL_FALSE'
      if value==1:
        name = 'EGL_TRUE'

      code.append('      case %s: return "%s";'%(hexValue(value,'0x%08x'),name))

  code.append('      default: break;')
  code.append('    }')
  code.append('    #endif // REGAL_ENUM_TO_STRING')
  code.append('    return "unknown_egl_enum";')
  code.append('  }')
  code.append('#endif // REGAL_SYS_EGL')

  substitute = {}
  substitute['LICENSE']       = args.license
  substitute['AUTOGENERATED'] = args.generated
  substitute['COPYRIGHT']     = args.copyright
  substitute['CODE']          = '\n'.join(code)
  outputCode( '%s/RegalToken.cpp' % args.srcdir, tokenSourceTemplate.substitute(substitute))

##############################################################################################

tokenHeaderTemplate = Template( '''${AUTOGENERATED}
${LICENSE}

#ifndef __${HEADER_NAME}_H__
#define __${HEADER_NAME}_H__

#include "RegalUtil.h"

REGAL_GLOBAL_BEGIN

#include <GL/Regal.h>

#include <string>

REGAL_GLOBAL_END

REGAL_NAMESPACE_BEGIN

namespace Token {

  const char * GLenumToString        (GLenum     v);
  const char * GLerrorToString       (GLenum     v); // gluErrorString
  const char * GLbooleanToString     (GLboolean  v);
  const char * internalFormatToString(GLint      v);

  std::string  GLtextureToString     (GLenum     v); // GL_TEXTUREi or 0xaaaa
  std::string  GLmodeToString        (GLenum     v); // GL_PRIMITIVE or 0xaaaa

  // Bitfield strings

  std::string GLblitFramebufferToString (GLbitfield v);
  std::string GLbufferAccessToString    (GLbitfield v);
  std::string GLbufferStorageToString   (GLbitfield v);
  std::string GLclearToString           (GLbitfield v);
  std::string GLclientWaitSyncToString  (GLbitfield v);
  std::string GLfenceSyncToString       (GLbitfield v);
  std::string GLmapBufferRangeToString  (GLbitfield v);
  std::string GLmemoryBarrierToString   (GLbitfield v);
  std::string GLpushAttribToString      (GLbitfield v);
  std::string GLpushClientAttribToString(GLbitfield v);
  std::string GLsampleMaskiToString     (GLbitfield v);
  std::string GLuseProgramStagesToString(GLbitfield v);
  std::string GLwaitSyncToString        (GLbitfield v);

  std::string GLcreateSyncFromCLeventARBToString(GLbitfield v);

  std::string GLimportSyncEXTToString(GLbitfield v);

  std::string GLgetPathMetricsNVToString(GLbitfield v);
  std::string GLpathGlyphsNVToString    (GLbitfield v);

  std::string GLtexStorageSparseAMDToString(GLbitfield v);

  std::string GLmapTexture2DINTELToString(GLbitfield v);

  std::string GLstartTilingQCOMToString(GLbitfield v);

  std::string GLTexParameterToString(GLenum pname, const GLfloat  param );
  std::string GLTexParameterToString(GLenum pname, const GLint    param );
  std::string GLTexParameterToString(GLenum pname, const GLfloat *params);
  std::string GLTexParameterToString(GLenum pname, const GLint   *params);
  std::string GLTexParameterToString(GLenum pname, const GLuint  *params);

  #if REGAL_SYS_GLX
  const char * GLXenumToString       (int        v);
  #endif

  #if REGAL_SYS_EGL
  const char * EGLenumToString       (int        v);
  #endif

  inline const char *toString(const GLenum    v) { return GLenumToString(v);    }
  inline const char *toString(const GLboolean v) { return GLbooleanToString(v); }
}

REGAL_NAMESPACE_END

#endif
''')

def generateTokenHeader(apis, args):

  substitute = {}
  substitute['LICENSE']       = args.license
  substitute['AUTOGENERATED'] = args.generated
  substitute['COPYRIGHT']     = args.copyright
  substitute['HEADER_NAME']   = "REGAL_TOKEN"
  outputCode( '%s/RegalToken.h' % args.srcdir, tokenHeaderTemplate.substitute(substitute))
