/* NOTE: Do not edit this file, it is generated by a script:
   Export.py --api gl 4.4 --api wgl 4.4 --api glx 4.4 --api cgl 1.4 --api egl 1.0 --outdir .
*/

/*
  Copyright (c) 2011-2013 NVIDIA Corporation
  Copyright (c) 2011-2013 Cass Everitt
  Copyright (c) 2012-2013 Scott Nations
  Copyright (c) 2012 Mathias Schott
  Copyright (c) 2012-2013 Nigel Stewart
  Copyright (c) 2012-2013 Google Inc.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without modification,
  are permitted provided that the following conditions are met:

    Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.

    Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
  OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
  Intended formatting conventions:
  $ astyle --style=allman --indent=spaces=2 --indent-switches
*/

#include "pch.h" /* For MS precompiled header support */

#include "RegalUtil.h"

#if REGAL_TRACE

#ifdef REGAL_NAMESPACE
#undef REGAL_NAMESPACE
#endif

REGAL_GLOBAL_BEGIN

#include <string>
using namespace std;

#include "RegalLog.h"
#include "RegalBreak.h"
#include "RegalPush.h"
#include "RegalToken.h"
#include "RegalHelper.h"
#include "RegalPrivate.h"
#include "RegalContext.h"
#include "RegalDispatcherGlobal.h"

REGAL_GLOBAL_END

REGAL_NAMESPACE_BEGIN

using namespace ::REGAL_NAMESPACE_INTERNAL::Logging;
using namespace ::REGAL_NAMESPACE_INTERNAL::Token;

namespace Trace
{

// GL_VERSION_1_0

  void  glAccum(GLenum op, GLfloat value);
  void  glAlphaFunc(GLenum func, GLclampf ref);
  void  glBegin(GLenum mode);
  void  glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap);
  void  glBlendFunc(GLenum sfactor, GLenum dfactor);
  void  glCallList(GLuint list);
  void  glCallLists(GLsizei n, GLenum type, const GLvoid *lists);
  void  glClear(GLbitfield mask);
  void  glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
  void  glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
  void  glClearDepth(GLclampd depth);
  void  glClearIndex(GLfloat c);
  void  glClearStencil(GLint s);
  void  glClipPlane(GLenum plane, const GLdouble *equation);
  void  glColor3b(GLbyte red, GLbyte green, GLbyte blue);
  void  glColor3bv(const GLbyte *v);
  void  glColor3d(GLdouble red, GLdouble green, GLdouble blue);
  void  glColor3dv(const GLdouble *v);
  void  glColor3f(GLfloat red, GLfloat green, GLfloat blue);
  void  glColor3fv(const GLfloat *v);
  void  glColor3i(GLint red, GLint green, GLint blue);
  void  glColor3iv(const GLint *v);
  void  glColor3s(GLshort red, GLshort green, GLshort blue);
  void  glColor3sv(const GLshort *v);
  void  glColor3ub(GLubyte red, GLubyte green, GLubyte blue);
  void  glColor3ubv(const GLubyte *v);
  void  glColor3ui(GLuint red, GLuint green, GLuint blue);
  void  glColor3uiv(const GLuint *v);
  void  glColor3us(GLushort red, GLushort green, GLushort blue);
  void  glColor3usv(const GLushort *v);
  void  glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha);
  void  glColor4bv(const GLbyte *v);
  void  glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha);
  void  glColor4dv(const GLdouble *v);
  void  glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
  void  glColor4fv(const GLfloat *v);
  void  glColor4i(GLint red, GLint green, GLint blue, GLint alpha);
  void  glColor4iv(const GLint *v);
  void  glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha);
  void  glColor4sv(const GLshort *v);
  void  glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha);
  void  glColor4ubv(const GLubyte *v);
  void  glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha);
  void  glColor4uiv(const GLuint *v);
  void  glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha);
  void  glColor4usv(const GLushort *v);
  void  glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
  void  glColorMaterial(GLenum face, GLenum mode);
  void  glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type);
  void  glCullFace(GLenum mode);
  void  glDeleteLists(GLuint list, GLsizei range);
  void  glDepthFunc(GLenum func);
  void  glDepthMask(GLboolean flag);
  void  glDepthRange(GLclampd zNear, GLclampd zFar);
  void  glDisable(GLenum cap);
  void  glDrawBuffer(GLenum mode);
  void  glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
  void  glEdgeFlag(GLboolean flag);
  void  glEdgeFlagv(const GLboolean *flag);
  void  glEnable(GLenum cap);
  void  glEnd(void);
  void  glEndList(void);
  void  glEvalCoord1d(GLdouble u);
  void  glEvalCoord1dv(const GLdouble *u);
  void  glEvalCoord1f(GLfloat u);
  void  glEvalCoord1fv(const GLfloat *u);
  void  glEvalCoord2d(GLdouble u, GLdouble v);
  void  glEvalCoord2dv(const GLdouble *u);
  void  glEvalCoord2f(GLfloat u, GLfloat v);
  void  glEvalCoord2fv(const GLfloat *u);
  void  glEvalMesh1(GLenum mode, GLint i1, GLint i2);
  void  glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2);
  void  glEvalPoint1(GLint i);
  void  glEvalPoint2(GLint i, GLint j);
  void  glFeedbackBuffer(GLsizei size, GLenum type, GLfloat *buffer);
  void  glFinish(void);
  void  glFlush(void);
  void  glFogf(GLenum pname, GLfloat param);
  void  glFogfv(GLenum pname, const GLfloat *params);
  void  glFogi(GLenum pname, GLint param);
  void  glFogiv(GLenum pname, const GLint *params);
  void  glFrontFace(GLenum mode);
  void  glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
  GLuint  glGenLists(GLsizei range);
  void  glGetBooleanv(GLenum pname, GLboolean *params);
  void  glGetClipPlane(GLenum plane, GLdouble *equation);
  void  glGetDoublev(GLenum pname, GLdouble *params);
  GLenum  glGetError(void);
  void  glGetFloatv(GLenum pname, GLfloat *params);
  void  glGetIntegerv(GLenum pname, GLint *params);
  void  glGetLightfv(GLenum light, GLenum pname, GLfloat *params);
  void  glGetLightiv(GLenum light, GLenum pname, GLint *params);
  void  glGetMapdv(GLenum target, GLenum query, GLdouble *v);
  void  glGetMapfv(GLenum target, GLenum query, GLfloat *v);
  void  glGetMapiv(GLenum target, GLenum query, GLint *v);
  void  glGetMaterialfv(GLenum face, GLenum pname, GLfloat *params);
  void  glGetMaterialiv(GLenum face, GLenum pname, GLint *params);
  void  glGetPixelMapfv(GLenum map, GLfloat *values);
  void  glGetPixelMapuiv(GLenum map, GLuint *values);
  void  glGetPixelMapusv(GLenum map, GLushort *values);
  void  glGetPolygonStipple(GLubyte *mask);
  const GLubyte * glGetString(GLenum name);
  void  glGetTexEnvfv(GLenum target, GLenum pname, GLfloat *params);
  void  glGetTexEnviv(GLenum target, GLenum pname, GLint *params);
  void  glGetTexGendv(GLenum coord, GLenum pname, GLdouble *params);
  void  glGetTexGenfv(GLenum coord, GLenum pname, GLfloat *params);
  void  glGetTexGeniv(GLenum coord, GLenum pname, GLint *params);
  void  glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels);
  void  glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params);
  void  glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params);
  void  glGetTexParameterfv(GLenum target, GLenum pname, GLfloat *params);
  void  glGetTexParameteriv(GLenum target, GLenum pname, GLint *params);
  void  glHint(GLenum target, GLenum mode);
  void  glIndexMask(GLuint mask);
  void  glIndexd(GLdouble c);
  void  glIndexdv(const GLdouble *c);
  void  glIndexf(GLfloat c);
  void  glIndexfv(const GLfloat *c);
  void  glIndexi(GLint c);
  void  glIndexiv(const GLint *c);
  void  glIndexs(GLshort c);
  void  glIndexsv(const GLshort *c);
  void  glInitNames(void);
  GLboolean  glIsEnabled(GLenum cap);
  GLboolean  glIsList(GLuint list);
  void  glLightModelf(GLenum pname, GLfloat param);
  void  glLightModelfv(GLenum pname, const GLfloat *params);
  void  glLightModeli(GLenum pname, GLint param);
  void  glLightModeliv(GLenum pname, const GLint *params);
  void  glLightf(GLenum light, GLenum pname, GLfloat param);
  void  glLightfv(GLenum light, GLenum pname, const GLfloat *params);
  void  glLighti(GLenum light, GLenum pname, GLint param);
  void  glLightiv(GLenum light, GLenum pname, const GLint *params);
  void  glLineStipple(GLint factor, GLushort pattern);
  void  glLineWidth(GLfloat width);
  void  glListBase(GLuint base);
  void  glLoadIdentity(void);
  void  glLoadMatrixd(const GLdouble *m);
  void  glLoadMatrixf(const GLfloat *m);
  void  glLoadName(GLuint name);
  void  glLogicOp(GLenum opcode);
  void  glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points);
  void  glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points);
  void  glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points);
  void  glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points);
  void  glMapGrid1d(GLint un, GLdouble u1, GLdouble u2);
  void  glMapGrid1f(GLint un, GLfloat u1, GLfloat u2);
  void  glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2);
  void  glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2);
  void  glMaterialf(GLenum face, GLenum pname, GLfloat param);
  void  glMaterialfv(GLenum face, GLenum pname, const GLfloat *params);
  void  glMateriali(GLenum face, GLenum pname, GLint param);
  void  glMaterialiv(GLenum face, GLenum pname, const GLint *params);
  void  glMatrixMode(GLenum mode);
  void  glMultMatrixd(const GLdouble *m);
  void  glMultMatrixf(const GLfloat *m);
  void  glNewList(GLuint list, GLenum mode);
  void  glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz);
  void  glNormal3bv(const GLbyte *v);
  void  glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz);
  void  glNormal3dv(const GLdouble *v);
  void  glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz);
  void  glNormal3fv(const GLfloat *v);
  void  glNormal3i(GLint nx, GLint ny, GLint nz);
  void  glNormal3iv(const GLint *v);
  void  glNormal3s(GLshort nx, GLshort ny, GLshort nz);
  void  glNormal3sv(const GLshort *v);
  void  glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
  void  glPassThrough(GLfloat token);
  void  glPixelMapfv(GLenum map, GLsizei mapsize, const GLfloat *values);
  void  glPixelMapuiv(GLenum map, GLsizei mapsize, const GLuint *values);
  void  glPixelMapusv(GLenum map, GLsizei mapsize, const GLushort *values);
  void  glPixelStoref(GLenum pname, GLfloat param);
  void  glPixelStorei(GLenum pname, GLint param);
  void  glPixelTransferf(GLenum pname, GLfloat param);
  void  glPixelTransferi(GLenum pname, GLint param);
  void  glPixelZoom(GLfloat xfactor, GLfloat yfactor);
  void  glPointSize(GLfloat size);
  void  glPolygonMode(GLenum face, GLenum mode);
  void  glPolygonStipple(const GLubyte *mask);
  void  glPopAttrib(void);
  void  glPopMatrix(void);
  void  glPopName(void);
  void  glPushAttrib(GLbitfield mask);
  void  glPushMatrix(void);
  void  glPushName(GLuint name);
  void  glRasterPos2d(GLdouble x, GLdouble y);
  void  glRasterPos2dv(const GLdouble *v);
  void  glRasterPos2f(GLfloat x, GLfloat y);
  void  glRasterPos2fv(const GLfloat *v);
  void  glRasterPos2i(GLint x, GLint y);
  void  glRasterPos2iv(const GLint *v);
  void  glRasterPos2s(GLshort x, GLshort y);
  void  glRasterPos2sv(const GLshort *v);
  void  glRasterPos3d(GLdouble x, GLdouble y, GLdouble z);
  void  glRasterPos3dv(const GLdouble *v);
  void  glRasterPos3f(GLfloat x, GLfloat y, GLfloat z);
  void  glRasterPos3fv(const GLfloat *v);
  void  glRasterPos3i(GLint x, GLint y, GLint z);
  void  glRasterPos3iv(const GLint *v);
  void  glRasterPos3s(GLshort x, GLshort y, GLshort z);
  void  glRasterPos3sv(const GLshort *v);
  void  glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w);
  void  glRasterPos4dv(const GLdouble *v);
  void  glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w);
  void  glRasterPos4fv(const GLfloat *v);
  void  glRasterPos4i(GLint x, GLint y, GLint z, GLint w);
  void  glRasterPos4iv(const GLint *v);
  void  glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w);
  void  glRasterPos4sv(const GLshort *v);
  void  glReadBuffer(GLenum mode);
  void  glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels);
  void  glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2);
  void  glRectdv(const GLdouble *v1, const GLdouble *v2);
  void  glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2);
  void  glRectfv(const GLfloat *v1, const GLfloat *v2);
  void  glRecti(GLint x1, GLint y1, GLint x2, GLint y2);
  void  glRectiv(const GLint *v1, const GLint *v2);
  void  glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2);
  void  glRectsv(const GLshort *v1, const GLshort *v2);
  GLint  glRenderMode(GLenum mode);
  void  glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
  void  glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
  void  glScaled(GLdouble x, GLdouble y, GLdouble z);
  void  glScalef(GLfloat x, GLfloat y, GLfloat z);
  void  glScissor(GLint x, GLint y, GLsizei width, GLsizei height);
  void  glSelectBuffer(GLsizei size, GLuint *buffer);
  void  glShadeModel(GLenum mode);
  void  glStencilFunc(GLenum func, GLint ref, GLuint mask);
  void  glStencilMask(GLuint mask);
  void  glStencilOp(GLenum fail, GLenum zfail, GLenum zpass);
  void  glTexCoord1d(GLdouble s);
  void  glTexCoord1dv(const GLdouble *v);
  void  glTexCoord1f(GLfloat s);
  void  glTexCoord1fv(const GLfloat *v);
  void  glTexCoord1i(GLint s);
  void  glTexCoord1iv(const GLint *v);
  void  glTexCoord1s(GLshort s);
  void  glTexCoord1sv(const GLshort *v);
  void  glTexCoord2d(GLdouble s, GLdouble t);
  void  glTexCoord2dv(const GLdouble *v);
  void  glTexCoord2f(GLfloat s, GLfloat t);
  void  glTexCoord2fv(const GLfloat *v);
  void  glTexCoord2i(GLint s, GLint t);
  void  glTexCoord2iv(const GLint *v);
  void  glTexCoord2s(GLshort s, GLshort t);
  void  glTexCoord2sv(const GLshort *v);
  void  glTexCoord3d(GLdouble s, GLdouble t, GLdouble r);
  void  glTexCoord3dv(const GLdouble *v);
  void  glTexCoord3f(GLfloat s, GLfloat t, GLfloat r);
  void  glTexCoord3fv(const GLfloat *v);
  void  glTexCoord3i(GLint s, GLint t, GLint r);
  void  glTexCoord3iv(const GLint *v);
  void  glTexCoord3s(GLshort s, GLshort t, GLshort r);
  void  glTexCoord3sv(const GLshort *v);
  void  glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q);
  void  glTexCoord4dv(const GLdouble *v);
  void  glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q);
  void  glTexCoord4fv(const GLfloat *v);
  void  glTexCoord4i(GLint s, GLint t, GLint r, GLint q);
  void  glTexCoord4iv(const GLint *v);
  void  glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q);
  void  glTexCoord4sv(const GLshort *v);
  void  glTexEnvf(GLenum target, GLenum pname, GLfloat param);
  void  glTexEnvfv(GLenum target, GLenum pname, const GLfloat *params);
  void  glTexEnvi(GLenum target, GLenum pname, GLint param);
  void  glTexEnviv(GLenum target, GLenum pname, const GLint *params);
  void  glTexGend(GLenum coord, GLenum pname, GLdouble param);
  void  glTexGendv(GLenum coord, GLenum pname, const GLdouble *params);
  void  glTexGenf(GLenum coord, GLenum pname, GLfloat param);
  void  glTexGenfv(GLenum coord, GLenum pname, const GLfloat *params);
  void  glTexGeni(GLenum coord, GLenum pname, GLint param);
  void  glTexGeniv(GLenum coord, GLenum pname, const GLint *params);
  void  glTexImage1D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
  void  glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
  void  glTexParameterf(GLenum target, GLenum pname, GLfloat param);
  void  glTexParameterfv(GLenum target, GLenum pname, const GLfloat *params);
  void  glTexParameteri(GLenum target, GLenum pname, GLint param);
  void  glTexParameteriv(GLenum target, GLenum pname, const GLint *params);
  void  glTranslated(GLdouble x, GLdouble y, GLdouble z);
  void  glTranslatef(GLfloat x, GLfloat y, GLfloat z);
  void  glVertex2d(GLdouble x, GLdouble y);
  void  glVertex2dv(const GLdouble *v);
  void  glVertex2f(GLfloat x, GLfloat y);
  void  glVertex2fv(const GLfloat *v);
  void  glVertex2i(GLint x, GLint y);
  void  glVertex2iv(const GLint *v);
  void  glVertex2s(GLshort x, GLshort y);
  void  glVertex2sv(const GLshort *v);
  void  glVertex3d(GLdouble x, GLdouble y, GLdouble z);
  void  glVertex3dv(const GLdouble *v);
  void  glVertex3f(GLfloat x, GLfloat y, GLfloat z);
  void  glVertex3fv(const GLfloat *v);
  void  glVertex3i(GLint x, GLint y, GLint z);
  void  glVertex3iv(const GLint *v);
  void  glVertex3s(GLshort x, GLshort y, GLshort z);
  void  glVertex3sv(const GLshort *v);
  void  glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w);
  void  glVertex4dv(const GLdouble *v);
  void  glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w);
  void  glVertex4fv(const GLfloat *v);
  void  glVertex4i(GLint x, GLint y, GLint z, GLint w);
  void  glVertex4iv(const GLint *v);
  void  glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w);
  void  glVertex4sv(const GLshort *v);
  void  glViewport(GLint x, GLint y, GLsizei width, GLsizei height);

// GL_VERSION_1_1

  GLboolean  glAreTexturesResident(GLsizei n, const GLuint *textures, GLboolean *residences);
  void  glArrayElement(GLint index);
  void  glBindTexture(GLenum target, GLuint texture);
  void  glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
  void  glCopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
  void  glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
  void  glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
  void  glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
  void  glDeleteTextures(GLsizei n, const GLuint *textures);
  void  glDisableClientState(GLenum cap);
  void  glDrawArrays(GLenum mode, GLint first, GLsizei count);
  void  glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices);
  void  glEdgeFlagPointer(GLsizei stride, const GLvoid *pointer);
  void  glEnableClientState(GLenum cap);
  void  glGenTextures(GLsizei n, GLuint *textures);
  void  glGetPointerv(GLenum pname, GLvoid **params);
  void  glIndexPointer(GLenum type, GLsizei stride, const GLvoid *pointer);
  void  glIndexub(GLubyte c);
  void  glIndexubv(const GLubyte *c);
  void  glInterleavedArrays(GLenum format, GLsizei stride, const GLvoid *pointer);
  GLboolean  glIsTexture(GLuint texture);
  void  glNormalPointer(GLenum type, GLsizei stride, const GLvoid *pointer);
  void  glPolygonOffset(GLfloat factor, GLfloat units);
  void  glPopClientAttrib(void);
  void  glPrioritizeTextures(GLsizei n, const GLuint *textures, const GLclampf *priorities);
  void  glPushClientAttrib(GLbitfield mask);
  void  glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
  void  glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
  void  glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
  void  glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);

// GL_VERSION_1_2

  void  glBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
  void  glBlendEquation(GLenum mode);
  void  glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
  void  glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);
  void  glTexImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
  void  glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);

// GL_VERSION_1_3

  void  glActiveTexture(GLenum texture);
  void  glClientActiveTexture(GLenum texture);
  void  glCompressedTexImage1D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data);
  void  glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
  void  glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data);
  void  glCompressedTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data);
  void  glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
  void  glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data);
  void  glGetCompressedTexImage(GLenum target, GLint lod, GLvoid *img);
  void  glLoadTransposeMatrixd(const GLdouble *m);
  void  glLoadTransposeMatrixf(const GLfloat *m);
  void  glMultTransposeMatrixd(const GLdouble *m);
  void  glMultTransposeMatrixf(const GLfloat *m);
  void  glMultiTexCoord1d(GLenum target, GLdouble s);
  void  glMultiTexCoord1dv(GLenum target, const GLdouble *v);
  void  glMultiTexCoord1f(GLenum target, GLfloat s);
  void  glMultiTexCoord1fv(GLenum target, const GLfloat *v);
  void  glMultiTexCoord1i(GLenum target, GLint s);
  void  glMultiTexCoord1iv(GLenum target, const GLint *v);
  void  glMultiTexCoord1s(GLenum target, GLshort s);
  void  glMultiTexCoord1sv(GLenum target, const GLshort *v);
  void  glMultiTexCoord2d(GLenum target, GLdouble s, GLdouble t);
  void  glMultiTexCoord2dv(GLenum target, const GLdouble *v);
  void  glMultiTexCoord2f(GLenum target, GLfloat s, GLfloat t);
  void  glMultiTexCoord2fv(GLenum target, const GLfloat *v);
  void  glMultiTexCoord2i(GLenum target, GLint s, GLint t);
  void  glMultiTexCoord2iv(GLenum target, const GLint *v);
  void  glMultiTexCoord2s(GLenum target, GLshort s, GLshort t);
  void  glMultiTexCoord2sv(GLenum target, const GLshort *v);
  void  glMultiTexCoord3d(GLenum target, GLdouble s, GLdouble t, GLdouble r);
  void  glMultiTexCoord3dv(GLenum target, const GLdouble *v);
  void  glMultiTexCoord3f(GLenum target, GLfloat s, GLfloat t, GLfloat r);
  void  glMultiTexCoord3fv(GLenum target, const GLfloat *v);
  void  glMultiTexCoord3i(GLenum target, GLint s, GLint t, GLint r);
  void  glMultiTexCoord3iv(GLenum target, const GLint *v);
  void  glMultiTexCoord3s(GLenum target, GLshort s, GLshort t, GLshort r);
  void  glMultiTexCoord3sv(GLenum target, const GLshort *v);
  void  glMultiTexCoord4d(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
  void  glMultiTexCoord4dv(GLenum target, const GLdouble *v);
  void  glMultiTexCoord4f(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
  void  glMultiTexCoord4fv(GLenum target, const GLfloat *v);
  void  glMultiTexCoord4i(GLenum target, GLint s, GLint t, GLint r, GLint q);
  void  glMultiTexCoord4iv(GLenum target, const GLint *v);
  void  glMultiTexCoord4s(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
  void  glMultiTexCoord4sv(GLenum target, const GLshort *v);
  void  glSampleCoverage(GLclampf value, GLboolean invert);

// GL_VERSION_1_4

  void  glBlendFuncSeparate(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
  void  glFogCoordPointer(GLenum type, GLsizei stride, const GLvoid *pointer);
  void  glFogCoordd(GLdouble coord);
  void  glFogCoorddv(const GLdouble *coord);
  void  glFogCoordf(GLfloat coord);
  void  glFogCoordfv(const GLfloat *coord);
  void  glMultiDrawArrays(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount);
  void  glMultiDrawElements(GLenum mode, const GLsizei *count, GLenum type, const GLvoid * const *indices, GLsizei primcount);
  void  glPointParameterf(GLenum pname, GLfloat param);
  void  glPointParameterfv(GLenum pname, const GLfloat *params);
  void  glPointParameteri(GLenum pname, GLint param);
  void  glPointParameteriv(GLenum pname, const GLint *params);
  void  glSecondaryColor3b(GLbyte red, GLbyte green, GLbyte blue);
  void  glSecondaryColor3bv(const GLbyte *v);
  void  glSecondaryColor3d(GLdouble red, GLdouble green, GLdouble blue);
  void  glSecondaryColor3dv(const GLdouble *v);
  void  glSecondaryColor3f(GLfloat red, GLfloat green, GLfloat blue);
  void  glSecondaryColor3fv(const GLfloat *v);
  void  glSecondaryColor3i(GLint red, GLint green, GLint blue);
  void  glSecondaryColor3iv(const GLint *v);
  void  glSecondaryColor3s(GLshort red, GLshort green, GLshort blue);
  void  glSecondaryColor3sv(const GLshort *v);
  void  glSecondaryColor3ub(GLubyte red, GLubyte green, GLubyte blue);
  void  glSecondaryColor3ubv(const GLubyte *v);
  void  glSecondaryColor3ui(GLuint red, GLuint green, GLuint blue);
  void  glSecondaryColor3uiv(const GLuint *v);
  void  glSecondaryColor3us(GLushort red, GLushort green, GLushort blue);
  void  glSecondaryColor3usv(const GLushort *v);
  void  glSecondaryColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
  void  glWindowPos2d(GLdouble x, GLdouble y);
  void  glWindowPos2dv(const GLdouble *p);
  void  glWindowPos2f(GLfloat x, GLfloat y);
  void  glWindowPos2fv(const GLfloat *p);
  void  glWindowPos2i(GLint x, GLint y);
  void  glWindowPos2iv(const GLint *p);
  void  glWindowPos2s(GLshort x, GLshort y);
  void  glWindowPos2sv(const GLshort *p);
  void  glWindowPos3d(GLdouble x, GLdouble y, GLdouble z);
  void  glWindowPos3dv(const GLdouble *p);
  void  glWindowPos3f(GLfloat x, GLfloat y, GLfloat z);
  void  glWindowPos3fv(const GLfloat *p);
  void  glWindowPos3i(GLint x, GLint y, GLint z);
  void  glWindowPos3iv(const GLint *p);
  void  glWindowPos3s(GLshort x, GLshort y, GLshort z);
  void  glWindowPos3sv(const GLshort *p);

// GL_VERSION_1_5

  void  glBeginQuery(GLenum target, GLuint id);
  void  glBindBuffer(GLenum target, GLuint buffer);
  void  glBufferData(GLenum target, GLsizeiptr size, const GLvoid *data, GLenum usage);
  void  glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *data);
  void  glDeleteBuffers(GLsizei n, const GLuint *buffers);
  void  glDeleteQueries(GLsizei n, const GLuint *ids);
  void  glEndQuery(GLenum target);
  void  glGenBuffers(GLsizei n, GLuint *buffers);
  void  glGenQueries(GLsizei n, GLuint *ids);
  void  glGetBufferParameteriv(GLenum target, GLenum pname, GLint *params);
  void  glGetBufferPointerv(GLenum target, GLenum pname, GLvoid **params);
  void  glGetBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, GLvoid *data);
  void  glGetQueryObjectiv(GLuint id, GLenum pname, GLint *params);
  void  glGetQueryObjectuiv(GLuint id, GLenum pname, GLuint *params);
  void  glGetQueryiv(GLenum target, GLenum pname, GLint *params);
  GLboolean  glIsBuffer(GLuint buffer);
  GLboolean  glIsQuery(GLuint id);
  GLvoid * glMapBuffer(GLenum target, GLenum access);
  GLboolean  glUnmapBuffer(GLenum target);

// GL_VERSION_2_0

  void  glAttachShader(GLuint program, GLuint shader);
  void  glBindAttribLocation(GLuint program, GLuint index, const GLchar *name);
  void  glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha);
  void  glCompileShader(GLuint shader);
  GLuint  glCreateProgram(void);
  GLuint  glCreateShader(GLenum type);
  void  glDeleteProgram(GLuint program);
  void  glDeleteShader(GLuint shader);
  void  glDetachShader(GLuint program, GLuint shader);
  void  glDisableVertexAttribArray(GLuint index);
  void  glDrawBuffers(GLsizei n, const GLenum *bufs);
  void  glEnableVertexAttribArray(GLuint index);
  void  glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
  void  glGetActiveUniform(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
  void  glGetAttachedShaders(GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders);
  GLint  glGetAttribLocation(GLuint program, const GLchar *name);
  void  glGetProgramInfoLog(GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
  void  glGetProgramiv(GLuint program, GLenum pname, GLint *params);
  void  glGetShaderInfoLog(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
  void  glGetShaderSource(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source);
  void  glGetShaderiv(GLuint shader, GLenum pname, GLint *params);
  GLint  glGetUniformLocation(GLuint program, const GLchar *name);
  void  glGetUniformfv(GLuint program, GLint location, GLfloat *params);
  void  glGetUniformiv(GLuint program, GLint location, GLint *params);
  void  glGetVertexAttribPointerv(GLuint index, GLenum pname, GLvoid **pointer);
  void  glGetVertexAttribdv(GLuint index, GLenum pname, GLdouble *params);
  void  glGetVertexAttribfv(GLuint index, GLenum pname, GLfloat *params);
  void  glGetVertexAttribiv(GLuint index, GLenum pname, GLint *params);
  GLboolean  glIsProgram(GLuint program);
  GLboolean  glIsShader(GLuint shader);
  void  glLinkProgram(GLuint program);
  void  glShaderSource(GLuint shader, GLsizei count, const GLchar * const *string, const GLint *length);
  void  glStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask);
  void  glStencilMaskSeparate(GLenum face, GLuint mask);
  void  glStencilOpSeparate(GLenum face, GLenum fail, GLenum zfail, GLenum zpass);
  void  glUniform1f(GLint location, GLfloat v0);
  void  glUniform1fv(GLint location, GLsizei count, const GLfloat *value);
  void  glUniform1i(GLint location, GLint v0);
  void  glUniform1iv(GLint location, GLsizei count, const GLint *value);
  void  glUniform2f(GLint location, GLfloat v0, GLfloat v1);
  void  glUniform2fv(GLint location, GLsizei count, const GLfloat *value);
  void  glUniform2i(GLint location, GLint v0, GLint v1);
  void  glUniform2iv(GLint location, GLsizei count, const GLint *value);
  void  glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
  void  glUniform3fv(GLint location, GLsizei count, const GLfloat *value);
  void  glUniform3i(GLint location, GLint v0, GLint v1, GLint v2);
  void  glUniform3iv(GLint location, GLsizei count, const GLint *value);
  void  glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
  void  glUniform4fv(GLint location, GLsizei count, const GLfloat *value);
  void  glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
  void  glUniform4iv(GLint location, GLsizei count, const GLint *value);
  void  glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
  void  glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
  void  glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
  void  glUseProgram(GLuint program);
  void  glValidateProgram(GLuint program);
  void  glVertexAttrib1d(GLuint index, GLdouble x);
  void  glVertexAttrib1dv(GLuint index, const GLdouble *v);
  void  glVertexAttrib1f(GLuint index, GLfloat x);
  void  glVertexAttrib1fv(GLuint index, const GLfloat *v);
  void  glVertexAttrib1s(GLuint index, GLshort x);
  void  glVertexAttrib1sv(GLuint index, const GLshort *v);
  void  glVertexAttrib2d(GLuint index, GLdouble x, GLdouble y);
  void  glVertexAttrib2dv(GLuint index, const GLdouble *v);
  void  glVertexAttrib2f(GLuint index, GLfloat x, GLfloat y);
  void  glVertexAttrib2fv(GLuint index, const GLfloat *v);
  void  glVertexAttrib2s(GLuint index, GLshort x, GLshort y);
  void  glVertexAttrib2sv(GLuint index, const GLshort *v);
  void  glVertexAttrib3d(GLuint index, GLdouble x, GLdouble y, GLdouble z);
  void  glVertexAttrib3dv(GLuint index, const GLdouble *v);
  void  glVertexAttrib3f(GLuint index, GLfloat x, GLfloat y, GLfloat z);
  void  glVertexAttrib3fv(GLuint index, const GLfloat *v);
  void  glVertexAttrib3s(GLuint index, GLshort x, GLshort y, GLshort z);
  void  glVertexAttrib3sv(GLuint index, const GLshort *v);
  void  glVertexAttrib4Nbv(GLuint index, const GLbyte *v);
  void  glVertexAttrib4Niv(GLuint index, const GLint *v);
  void  glVertexAttrib4Nsv(GLuint index, const GLshort *v);
  void  glVertexAttrib4Nub(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
  void  glVertexAttrib4Nubv(GLuint index, const GLubyte *v);
  void  glVertexAttrib4Nuiv(GLuint index, const GLuint *v);
  void  glVertexAttrib4Nusv(GLuint index, const GLushort *v);
  void  glVertexAttrib4bv(GLuint index, const GLbyte *v);
  void  glVertexAttrib4d(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
  void  glVertexAttrib4dv(GLuint index, const GLdouble *v);
  void  glVertexAttrib4f(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
  void  glVertexAttrib4fv(GLuint index, const GLfloat *v);
  void  glVertexAttrib4iv(GLuint index, const GLint *v);
  void  glVertexAttrib4s(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
  void  glVertexAttrib4sv(GLuint index, const GLshort *v);
  void  glVertexAttrib4ubv(GLuint index, const GLubyte *v);
  void  glVertexAttrib4uiv(GLuint index, const GLuint *v);
  void  glVertexAttrib4usv(GLuint index, const GLushort *v);
  void  glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer);

// GL_VERSION_2_1

  void  glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
  void  glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
  void  glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
  void  glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
  void  glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
  void  glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);

// GL_VERSION_3_0

  void  glBeginConditionalRender(GLuint id, GLenum mode);
  void  glBeginTransformFeedback(GLenum primitiveMode);
  void  glBindFragDataLocation(GLuint program, GLuint color, const GLchar *name);
  void  glClampColor(GLenum target, GLenum clamp);
  void  glClearBufferfi(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);
  void  glClearBufferfv(GLenum buffer, GLint drawbuffer, const GLfloat *value);
  void  glClearBufferiv(GLenum buffer, GLint drawbuffer, const GLint *value);
  void  glClearBufferuiv(GLenum buffer, GLint drawbuffer, const GLuint *value);
  void  glColorMaski(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
  void  glDisablei(GLenum cap, GLuint index);
  void  glEnablei(GLenum cap, GLuint index);
  void  glEndConditionalRender(void);
  void  glEndTransformFeedback(void);
  void  glGetBooleani_v(GLenum target, GLuint index, GLboolean *data);
  GLint  glGetFragDataLocation(GLuint program, const GLchar *name);
  const GLubyte * glGetStringi(GLenum name, GLuint index);
  void  glGetTexParameterIiv(GLenum target, GLenum pname, GLint *params);
  void  glGetTexParameterIuiv(GLenum target, GLenum pname, GLuint *params);
  void  glGetTransformFeedbackVarying(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name);
  void  glGetUniformuiv(GLuint program, GLint location, GLuint *params);
  void  glGetVertexAttribIiv(GLuint index, GLenum pname, GLint *params);
  void  glGetVertexAttribIuiv(GLuint index, GLenum pname, GLuint *params);
  GLboolean  glIsEnabledi(GLenum target, GLuint index);
  void  glTexParameterIiv(GLenum target, GLenum pname, const GLint *params);
  void  glTexParameterIuiv(GLenum target, GLenum pname, const GLuint *params);
  void  glTransformFeedbackVaryings(GLuint program, GLsizei count, const GLchar * const *varyings, GLenum bufferMode);
  void  glUniform1ui(GLint location, GLuint v0);
  void  glUniform1uiv(GLint location, GLsizei count, const GLuint *value);
  void  glUniform2ui(GLint location, GLuint v0, GLuint v1);
  void  glUniform2uiv(GLint location, GLsizei count, const GLuint *value);
  void  glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2);
  void  glUniform3uiv(GLint location, GLsizei count, const GLuint *value);
  void  glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
  void  glUniform4uiv(GLint location, GLsizei count, const GLuint *value);
  void  glVertexAttribI1i(GLuint index, GLint x);
  void  glVertexAttribI1iv(GLuint index, const GLint *v);
  void  glVertexAttribI1ui(GLuint index, GLuint x);
  void  glVertexAttribI1uiv(GLuint index, const GLuint *v);
  void  glVertexAttribI2i(GLuint index, GLint x, GLint y);
  void  glVertexAttribI2iv(GLuint index, const GLint *v);
  void  glVertexAttribI2ui(GLuint index, GLuint x, GLuint y);
  void  glVertexAttribI2uiv(GLuint index, const GLuint *v);
  void  glVertexAttribI3i(GLuint index, GLint x, GLint y, GLint z);
  void  glVertexAttribI3iv(GLuint index, const GLint *v);
  void  glVertexAttribI3ui(GLuint index, GLuint x, GLuint y, GLuint z);
  void  glVertexAttribI3uiv(GLuint index, const GLuint *v);
  void  glVertexAttribI4bv(GLuint index, const GLbyte *v);
  void  glVertexAttribI4i(GLuint index, GLint x, GLint y, GLint z, GLint w);
  void  glVertexAttribI4iv(GLuint index, const GLint *v);
  void  glVertexAttribI4sv(GLuint index, const GLshort *v);
  void  glVertexAttribI4ubv(GLuint index, const GLubyte *v);
  void  glVertexAttribI4ui(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
  void  glVertexAttribI4uiv(GLuint index, const GLuint *v);
  void  glVertexAttribI4usv(GLuint index, const GLushort *v);
  void  glVertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);

// GL_VERSION_3_1

  void  glDrawArraysInstanced(GLenum mode, GLint start, GLsizei count, GLsizei primcount);
  void  glDrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount);
  void  glPrimitiveRestartIndex(GLuint index);
  void  glTexBuffer(GLenum target, GLenum internalformat, GLuint buffer);

// GL_VERSION_3_2

  void  glFramebufferTexture(GLenum target, GLenum attachment, GLuint texture, GLint level);
  void  glGetBufferParameteri64v(GLenum target, GLenum pname, GLint64 *params);
  void  glGetInteger64i_v(GLenum target, GLuint index, GLint64 *data);

// GL_VERSION_3_3

  void  glVertexAttribDivisor(GLuint index, GLuint divisor);

// GL_VERSION_4_0

  void  glBlendEquationSeparatei(GLuint buf, GLenum modeRGB, GLenum modeAlpha);
  void  glBlendEquationi(GLuint buf, GLenum mode);
  void  glBlendFuncSeparatei(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
  void  glBlendFunci(GLuint buf, GLenum src, GLenum dst);

// GL_3DFX_tbuffer

  void  glTbufferMask3DFX(GLuint mask);

// GL_AMD_debug_output

  void  glDebugMessageCallbackAMD(GLDEBUGPROCAMD callback, GLvoid *userParam);
  void  glDebugMessageEnableAMD(GLenum category, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled);
  void  glDebugMessageInsertAMD(GLenum category, GLenum severity, GLuint id, GLsizei length, const GLchar *buf);
  GLuint  glGetDebugMessageLogAMD(GLuint count, GLsizei bufsize, GLenum *categories, GLuint *severities, GLuint *ids, GLsizei *lengths, GLchar *message);

// GL_AMD_draw_buffers_blend

  void  glBlendEquationIndexedAMD(GLuint buf, GLenum mode);
  void  glBlendEquationSeparateIndexedAMD(GLuint buf, GLenum modeRGB, GLenum modeAlpha);
  void  glBlendFuncIndexedAMD(GLuint buf, GLenum src, GLenum dst);
  void  glBlendFuncSeparateIndexedAMD(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);

// GL_AMD_multi_draw_indirect

  void  glMultiDrawArraysIndirectAMD(GLenum mode, const GLvoid *indirect, GLsizei primcount, GLsizei stride);
  void  glMultiDrawElementsIndirectAMD(GLenum mode, GLenum type, const GLvoid *indirect, GLsizei primcount, GLsizei stride);

// GL_AMD_name_gen_delete

  void  glDeleteNamesAMD(GLenum identifier, GLuint num, const GLuint *names);
  void  glGenNamesAMD(GLenum identifier, GLuint num, GLuint *names);
  GLboolean  glIsNameAMD(GLenum identifier, GLuint name);

// GL_AMD_performance_monitor

  void  glBeginPerfMonitorAMD(GLuint monitor);
  void  glDeletePerfMonitorsAMD(GLsizei n, GLuint *monitors);
  void  glEndPerfMonitorAMD(GLuint monitor);
  void  glGenPerfMonitorsAMD(GLsizei n, GLuint *monitors);
  void  glGetPerfMonitorCounterDataAMD(GLuint monitor, GLenum pname, GLsizei dataSize, GLuint *data, GLint *bytesWritten);
  void  glGetPerfMonitorCounterInfoAMD(GLuint group, GLuint counter, GLenum pname, GLvoid *data);
  void  glGetPerfMonitorCounterStringAMD(GLuint group, GLuint counter, GLsizei bufSize, GLsizei *length, GLchar *counterString);
  void  glGetPerfMonitorCountersAMD(GLuint group, GLint *numCounters, GLint *maxActiveCounters, GLsizei countersSize, GLuint *counters);
  void  glGetPerfMonitorGroupStringAMD(GLuint group, GLsizei bufSize, GLsizei *length, GLchar *groupString);
  void  glGetPerfMonitorGroupsAMD(GLint *numGroups, GLsizei groupsSize, GLuint *groups);
  void  glSelectPerfMonitorCountersAMD(GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint *counterList);

// GL_AMD_sample_positions

  void  glSetMultisamplefvAMD(GLenum pname, GLuint index, const GLfloat *val);

// GL_AMD_vertex_shader_tessellator

  void  glTessellationFactorAMD(GLfloat factor);
  void  glTessellationModeAMD(GLenum mode);

// GL_ANGLE_framebuffer_blit

  void  glBlitFramebufferANGLE(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);

// GL_ANGLE_framebuffer_multisample

  void  glRenderbufferStorageMultisampleANGLE(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);

// GL_APPLE_element_array

  void  glDrawElementArrayAPPLE(GLenum mode, GLint first, GLsizei count);
  void  glDrawRangeElementArrayAPPLE(GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count);
  void  glElementPointerAPPLE(GLenum type, const GLvoid *pointer);
  void  glMultiDrawElementArrayAPPLE(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount);
  void  glMultiDrawRangeElementArrayAPPLE(GLenum mode, GLuint start, GLuint end, const GLint *first, const GLsizei *count, GLsizei primcount);

// GL_APPLE_fence

  void  glDeleteFencesAPPLE(GLsizei n, const GLuint *fences);
  void  glFinishFenceAPPLE(GLuint fence);
  void  glFinishObjectAPPLE(GLenum object, GLint name);
  void  glGenFencesAPPLE(GLsizei n, GLuint *fences);
  GLboolean  glIsFenceAPPLE(GLuint fence);
  void  glSetFenceAPPLE(GLuint fence);
  GLboolean  glTestFenceAPPLE(GLuint fence);
  GLboolean  glTestObjectAPPLE(GLenum object, GLuint name);

// GL_APPLE_flush_buffer_range

  void  glBufferParameteriAPPLE(GLenum target, GLenum pname, GLint param);
  void  glFlushMappedBufferRangeAPPLE(GLenum target, GLintptr offset, GLsizeiptr size);

// GL_APPLE_flush_render

  void  glFinishRenderAPPLE(void);
  void  glFlushRenderAPPLE(void);
  void  glSwapAPPLE(void);

// GL_APPLE_framebuffer_multisample

  void  glRenderbufferStorageMultisampleAPPLE(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
  void  glResolveMultisampleFramebufferAPPLE(void);

// GL_APPLE_object_purgeable

  void  glGetObjectParameterivAPPLE(GLenum objectType, GLuint name, GLenum pname, GLint *params);
  GLenum  glObjectPurgeableAPPLE(GLenum objectType, GLuint name, GLenum option);
  GLenum  glObjectUnpurgeableAPPLE(GLenum objectType, GLuint name, GLenum option);

// GL_APPLE_texture_range

  void  glGetTexParameterPointervAPPLE(GLenum target, GLenum pname, GLvoid **params);
  void  glTextureRangeAPPLE(GLenum target, GLsizei length, const GLvoid *pointer);

// GL_APPLE_vertex_array_object

  void  glBindVertexArrayAPPLE(GLuint array);
  void  glDeleteVertexArraysAPPLE(GLsizei n, const GLuint *arrays);
  void  glGenVertexArraysAPPLE(GLsizei n, GLuint *arrays);
  GLboolean  glIsVertexArrayAPPLE(GLuint array);

// GL_APPLE_vertex_array_range

  void  glFlushVertexArrayRangeAPPLE(GLsizei length, GLvoid *pointer);
  void  glVertexArrayParameteriAPPLE(GLenum pname, GLint param);
  void  glVertexArrayRangeAPPLE(GLsizei length, GLvoid *pointer);

// GL_APPLE_vertex_program_evaluators

  void  glDisableVertexAttribAPPLE(GLuint index, GLenum pname);
  void  glEnableVertexAttribAPPLE(GLuint index, GLenum pname);
  GLboolean  glIsVertexAttribEnabledAPPLE(GLuint index, GLenum pname);
  void  glMapVertexAttrib1dAPPLE(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points);
  void  glMapVertexAttrib1fAPPLE(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points);
  void  glMapVertexAttrib2dAPPLE(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points);
  void  glMapVertexAttrib2fAPPLE(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points);

// GL_ARB_ES2_compatibility

  void  glClearDepthf(GLclampf d);
  void  glDepthRangef(GLclampf n, GLclampf f);
  void  glGetShaderPrecisionFormat(GLenum shadertype, GLenum precisiontype, GLint *range, GLint *precision);
  void  glReleaseShaderCompiler(void);
  void  glShaderBinary(GLsizei count, const GLuint *shaders, GLenum binaryformat, const GLvoid *binary, GLsizei length);

// GL_ARB_base_instance

  void  glDrawArraysInstancedBaseInstance(GLenum mode, GLint first, GLsizei count, GLsizei primcount, GLuint baseinstance);
  void  glDrawElementsInstancedBaseInstance(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount, GLuint baseinstance);
  void  glDrawElementsInstancedBaseVertexBaseInstance(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount, GLint basevertex, GLuint baseinstance);

// GL_ARB_blend_func_extended

  void  glBindFragDataLocationIndexed(GLuint program, GLuint colorNumber, GLuint index, const GLchar *name);
  GLint  glGetFragDataIndex(GLuint program, const GLchar *name);

// GL_ARB_clear_buffer_object

  void  glClearBufferData(GLenum target, GLenum internalformat, GLenum format, GLenum type, const GLvoid *data);
  void  glClearBufferSubData(GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const GLvoid *data);
  void  glClearNamedBufferDataEXT(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const GLvoid *data);

// GL_ARB_color_buffer_float

  void  glClampColorARB(GLenum target, GLenum clamp);

// GL_ARB_compute_shader

  void  glDispatchCompute(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z);
  void  glDispatchComputeIndirect(GLintptr indirect);

// GL_ARB_copy_buffer

  void  glCopyBufferSubData(GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size);

// GL_ARB_copy_image

  void  glCopyImageSubData(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth);

// GL_ARB_debug_output

  void  glDebugMessageCallbackARB(GLDEBUGPROCARB callback, const GLvoid *userParam);
  void  glDebugMessageControlARB(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled);
  void  glDebugMessageInsertARB(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf);
  GLuint  glGetDebugMessageLogARB(GLuint count, GLsizei bufsize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog);

// GL_ARB_draw_buffers

  void  glDrawBuffersARB(GLsizei n, const GLenum *bufs);

// GL_ARB_draw_buffers_blend

  void  glBlendEquationSeparateiARB(GLuint buf, GLenum modeRGB, GLenum modeAlpha);
  void  glBlendEquationiARB(GLuint buf, GLenum mode);
  void  glBlendFuncSeparateiARB(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
  void  glBlendFunciARB(GLuint buf, GLenum src, GLenum dst);

// GL_ARB_draw_elements_base_vertex

  void  glDrawElementsBaseVertex(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLint basevertex);
  void  glDrawElementsInstancedBaseVertex(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount, GLint basevertex);
  void  glDrawRangeElementsBaseVertex(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices, GLint basevertex);
  void  glMultiDrawElementsBaseVertex(GLenum mode, const GLsizei *count, GLenum type, const GLvoid * const *indices, GLsizei primcount, const GLint *basevertex);

// GL_ARB_draw_indirect

  void  glDrawArraysIndirect(GLenum mode, const GLvoid *indirect);
  void  glDrawElementsIndirect(GLenum mode, GLenum type, const GLvoid *indirect);

// GL_ARB_draw_instanced

  void  glDrawArraysInstancedARB(GLenum mode, GLint start, GLsizei count, GLsizei primcount);
  void  glDrawElementsInstancedARB(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount);

// GL_ARB_framebuffer_no_attachments

  void  glFramebufferParameteri(GLenum target, GLenum pname, GLint param);
  void  glGetFramebufferParameteriv(GLenum target, GLenum pname, GLint *params);
  void  glGetNamedFramebufferParameterivEXT(GLuint framebuffer, GLenum pname, GLint *params);
  void  glNamedFramebufferParameteriEXT(GLuint framebuffer, GLenum pname, GLint param);

// GL_ARB_framebuffer_object

  void  glBindFramebuffer(GLenum target, GLuint framebuffer);
  void  glBindRenderbuffer(GLenum target, GLuint renderbuffer);
  void  glBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
  GLenum  glCheckFramebufferStatus(GLenum target);
  void  glDeleteFramebuffers(GLsizei n, const GLuint *framebuffers);
  void  glDeleteRenderbuffers(GLsizei n, const GLuint *renderbuffers);
  void  glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
  void  glFramebufferTexture1D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
  void  glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
  void  glFramebufferTexture3D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint layer);
  void  glFramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
  void  glGenFramebuffers(GLsizei n, GLuint *framebuffers);
  void  glGenRenderbuffers(GLsizei n, GLuint *renderbuffers);
  void  glGenerateMipmap(GLenum target);
  void  glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint *params);
  void  glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint *params);
  GLboolean  glIsFramebuffer(GLuint framebuffer);
  GLboolean  glIsRenderbuffer(GLuint renderbuffer);
  void  glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
  void  glRenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);

// GL_ARB_geometry_shader4

  void  glFramebufferTextureARB(GLenum target, GLenum attachment, GLuint texture, GLint level);
  void  glFramebufferTextureFaceARB(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face);
  void  glFramebufferTextureLayerARB(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
  void  glProgramParameteriARB(GLuint program, GLenum pname, GLint value);

// GL_ARB_get_program_binary

  void  glGetProgramBinary(GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, GLvoid *binary);
  void  glProgramBinary(GLuint program, GLenum binaryFormat, const GLvoid *binary, GLsizei length);
  void  glProgramParameteri(GLuint program, GLenum pname, GLint value);

// GL_ARB_gpu_shader_fp64

  void  glGetUniformdv(GLuint program, GLint location, GLdouble *params);
  void  glUniform1d(GLint location, GLdouble x);
  void  glUniform1dv(GLint location, GLsizei count, const GLdouble *value);
  void  glUniform2d(GLint location, GLdouble x, GLdouble y);
  void  glUniform2dv(GLint location, GLsizei count, const GLdouble *value);
  void  glUniform3d(GLint location, GLdouble x, GLdouble y, GLdouble z);
  void  glUniform3dv(GLint location, GLsizei count, const GLdouble *value);
  void  glUniform4d(GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
  void  glUniform4dv(GLint location, GLsizei count, const GLdouble *value);
  void  glUniformMatrix2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
  void  glUniformMatrix2x3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
  void  glUniformMatrix2x4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
  void  glUniformMatrix3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
  void  glUniformMatrix3x2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
  void  glUniformMatrix3x4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
  void  glUniformMatrix4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
  void  glUniformMatrix4x2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
  void  glUniformMatrix4x3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);

// GL_ARB_imaging

  void  glColorSubTable(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data);
  void  glColorTable(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table);
  void  glColorTableParameterfv(GLenum target, GLenum pname, const GLfloat *params);
  void  glColorTableParameteriv(GLenum target, GLenum pname, const GLint *params);
  void  glConvolutionFilter1D(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image);
  void  glConvolutionFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image);
  void  glConvolutionParameterf(GLenum target, GLenum pname, GLfloat params);
  void  glConvolutionParameterfv(GLenum target, GLenum pname, const GLfloat *params);
  void  glConvolutionParameteri(GLenum target, GLenum pname, GLint params);
  void  glConvolutionParameteriv(GLenum target, GLenum pname, const GLint *params);
  void  glCopyColorSubTable(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);
  void  glCopyColorTable(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
  void  glCopyConvolutionFilter1D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
  void  glCopyConvolutionFilter2D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
  void  glGetColorTable(GLenum target, GLenum format, GLenum type, GLvoid *table);
  void  glGetColorTableParameterfv(GLenum target, GLenum pname, GLfloat *params);
  void  glGetColorTableParameteriv(GLenum target, GLenum pname, GLint *params);
  void  glGetConvolutionFilter(GLenum target, GLenum format, GLenum type, GLvoid *image);
  void  glGetConvolutionParameterfv(GLenum target, GLenum pname, GLfloat *params);
  void  glGetConvolutionParameteriv(GLenum target, GLenum pname, GLint *params);
  void  glGetHistogram(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
  void  glGetHistogramParameterfv(GLenum target, GLenum pname, GLfloat *params);
  void  glGetHistogramParameteriv(GLenum target, GLenum pname, GLint *params);
  void  glGetMinmax(GLenum target, GLboolean reset, GLenum format, GLenum types, GLvoid *values);
  void  glGetMinmaxParameterfv(GLenum target, GLenum pname, GLfloat *params);
  void  glGetMinmaxParameteriv(GLenum target, GLenum pname, GLint *params);
  void  glGetSeparableFilter(GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span);
  void  glHistogram(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
  void  glMinmax(GLenum target, GLenum internalformat, GLboolean sink);
  void  glResetHistogram(GLenum target);
  void  glResetMinmax(GLenum target);
  void  glSeparableFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column);

// GL_ARB_instanced_arrays

  void  glVertexAttribDivisorARB(GLuint index, GLuint divisor);

// GL_ARB_internalformat_query

  void  glGetInternalformativ(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *params);

// GL_ARB_internalformat_query2

  void  glGetInternalformati64v(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint64 *params);

// GL_ARB_invalidate_subdata

  void  glInvalidateBufferData(GLuint buffer);
  void  glInvalidateBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr length);
  void  glInvalidateFramebuffer(GLenum target, GLsizei numAttachments, const GLenum *attachments);
  void  glInvalidateSubFramebuffer(GLenum target, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height);
  void  glInvalidateTexImage(GLuint texture, GLint level);
  void  glInvalidateTexSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth);

// GL_ARB_map_buffer_range

  void  glFlushMappedBufferRange(GLenum target, GLintptr offset, GLsizeiptr length);
  GLvoid * glMapBufferRange(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);

// GL_ARB_matrix_palette

  void  glCurrentPaletteMatrixARB(GLint index);
  void  glMatrixIndexPointerARB(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
  void  glMatrixIndexubvARB(GLint size, const GLubyte *indices);
  void  glMatrixIndexuivARB(GLint size, const GLuint *indices);
  void  glMatrixIndexusvARB(GLint size, const GLushort *indices);

// GL_ARB_multi_draw_indirect

  void  glMultiDrawArraysIndirect(GLenum mode, const GLvoid *indirect, GLsizei primcount, GLsizei stride);
  void  glMultiDrawElementsIndirect(GLenum mode, GLenum type, const GLvoid *indirect, GLsizei primcount, GLsizei stride);

// GL_ARB_multisample

  void  glSampleCoverageARB(GLclampf value, GLboolean invert);

// GL_ARB_multitexture

  void  glActiveTextureARB(GLenum texture);
  void  glClientActiveTextureARB(GLenum texture);
  void  glMultiTexCoord1dARB(GLenum target, GLdouble s);
  void  glMultiTexCoord1dvARB(GLenum target, const GLdouble *v);
  void  glMultiTexCoord1fARB(GLenum target, GLfloat s);
  void  glMultiTexCoord1fvARB(GLenum target, const GLfloat *v);
  void  glMultiTexCoord1iARB(GLenum target, GLint s);
  void  glMultiTexCoord1ivARB(GLenum target, const GLint *v);
  void  glMultiTexCoord1sARB(GLenum target, GLshort s);
  void  glMultiTexCoord1svARB(GLenum target, const GLshort *v);
  void  glMultiTexCoord2dARB(GLenum target, GLdouble s, GLdouble t);
  void  glMultiTexCoord2dvARB(GLenum target, const GLdouble *v);
  void  glMultiTexCoord2fARB(GLenum target, GLfloat s, GLfloat t);
  void  glMultiTexCoord2fvARB(GLenum target, const GLfloat *v);
  void  glMultiTexCoord2iARB(GLenum target, GLint s, GLint t);
  void  glMultiTexCoord2ivARB(GLenum target, const GLint *v);
  void  glMultiTexCoord2sARB(GLenum target, GLshort s, GLshort t);
  void  glMultiTexCoord2svARB(GLenum target, const GLshort *v);
  void  glMultiTexCoord3dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r);
  void  glMultiTexCoord3dvARB(GLenum target, const GLdouble *v);
  void  glMultiTexCoord3fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r);
  void  glMultiTexCoord3fvARB(GLenum target, const GLfloat *v);
  void  glMultiTexCoord3iARB(GLenum target, GLint s, GLint t, GLint r);
  void  glMultiTexCoord3ivARB(GLenum target, const GLint *v);
  void  glMultiTexCoord3sARB(GLenum target, GLshort s, GLshort t, GLshort r);
  void  glMultiTexCoord3svARB(GLenum target, const GLshort *v);
  void  glMultiTexCoord4dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
  void  glMultiTexCoord4dvARB(GLenum target, const GLdouble *v);
  void  glMultiTexCoord4fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
  void  glMultiTexCoord4fvARB(GLenum target, const GLfloat *v);
  void  glMultiTexCoord4iARB(GLenum target, GLint s, GLint t, GLint r, GLint q);
  void  glMultiTexCoord4ivARB(GLenum target, const GLint *v);
  void  glMultiTexCoord4sARB(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
  void  glMultiTexCoord4svARB(GLenum target, const GLshort *v);

// GL_ARB_occlusion_query

  void  glBeginQueryARB(GLenum target, GLuint id);
  void  glDeleteQueriesARB(GLsizei n, const GLuint *ids);
  void  glEndQueryARB(GLenum target);
  void  glGenQueriesARB(GLsizei n, GLuint *ids);
  void  glGetQueryObjectivARB(GLuint id, GLenum pname, GLint *params);
  void  glGetQueryObjectuivARB(GLuint id, GLenum pname, GLuint *params);
  void  glGetQueryivARB(GLenum target, GLenum pname, GLint *params);
  GLboolean  glIsQueryARB(GLuint id);

// GL_ARB_point_parameters

  void  glPointParameterfARB(GLenum pname, GLfloat param);
  void  glPointParameterfvARB(GLenum pname, const GLfloat *params);

// GL_ARB_program_interface_query

  void  glGetProgramInterfaceiv(GLuint program, GLenum programInterface, GLenum pname, GLint *params);
  GLuint  glGetProgramResourceIndex(GLuint program, GLenum programInterface, const GLchar *name);
  GLint  glGetProgramResourceLocation(GLuint program, GLenum programInterface, const GLchar *name);
  GLint  glGetProgramResourceLocationIndex(GLuint program, GLenum programInterface, const GLchar *name);
  void  glGetProgramResourceName(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name);
  void  glGetProgramResourceiv(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum *props, GLsizei bufSize, GLsizei *length, GLint *params);

// GL_ARB_provoking_vertex

  void  glProvokingVertex(GLenum mode);

// GL_ARB_robustness

  GLenum  glGetGraphicsResetStatusARB(void);
  void  glGetnColorTableARB(GLenum target, GLenum format, GLenum type, GLsizei bufSize, GLvoid *table);
  void  glGetnCompressedTexImageARB(GLenum target, GLint lod, GLsizei bufSize, GLvoid *img);
  void  glGetnConvolutionFilterARB(GLenum target, GLenum format, GLenum type, GLsizei bufSize, GLvoid *image);
  void  glGetnHistogramARB(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, GLvoid *values);
  void  glGetnMapdvARB(GLenum target, GLenum query, GLsizei bufSize, GLdouble *v);
  void  glGetnMapfvARB(GLenum target, GLenum query, GLsizei bufSize, GLfloat *v);
  void  glGetnMapivARB(GLenum target, GLenum query, GLsizei bufSize, GLint *v);
  void  glGetnMinmaxARB(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, GLvoid *values);
  void  glGetnPixelMapfvARB(GLenum map, GLsizei bufSize, GLfloat *values);
  void  glGetnPixelMapuivARB(GLenum map, GLsizei bufSize, GLuint *values);
  void  glGetnPixelMapusvARB(GLenum map, GLsizei bufSize, GLushort *values);
  void  glGetnPolygonStippleARB(GLsizei bufSize, GLubyte *pattern);
  void  glGetnSeparableFilterARB(GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, GLvoid *row, GLsizei columnBufSize, GLvoid *column, GLvoid *span);
  void  glGetnTexImageARB(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, GLvoid *img);
  void  glGetnUniformdvARB(GLuint program, GLint location, GLsizei bufSize, GLdouble *params);
  void  glGetnUniformfvARB(GLuint program, GLint location, GLsizei bufSize, GLfloat *params);
  void  glGetnUniformivARB(GLuint program, GLint location, GLsizei bufSize, GLint *params);
  void  glGetnUniformuivARB(GLuint program, GLint location, GLsizei bufSize, GLuint *params);
  void  glReadnPixelsARB(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, GLvoid *data);

// GL_ARB_sample_shading

  void  glMinSampleShading(GLclampf value);
  void  glMinSampleShadingARB(GLclampf value);

// GL_ARB_sampler_objects

  void  glBindSampler(GLuint unit, GLuint sampler);
  void  glDeleteSamplers(GLsizei count, const GLuint *samplers);
  void  glGenSamplers(GLsizei count, GLuint *samplers);
  void  glGetSamplerParameterIiv(GLuint sampler, GLenum pname, GLint *params);
  void  glGetSamplerParameterIuiv(GLuint sampler, GLenum pname, GLuint *params);
  void  glGetSamplerParameterfv(GLuint sampler, GLenum pname, GLfloat *params);
  void  glGetSamplerParameteriv(GLuint sampler, GLenum pname, GLint *params);
  GLboolean  glIsSampler(GLuint sampler);
  void  glSamplerParameterIiv(GLuint sampler, GLenum pname, const GLint *params);
  void  glSamplerParameterIuiv(GLuint sampler, GLenum pname, const GLuint *params);
  void  glSamplerParameterf(GLuint sampler, GLenum pname, GLfloat param);
  void  glSamplerParameterfv(GLuint sampler, GLenum pname, const GLfloat *params);
  void  glSamplerParameteri(GLuint sampler, GLenum pname, GLint param);
  void  glSamplerParameteriv(GLuint sampler, GLenum pname, const GLint *params);

// GL_ARB_separate_shader_objects

  void  glActiveShaderProgram(GLuint pipeline, GLuint program);
  void  glBindProgramPipeline(GLuint pipeline);
  GLuint  glCreateShaderProgramv(GLenum type, GLsizei count, const GLchar * const *strings);
  void  glDeleteProgramPipelines(GLsizei n, const GLuint *pipelines);
  void  glGenProgramPipelines(GLsizei n, GLuint *pipelines);
  void  glGetProgramPipelineInfoLog(GLuint pipeline, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
  void  glGetProgramPipelineiv(GLuint pipeline, GLenum pname, GLint *params);
  GLboolean  glIsProgramPipeline(GLuint pipeline);
  void  glProgramUniform1d(GLuint program, GLint location, GLdouble x);
  void  glProgramUniform1dv(GLuint program, GLint location, GLsizei count, const GLdouble *value);
  void  glProgramUniform1f(GLuint program, GLint location, GLfloat x);
  void  glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value);
  void  glProgramUniform1i(GLuint program, GLint location, GLint x);
  void  glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value);
  void  glProgramUniform1ui(GLuint program, GLint location, GLuint v0);
  void  glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value);
  void  glProgramUniform2d(GLuint program, GLint location, GLdouble x, GLdouble y);
  void  glProgramUniform2dv(GLuint program, GLint location, GLsizei count, const GLdouble *value);
  void  glProgramUniform2f(GLuint program, GLint location, GLfloat x, GLfloat y);
  void  glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value);
  void  glProgramUniform2i(GLuint program, GLint location, GLint x, GLint y);
  void  glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value);
  void  glProgramUniform2ui(GLuint program, GLint location, GLuint x, GLuint y);
  void  glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value);
  void  glProgramUniform3d(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z);
  void  glProgramUniform3dv(GLuint program, GLint location, GLsizei count, const GLdouble *value);
  void  glProgramUniform3f(GLuint program, GLint location, GLfloat x, GLfloat y, GLfloat z);
  void  glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value);
  void  glProgramUniform3i(GLuint program, GLint location, GLint x, GLint y, GLint z);
  void  glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value);
  void  glProgramUniform3ui(GLuint program, GLint location, GLuint x, GLuint y, GLuint z);
  void  glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value);
  void  glProgramUniform4d(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
  void  glProgramUniform4dv(GLuint program, GLint location, GLsizei count, const GLdouble *value);
  void  glProgramUniform4f(GLuint program, GLint location, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
  void  glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value);
  void  glProgramUniform4i(GLuint program, GLint location, GLint x, GLint y, GLint z, GLint w);
  void  glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value);
  void  glProgramUniform4ui(GLuint program, GLint location, GLuint x, GLuint y, GLuint z, GLuint w);
  void  glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value);
  void  glProgramUniformMatrix2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
  void  glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
  void  glProgramUniformMatrix2x3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
  void  glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
  void  glProgramUniformMatrix2x4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
  void  glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
  void  glProgramUniformMatrix3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
  void  glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
  void  glProgramUniformMatrix3x2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
  void  glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
  void  glProgramUniformMatrix3x4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
  void  glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
  void  glProgramUniformMatrix4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
  void  glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
  void  glProgramUniformMatrix4x2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
  void  glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
  void  glProgramUniformMatrix4x3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
  void  glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
  void  glUseProgramStages(GLuint pipeline, GLbitfield stages, GLuint program);
  void  glValidateProgramPipeline(GLuint pipeline);

// GL_ARB_shader_atomic_counters

  void  glGetActiveAtomicCounterBufferiv(GLuint program, GLuint bufferIndex, GLenum pname, GLint *params);

// GL_ARB_shader_image_load_store

  void  glBindImageTexture(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format);
  void  glMemoryBarrier(GLbitfield barriers);

// GL_ARB_shader_objects

  void  glAttachObjectARB(GLhandleARB containerObj, GLhandleARB obj);
  void  glCompileShaderARB(GLhandleARB shaderObj);
  GLhandleARB  glCreateProgramObjectARB(void);
  GLhandleARB  glCreateShaderObjectARB(GLenum shaderType);
  void  glDeleteObjectARB(GLhandleARB obj);
  void  glDetachObjectARB(GLhandleARB containerObj, GLhandleARB attachedObj);
  void  glGetActiveUniformARB(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name);
  void  glGetAttachedObjectsARB(GLhandleARB containerObj, GLsizei maxCount, GLsizei *count, GLhandleARB *obj);
  GLhandleARB  glGetHandleARB(GLenum pname);
  void  glGetInfoLogARB(GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *infoLog);
  void  glGetObjectParameterfvARB(GLhandleARB obj, GLenum pname, GLfloat *params);
  void  glGetObjectParameterivARB(GLhandleARB obj, GLenum pname, GLint *params);
  void  glGetShaderSourceARB(GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *source);
  GLint  glGetUniformLocationARB(GLhandleARB programObj, const GLcharARB *name);
  void  glGetUniformfvARB(GLhandleARB programObj, GLint location, GLfloat *params);
  void  glGetUniformivARB(GLhandleARB programObj, GLint location, GLint *params);
  void  glLinkProgramARB(GLhandleARB programObj);
  void  glShaderSourceARB(GLhandleARB shaderObj, GLsizei count, const GLcharARB ** const string, const GLint *length);
  void  glUniform1fARB(GLint location, GLfloat v0);
  void  glUniform1fvARB(GLint location, GLsizei count, const GLfloat *value);
  void  glUniform1iARB(GLint location, GLint v0);
  void  glUniform1ivARB(GLint location, GLsizei count, const GLint *value);
  void  glUniform2fARB(GLint location, GLfloat v0, GLfloat v1);
  void  glUniform2fvARB(GLint location, GLsizei count, const GLfloat *value);
  void  glUniform2iARB(GLint location, GLint v0, GLint v1);
  void  glUniform2ivARB(GLint location, GLsizei count, const GLint *value);
  void  glUniform3fARB(GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
  void  glUniform3fvARB(GLint location, GLsizei count, const GLfloat *value);
  void  glUniform3iARB(GLint location, GLint v0, GLint v1, GLint v2);
  void  glUniform3ivARB(GLint location, GLsizei count, const GLint *value);
  void  glUniform4fARB(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
  void  glUniform4fvARB(GLint location, GLsizei count, const GLfloat *value);
  void  glUniform4iARB(GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
  void  glUniform4ivARB(GLint location, GLsizei count, const GLint *value);
  void  glUniformMatrix2fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
  void  glUniformMatrix3fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
  void  glUniformMatrix4fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
  void  glUseProgramObjectARB(GLhandleARB programObj);
  void  glValidateProgramARB(GLhandleARB programObj);

// GL_ARB_shader_storage_buffer_object

  void  glShaderStorageBlockBinding(GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding);

// GL_ARB_shader_subroutine

  void  glGetActiveSubroutineName(GLuint program, GLenum shaderType, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name);
  void  glGetActiveSubroutineUniformName(GLuint program, GLenum shaderType, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name);
  void  glGetActiveSubroutineUniformiv(GLuint program, GLenum shaderType, GLuint index, GLenum pname, GLint *values);
  void  glGetProgramStageiv(GLuint program, GLenum shaderType, GLenum pname, GLint *values);
  void  glGetProgramSubroutineParameteruivNV(GLenum target, GLuint index, GLuint *params);
  GLuint  glGetSubroutineIndex(GLuint program, GLenum shaderType, const GLchar *name);
  GLint  glGetSubroutineUniformLocation(GLuint program, GLenum shaderType, const GLchar *name);
  void  glGetUniformSubroutineuiv(GLenum shaderType, GLint location, GLuint *params);
  void  glProgramSubroutineParametersuivNV(GLenum target, GLsizei count, const GLuint *params);
  void  glUniformSubroutinesuiv(GLenum shaderType, GLsizei count, const GLuint *indices);

// GL_ARB_shading_language_include

  void  glCompileShaderIncludeARB(GLuint shader, GLsizei count, const GLchar **path, const GLint *length);
  void  glDeleteNamedStringARB(GLint namelen, const GLchar *name);
  void  glGetNamedStringARB(GLint namelen, const GLchar *name, GLsizei bufSize, GLint *stringlen, GLchar *string);
  void  glGetNamedStringivARB(GLint namelen, const GLchar *name, GLenum pname, GLint *params);
  GLboolean  glIsNamedStringARB(GLint namelen, const GLchar *name);
  void  glNamedStringARB(GLenum type, GLint namelen, const GLchar *name, GLint stringlen, const GLchar *string);

// GL_ARB_sync

  GLenum  glClientWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout);
  void  glDeleteSync(GLsync sync);
  GLsync  glFenceSync(GLenum condition, GLbitfield flags);
  void  glGetInteger64v(GLenum pname, GLint64 *params);
  void  glGetSynciv(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values);
  GLboolean  glIsSync(GLsync sync);
  void  glWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout);

// GL_ARB_tessellation_shader

  void  glPatchParameterfv(GLenum pname, const GLfloat *values);
  void  glPatchParameteri(GLenum pname, GLint value);

// GL_ARB_texture_buffer_object

  void  glTexBufferARB(GLenum target, GLenum internalformat, GLuint buffer);

// GL_ARB_texture_buffer_range

  void  glTexBufferRange(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
  void  glTextureBufferRangeEXT(GLuint texture, GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);

// GL_ARB_texture_compression

  void  glCompressedTexImage1DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data);
  void  glCompressedTexImage2DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
  void  glCompressedTexImage3DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data);
  void  glCompressedTexSubImage1DARB(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data);
  void  glCompressedTexSubImage2DARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
  void  glCompressedTexSubImage3DARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data);
  void  glGetCompressedTexImageARB(GLenum target, GLint lod, GLvoid *img);

// GL_ARB_texture_multisample

  void  glGetMultisamplefv(GLenum pname, GLuint index, GLfloat *val);
  void  glSampleMaski(GLuint index, GLbitfield mask);
  void  glTexImage2DMultisample(GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
  void  glTexImage3DMultisample(GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);

// GL_ARB_texture_storage

  void  glTexStorage1D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
  void  glTexStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
  void  glTexStorage3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
  void  glTextureStorage1DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
  void  glTextureStorage2DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
  void  glTextureStorage3DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);

// GL_ARB_texture_storage_multisample

  void  glTexStorage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
  void  glTexStorage3DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
  void  glTextureStorage2DMultisampleEXT(GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
  void  glTextureStorage3DMultisampleEXT(GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);

// GL_ARB_texture_view

  void  glTextureView(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers);

// GL_ARB_timer_query

  void  glGetQueryObjecti64v(GLuint id, GLenum pname, GLint64 *params);
  void  glGetQueryObjectui64v(GLuint id, GLenum pname, GLuint64 *params);
  void  glQueryCounter(GLuint id, GLenum target);

// GL_ARB_transform_feedback2

  void  glBindTransformFeedback(GLenum target, GLuint id);
  void  glDeleteTransformFeedbacks(GLsizei n, const GLuint *ids);
  void  glDrawTransformFeedback(GLenum mode, GLuint name);
  void  glGenTransformFeedbacks(GLsizei n, GLuint *ids);
  GLboolean  glIsTransformFeedback(GLuint id);
  void  glPauseTransformFeedback(void);
  void  glResumeTransformFeedback(void);

// GL_ARB_transform_feedback3

  void  glBeginQueryIndexed(GLenum target, GLuint index, GLuint id);
  void  glDrawTransformFeedbackStream(GLenum mode, GLuint id, GLuint stream);
  void  glEndQueryIndexed(GLenum target, GLuint index);
  void  glGetQueryIndexediv(GLenum target, GLuint index, GLenum pname, GLint *params);

// GL_ARB_transform_feedback_instanced

  void  glDrawTransformFeedbackInstanced(GLenum mode, GLuint id, GLsizei primcount);
  void  glDrawTransformFeedbackStreamInstanced(GLenum mode, GLuint id, GLuint stream, GLsizei primcount);

// GL_ARB_transpose_matrix

  void  glLoadTransposeMatrixdARB(const GLdouble *m);
  void  glLoadTransposeMatrixfARB(const GLfloat *m);
  void  glMultTransposeMatrixdARB(const GLdouble *m);
  void  glMultTransposeMatrixfARB(const GLfloat *m);

// GL_ARB_uniform_buffer_object

  void  glBindBufferBase(GLenum target, GLuint index, GLuint buffer);
  void  glBindBufferRange(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
  void  glGetActiveUniformBlockName(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName);
  void  glGetActiveUniformBlockiv(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params);
  void  glGetActiveUniformName(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformName);
  void  glGetActiveUniformsiv(GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params);
  void  glGetIntegeri_v(GLenum target, GLuint index, GLint *data);
  GLuint  glGetUniformBlockIndex(GLuint program, const GLchar *uniformBlockName);
  void  glGetUniformIndices(GLuint program, GLsizei uniformCount, const GLchar * const *uniformNames, GLuint *uniformIndices);
  void  glUniformBlockBinding(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);

// GL_ARB_vertex_array_object

  void  glBindVertexArray(GLuint array);
  void  glDeleteVertexArrays(GLsizei n, const GLuint *arrays);
  void  glGenVertexArrays(GLsizei n, GLuint *arrays);
  GLboolean  glIsVertexArray(GLuint array);

// GL_ARB_vertex_attrib_64bit

  void  glGetVertexAttribLdv(GLuint index, GLenum pname, GLdouble *params);
  void  glVertexAttribL1d(GLuint index, GLdouble x);
  void  glVertexAttribL1dv(GLuint index, const GLdouble *v);
  void  glVertexAttribL2d(GLuint index, GLdouble x, GLdouble y);
  void  glVertexAttribL2dv(GLuint index, const GLdouble *v);
  void  glVertexAttribL3d(GLuint index, GLdouble x, GLdouble y, GLdouble z);
  void  glVertexAttribL3dv(GLuint index, const GLdouble *v);
  void  glVertexAttribL4d(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
  void  glVertexAttribL4dv(GLuint index, const GLdouble *v);
  void  glVertexAttribLPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);

// GL_ARB_vertex_attrib_binding

  void  glBindVertexBuffer(GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
  void  glVertexAttribBinding(GLuint attribindex, GLuint bindingindex);
  void  glVertexAttribFormat(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
  void  glVertexAttribIFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
  void  glVertexAttribLFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
  void  glVertexBindingDivisor(GLuint bindingindex, GLuint divisor);

// GL_ARB_vertex_blend

  void  glVertexBlendARB(GLint count);
  void  glWeightPointerARB(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
  void  glWeightbvARB(GLint size, const GLbyte *weights);
  void  glWeightdvARB(GLint size, const GLdouble *weights);
  void  glWeightfvARB(GLint size, const GLfloat *weights);
  void  glWeightivARB(GLint size, const GLint *weights);
  void  glWeightsvARB(GLint size, const GLshort *weights);
  void  glWeightubvARB(GLint size, const GLubyte *weights);
  void  glWeightuivARB(GLint size, const GLuint *weights);
  void  glWeightusvARB(GLint size, const GLushort *weights);

// GL_ARB_vertex_buffer_object

  void  glBindBufferARB(GLenum target, GLuint buffer);
  void  glBufferDataARB(GLenum target, GLsizeiptrARB size, const GLvoid *data, GLenum usage);
  void  glBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid *data);
  void  glDeleteBuffersARB(GLsizei n, const GLuint *buffers);
  void  glGenBuffersARB(GLsizei n, GLuint *buffers);
  void  glGetBufferParameterivARB(GLenum target, GLenum pname, GLint *params);
  void  glGetBufferPointervARB(GLenum target, GLenum pname, GLvoid **params);
  void  glGetBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, GLvoid *data);
  GLboolean  glIsBufferARB(GLuint buffer);
  GLvoid * glMapBufferARB(GLenum target, GLenum access);
  GLboolean  glUnmapBufferARB(GLenum target);

// GL_ARB_vertex_program

  void  glBindProgramARB(GLenum target, GLuint program);
  void  glDeleteProgramsARB(GLsizei n, const GLuint *programs);
  void  glDisableVertexAttribArrayARB(GLuint index);
  void  glEnableVertexAttribArrayARB(GLuint index);
  void  glGenProgramsARB(GLsizei n, GLuint *programs);
  void  glGetProgramEnvParameterdvARB(GLenum target, GLuint index, GLdouble *params);
  void  glGetProgramEnvParameterfvARB(GLenum target, GLuint index, GLfloat *params);
  void  glGetProgramLocalParameterdvARB(GLenum target, GLuint index, GLdouble *params);
  void  glGetProgramLocalParameterfvARB(GLenum target, GLuint index, GLfloat *params);
  void  glGetProgramStringARB(GLenum target, GLenum pname, GLvoid *string);
  void  glGetProgramivARB(GLenum target, GLenum pname, GLint *params);
  void  glGetVertexAttribPointervARB(GLuint index, GLenum pname, GLvoid **pointer);
  void  glGetVertexAttribdvARB(GLuint index, GLenum pname, GLdouble *params);
  void  glGetVertexAttribfvARB(GLuint index, GLenum pname, GLfloat *params);
  void  glGetVertexAttribivARB(GLuint index, GLenum pname, GLint *params);
  GLboolean  glIsProgramARB(GLuint program);
  void  glProgramEnvParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
  void  glProgramEnvParameter4dvARB(GLenum target, GLuint index, const GLdouble *params);
  void  glProgramEnvParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
  void  glProgramEnvParameter4fvARB(GLenum target, GLuint index, const GLfloat *params);
  void  glProgramLocalParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
  void  glProgramLocalParameter4dvARB(GLenum target, GLuint index, const GLdouble *params);
  void  glProgramLocalParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
  void  glProgramLocalParameter4fvARB(GLenum target, GLuint index, const GLfloat *params);
  void  glProgramStringARB(GLenum target, GLenum format, GLsizei len, const GLvoid *string);
  void  glVertexAttrib1dARB(GLuint index, GLdouble x);
  void  glVertexAttrib1dvARB(GLuint index, const GLdouble *v);
  void  glVertexAttrib1fARB(GLuint index, GLfloat x);
  void  glVertexAttrib1fvARB(GLuint index, const GLfloat *v);
  void  glVertexAttrib1sARB(GLuint index, GLshort x);
  void  glVertexAttrib1svARB(GLuint index, const GLshort *v);
  void  glVertexAttrib2dARB(GLuint index, GLdouble x, GLdouble y);
  void  glVertexAttrib2dvARB(GLuint index, const GLdouble *v);
  void  glVertexAttrib2fARB(GLuint index, GLfloat x, GLfloat y);
  void  glVertexAttrib2fvARB(GLuint index, const GLfloat *v);
  void  glVertexAttrib2sARB(GLuint index, GLshort x, GLshort y);
  void  glVertexAttrib2svARB(GLuint index, const GLshort *v);
  void  glVertexAttrib3dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z);
  void  glVertexAttrib3dvARB(GLuint index, const GLdouble *v);
  void  glVertexAttrib3fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z);
  void  glVertexAttrib3fvARB(GLuint index, const GLfloat *v);
  void  glVertexAttrib3sARB(GLuint index, GLshort x, GLshort y, GLshort z);
  void  glVertexAttrib3svARB(GLuint index, const GLshort *v);
  void  glVertexAttrib4NbvARB(GLuint index, const GLbyte *v);
  void  glVertexAttrib4NivARB(GLuint index, const GLint *v);
  void  glVertexAttrib4NsvARB(GLuint index, const GLshort *v);
  void  glVertexAttrib4NubARB(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
  void  glVertexAttrib4NubvARB(GLuint index, const GLubyte *v);
  void  glVertexAttrib4NuivARB(GLuint index, const GLuint *v);
  void  glVertexAttrib4NusvARB(GLuint index, const GLushort *v);
  void  glVertexAttrib4bvARB(GLuint index, const GLbyte *v);
  void  glVertexAttrib4dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
  void  glVertexAttrib4dvARB(GLuint index, const GLdouble *v);
  void  glVertexAttrib4fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
  void  glVertexAttrib4fvARB(GLuint index, const GLfloat *v);
  void  glVertexAttrib4ivARB(GLuint index, const GLint *v);
  void  glVertexAttrib4sARB(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
  void  glVertexAttrib4svARB(GLuint index, const GLshort *v);
  void  glVertexAttrib4ubvARB(GLuint index, const GLubyte *v);
  void  glVertexAttrib4uivARB(GLuint index, const GLuint *v);
  void  glVertexAttrib4usvARB(GLuint index, const GLushort *v);
  void  glVertexAttribPointerARB(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer);

// GL_ARB_vertex_shader

  void  glBindAttribLocationARB(GLhandleARB programObj, GLuint index, const GLcharARB *name);
  void  glGetActiveAttribARB(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name);
  GLint  glGetAttribLocationARB(GLhandleARB programObj, const GLcharARB *name);

// GL_ARB_vertex_type_2_10_10_10_rev

  void  glColorP3ui(GLenum type, GLuint color);
  void  glColorP3uiv(GLenum type, const GLuint *color);
  void  glColorP4ui(GLenum type, GLuint color);
  void  glColorP4uiv(GLenum type, const GLuint *color);
  void  glMultiTexCoordP1ui(GLenum texture, GLenum type, GLuint coords);
  void  glMultiTexCoordP1uiv(GLenum texture, GLenum type, const GLuint *coords);
  void  glMultiTexCoordP2ui(GLenum texture, GLenum type, GLuint coords);
  void  glMultiTexCoordP2uiv(GLenum texture, GLenum type, const GLuint *coords);
  void  glMultiTexCoordP3ui(GLenum texture, GLenum type, GLuint coords);
  void  glMultiTexCoordP3uiv(GLenum texture, GLenum type, const GLuint *coords);
  void  glMultiTexCoordP4ui(GLenum texture, GLenum type, GLuint coords);
  void  glMultiTexCoordP4uiv(GLenum texture, GLenum type, const GLuint *coords);
  void  glNormalP3ui(GLenum type, GLuint coords);
  void  glNormalP3uiv(GLenum type, const GLuint *coords);
  void  glSecondaryColorP3ui(GLenum type, GLuint color);
  void  glSecondaryColorP3uiv(GLenum type, const GLuint *color);
  void  glTexCoordP1ui(GLenum type, GLuint coords);
  void  glTexCoordP1uiv(GLenum type, const GLuint *coords);
  void  glTexCoordP2ui(GLenum type, GLuint coords);
  void  glTexCoordP2uiv(GLenum type, const GLuint *coords);
  void  glTexCoordP3ui(GLenum type, GLuint coords);
  void  glTexCoordP3uiv(GLenum type, const GLuint *coords);
  void  glTexCoordP4ui(GLenum type, GLuint coords);
  void  glTexCoordP4uiv(GLenum type, const GLuint *coords);
  void  glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value);
  void  glVertexAttribP1uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
  void  glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value);
  void  glVertexAttribP2uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
  void  glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value);
  void  glVertexAttribP3uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
  void  glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value);
  void  glVertexAttribP4uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
  void  glVertexP2ui(GLenum type, GLuint coords);
  void  glVertexP2uiv(GLenum type, const GLuint *coords);
  void  glVertexP3ui(GLenum type, GLuint coords);
  void  glVertexP3uiv(GLenum type, const GLuint *coords);
  void  glVertexP4ui(GLenum type, GLuint coords);
  void  glVertexP4uiv(GLenum type, const GLuint *coords);

// GL_ARB_viewport_array

  void  glDepthRangeArrayv(GLuint first, GLsizei count, const GLclampd *v);
  void  glDepthRangeIndexed(GLuint index, GLclampd n, GLclampd f);
  void  glGetDoublei_v(GLenum target, GLuint index, GLdouble *v);
  void  glGetFloati_v(GLenum target, GLuint index, GLfloat *v);
  void  glScissorArrayv(GLuint first, GLsizei count, const GLint *v);
  void  glScissorIndexed(GLuint index, GLint left, GLint bottom, GLint width, GLint height);
  void  glScissorIndexedv(GLuint index, const GLint *v);
  void  glViewportArrayv(GLuint first, GLsizei count, const GLfloat *v);
  void  glViewportIndexedf(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h);
  void  glViewportIndexedfv(GLuint index, const GLfloat *v);

// GL_ARB_window_pos

  void  glWindowPos2dARB(GLdouble x, GLdouble y);
  void  glWindowPos2dvARB(const GLdouble *p);
  void  glWindowPos2fARB(GLfloat x, GLfloat y);
  void  glWindowPos2fvARB(const GLfloat *p);
  void  glWindowPos2iARB(GLint x, GLint y);
  void  glWindowPos2ivARB(const GLint *p);
  void  glWindowPos2sARB(GLshort x, GLshort y);
  void  glWindowPos2svARB(const GLshort *p);
  void  glWindowPos3dARB(GLdouble x, GLdouble y, GLdouble z);
  void  glWindowPos3dvARB(const GLdouble *p);
  void  glWindowPos3fARB(GLfloat x, GLfloat y, GLfloat z);
  void  glWindowPos3fvARB(const GLfloat *p);
  void  glWindowPos3iARB(GLint x, GLint y, GLint z);
  void  glWindowPos3ivARB(const GLint *p);
  void  glWindowPos3sARB(GLshort x, GLshort y, GLshort z);
  void  glWindowPos3svARB(const GLshort *p);

// GL_ATI_draw_buffers

  void  glDrawBuffersATI(GLsizei n, const GLenum *bufs);

// GL_ATI_element_array

  void  glDrawElementArrayATI(GLenum mode, GLsizei count);
  void  glDrawRangeElementArrayATI(GLenum mode, GLuint start, GLuint end, GLsizei count);
  void  glElementPointerATI(GLenum type, const GLvoid *pointer);

// GL_ATI_envmap_bumpmap

  void  glGetTexBumpParameterfvATI(GLenum pname, GLfloat *param);
  void  glGetTexBumpParameterivATI(GLenum pname, GLint *param);
  void  glTexBumpParameterfvATI(GLenum pname, const GLfloat *param);
  void  glTexBumpParameterivATI(GLenum pname, const GLint *param);

// GL_ATI_fragment_shader

  void  glAlphaFragmentOp1ATI(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod);
  void  glAlphaFragmentOp2ATI(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod);
  void  glAlphaFragmentOp3ATI(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod);
  void  glBeginFragmentShaderATI(void);
  void  glBindFragmentShaderATI(GLuint id);
  void  glColorFragmentOp1ATI(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod);
  void  glColorFragmentOp2ATI(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod);
  void  glColorFragmentOp3ATI(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod);
  void  glDeleteFragmentShaderATI(GLuint id);
  void  glEndFragmentShaderATI(void);
  GLuint  glGenFragmentShadersATI(GLuint range);
  void  glPassTexCoordATI(GLuint dst, GLuint coord, GLenum swizzle);
  void  glSampleMapATI(GLuint dst, GLuint interp, GLenum swizzle);
  void  glSetFragmentShaderConstantATI(GLuint dst, const GLfloat *value);

// GL_ATI_map_object_buffer

  GLvoid * glMapObjectBufferATI(GLuint buffer);
  void  glUnmapObjectBufferATI(GLuint buffer);

// GL_ATI_pn_triangles

  void  glPNTrianglesfATI(GLenum pname, GLfloat param);
  void  glPNTrianglesiATI(GLenum pname, GLint param);

// GL_ATI_separate_stencil

  void  glStencilFuncSeparateATI(GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask);
  void  glStencilOpSeparateATI(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);

// GL_ATI_vertex_array_object

  void  glArrayObjectATI(GLenum array, GLint size, GLenum type, GLsizei stride, GLuint buffer, GLuint offset);
  void  glFreeObjectBufferATI(GLuint buffer);
  void  glGetArrayObjectfvATI(GLenum array, GLenum pname, GLfloat *params);
  void  glGetArrayObjectivATI(GLenum array, GLenum pname, GLint *params);
  void  glGetObjectBufferfvATI(GLuint buffer, GLenum pname, GLfloat *params);
  void  glGetObjectBufferivATI(GLuint buffer, GLenum pname, GLint *params);
  void  glGetVariantArrayObjectfvATI(GLuint id, GLenum pname, GLfloat *params);
  void  glGetVariantArrayObjectivATI(GLuint id, GLenum pname, GLint *params);
  GLboolean  glIsObjectBufferATI(GLuint buffer);
  GLuint  glNewObjectBufferATI(GLsizei size, const GLvoid *pointer, GLenum usage);
  void  glUpdateObjectBufferATI(GLuint buffer, GLuint offset, GLsizei size, const GLvoid *pointer, GLenum preserve);
  void  glVariantArrayObjectATI(GLuint id, GLenum type, GLsizei stride, GLuint buffer, GLuint offset);

// GL_ATI_vertex_attrib_array_object

  void  glGetVertexAttribArrayObjectfvATI(GLuint index, GLenum pname, GLfloat *params);
  void  glGetVertexAttribArrayObjectivATI(GLuint index, GLenum pname, GLint *params);
  void  glVertexAttribArrayObjectATI(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLuint buffer, GLuint offset);

// GL_ATI_vertex_streams

  void  glClientActiveVertexStreamATI(GLenum stream);
  void  glNormalStream3bATI(GLenum stream, GLbyte x, GLbyte y, GLbyte z);
  void  glNormalStream3bvATI(GLenum stream, const GLbyte *coords);
  void  glNormalStream3dATI(GLenum stream, GLdouble x, GLdouble y, GLdouble z);
  void  glNormalStream3dvATI(GLenum stream, const GLdouble *coords);
  void  glNormalStream3fATI(GLenum stream, GLfloat x, GLfloat y, GLfloat z);
  void  glNormalStream3fvATI(GLenum stream, const GLfloat *coords);
  void  glNormalStream3iATI(GLenum stream, GLint x, GLint y, GLint z);
  void  glNormalStream3ivATI(GLenum stream, const GLint *coords);
  void  glNormalStream3sATI(GLenum stream, GLshort x, GLshort y, GLshort z);
  void  glNormalStream3svATI(GLenum stream, const GLshort *coords);
  void  glVertexBlendEnvfATI(GLenum pname, GLfloat param);
  void  glVertexBlendEnviATI(GLenum pname, GLint param);
  void  glVertexStream1dATI(GLenum stream, GLdouble x);
  void  glVertexStream1dvATI(GLenum stream, const GLdouble *coords);
  void  glVertexStream1fATI(GLenum stream, GLfloat x);
  void  glVertexStream1fvATI(GLenum stream, const GLfloat *coords);
  void  glVertexStream1iATI(GLenum stream, GLint x);
  void  glVertexStream1ivATI(GLenum stream, const GLint *coords);
  void  glVertexStream1sATI(GLenum stream, GLshort x);
  void  glVertexStream1svATI(GLenum stream, const GLshort *coords);
  void  glVertexStream2dATI(GLenum stream, GLdouble x, GLdouble y);
  void  glVertexStream2dvATI(GLenum stream, const GLdouble *coords);
  void  glVertexStream2fATI(GLenum stream, GLfloat x, GLfloat y);
  void  glVertexStream2fvATI(GLenum stream, const GLfloat *coords);
  void  glVertexStream2iATI(GLenum stream, GLint x, GLint y);
  void  glVertexStream2ivATI(GLenum stream, const GLint *coords);
  void  glVertexStream2sATI(GLenum stream, GLshort x, GLshort y);
  void  glVertexStream2svATI(GLenum stream, const GLshort *coords);
  void  glVertexStream3dATI(GLenum stream, GLdouble x, GLdouble y, GLdouble z);
  void  glVertexStream3dvATI(GLenum stream, const GLdouble *coords);
  void  glVertexStream3fATI(GLenum stream, GLfloat x, GLfloat y, GLfloat z);
  void  glVertexStream3fvATI(GLenum stream, const GLfloat *coords);
  void  glVertexStream3iATI(GLenum stream, GLint x, GLint y, GLint z);
  void  glVertexStream3ivATI(GLenum stream, const GLint *coords);
  void  glVertexStream3sATI(GLenum stream, GLshort x, GLshort y, GLshort z);
  void  glVertexStream3svATI(GLenum stream, const GLshort *coords);
  void  glVertexStream4dATI(GLenum stream, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
  void  glVertexStream4dvATI(GLenum stream, const GLdouble *coords);
  void  glVertexStream4fATI(GLenum stream, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
  void  glVertexStream4fvATI(GLenum stream, const GLfloat *coords);
  void  glVertexStream4iATI(GLenum stream, GLint x, GLint y, GLint z, GLint w);
  void  glVertexStream4ivATI(GLenum stream, const GLint *coords);
  void  glVertexStream4sATI(GLenum stream, GLshort x, GLshort y, GLshort z, GLshort w);
  void  glVertexStream4svATI(GLenum stream, const GLshort *coords);

// GL_EXT_bindable_uniform

  GLint  glGetUniformBufferSizeEXT(GLuint program, GLint location);
  GLintptr  glGetUniformOffsetEXT(GLuint program, GLint location);
  void  glUniformBufferEXT(GLuint program, GLint location, GLuint buffer);

// GL_EXT_blend_color

  void  glBlendColorEXT(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);

// GL_EXT_blend_equation_separate

  void  glBlendEquationSeparateEXT(GLenum modeRGB, GLenum modeAlpha);

// GL_EXT_blend_func_separate

  void  glBlendFuncSeparateEXT(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);

// GL_EXT_blend_minmax

  void  glBlendEquationEXT(GLenum mode);

// GL_EXT_color_subtable

  void  glColorSubTableEXT(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *table);
  void  glCopyColorSubTableEXT(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);

// GL_EXT_compiled_vertex_array

  void  glLockArraysEXT(GLint first, GLsizei count);
  void  glUnlockArraysEXT(void);

// GL_EXT_convolution

  void  glConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image);
  void  glConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image);
  void  glConvolutionParameterfEXT(GLenum target, GLenum pname, GLfloat param);
  void  glConvolutionParameterfvEXT(GLenum target, GLenum pname, const GLfloat *params);
  void  glConvolutionParameteriEXT(GLenum target, GLenum pname, GLint param);
  void  glConvolutionParameterivEXT(GLenum target, GLenum pname, const GLint *params);
  void  glCopyConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
  void  glCopyConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
  void  glGetConvolutionFilterEXT(GLenum target, GLenum format, GLenum type, GLvoid *image);
  void  glGetConvolutionParameterfvEXT(GLenum target, GLenum pname, GLfloat *params);
  void  glGetConvolutionParameterivEXT(GLenum target, GLenum pname, GLint *params);
  void  glGetSeparableFilterEXT(GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span);
  void  glSeparableFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column);

// GL_EXT_coordinate_frame

  void  glBinormal3bEXT(GLbyte bx, GLbyte by, GLbyte bz);
  void  glBinormal3bvEXT(const GLbyte *v);
  void  glBinormal3dEXT(GLdouble bx, GLdouble by, GLdouble bz);
  void  glBinormal3dvEXT(const GLdouble *v);
  void  glBinormal3fEXT(GLfloat bx, GLfloat by, GLfloat bz);
  void  glBinormal3fvEXT(const GLfloat *v);
  void  glBinormal3iEXT(GLint bx, GLint by, GLint bz);
  void  glBinormal3ivEXT(const GLint *v);
  void  glBinormal3sEXT(GLshort bx, GLshort by, GLshort bz);
  void  glBinormal3svEXT(const GLshort *v);
  void  glBinormalPointerEXT(GLenum type, GLsizei stride, const GLvoid *pointer);
  void  glTangent3bEXT(GLbyte tx, GLbyte ty, GLbyte tz);
  void  glTangent3bvEXT(const GLbyte *v);
  void  glTangent3dEXT(GLdouble tx, GLdouble ty, GLdouble tz);
  void  glTangent3dvEXT(const GLdouble *v);
  void  glTangent3fEXT(GLfloat tx, GLfloat ty, GLfloat tz);
  void  glTangent3fvEXT(const GLfloat *v);
  void  glTangent3iEXT(GLint tx, GLint ty, GLint tz);
  void  glTangent3ivEXT(const GLint *v);
  void  glTangent3sEXT(GLshort tx, GLshort ty, GLshort tz);
  void  glTangent3svEXT(const GLshort *v);
  void  glTangentPointerEXT(GLenum type, GLsizei stride, const GLvoid *pointer);

// GL_EXT_copy_texture

  void  glCopyTexImage1DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
  void  glCopyTexImage2DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
  void  glCopyTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
  void  glCopyTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
  void  glCopyTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);

// GL_EXT_cull_vertex

  void  glCullParameterdvEXT(GLenum pname, GLdouble *params);
  void  glCullParameterfvEXT(GLenum pname, GLfloat *params);

// GL_EXT_debug_label

  void  glGetObjectLabelEXT(GLenum type, GLuint object, GLsizei bufSize, GLsizei *length, GLchar *label);
  void  glLabelObjectEXT(GLenum type, GLuint object, GLsizei length, const GLchar *label);

// GL_EXT_debug_marker

  void  glInsertEventMarkerEXT(GLsizei length, const GLchar *marker);
  void  glPopGroupMarkerEXT(void);
  void  glPushGroupMarkerEXT(GLsizei length, const GLchar *marker);

// GL_EXT_depth_bounds_test

  void  glDepthBoundsEXT(GLclampd zmin, GLclampd zmax);

// GL_EXT_direct_state_access

  void  glBindMultiTextureEXT(GLenum texunit, GLenum target, GLuint texture);
  GLenum  glCheckNamedFramebufferStatusEXT(GLuint framebuffer, GLenum target);
  void  glClientAttribDefaultEXT(GLbitfield mask);
  void  glCompressedMultiTexImage1DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data);
  void  glCompressedMultiTexImage2DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *bits);
  void  glCompressedMultiTexImage3DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *bits);
  void  glCompressedMultiTexSubImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data);
  void  glCompressedMultiTexSubImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
  void  glCompressedMultiTexSubImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data);
  void  glCompressedTextureImage1DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *bits);
  void  glCompressedTextureImage2DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *bits);
  void  glCompressedTextureImage3DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *bits);
  void  glCompressedTextureSubImage1DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *bits);
  void  glCompressedTextureSubImage2DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *bits);
  void  glCompressedTextureSubImage3DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *bits);
  void  glCopyMultiTexImage1DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
  void  glCopyMultiTexImage2DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
  void  glCopyMultiTexSubImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
  void  glCopyMultiTexSubImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
  void  glCopyMultiTexSubImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
  void  glCopyTextureImage1DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
  void  glCopyTextureImage2DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
  void  glCopyTextureSubImage1DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
  void  glCopyTextureSubImage2DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
  void  glCopyTextureSubImage3DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
  void  glDisableClientStateIndexedEXT(GLenum array, GLuint index);
  void  glDisableVertexArrayAttribEXT(GLuint vaobj, GLenum array);
  void  glDisableVertexArrayEXT(GLuint vaobj, GLenum array);
  void  glEnableClientStateIndexedEXT(GLenum array, GLuint index);
  void  glEnableVertexArrayAttribEXT(GLuint vaobj, GLenum array);
  void  glEnableVertexArrayEXT(GLuint vaobj, GLenum array);
  void  glFlushMappedNamedBufferRangeEXT(GLuint buffer, GLintptr offset, GLsizeiptr length);
  void  glFramebufferDrawBufferEXT(GLuint framebuffer, GLenum mode);
  void  glFramebufferDrawBuffersEXT(GLuint framebuffer, GLsizei n, const GLenum *bufs);
  void  glFramebufferReadBufferEXT(GLuint framebuffer, GLenum mode);
  void  glGenerateMultiTexMipmapEXT(GLenum texunit, GLenum target);
  void  glGenerateTextureMipmapEXT(GLuint texture, GLenum target);
  void  glGetCompressedMultiTexImageEXT(GLenum texunit, GLenum target, GLint lod, GLvoid *img);
  void  glGetCompressedTextureImageEXT(GLuint texture, GLenum target, GLint lod, GLvoid *img);
  void  glGetDoubleIndexedvEXT(GLenum target, GLuint index, GLdouble *data);
  void  glGetFloatIndexedvEXT(GLenum target, GLuint index, GLfloat *data);
  void  glGetFramebufferParameterivEXT(GLuint framebuffer, GLenum pname, GLint *params);
  void  glGetMultiTexEnvfvEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat *params);
  void  glGetMultiTexEnvivEXT(GLenum texunit, GLenum target, GLenum pname, GLint *params);
  void  glGetMultiTexGendvEXT(GLenum texunit, GLenum coord, GLenum pname, GLdouble *params);
  void  glGetMultiTexGenfvEXT(GLenum texunit, GLenum coord, GLenum pname, GLfloat *params);
  void  glGetMultiTexGenivEXT(GLenum texunit, GLenum coord, GLenum pname, GLint *params);
  void  glGetMultiTexImageEXT(GLenum texunit, GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels);
  void  glGetMultiTexLevelParameterfvEXT(GLenum texunit, GLenum target, GLint level, GLenum pname, GLfloat *params);
  void  glGetMultiTexLevelParameterivEXT(GLenum texunit, GLenum target, GLint level, GLenum pname, GLint *params);
  void  glGetMultiTexParameterIivEXT(GLenum texunit, GLenum target, GLenum pname, GLint *params);
  void  glGetMultiTexParameterIuivEXT(GLenum texunit, GLenum target, GLenum pname, GLuint *params);
  void  glGetMultiTexParameterfvEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat *params);
  void  glGetMultiTexParameterivEXT(GLenum texunit, GLenum target, GLenum pname, GLint *params);
  void  glGetNamedBufferParameterivEXT(GLuint buffer, GLenum pname, GLint *params);
  void  glGetNamedBufferPointervEXT(GLuint buffer, GLenum pname, GLvoid **params);
  void  glGetNamedBufferSubDataEXT(GLuint buffer, GLintptr offset, GLsizeiptr size, GLvoid *data);
  void  glGetNamedFramebufferAttachmentParameterivEXT(GLuint framebuffer, GLenum attachment, GLenum pname, GLint *params);
  void  glGetNamedProgramLocalParameterIivEXT(GLuint program, GLenum target, GLuint index, GLint *params);
  void  glGetNamedProgramLocalParameterIuivEXT(GLuint program, GLenum target, GLuint index, GLuint *params);
  void  glGetNamedProgramLocalParameterdvEXT(GLuint program, GLenum target, GLuint index, GLdouble *params);
  void  glGetNamedProgramLocalParameterfvEXT(GLuint program, GLenum target, GLuint index, GLfloat *params);
  void  glGetNamedProgramStringEXT(GLuint program, GLenum target, GLenum pname, GLvoid *string);
  void  glGetNamedProgramivEXT(GLuint program, GLenum target, GLenum pname, GLint *params);
  void  glGetNamedRenderbufferParameterivEXT(GLuint renderbuffer, GLenum pname, GLint *params);
  void  glGetPointerIndexedvEXT(GLenum target, GLuint index, GLvoid **data);
  void  glGetTextureImageEXT(GLuint texture, GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels);
  void  glGetTextureLevelParameterfvEXT(GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat *params);
  void  glGetTextureLevelParameterivEXT(GLuint texture, GLenum target, GLint level, GLenum pname, GLint *params);
  void  glGetTextureParameterIivEXT(GLuint texture, GLenum target, GLenum pname, GLint *params);
  void  glGetTextureParameterIuivEXT(GLuint texture, GLenum target, GLenum pname, GLuint *params);
  void  glGetTextureParameterfvEXT(GLuint texture, GLenum target, GLenum pname, GLfloat *params);
  void  glGetTextureParameterivEXT(GLuint texture, GLenum target, GLenum pname, GLint *params);
  void  glGetVertexArrayIntegeri_vEXT(GLuint vaobj, GLuint index, GLenum pname, GLint *param);
  void  glGetVertexArrayIntegervEXT(GLuint vaobj, GLenum pname, GLint *param);
  void  glGetVertexArrayPointeri_vEXT(GLuint vaobj, GLuint index, GLenum pname, GLvoid **param);
  void  glGetVertexArrayPointervEXT(GLuint vaobj, GLenum pname, GLvoid **param);
  GLvoid * glMapNamedBufferEXT(GLuint buffer, GLenum access);
  GLvoid * glMapNamedBufferRangeEXT(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access);
  void  glMatrixFrustumEXT(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
  void  glMatrixLoadIdentityEXT(GLenum mode);
  void  glMatrixLoadTransposedEXT(GLenum mode, const GLdouble *m);
  void  glMatrixLoadTransposefEXT(GLenum mode, const GLfloat *m);
  void  glMatrixLoaddEXT(GLenum mode, const GLdouble *m);
  void  glMatrixLoadfEXT(GLenum mode, const GLfloat *m);
  void  glMatrixMultTransposedEXT(GLenum mode, const GLdouble *m);
  void  glMatrixMultTransposefEXT(GLenum mode, const GLfloat *m);
  void  glMatrixMultdEXT(GLenum mode, const GLdouble *m);
  void  glMatrixMultfEXT(GLenum mode, const GLfloat *m);
  void  glMatrixOrthoEXT(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
  void  glMatrixPopEXT(GLenum mode);
  void  glMatrixPushEXT(GLenum mode);
  void  glMatrixRotatedEXT(GLenum mode, GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
  void  glMatrixRotatefEXT(GLenum mode, GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
  void  glMatrixScaledEXT(GLenum mode, GLdouble x, GLdouble y, GLdouble z);
  void  glMatrixScalefEXT(GLenum mode, GLfloat x, GLfloat y, GLfloat z);
  void  glMatrixTranslatedEXT(GLenum mode, GLdouble x, GLdouble y, GLdouble z);
  void  glMatrixTranslatefEXT(GLenum mode, GLfloat x, GLfloat y, GLfloat z);
  void  glMultiTexBufferEXT(GLenum texunit, GLenum target, GLenum internalformat, GLuint buffer);
  void  glMultiTexCoordPointerEXT(GLenum texunit, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
  void  glMultiTexEnvfEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat param);
  void  glMultiTexEnvfvEXT(GLenum texunit, GLenum target, GLenum pname, const GLfloat *params);
  void  glMultiTexEnviEXT(GLenum texunit, GLenum target, GLenum pname, GLint param);
  void  glMultiTexEnvivEXT(GLenum texunit, GLenum target, GLenum pname, const GLint *params);
  void  glMultiTexGendEXT(GLenum texunit, GLenum coord, GLenum pname, GLdouble param);
  void  glMultiTexGendvEXT(GLenum texunit, GLenum coord, GLenum pname, const GLdouble *params);
  void  glMultiTexGenfEXT(GLenum texunit, GLenum coord, GLenum pname, GLfloat param);
  void  glMultiTexGenfvEXT(GLenum texunit, GLenum coord, GLenum pname, const GLfloat *params);
  void  glMultiTexGeniEXT(GLenum texunit, GLenum coord, GLenum pname, GLint param);
  void  glMultiTexGenivEXT(GLenum texunit, GLenum coord, GLenum pname, const GLint *params);
  void  glMultiTexParameterIivEXT(GLenum texunit, GLenum target, GLenum pname, const GLint *params);
  void  glMultiTexParameterIuivEXT(GLenum texunit, GLenum target, GLenum pname, const GLuint *params);
  void  glMultiTexParameterfEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat param);
  void  glMultiTexParameterfvEXT(GLenum texunit, GLenum target, GLenum pname, const GLfloat *param);
  void  glMultiTexParameteriEXT(GLenum texunit, GLenum target, GLenum pname, GLint param);
  void  glMultiTexParameterivEXT(GLenum texunit, GLenum target, GLenum pname, const GLint *param);
  void  glMultiTexRenderbufferEXT(GLenum texunit, GLenum target, GLuint renderbuffer);
  void  glMultiTexSubImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
  void  glMultiTexSubImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
  void  glMultiTexSubImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);
  void  glNamedBufferDataEXT(GLuint buffer, GLsizeiptr size, const GLvoid *data, GLenum usage);
  void  glNamedBufferSubDataEXT(GLuint buffer, GLintptr offset, GLsizeiptr size, const GLvoid *data);
  void  glNamedCopyBufferSubDataEXT(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
  void  glNamedFramebufferRenderbufferEXT(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
  void  glNamedFramebufferTexture1DEXT(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
  void  glNamedFramebufferTexture2DEXT(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
  void  glNamedFramebufferTexture3DEXT(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
  void  glNamedFramebufferTextureEXT(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level);
  void  glNamedFramebufferTextureFaceEXT(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLenum face);
  void  glNamedFramebufferTextureLayerEXT(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer);
  void  glNamedProgramLocalParameter4dEXT(GLuint program, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
  void  glNamedProgramLocalParameter4dvEXT(GLuint program, GLenum target, GLuint index, const GLdouble *params);
  void  glNamedProgramLocalParameter4fEXT(GLuint program, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
  void  glNamedProgramLocalParameter4fvEXT(GLuint program, GLenum target, GLuint index, const GLfloat *params);
  void  glNamedProgramLocalParameterI4iEXT(GLuint program, GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
  void  glNamedProgramLocalParameterI4ivEXT(GLuint program, GLenum target, GLuint index, const GLint *params);
  void  glNamedProgramLocalParameterI4uiEXT(GLuint program, GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
  void  glNamedProgramLocalParameterI4uivEXT(GLuint program, GLenum target, GLuint index, const GLuint *params);
  void  glNamedProgramLocalParameters4fvEXT(GLuint program, GLenum target, GLuint index, GLsizei count, const GLfloat *params);
  void  glNamedProgramLocalParametersI4ivEXT(GLuint program, GLenum target, GLuint index, GLsizei count, const GLint *params);
  void  glNamedProgramLocalParametersI4uivEXT(GLuint program, GLenum target, GLuint index, GLsizei count, const GLuint *params);
  void  glNamedProgramStringEXT(GLuint program, GLenum target, GLenum format, GLsizei len, const GLvoid *string);
  void  glNamedRenderbufferStorageEXT(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height);
  void  glNamedRenderbufferStorageMultisampleCoverageEXT(GLuint renderbuffer, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height);
  void  glNamedRenderbufferStorageMultisampleEXT(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
  void  glProgramUniform1dEXT(GLuint program, GLint location, GLdouble x);
  void  glProgramUniform1dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble *value);
  void  glProgramUniform1fEXT(GLuint program, GLint location, GLfloat v0);
  void  glProgramUniform1fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat *value);
  void  glProgramUniform1iEXT(GLuint program, GLint location, GLint v0);
  void  glProgramUniform1ivEXT(GLuint program, GLint location, GLsizei count, const GLint *value);
  void  glProgramUniform1uiEXT(GLuint program, GLint location, GLuint v0);
  void  glProgramUniform1uivEXT(GLuint program, GLint location, GLsizei count, const GLuint *value);
  void  glProgramUniform2dEXT(GLuint program, GLint location, GLdouble x, GLdouble y);
  void  glProgramUniform2dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble *value);
  void  glProgramUniform2fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1);
  void  glProgramUniform2fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat *value);
  void  glProgramUniform2iEXT(GLuint program, GLint location, GLint v0, GLint v1);
  void  glProgramUniform2ivEXT(GLuint program, GLint location, GLsizei count, const GLint *value);
  void  glProgramUniform2uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1);
  void  glProgramUniform2uivEXT(GLuint program, GLint location, GLsizei count, const GLuint *value);
  void  glProgramUniform3dEXT(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z);
  void  glProgramUniform3dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble *value);
  void  glProgramUniform3fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
  void  glProgramUniform3fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat *value);
  void  glProgramUniform3iEXT(GLuint program, GLint location, GLint v0, GLint v1, GLint v2);
  void  glProgramUniform3ivEXT(GLuint program, GLint location, GLsizei count, const GLint *value);
  void  glProgramUniform3uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2);
  void  glProgramUniform3uivEXT(GLuint program, GLint location, GLsizei count, const GLuint *value);
  void  glProgramUniform4dEXT(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
  void  glProgramUniform4dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble *value);
  void  glProgramUniform4fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
  void  glProgramUniform4fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat *value);
  void  glProgramUniform4iEXT(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
  void  glProgramUniform4ivEXT(GLuint program, GLint location, GLsizei count, const GLint *value);
  void  glProgramUniform4uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
  void  glProgramUniform4uivEXT(GLuint program, GLint location, GLsizei count, const GLuint *value);
  void  glProgramUniformMatrix2dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
  void  glProgramUniformMatrix2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
  void  glProgramUniformMatrix2x3dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
  void  glProgramUniformMatrix2x3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
  void  glProgramUniformMatrix2x4dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
  void  glProgramUniformMatrix2x4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
  void  glProgramUniformMatrix3dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
  void  glProgramUniformMatrix3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
  void  glProgramUniformMatrix3x2dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
  void  glProgramUniformMatrix3x2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
  void  glProgramUniformMatrix3x4dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
  void  glProgramUniformMatrix3x4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
  void  glProgramUniformMatrix4dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
  void  glProgramUniformMatrix4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
  void  glProgramUniformMatrix4x2dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
  void  glProgramUniformMatrix4x2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
  void  glProgramUniformMatrix4x3dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
  void  glProgramUniformMatrix4x3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
  void  glPushClientAttribDefaultEXT(GLbitfield mask);
  void  glTextureBufferEXT(GLuint texture, GLenum target, GLenum internalformat, GLuint buffer);
  void  glTextureParameterIivEXT(GLuint texture, GLenum target, GLenum pname, const GLint *params);
  void  glTextureParameterIuivEXT(GLuint texture, GLenum target, GLenum pname, const GLuint *params);
  void  glTextureParameterfEXT(GLuint texture, GLenum target, GLenum pname, GLfloat param);
  void  glTextureParameterfvEXT(GLuint texture, GLenum target, GLenum pname, const GLfloat *param);
  void  glTextureParameteriEXT(GLuint texture, GLenum target, GLenum pname, GLint param);
  void  glTextureParameterivEXT(GLuint texture, GLenum target, GLenum pname, const GLint *param);
  void  glTextureRenderbufferEXT(GLuint texture, GLenum target, GLuint renderbuffer);
  void  glTextureSubImage1DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
  void  glTextureSubImage2DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
  void  glTextureSubImage3DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);
  GLboolean  glUnmapNamedBufferEXT(GLuint buffer);
  void  glVertexArrayColorOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, const GLintptr offset);
  void  glVertexArrayEdgeFlagOffsetEXT(GLuint vaobj, GLuint buffer, GLsizei stride, const GLintptr offset);
  void  glVertexArrayFogCoordOffsetEXT(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, const GLintptr offset);
  void  glVertexArrayIndexOffsetEXT(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, const GLintptr offset);
  void  glVertexArrayMultiTexCoordOffsetEXT(GLuint vaobj, GLuint buffer, GLenum texunit, GLint size, GLenum type, GLsizei stride, const GLintptr offset);
  void  glVertexArrayNormalOffsetEXT(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, const GLintptr offset);
  void  glVertexArraySecondaryColorOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, const GLintptr offset);
  void  glVertexArrayTexCoordOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, const GLintptr offset);
  void  glVertexArrayVertexAttribIOffsetEXT(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, const GLintptr offset);
  void  glVertexArrayVertexAttribOffsetEXT(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLintptr offset);
  void  glVertexArrayVertexOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, const GLintptr offset);

// GL_EXT_discard_framebuffer

  void  glDiscardFramebufferEXT(GLenum target, GLsizei numAttachments, const GLenum *attachments);

// GL_EXT_draw_buffers2

  void  glColorMaskIndexedEXT(GLuint buf, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
  void  glDisableIndexedEXT(GLenum target, GLuint index);
  void  glEnableIndexedEXT(GLenum target, GLuint index);
  void  glGetBooleanIndexedvEXT(GLenum value, GLuint index, GLboolean *data);
  void  glGetIntegerIndexedvEXT(GLenum value, GLuint index, GLint *data);
  GLboolean  glIsEnabledIndexedEXT(GLenum target, GLuint index);

// GL_EXT_draw_instanced

  void  glDrawArraysInstancedEXT(GLenum mode, GLint start, GLsizei count, GLsizei primcount);
  void  glDrawElementsInstancedEXT(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount);

// GL_EXT_draw_range_elements

  void  glDrawRangeElementsEXT(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);

// GL_EXT_fog_coord

  void  glFogCoordPointerEXT(GLenum type, GLsizei stride, const GLvoid *pointer);
  void  glFogCoorddEXT(GLdouble coord);
  void  glFogCoorddvEXT(const GLdouble *coord);
  void  glFogCoordfEXT(GLfloat coord);
  void  glFogCoordfvEXT(const GLfloat *coord);

// GL_EXT_framebuffer_blit

  void  glBlitFramebufferEXT(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);

// GL_EXT_framebuffer_multisample

  void  glRenderbufferStorageMultisampleEXT(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);

// GL_EXT_framebuffer_object

  void  glBindFramebufferEXT(GLenum target, GLuint framebuffer);
  void  glBindRenderbufferEXT(GLenum target, GLuint renderbuffer);
  GLenum  glCheckFramebufferStatusEXT(GLenum target);
  void  glDeleteFramebuffersEXT(GLsizei n, const GLuint *framebuffers);
  void  glDeleteRenderbuffersEXT(GLsizei n, const GLuint *renderbuffers);
  void  glFramebufferRenderbufferEXT(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
  void  glFramebufferTexture1DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
  void  glFramebufferTexture2DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
  void  glFramebufferTexture3DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
  void  glGenFramebuffersEXT(GLsizei n, GLuint *framebuffers);
  void  glGenRenderbuffersEXT(GLsizei n, GLuint *renderbuffers);
  void  glGenerateMipmapEXT(GLenum target);
  void  glGetFramebufferAttachmentParameterivEXT(GLenum target, GLenum attachment, GLenum pname, GLint *params);
  void  glGetRenderbufferParameterivEXT(GLenum target, GLenum pname, GLint *params);
  GLboolean  glIsFramebufferEXT(GLuint framebuffer);
  GLboolean  glIsRenderbufferEXT(GLuint renderbuffer);
  void  glRenderbufferStorageEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);

// GL_EXT_geometry_shader4

  void  glFramebufferTextureEXT(GLenum target, GLenum attachment, GLuint texture, GLint level);
  void  glFramebufferTextureFaceEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face);
  void  glProgramParameteriEXT(GLuint program, GLenum pname, GLint value);

// GL_EXT_gpu_program_parameters

  void  glProgramEnvParameters4fvEXT(GLenum target, GLuint index, GLsizei count, const GLfloat *params);
  void  glProgramLocalParameters4fvEXT(GLenum target, GLuint index, GLsizei count, const GLfloat *params);

// GL_EXT_gpu_shader4

  void  glBindFragDataLocationEXT(GLuint program, GLuint color, const GLchar *name);
  GLint  glGetFragDataLocationEXT(GLuint program, const GLchar *name);
  void  glGetUniformuivEXT(GLuint program, GLint location, GLuint *params);
  void  glGetVertexAttribIivEXT(GLuint index, GLenum pname, GLint *params);
  void  glGetVertexAttribIuivEXT(GLuint index, GLenum pname, GLuint *params);
  void  glUniform1uiEXT(GLint location, GLuint v0);
  void  glUniform1uivEXT(GLint location, GLsizei count, const GLuint *value);
  void  glUniform2uiEXT(GLint location, GLuint v0, GLuint v1);
  void  glUniform2uivEXT(GLint location, GLsizei count, const GLuint *value);
  void  glUniform3uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2);
  void  glUniform3uivEXT(GLint location, GLsizei count, const GLuint *value);
  void  glUniform4uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
  void  glUniform4uivEXT(GLint location, GLsizei count, const GLuint *value);
  void  glVertexAttribI1iEXT(GLuint index, GLint x);
  void  glVertexAttribI1ivEXT(GLuint index, const GLint *v);
  void  glVertexAttribI1uiEXT(GLuint index, GLuint x);
  void  glVertexAttribI1uivEXT(GLuint index, const GLuint *v);
  void  glVertexAttribI2iEXT(GLuint index, GLint x, GLint y);
  void  glVertexAttribI2ivEXT(GLuint index, const GLint *v);
  void  glVertexAttribI2uiEXT(GLuint index, GLuint x, GLuint y);
  void  glVertexAttribI2uivEXT(GLuint index, const GLuint *v);
  void  glVertexAttribI3iEXT(GLuint index, GLint x, GLint y, GLint z);
  void  glVertexAttribI3ivEXT(GLuint index, const GLint *v);
  void  glVertexAttribI3uiEXT(GLuint index, GLuint x, GLuint y, GLuint z);
  void  glVertexAttribI3uivEXT(GLuint index, const GLuint *v);
  void  glVertexAttribI4bvEXT(GLuint index, const GLbyte *v);
  void  glVertexAttribI4iEXT(GLuint index, GLint x, GLint y, GLint z, GLint w);
  void  glVertexAttribI4ivEXT(GLuint index, const GLint *v);
  void  glVertexAttribI4svEXT(GLuint index, const GLshort *v);
  void  glVertexAttribI4ubvEXT(GLuint index, const GLubyte *v);
  void  glVertexAttribI4uiEXT(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
  void  glVertexAttribI4uivEXT(GLuint index, const GLuint *v);
  void  glVertexAttribI4usvEXT(GLuint index, const GLushort *v);
  void  glVertexAttribIPointerEXT(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);

// GL_EXT_histogram

  void  glGetHistogramEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
  void  glGetHistogramParameterfvEXT(GLenum target, GLenum pname, GLfloat *params);
  void  glGetHistogramParameterivEXT(GLenum target, GLenum pname, GLint *params);
  void  glGetMinmaxEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
  void  glGetMinmaxParameterfvEXT(GLenum target, GLenum pname, GLfloat *params);
  void  glGetMinmaxParameterivEXT(GLenum target, GLenum pname, GLint *params);
  void  glHistogramEXT(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
  void  glMinmaxEXT(GLenum target, GLenum internalformat, GLboolean sink);
  void  glResetHistogramEXT(GLenum target);
  void  glResetMinmaxEXT(GLenum target);

// GL_EXT_index_func

  void  glIndexFuncEXT(GLenum func, GLfloat ref);

// GL_EXT_index_material

  void  glIndexMaterialEXT(GLenum face, GLenum mode);

// GL_EXT_light_texture

  void  glApplyTextureEXT(GLenum mode);
  void  glTextureLightEXT(GLenum pname);
  void  glTextureMaterialEXT(GLenum face, GLenum mode);

// GL_EXT_multi_draw_arrays

  void  glMultiDrawArraysEXT(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount);
  void  glMultiDrawElementsEXT(GLenum mode, const GLsizei *count, GLenum type, const GLvoid **indices, GLsizei primcount);

// GL_EXT_multisample

  void  glSampleMaskEXT(GLclampf value, GLboolean invert);
  void  glSamplePatternEXT(GLenum pattern);

// GL_EXT_occlusion_query_boolean

  void  glBeginQueryEXT(GLenum target, GLuint id);
  void  glDeleteQueriesEXT(GLsizei n, const GLuint *ids);
  void  glEndQueryEXT(GLenum target);
  void  glGenQueriesEXT(GLsizei n, GLuint *ids);
  void  glGetQueryObjectuivEXT(GLuint id, GLenum pname, GLuint *params);
  void  glGetQueryivEXT(GLenum target, GLenum pname, GLint *params);
  GLboolean  glIsQueryEXT(GLuint id);

// GL_EXT_paletted_texture

  void  glColorTableEXT(GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const GLvoid *table);
  void  glGetColorTableEXT(GLenum target, GLenum format, GLenum type, GLvoid *data);
  void  glGetColorTableParameterfvEXT(GLenum target, GLenum pname, GLfloat *params);
  void  glGetColorTableParameterivEXT(GLenum target, GLenum pname, GLint *params);

// GL_EXT_pixel_transform

  void  glPixelTransformParameterfEXT(GLenum target, GLenum pname, const GLfloat param);
  void  glPixelTransformParameterfvEXT(GLenum target, GLenum pname, const GLfloat *params);
  void  glPixelTransformParameteriEXT(GLenum target, GLenum pname, const GLint param);
  void  glPixelTransformParameterivEXT(GLenum target, GLenum pname, const GLint *params);

// GL_EXT_point_parameters

  void  glPointParameterfEXT(GLenum pname, GLfloat param);
  void  glPointParameterfvEXT(GLenum pname, const GLfloat *params);

// GL_EXT_polygon_offset

  void  glPolygonOffsetEXT(GLfloat factor, GLfloat bias);

// GL_EXT_provoking_vertex

  void  glProvokingVertexEXT(GLenum mode);

// GL_EXT_secondary_color

  void  glSecondaryColor3bEXT(GLbyte red, GLbyte green, GLbyte blue);
  void  glSecondaryColor3bvEXT(const GLbyte *v);
  void  glSecondaryColor3dEXT(GLdouble red, GLdouble green, GLdouble blue);
  void  glSecondaryColor3dvEXT(const GLdouble *v);
  void  glSecondaryColor3fEXT(GLfloat red, GLfloat green, GLfloat blue);
  void  glSecondaryColor3fvEXT(const GLfloat *v);
  void  glSecondaryColor3iEXT(GLint red, GLint green, GLint blue);
  void  glSecondaryColor3ivEXT(const GLint *v);
  void  glSecondaryColor3sEXT(GLshort red, GLshort green, GLshort blue);
  void  glSecondaryColor3svEXT(const GLshort *v);
  void  glSecondaryColor3ubEXT(GLubyte red, GLubyte green, GLubyte blue);
  void  glSecondaryColor3ubvEXT(const GLubyte *v);
  void  glSecondaryColor3uiEXT(GLuint red, GLuint green, GLuint blue);
  void  glSecondaryColor3uivEXT(const GLuint *v);
  void  glSecondaryColor3usEXT(GLushort red, GLushort green, GLushort blue);
  void  glSecondaryColor3usvEXT(const GLushort *v);
  void  glSecondaryColorPointerEXT(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);

// GL_EXT_separate_shader_objects

  void  glActiveProgramEXT(GLuint program);
  GLuint  glCreateShaderProgramEXT(GLenum type, const GLchar *string);
  void  glUseShaderProgramEXT(GLenum type, GLuint program);

// GL_EXT_shader_image_load_store

  void  glBindImageTextureEXT(GLuint index, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLint format);
  void  glMemoryBarrierEXT(GLbitfield barriers);

// GL_EXT_stencil_clear_tag

  void  glStencilClearTagEXT(GLsizei stencilTagBits, GLuint stencilClearTag);

// GL_EXT_stencil_two_side

  void  glActiveStencilFaceEXT(GLenum face);

// GL_EXT_subtexture

  void  glTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
  void  glTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
  void  glTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);

// GL_EXT_texture3D

  void  glTexImage3DEXT(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);

// GL_EXT_texture_array

  void  glFramebufferTextureLayerEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);

// GL_EXT_texture_buffer_object

  void  glTexBufferEXT(GLenum target, GLenum internalformat, GLuint buffer);

// GL_EXT_texture_integer

  void  glClearColorIiEXT(GLint red, GLint green, GLint blue, GLint alpha);
  void  glClearColorIuiEXT(GLuint red, GLuint green, GLuint blue, GLuint alpha);
  void  glGetTexParameterIivEXT(GLenum target, GLenum pname, GLint *params);
  void  glGetTexParameterIuivEXT(GLenum target, GLenum pname, GLuint *params);
  void  glTexParameterIivEXT(GLenum target, GLenum pname, const GLint *params);
  void  glTexParameterIuivEXT(GLenum target, GLenum pname, const GLuint *params);

// GL_EXT_texture_object

  GLboolean  glAreTexturesResidentEXT(GLsizei n, const GLuint *textures, GLboolean *residences);
  void  glBindTextureEXT(GLenum target, GLuint texture);
  void  glDeleteTexturesEXT(GLsizei n, const GLuint *textures);
  void  glGenTexturesEXT(GLsizei n, GLuint *textures);
  GLboolean  glIsTextureEXT(GLuint texture);
  void  glPrioritizeTexturesEXT(GLsizei n, const GLuint *textures, const GLclampf *priorities);

// GL_EXT_texture_perturb_normal

  void  glTextureNormalEXT(GLenum mode);

// GL_EXT_timer_query

  void  glGetQueryObjecti64vEXT(GLuint id, GLenum pname, GLint64EXT *params);
  void  glGetQueryObjectui64vEXT(GLuint id, GLenum pname, GLuint64EXT *params);

// GL_EXT_transform_feedback

  void  glBeginTransformFeedbackEXT(GLenum primitiveMode);
  void  glBindBufferBaseEXT(GLenum target, GLuint index, GLuint buffer);
  void  glBindBufferOffsetEXT(GLenum target, GLuint index, GLuint buffer, GLintptr offset);
  void  glBindBufferRangeEXT(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
  void  glEndTransformFeedbackEXT(void);
  void  glGetTransformFeedbackVaryingEXT(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name);
  void  glTransformFeedbackVaryingsEXT(GLuint program, GLsizei count, const GLchar ** const varyings, GLenum bufferMode);

// GL_EXT_vertex_array

  void  glArrayElementEXT(GLint i);
  void  glColorPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
  void  glDrawArraysEXT(GLenum mode, GLint first, GLsizei count);
  void  glEdgeFlagPointerEXT(GLsizei stride, GLsizei count, const GLboolean *pointer);
  void  glGetPointervEXT(GLenum pname, GLvoid **params);
  void  glIndexPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
  void  glNormalPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
  void  glTexCoordPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
  void  glVertexPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);

// GL_EXT_vertex_attrib_64bit

  void  glGetVertexAttribLdvEXT(GLuint index, GLenum pname, GLdouble *params);
  void  glVertexArrayVertexAttribLOffsetEXT(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset);
  void  glVertexAttribL1dEXT(GLuint index, GLdouble x);
  void  glVertexAttribL1dvEXT(GLuint index, const GLdouble *v);
  void  glVertexAttribL2dEXT(GLuint index, GLdouble x, GLdouble y);
  void  glVertexAttribL2dvEXT(GLuint index, const GLdouble *v);
  void  glVertexAttribL3dEXT(GLuint index, GLdouble x, GLdouble y, GLdouble z);
  void  glVertexAttribL3dvEXT(GLuint index, const GLdouble *v);
  void  glVertexAttribL4dEXT(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
  void  glVertexAttribL4dvEXT(GLuint index, const GLdouble *v);
  void  glVertexAttribLPointerEXT(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);

// GL_EXT_vertex_shader

  void  glBeginVertexShaderEXT(void);
  GLuint  glBindLightParameterEXT(GLenum light, GLenum value);
  GLuint  glBindMaterialParameterEXT(GLenum face, GLenum value);
  GLuint  glBindParameterEXT(GLenum value);
  GLuint  glBindTexGenParameterEXT(GLenum unit, GLenum coord, GLenum value);
  GLuint  glBindTextureUnitParameterEXT(GLenum unit, GLenum value);
  void  glBindVertexShaderEXT(GLuint id);
  void  glDeleteVertexShaderEXT(GLuint id);
  void  glDisableVariantClientStateEXT(GLuint id);
  void  glEnableVariantClientStateEXT(GLuint id);
  void  glEndVertexShaderEXT(void);
  void  glExtractComponentEXT(GLuint res, GLuint src, GLuint num);
  GLuint  glGenSymbolsEXT(GLenum datatype, GLenum storagetype, GLenum range, GLuint components);
  GLuint  glGenVertexShadersEXT(GLuint range);
  void  glGetInvariantBooleanvEXT(GLuint id, GLenum value, GLboolean *data);
  void  glGetInvariantFloatvEXT(GLuint id, GLenum value, GLfloat *data);
  void  glGetInvariantIntegervEXT(GLuint id, GLenum value, GLint *data);
  void  glGetLocalConstantBooleanvEXT(GLuint id, GLenum value, GLboolean *data);
  void  glGetLocalConstantFloatvEXT(GLuint id, GLenum value, GLfloat *data);
  void  glGetLocalConstantIntegervEXT(GLuint id, GLenum value, GLint *data);
  void  glGetVariantBooleanvEXT(GLuint id, GLenum value, GLboolean *data);
  void  glGetVariantFloatvEXT(GLuint id, GLenum value, GLfloat *data);
  void  glGetVariantIntegervEXT(GLuint id, GLenum value, GLint *data);
  void  glGetVariantPointervEXT(GLuint id, GLenum value, GLvoid **data);
  void  glInsertComponentEXT(GLuint res, GLuint src, GLuint num);
  GLboolean  glIsVariantEnabledEXT(GLuint id, GLenum cap);
  void  glSetInvariantEXT(GLuint id, GLenum type, const GLvoid *addr);
  void  glSetLocalConstantEXT(GLuint id, GLenum type, const GLvoid *addr);
  void  glShaderOp1EXT(GLenum op, GLuint res, GLuint arg1);
  void  glShaderOp2EXT(GLenum op, GLuint res, GLuint arg1, GLuint arg2);
  void  glShaderOp3EXT(GLenum op, GLuint res, GLuint arg1, GLuint arg2, GLuint arg3);
  void  glSwizzleEXT(GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW);
  void  glVariantPointerEXT(GLuint id, GLenum type, GLuint stride, const GLvoid *addr);
  void  glVariantbvEXT(GLuint id, const GLbyte *addr);
  void  glVariantdvEXT(GLuint id, const GLdouble *addr);
  void  glVariantfvEXT(GLuint id, const GLfloat *addr);
  void  glVariantivEXT(GLuint id, const GLint *addr);
  void  glVariantsvEXT(GLuint id, const GLshort *addr);
  void  glVariantubvEXT(GLuint id, const GLubyte *addr);
  void  glVariantuivEXT(GLuint id, const GLuint *addr);
  void  glVariantusvEXT(GLuint id, const GLushort *addr);
  void  glWriteMaskEXT(GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW);

// GL_EXT_vertex_weighting

  void  glVertexWeightPointerEXT(GLsizei size, GLenum type, GLsizei stride, const GLvoid *pointer);
  void  glVertexWeightfEXT(GLfloat weight);
  void  glVertexWeightfvEXT(const GLfloat *weight);

// GL_EXT_x11_sync_object

  GLsync  glImportSyncEXT(GLenum external_sync_type, GLintptr external_sync, GLbitfield flags);

// GL_GREMEDY_frame_terminator

  void  glFrameTerminatorGREMEDY(void);

// GL_GREMEDY_string_marker

  void  glStringMarkerGREMEDY(GLsizei len, const GLvoid *string);

// GL_HP_image_transform

  void  glGetImageTransformParameterfvHP(GLenum target, GLenum pname, GLfloat *params);
  void  glGetImageTransformParameterivHP(GLenum target, GLenum pname, GLint *params);
  void  glImageTransformParameterfHP(GLenum target, GLenum pname, GLfloat param);
  void  glImageTransformParameterfvHP(GLenum target, GLenum pname, const GLfloat *params);
  void  glImageTransformParameteriHP(GLenum target, GLenum pname, GLint param);
  void  glImageTransformParameterivHP(GLenum target, GLenum pname, const GLint *params);

// GL_IBM_multimode_draw_arrays

  void  glMultiModeDrawArraysIBM(const GLenum *mode, const GLint *first, const GLsizei *count, GLsizei primcount, GLint modestride);
  void  glMultiModeDrawElementsIBM(const GLenum *mode, const GLsizei *count, GLenum type, const GLvoid * const *indices, GLsizei primcount, GLint modestride);

// GL_IBM_vertex_array_lists

  void  glColorPointerListIBM(GLint size, GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride);
  void  glEdgeFlagPointerListIBM(GLint stride, const GLboolean **pointer, GLint ptrstride);
  void  glFogCoordPointerListIBM(GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride);
  void  glIndexPointerListIBM(GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride);
  void  glNormalPointerListIBM(GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride);
  void  glSecondaryColorPointerListIBM(GLint size, GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride);
  void  glTexCoordPointerListIBM(GLint size, GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride);
  void  glVertexPointerListIBM(GLint size, GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride);

// GL_IMG_multisampled_render_to_texture

  void  glFramebufferTexture2DMultisampleIMG(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples);
  void  glRenderbufferStorageMultisampleIMG(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);

// GL_INGR_blend_func_separate

  void  glBlendFuncSeparateINGR(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);

// GL_INTEL_parallel_arrays

  void  glColorPointervINTEL(GLint size, GLenum type, const GLvoid **pointer);
  void  glNormalPointervINTEL(GLenum type, const GLvoid **pointer);
  void  glTexCoordPointervINTEL(GLint size, GLenum type, const GLvoid **pointer);
  void  glVertexPointervINTEL(GLint size, GLenum type, const GLvoid **pointer);

// GL_KHR_debug

  void  glDebugMessageCallback(GLDEBUGPROC callback, const GLvoid *userParam);
  void  glDebugMessageControl(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled);
  void  glDebugMessageInsert(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf);
  GLuint  glGetDebugMessageLog(GLuint count, GLsizei bufsize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog);
  void  glGetObjectLabel(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei *length, GLchar *label);
  void  glGetObjectPtrLabel(const GLvoid *ptr, GLsizei bufSize, GLsizei *length, GLchar *label);
  void  glObjectLabel(GLenum identifier, GLuint name, GLsizei length, const GLchar *label);
  void  glObjectPtrLabel(const GLvoid *ptr, GLsizei length, const GLchar *label);
  void  glPopDebugGroup(void);
  void  glPushDebugGroup(GLenum source, GLuint id, GLsizei length, const GLchar *message);

// GL_KTX_buffer_region

  GLuint  glBufferRegionEnabled(void);
  void  glDeleteBufferRegion(GLenum region);
  void  glDrawBufferRegion(GLuint region, GLint x, GLint y, GLsizei width, GLsizei height, GLint xDest, GLint yDest);
  GLuint  glNewBufferRegion(GLenum region);
  void  glReadBufferRegion(GLuint region, GLint x, GLint y, GLsizei width, GLsizei height);

// GL_MESA_resize_buffers

  void  glResizeBuffersMESA(void);

// GL_MESA_window_pos

  void  glWindowPos2dMESA(GLdouble x, GLdouble y);
  void  glWindowPos2dvMESA(const GLdouble *v);
  void  glWindowPos2fMESA(GLfloat x, GLfloat y);
  void  glWindowPos2fvMESA(const GLfloat *v);
  void  glWindowPos2iMESA(GLint x, GLint y);
  void  glWindowPos2ivMESA(const GLint *v);
  void  glWindowPos2sMESA(GLshort x, GLshort y);
  void  glWindowPos2svMESA(const GLshort *v);
  void  glWindowPos3dMESA(GLdouble x, GLdouble y, GLdouble z);
  void  glWindowPos3dvMESA(const GLdouble *v);
  void  glWindowPos3fMESA(GLfloat x, GLfloat y, GLfloat z);
  void  glWindowPos3fvMESA(const GLfloat *v);
  void  glWindowPos3iMESA(GLint x, GLint y, GLint z);
  void  glWindowPos3ivMESA(const GLint *v);
  void  glWindowPos3sMESA(GLshort x, GLshort y, GLshort z);
  void  glWindowPos3svMESA(const GLshort *v);
  void  glWindowPos4dMESA(GLdouble x, GLdouble y, GLdouble z, GLdouble w);
  void  glWindowPos4dvMESA(const GLdouble *v);
  void  glWindowPos4fMESA(GLfloat x, GLfloat y, GLfloat z, GLfloat w);
  void  glWindowPos4fvMESA(const GLfloat *v);
  void  glWindowPos4iMESA(GLint x, GLint y, GLint z, GLint w);
  void  glWindowPos4ivMESA(const GLint *v);
  void  glWindowPos4sMESA(GLshort x, GLshort y, GLshort z, GLshort w);
  void  glWindowPos4svMESA(const GLshort *v);

// GL_NV_conditional_render

  void  glBeginConditionalRenderNV(GLuint id, GLenum mode);
  void  glEndConditionalRenderNV(void);

// GL_NV_copy_image

  void  glCopyImageSubDataNV(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth);

// GL_NV_coverage_sample

  void  glCoverageMaskNV(GLboolean mask);
  void  glCoverageOperationNV(GLenum operation);

// GL_NV_depth_buffer_float

  void  glClearDepthdNV(GLdouble depth);
  void  glDepthBoundsdNV(GLdouble zmin, GLdouble zmax);
  void  glDepthRangedNV(GLdouble zNear, GLdouble zFar);

// GL_NV_draw_buffers

  void  glDrawBuffersNV(GLsizei n, const GLenum *bufs);

// GL_NV_evaluators

  void  glEvalMapsNV(GLenum target, GLenum mode);
  void  glGetMapAttribParameterfvNV(GLenum target, GLuint index, GLenum pname, GLfloat *params);
  void  glGetMapAttribParameterivNV(GLenum target, GLuint index, GLenum pname, GLint *params);
  void  glGetMapControlPointsNV(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, GLvoid *points);
  void  glGetMapParameterfvNV(GLenum target, GLenum pname, GLfloat *params);
  void  glGetMapParameterivNV(GLenum target, GLenum pname, GLint *params);
  void  glMapControlPointsNV(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const GLvoid *points);
  void  glMapParameterfvNV(GLenum target, GLenum pname, const GLfloat *params);
  void  glMapParameterivNV(GLenum target, GLenum pname, const GLint *params);

// GL_NV_explicit_multisample

  void  glGetMultisamplefvNV(GLenum pname, GLuint index, GLfloat *val);
  void  glSampleMaskIndexedNV(GLuint index, GLbitfield mask);
  void  glTexRenderbufferNV(GLenum target, GLuint renderbuffer);

// GL_NV_fence

  void  glDeleteFencesNV(GLsizei n, const GLuint *fences);
  void  glFinishFenceNV(GLuint fence);
  void  glGenFencesNV(GLsizei n, GLuint *fences);
  void  glGetFenceivNV(GLuint fence, GLenum pname, GLint *params);
  GLboolean  glIsFenceNV(GLuint fence);
  void  glSetFenceNV(GLuint fence, GLenum condition);
  GLboolean  glTestFenceNV(GLuint fence);

// GL_NV_fragment_program

  void  glGetProgramNamedParameterdvNV(GLuint id, GLsizei len, const GLubyte *name, GLdouble *params);
  void  glGetProgramNamedParameterfvNV(GLuint id, GLsizei len, const GLubyte *name, GLfloat *params);
  void  glProgramNamedParameter4dNV(GLuint id, GLsizei len, const GLubyte *name, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
  void  glProgramNamedParameter4dvNV(GLuint id, GLsizei len, const GLubyte *name, const GLdouble *v);
  void  glProgramNamedParameter4fNV(GLuint id, GLsizei len, const GLubyte *name, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
  void  glProgramNamedParameter4fvNV(GLuint id, GLsizei len, const GLubyte *name, const GLfloat *v);

// GL_NV_framebuffer_multisample_coverage

  void  glRenderbufferStorageMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height);

// GL_NV_geometry_program4

  void  glProgramVertexLimitNV(GLenum target, GLint limit);

// GL_NV_gpu_program4

  void  glGetProgramEnvParameterIivNV(GLenum target, GLuint index, GLint *params);
  void  glGetProgramEnvParameterIuivNV(GLenum target, GLuint index, GLuint *params);
  void  glGetProgramLocalParameterIivNV(GLenum target, GLuint index, GLint *params);
  void  glGetProgramLocalParameterIuivNV(GLenum target, GLuint index, GLuint *params);
  void  glProgramEnvParameterI4iNV(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
  void  glProgramEnvParameterI4ivNV(GLenum target, GLuint index, const GLint *params);
  void  glProgramEnvParameterI4uiNV(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
  void  glProgramEnvParameterI4uivNV(GLenum target, GLuint index, const GLuint *params);
  void  glProgramEnvParametersI4ivNV(GLenum target, GLuint index, GLsizei count, const GLint *params);
  void  glProgramEnvParametersI4uivNV(GLenum target, GLuint index, GLsizei count, const GLuint *params);
  void  glProgramLocalParameterI4iNV(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
  void  glProgramLocalParameterI4ivNV(GLenum target, GLuint index, const GLint *params);
  void  glProgramLocalParameterI4uiNV(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
  void  glProgramLocalParameterI4uivNV(GLenum target, GLuint index, const GLuint *params);
  void  glProgramLocalParametersI4ivNV(GLenum target, GLuint index, GLsizei count, const GLint *params);
  void  glProgramLocalParametersI4uivNV(GLenum target, GLuint index, GLsizei count, const GLuint *params);

// GL_NV_gpu_shader5

  void  glGetUniformi64vNV(GLuint program, GLint location, GLint64EXT *params);
  void  glProgramUniform1i64NV(GLuint program, GLint location, GLint64EXT x);
  void  glProgramUniform1i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT *value);
  void  glProgramUniform1ui64NV(GLuint program, GLint location, GLuint64EXT x);
  void  glProgramUniform1ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value);
  void  glProgramUniform2i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y);
  void  glProgramUniform2i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT *value);
  void  glProgramUniform2ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y);
  void  glProgramUniform2ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value);
  void  glProgramUniform3i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z);
  void  glProgramUniform3i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT *value);
  void  glProgramUniform3ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
  void  glProgramUniform3ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value);
  void  glProgramUniform4i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
  void  glProgramUniform4i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT *value);
  void  glProgramUniform4ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
  void  glProgramUniform4ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value);
  void  glUniform1i64NV(GLint location, GLint64EXT x);
  void  glUniform1i64vNV(GLint location, GLsizei count, const GLint64EXT *value);
  void  glUniform1ui64NV(GLint location, GLuint64EXT x);
  void  glUniform1ui64vNV(GLint location, GLsizei count, const GLuint64EXT *value);
  void  glUniform2i64NV(GLint location, GLint64EXT x, GLint64EXT y);
  void  glUniform2i64vNV(GLint location, GLsizei count, const GLint64EXT *value);
  void  glUniform2ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y);
  void  glUniform2ui64vNV(GLint location, GLsizei count, const GLuint64EXT *value);
  void  glUniform3i64NV(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z);
  void  glUniform3i64vNV(GLint location, GLsizei count, const GLint64EXT *value);
  void  glUniform3ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
  void  glUniform3ui64vNV(GLint location, GLsizei count, const GLuint64EXT *value);
  void  glUniform4i64NV(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
  void  glUniform4i64vNV(GLint location, GLsizei count, const GLint64EXT *value);
  void  glUniform4ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
  void  glUniform4ui64vNV(GLint location, GLsizei count, const GLuint64EXT *value);

// GL_NV_half_float

  void  glColor3hNV(GLhalfNV red, GLhalfNV green, GLhalfNV blue);
  void  glColor3hvNV(const GLhalfNV *v);
  void  glColor4hNV(GLhalfNV red, GLhalfNV green, GLhalfNV blue, GLhalfNV alpha);
  void  glColor4hvNV(const GLhalfNV *v);
  void  glFogCoordhNV(GLhalfNV coord);
  void  glFogCoordhvNV(const GLhalfNV *coord);
  void  glMultiTexCoord1hNV(GLenum target, GLhalfNV s);
  void  glMultiTexCoord1hvNV(GLenum target, const GLhalfNV *v);
  void  glMultiTexCoord2hNV(GLenum target, GLhalfNV s, GLhalfNV t);
  void  glMultiTexCoord2hvNV(GLenum target, const GLhalfNV *v);
  void  glMultiTexCoord3hNV(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r);
  void  glMultiTexCoord3hvNV(GLenum target, const GLhalfNV *v);
  void  glMultiTexCoord4hNV(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q);
  void  glMultiTexCoord4hvNV(GLenum target, const GLhalfNV *v);
  void  glNormal3hNV(GLhalfNV nx, GLhalfNV ny, GLhalfNV nz);
  void  glNormal3hvNV(const GLhalfNV *v);
  void  glSecondaryColor3hNV(GLhalfNV red, GLhalfNV green, GLhalfNV blue);
  void  glSecondaryColor3hvNV(const GLhalfNV *v);
  void  glTexCoord1hNV(GLhalfNV s);
  void  glTexCoord1hvNV(const GLhalfNV *v);
  void  glTexCoord2hNV(GLhalfNV s, GLhalfNV t);
  void  glTexCoord2hvNV(const GLhalfNV *v);
  void  glTexCoord3hNV(GLhalfNV s, GLhalfNV t, GLhalfNV r);
  void  glTexCoord3hvNV(const GLhalfNV *v);
  void  glTexCoord4hNV(GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q);
  void  glTexCoord4hvNV(const GLhalfNV *v);
  void  glVertex2hNV(GLhalfNV x, GLhalfNV y);
  void  glVertex2hvNV(const GLhalfNV *v);
  void  glVertex3hNV(GLhalfNV x, GLhalfNV y, GLhalfNV z);
  void  glVertex3hvNV(const GLhalfNV *v);
  void  glVertex4hNV(GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w);
  void  glVertex4hvNV(const GLhalfNV *v);
  void  glVertexAttrib1hNV(GLuint index, GLhalfNV x);
  void  glVertexAttrib1hvNV(GLuint index, const GLhalfNV *v);
  void  glVertexAttrib2hNV(GLuint index, GLhalfNV x, GLhalfNV y);
  void  glVertexAttrib2hvNV(GLuint index, const GLhalfNV *v);
  void  glVertexAttrib3hNV(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z);
  void  glVertexAttrib3hvNV(GLuint index, const GLhalfNV *v);
  void  glVertexAttrib4hNV(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w);
  void  glVertexAttrib4hvNV(GLuint index, const GLhalfNV *v);
  void  glVertexAttribs1hvNV(GLuint index, GLsizei count, const GLhalfNV *v);
  void  glVertexAttribs2hvNV(GLuint index, GLsizei count, const GLhalfNV *v);
  void  glVertexAttribs3hvNV(GLuint index, GLsizei count, const GLhalfNV *v);
  void  glVertexAttribs4hvNV(GLuint index, GLsizei count, const GLhalfNV *v);
  void  glVertexWeighthNV(GLhalfNV weight);
  void  glVertexWeighthvNV(const GLhalfNV *weight);

// GL_NV_occlusion_query

  void  glBeginOcclusionQueryNV(GLuint id);
  void  glDeleteOcclusionQueriesNV(GLsizei n, const GLuint *ids);
  void  glEndOcclusionQueryNV(void);
  void  glGenOcclusionQueriesNV(GLsizei n, GLuint *ids);
  void  glGetOcclusionQueryivNV(GLuint id, GLenum pname, GLint *params);
  void  glGetOcclusionQueryuivNV(GLuint id, GLenum pname, GLuint *params);
  GLboolean  glIsOcclusionQueryNV(GLuint id);

// GL_NV_parameter_buffer_object

  void  glProgramBufferParametersIivNV(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLint *params);
  void  glProgramBufferParametersIuivNV(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLuint *params);
  void  glProgramBufferParametersfvNV(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLfloat *params);

// GL_NV_path_rendering

  void  glCopyPathNV(GLuint resultPath, GLuint srcPath);
  void  glCoverFillPathInstancedNV(GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues);
  void  glCoverFillPathNV(GLuint path, GLenum coverMode);
  void  glCoverStrokePathInstancedNV(GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues);
  void  glCoverStrokePathNV(GLuint name, GLenum coverMode);
  void  glDeletePathsNV(GLuint path, GLsizei range);
  GLuint  glGenPathsNV(GLsizei range);
  void  glGetPathColorGenfvNV(GLenum color, GLenum pname, GLfloat *value);
  void  glGetPathColorGenivNV(GLenum color, GLenum pname, GLint *value);
  void  glGetPathCommandsNV(GLuint name, GLubyte *commands);
  void  glGetPathCoordsNV(GLuint name, GLfloat *coords);
  void  glGetPathDashArrayNV(GLuint name, GLfloat *dashArray);
  GLfloat  glGetPathLengthNV(GLuint path, GLsizei startSegment, GLsizei numSegments);
  void  glGetPathMetricRangeNV(GLbitfield metricQueryMask, GLuint fistPathName, GLsizei numPaths, GLsizei stride, GLfloat *metrics);
  void  glGetPathMetricsNV(GLbitfield metricQueryMask, GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLsizei stride, GLfloat *metrics);
  void  glGetPathParameterfvNV(GLuint name, GLenum param, GLfloat *value);
  void  glGetPathParameterivNV(GLuint name, GLenum param, GLint *value);
  void  glGetPathSpacingNV(GLenum pathListMode, GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLfloat advanceScale, GLfloat kerningScale, GLenum transformType, GLfloat *returnedSpacing);
  void  glGetPathTexGenfvNV(GLenum texCoordSet, GLenum pname, GLfloat *value);
  void  glGetPathTexGenivNV(GLenum texCoordSet, GLenum pname, GLint *value);
  void  glInterpolatePathsNV(GLuint resultPath, GLuint pathA, GLuint pathB, GLfloat weight);
  GLboolean  glIsPathNV(GLuint path);
  GLboolean  glIsPointInFillPathNV(GLuint path, GLuint mask, GLfloat x, GLfloat y);
  GLboolean  glIsPointInStrokePathNV(GLuint path, GLfloat x, GLfloat y);
  void  glPathColorGenNV(GLenum color, GLenum genMode, GLenum colorFormat, const GLfloat *coeffs);
  void  glPathCommandsNV(GLuint path, GLsizei numCommands, const GLubyte *commands, GLsizei numCoords, GLenum coordType, const GLvoid *coords);
  void  glPathCoordsNV(GLuint path, GLsizei numCoords, GLenum coordType, const GLvoid *coords);
  void  glPathCoverDepthFuncNV(GLenum zfunc);
  void  glPathDashArrayNV(GLuint path, GLsizei dashCount, const GLfloat *dashArray);
  void  glPathFogGenNV(GLenum genMode);
  void  glPathGlyphRangeNV(GLuint firstPathName, GLenum fontTarget, const GLvoid *fontName, GLbitfield fontStyle, GLuint firstGlyph, GLsizei numGlyphs, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
  void  glPathGlyphsNV(GLuint firstPathName, GLenum fontTarget, const GLvoid *fontName, GLbitfield fontStyle, GLsizei numGlyphs, GLenum type, const GLvoid *charcodes, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
  void  glPathParameterfNV(GLuint path, GLenum pname, GLfloat value);
  void  glPathParameterfvNV(GLuint path, GLenum pname, const GLfloat *value);
  void  glPathParameteriNV(GLuint path, GLenum pname, GLint value);
  void  glPathParameterivNV(GLuint path, GLenum pname, const GLint *value);
  void  glPathStencilDepthOffsetNV(GLfloat factor, GLfloat units);
  void  glPathStencilFuncNV(GLenum func, GLint ref, GLuint mask);
  void  glPathStringNV(GLuint path, GLenum format, GLsizei length, const GLvoid *pathString);
  void  glPathSubCommandsNV(GLuint path, GLsizei commandStart, GLsizei commandsToDelete, GLsizei numCommands, const GLubyte *commands, GLsizei numCoords, GLenum coordType, const GLvoid *coords);
  void  glPathSubCoordsNV(GLuint path, GLsizei coordStart, GLsizei numCoords, GLenum coordType, const GLvoid *coords);
  void  glPathTexGenNV(GLenum texCoordSet, GLenum genMode, GLint components, const GLfloat *coeffs);
  GLboolean  glPointAlongPathNV(GLuint path, GLsizei startSegment, GLsizei numSegments, GLfloat distance, GLfloat *x, GLfloat *y, GLfloat *tangentX, GLfloat *tangentY);
  void  glStencilFillPathInstancedNV(GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum transformType, const GLfloat *transformValues);
  void  glStencilFillPathNV(GLuint path, GLenum fillMode, GLuint mask);
  void  glStencilStrokePathInstancedNV(GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLint reference, GLuint mask, GLenum transformType, const GLfloat *transformValues);
  void  glStencilStrokePathNV(GLuint path, GLint reference, GLuint mask);
  void  glTransformPathNV(GLuint resultPath, GLuint srcPath, GLenum transformType, const GLfloat *transformValues);
  void  glWeightPathsNV(GLuint resultPath, GLsizei numPaths, const GLuint *paths, const GLfloat *weights);

// GL_NV_pixel_data_range

  void  glFlushPixelDataRangeNV(GLenum target);
  void  glPixelDataRangeNV(GLenum target, GLsizei size, const GLvoid *pointer);

// GL_NV_point_sprite

  void  glPointParameteriNV(GLenum pname, GLint param);
  void  glPointParameterivNV(GLenum pname, const GLint *params);

// GL_NV_present_video

  void  glGetVideoi64vNV(GLuint video_slot, GLenum pname, GLint64EXT *params);
  void  glGetVideoivNV(GLuint video_slot, GLenum pname, GLint *params);
  void  glGetVideoui64vNV(GLuint video_slot, GLenum pname, GLuint64EXT *params);
  void  glGetVideouivNV(GLuint video_slot, GLenum pname, GLuint *params);
  void  glPresentFrameDualFillNV(GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLenum target1, GLuint fill1, GLenum target2, GLuint fill2, GLenum target3, GLuint fill3);
  void  glPresentFrameKeyedNV(GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLuint key0, GLenum target1, GLuint fill1, GLuint key1);

// GL_NV_primitive_restart

  void  glPrimitiveRestartIndexNV(GLuint index);
  void  glPrimitiveRestartNV(void);

// GL_NV_read_buffer

  void  glReadBufferNV(GLenum mode);

// GL_NV_register_combiners

  void  glCombinerInputNV(GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage);
  void  glCombinerOutputNV(GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum);
  void  glCombinerParameterfNV(GLenum pname, GLfloat param);
  void  glCombinerParameterfvNV(GLenum pname, const GLfloat *params);
  void  glCombinerParameteriNV(GLenum pname, GLint param);
  void  glCombinerParameterivNV(GLenum pname, const GLint *params);
  void  glFinalCombinerInputNV(GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage);
  void  glGetCombinerInputParameterfvNV(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat *params);
  void  glGetCombinerInputParameterivNV(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint *params);
  void  glGetCombinerOutputParameterfvNV(GLenum stage, GLenum portion, GLenum pname, GLfloat *params);
  void  glGetCombinerOutputParameterivNV(GLenum stage, GLenum portion, GLenum pname, GLint *params);
  void  glGetFinalCombinerInputParameterfvNV(GLenum variable, GLenum pname, GLfloat *params);
  void  glGetFinalCombinerInputParameterivNV(GLenum variable, GLenum pname, GLint *params);

// GL_NV_register_combiners2

  void  glCombinerStageParameterfvNV(GLenum stage, GLenum pname, const GLfloat *params);
  void  glGetCombinerStageParameterfvNV(GLenum stage, GLenum pname, GLfloat *params);

// GL_NV_shader_buffer_load

  void  glGetBufferParameterui64vNV(GLenum target, GLenum pname, GLuint64EXT *params);
  void  glGetIntegerui64vNV(GLenum target, GLuint64EXT *data);
  void  glGetNamedBufferParameterui64vNV(GLuint buffer, GLenum pname, GLuint64EXT *params);
  void  glGetUniformui64vNV(GLuint program, GLint location, GLuint64EXT *params);
  GLboolean  glIsBufferResidentNV(GLenum target);
  GLboolean  glIsNamedBufferResidentNV(GLuint buffer);
  void  glMakeBufferNonResidentNV(GLenum target);
  void  glMakeBufferResidentNV(GLenum target, GLenum access);
  void  glMakeNamedBufferNonResidentNV(GLuint buffer);
  void  glMakeNamedBufferResidentNV(GLuint buffer, GLenum access);
  void  glProgramUniformui64NV(GLuint program, GLint location, GLuint64EXT v0);
  void  glProgramUniformui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value);
  void  glUniformui64NV(GLint location, GLuint64EXT v0);
  void  glUniformui64vNV(GLint location, GLsizei count, const GLuint64EXT *value);

// GL_NV_texture_barrier

  void  glTextureBarrierNV(void);

// GL_NV_texture_multisample

  void  glTexImage2DMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
  void  glTexImage3DMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);
  void  glTextureImage2DMultisampleCoverageNV(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
  void  glTextureImage2DMultisampleNV(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
  void  glTextureImage3DMultisampleCoverageNV(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);
  void  glTextureImage3DMultisampleNV(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);

// GL_NV_transform_feedback

  void  glActiveVaryingNV(GLuint program, const GLchar *name);
  void  glBeginTransformFeedbackNV(GLenum primitiveMode);
  void  glBindBufferBaseNV(GLenum target, GLuint index, GLuint buffer);
  void  glBindBufferOffsetNV(GLenum target, GLuint index, GLuint buffer, GLintptr offset);
  void  glBindBufferRangeNV(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
  void  glEndTransformFeedbackNV(void);
  void  glGetActiveVaryingNV(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name);
  void  glGetTransformFeedbackVaryingNV(GLuint program, GLuint index, GLint *location);
  GLint  glGetVaryingLocationNV(GLuint program, const GLchar *name);
  void  glTransformFeedbackAttribsNV(GLuint count, const GLint *attribs, GLenum bufferMode);
  void  glTransformFeedbackVaryingsNV(GLuint program, GLsizei count, const GLint *locations, GLenum bufferMode);

// GL_NV_transform_feedback2

  void  glBindTransformFeedbackNV(GLenum target, GLuint id);
  void  glDeleteTransformFeedbacksNV(GLsizei n, const GLuint *ids);
  void  glDrawTransformFeedbackNV(GLenum mode, GLuint name);
  void  glGenTransformFeedbacksNV(GLsizei n, GLuint *ids);
  GLboolean  glIsTransformFeedbackNV(GLuint id);
  void  glPauseTransformFeedbackNV(void);
  void  glResumeTransformFeedbackNV(void);

// GL_NV_vertex_array_range

  void  glFlushVertexArrayRangeNV(void);
  void  glVertexArrayRangeNV(GLsizei size, const GLvoid *pointer);

// GL_NV_vertex_attrib_integer_64bit

  void  glGetVertexAttribLi64vNV(GLuint index, GLenum pname, GLint64EXT *params);
  void  glGetVertexAttribLui64vNV(GLuint index, GLenum pname, GLuint64EXT *params);
  void  glVertexAttribL1i64NV(GLuint index, GLint64EXT x);
  void  glVertexAttribL1i64vNV(GLuint index, const GLint64EXT *v);
  void  glVertexAttribL1ui64NV(GLuint index, GLuint64EXT x);
  void  glVertexAttribL1ui64vNV(GLuint index, const GLuint64EXT *v);
  void  glVertexAttribL2i64NV(GLuint index, GLint64EXT x, GLint64EXT y);
  void  glVertexAttribL2i64vNV(GLuint index, const GLint64EXT *v);
  void  glVertexAttribL2ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y);
  void  glVertexAttribL2ui64vNV(GLuint index, const GLuint64EXT *v);
  void  glVertexAttribL3i64NV(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z);
  void  glVertexAttribL3i64vNV(GLuint index, const GLint64EXT *v);
  void  glVertexAttribL3ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
  void  glVertexAttribL3ui64vNV(GLuint index, const GLuint64EXT *v);
  void  glVertexAttribL4i64NV(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
  void  glVertexAttribL4i64vNV(GLuint index, const GLint64EXT *v);
  void  glVertexAttribL4ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
  void  glVertexAttribL4ui64vNV(GLuint index, const GLuint64EXT *v);
  void  glVertexAttribLFormatNV(GLuint index, GLint size, GLenum type, GLsizei stride);

// GL_NV_vertex_buffer_unified_memory

  void  glBufferAddressRangeNV(GLenum pname, GLuint index, GLuint64EXT address, GLsizeiptr length);
  void  glColorFormatNV(GLint size, GLenum type, GLsizei stride);
  void  glEdgeFlagFormatNV(GLsizei stride);
  void  glFogCoordFormatNV(GLenum type, GLsizei stride);
  void  glGetIntegerui64i_vNV(GLenum target, GLuint index, GLuint64EXT *data);
  void  glIndexFormatNV(GLenum type, GLsizei stride);
  void  glNormalFormatNV(GLenum type, GLsizei stride);
  void  glSecondaryColorFormatNV(GLint size, GLenum type, GLsizei stride);
  void  glTexCoordFormatNV(GLint size, GLenum type, GLsizei stride);
  void  glVertexAttribFormatNV(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride);
  void  glVertexAttribIFormatNV(GLuint index, GLint size, GLenum type, GLsizei stride);
  void  glVertexFormatNV(GLint size, GLenum type, GLsizei stride);

// GL_NV_vertex_program

  GLboolean  glAreProgramsResidentNV(GLsizei n, const GLuint *programs, GLboolean *residences);
  void  glBindProgramNV(GLenum target, GLuint id);
  void  glDeleteProgramsNV(GLsizei n, const GLuint *programs);
  void  glExecuteProgramNV(GLenum target, GLuint id, const GLfloat *params);
  void  glGenProgramsNV(GLsizei n, GLuint *programs);
  void  glGetProgramParameterdvNV(GLenum target, GLuint index, GLenum pname, GLdouble *params);
  void  glGetProgramParameterfvNV(GLenum target, GLuint index, GLenum pname, GLfloat *params);
  void  glGetProgramStringNV(GLuint id, GLenum pname, GLubyte *program);
  void  glGetProgramivNV(GLuint id, GLenum pname, GLint *params);
  void  glGetTrackMatrixivNV(GLenum target, GLuint address, GLenum pname, GLint *params);
  void  glGetVertexAttribPointervNV(GLuint index, GLenum pname, GLvoid **pointer);
  void  glGetVertexAttribdvNV(GLuint index, GLenum pname, GLdouble *params);
  void  glGetVertexAttribfvNV(GLuint index, GLenum pname, GLfloat *params);
  void  glGetVertexAttribivNV(GLuint index, GLenum pname, GLint *params);
  GLboolean  glIsProgramNV(GLuint id);
  void  glLoadProgramNV(GLenum target, GLuint id, GLsizei len, const GLubyte *program);
  void  glProgramParameter4dNV(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
  void  glProgramParameter4dvNV(GLenum target, GLuint index, const GLdouble *v);
  void  glProgramParameter4fNV(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
  void  glProgramParameter4fvNV(GLenum target, GLuint index, const GLfloat *v);
  void  glProgramParameters4dvNV(GLenum target, GLuint index, GLsizei count, const GLdouble *v);
  void  glProgramParameters4fvNV(GLenum target, GLuint index, GLsizei count, const GLfloat *v);
  void  glRequestResidentProgramsNV(GLsizei n, const GLuint *programs);
  void  glTrackMatrixNV(GLenum target, GLuint address, GLenum matrix, GLenum transform);
  void  glVertexAttrib1dNV(GLuint index, GLdouble x);
  void  glVertexAttrib1dvNV(GLuint index, const GLdouble *v);
  void  glVertexAttrib1fNV(GLuint index, GLfloat x);
  void  glVertexAttrib1fvNV(GLuint index, const GLfloat *v);
  void  glVertexAttrib1sNV(GLuint index, GLshort x);
  void  glVertexAttrib1svNV(GLuint index, const GLshort *v);
  void  glVertexAttrib2dNV(GLuint index, GLdouble x, GLdouble y);
  void  glVertexAttrib2dvNV(GLuint index, const GLdouble *v);
  void  glVertexAttrib2fNV(GLuint index, GLfloat x, GLfloat y);
  void  glVertexAttrib2fvNV(GLuint index, const GLfloat *v);
  void  glVertexAttrib2sNV(GLuint index, GLshort x, GLshort y);
  void  glVertexAttrib2svNV(GLuint index, const GLshort *v);
  void  glVertexAttrib3dNV(GLuint index, GLdouble x, GLdouble y, GLdouble z);
  void  glVertexAttrib3dvNV(GLuint index, const GLdouble *v);
  void  glVertexAttrib3fNV(GLuint index, GLfloat x, GLfloat y, GLfloat z);
  void  glVertexAttrib3fvNV(GLuint index, const GLfloat *v);
  void  glVertexAttrib3sNV(GLuint index, GLshort x, GLshort y, GLshort z);
  void  glVertexAttrib3svNV(GLuint index, const GLshort *v);
  void  glVertexAttrib4dNV(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
  void  glVertexAttrib4dvNV(GLuint index, const GLdouble *v);
  void  glVertexAttrib4fNV(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
  void  glVertexAttrib4fvNV(GLuint index, const GLfloat *v);
  void  glVertexAttrib4sNV(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
  void  glVertexAttrib4svNV(GLuint index, const GLshort *v);
  void  glVertexAttrib4ubNV(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
  void  glVertexAttrib4ubvNV(GLuint index, const GLubyte *v);
  void  glVertexAttribPointerNV(GLuint index, GLint fsize, GLenum type, GLsizei stride, const GLvoid *pointer);
  void  glVertexAttribs1dvNV(GLuint index, GLsizei n, const GLdouble *v);
  void  glVertexAttribs1fvNV(GLuint index, GLsizei n, const GLfloat *v);
  void  glVertexAttribs1svNV(GLuint index, GLsizei n, const GLshort *v);
  void  glVertexAttribs2dvNV(GLuint index, GLsizei n, const GLdouble *v);
  void  glVertexAttribs2fvNV(GLuint index, GLsizei n, const GLfloat *v);
  void  glVertexAttribs2svNV(GLuint index, GLsizei n, const GLshort *v);
  void  glVertexAttribs3dvNV(GLuint index, GLsizei n, const GLdouble *v);
  void  glVertexAttribs3fvNV(GLuint index, GLsizei n, const GLfloat *v);
  void  glVertexAttribs3svNV(GLuint index, GLsizei n, const GLshort *v);
  void  glVertexAttribs4dvNV(GLuint index, GLsizei n, const GLdouble *v);
  void  glVertexAttribs4fvNV(GLuint index, GLsizei n, const GLfloat *v);
  void  glVertexAttribs4svNV(GLuint index, GLsizei n, const GLshort *v);
  void  glVertexAttribs4ubvNV(GLuint index, GLsizei n, const GLubyte *v);

// GL_NV_video_capture

  void  glBeginVideoCaptureNV(GLuint video_capture_slot);
  void  glBindVideoCaptureStreamBufferNV(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLintptr offset);
  void  glBindVideoCaptureStreamTextureNV(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLenum target, GLuint texture);
  void  glEndVideoCaptureNV(GLuint video_capture_slot);
  void  glGetVideoCaptureStreamdvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, GLdouble *params);
  void  glGetVideoCaptureStreamfvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, GLfloat *params);
  void  glGetVideoCaptureStreamivNV(GLuint video_capture_slot, GLuint stream, GLenum pname, GLint *params);
  void  glGetVideoCaptureivNV(GLuint video_capture_slot, GLenum pname, GLint *params);
  GLenum  glVideoCaptureNV(GLuint video_capture_slot, GLuint *sequence_num, GLuint64EXT *capture_time);
  void  glVideoCaptureStreamParameterdvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLdouble *params);
  void  glVideoCaptureStreamParameterfvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLfloat *params);
  void  glVideoCaptureStreamParameterivNV(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLint *params);

// GL_OES_blend_equation_separate

  void  glBlendEquationSeparateOES(GLenum modeRGB, GLenum modeAlpha);

// GL_OES_blend_func_separate

  void  glBlendFuncSeparateOES(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);

// GL_OES_blend_subtract

  void  glBlendEquationOES(GLenum mode);

// GL_OES_framebuffer_object

  void  glBindFramebufferOES(GLenum target, GLuint framebuffer);
  void  glBindRenderbufferOES(GLenum target, GLuint renderbuffer);
  GLenum  glCheckFramebufferStatusOES(GLenum target);
  void  glDeleteFramebuffersOES(GLsizei n, const GLuint *framebuffers);
  void  glDeleteRenderbuffersOES(GLsizei n, const GLuint *renderbuffers);
  void  glFramebufferRenderbufferOES(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
  void  glFramebufferTexture2DOES(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
  void  glGenFramebuffersOES(GLsizei n, GLuint *framebuffers);
  void  glGenRenderbuffersOES(GLsizei n, GLuint *renderbuffers);
  void  glGenerateMipmapOES(GLenum target);
  void  glGetFramebufferAttachmentParameterivOES(GLenum target, GLenum attachment, GLenum pname, GLint *params);
  void  glGetRenderbufferParameterivOES(GLenum target, GLenum pname, GLint *params);
  GLboolean  glIsFramebufferOES(GLuint framebuffer);
  GLboolean  glIsRenderbufferOES(GLuint renderbuffer);
  void  glRenderbufferStorageOES(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);

// GL_OES_get_program_binary

  void  glGetProgramBinaryOES(GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, GLvoid *binary);
  void  glProgramBinaryOES(GLuint program, GLenum binaryFormat, const GLvoid *binary, GLint length);

// GL_OES_mapbuffer

  void  glGetBufferPointervOES(GLenum target, GLenum pname, GLvoid **params);
  GLvoid * glMapBufferOES(GLenum target, GLenum access);
  GLboolean  glUnmapBufferOES(GLenum target);

// GL_OES_matrix_palette

  void  glCurrentPaletteMatrixOES(GLuint index);

// GL_OES_texture_3D

  void  glCompressedTexImage3DOES(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data);
  void  glCompressedTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data);
  void  glCopyTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
  void  glFramebufferTexture3DOES(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
  void  glTexImage3DOES(GLenum target, GLint level, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
  void  glTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);

// GL_OES_texture_cube_map

  void  glGetTexGenfvOES(GLenum coord, GLenum pname, GLfloat *params);
  void  glGetTexGenivOES(GLenum coord, GLenum pname, GLint *params);
  void  glGetTexGenxvOES(GLenum coord, GLenum pname, GLfixed *params);
  void  glTexGenfOES(GLenum coord, GLenum pname, GLfloat param);
  void  glTexGenfvOES(GLenum coord, GLenum pname, const GLfloat *params);
  void  glTexGeniOES(GLenum coord, GLenum pname, GLint param);
  void  glTexGenivOES(GLenum coord, GLenum pname, const GLint *params);
  void  glTexGenxOES(GLenum coord, GLenum pname, GLfixed param);
  void  glTexGenxvOES(GLenum coord, GLenum pname, const GLfixed *params);

// GL_OES_vertex_array_object

  void  glBindVertexArrayOES(GLuint array);
  void  glDeleteVertexArraysOES(GLsizei n, const GLuint *arrays);
  void  glGenVertexArraysOES(GLsizei n, GLuint *arrays);
  GLboolean  glIsVertexArrayOES(GLuint array);

// GL_PGI_misc_hints

  void  glHintPGI(GLenum target, GLint mode);

// GL_REGAL_ES1_0_compatibility

  void  glAlphaFuncx(GLenum func, GLclampx ref);
  void  glClearColorx(GLclampx red, GLclampx green, GLclampx blue, GLclampx alpha);
  void  glClearDepthx(GLclampx depth);
  void  glColor4x(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha);
  void  glDepthRangex(GLclampx zNear, GLclampx zFar);
  void  glFogx(GLenum pname, GLfixed param);
  void  glFogxv(GLenum pname, const GLfixed *params);
  void  glFrustumf(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);
  void  glFrustumx(GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar);
  void  glLightModelx(GLenum pname, GLfixed param);
  void  glLightModelxv(GLenum pname, const GLfixed *params);
  void  glLightx(GLenum light, GLenum pname, GLfixed param);
  void  glLightxv(GLenum light, GLenum pname, const GLfixed *params);
  void  glLineWidthx(GLfixed width);
  void  glLoadMatrixx(const GLfixed *m);
  void  glMaterialx(GLenum face, GLenum pname, GLfixed param);
  void  glMaterialxv(GLenum face, GLenum pname, const GLfixed *params);
  void  glMultMatrixx(const GLfixed *m);
  void  glMultiTexCoord4x(GLenum target, GLfixed s, GLfixed t, GLfixed r, GLfixed q);
  void  glNormal3x(GLfixed nx, GLfixed ny, GLfixed nz);
  void  glOrthof(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);
  void  glOrthox(GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar);
  void  glPointSizex(GLfixed size);
  void  glPolygonOffsetx(GLfixed factor, GLfixed units);
  void  glRotatex(GLfixed angle, GLfixed x, GLfixed y, GLfixed z);
  void  glSampleCoveragex(GLclampx value, GLboolean invert);
  void  glScalex(GLfixed x, GLfixed y, GLfixed z);
  void  glTexEnvx(GLenum target, GLenum pname, GLfixed param);
  void  glTexEnvxv(GLenum target, GLenum pname, const GLfixed *params);
  void  glTexParameterx(GLenum target, GLenum pname, GLfixed param);
  void  glTranslatex(GLfixed x, GLfixed y, GLfixed z);

// GL_REGAL_ES1_1_compatibility

  void  glClipPlanef(GLenum plane, const GLfloat *equation);
  void  glClipPlanex(GLenum plane, const GLfixed *equation);
  void  glGetClipPlanef(GLenum pname, GLfloat *eqn);
  void  glGetClipPlanex(GLenum pname, GLfixed *eqn);
  void  glGetFixedv(GLenum pname, GLfixed *params);
  void  glGetLightxv(GLenum light, GLenum pname, GLfixed *params);
  void  glGetMaterialxv(GLenum face, GLenum pname, GLfixed *params);
  void  glGetTexEnvxv(GLenum env, GLenum pname, GLfixed *params);
  void  glGetTexParameterxv(GLenum target, GLenum pname, GLfixed *params);
  void  glPointParameterx(GLenum pname, GLfixed param);
  void  glPointParameterxv(GLenum pname, const GLfixed *params);
  void  glPointSizePointerOES(GLenum type, GLsizei stride, const GLvoid *pointer);
  void  glTexParameterxv(GLenum target, GLenum pname, const GLfixed *params);

// GL_SGIS_detail_texture

  void  glDetailTexFuncSGIS(GLenum target, GLsizei n, const GLfloat *points);
  void  glGetDetailTexFuncSGIS(GLenum target, GLfloat *points);

// GL_SGIS_fog_function

  void  glFogFuncSGIS(GLsizei n, const GLfloat *points);
  void  glGetFogFuncSGIS(GLfloat *points);

// GL_SGIS_multisample

  void  glSampleMaskSGIS(GLclampf value, GLboolean invert);
  void  glSamplePatternSGIS(GLenum pattern);

// GL_SGIS_pixel_texture

  void  glGetPixelTexGenParameterfvSGIS(GLenum pname, GLfloat *params);
  void  glGetPixelTexGenParameterivSGIS(GLenum pname, GLint *params);
  void  glPixelTexGenParameterfSGIS(GLenum pname, GLfloat param);
  void  glPixelTexGenParameterfvSGIS(GLenum pname, const GLfloat *params);
  void  glPixelTexGenParameteriSGIS(GLenum pname, GLint param);
  void  glPixelTexGenParameterivSGIS(GLenum pname, const GLint *params);

// GL_SGIS_point_parameters

  void  glPointParameterfSGIS(GLenum pname, GLfloat param);
  void  glPointParameterfvSGIS(GLenum pname, const GLfloat *params);

// GL_SGIS_sharpen_texture

  void  glGetSharpenTexFuncSGIS(GLenum target, GLfloat *points);
  void  glSharpenTexFuncSGIS(GLenum target, GLsizei n, const GLfloat *points);

// GL_SGIS_texture4D

  void  glTexImage4DSGIS(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
  void  glTexSubImage4DSGIS(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLenum format, GLenum type, const GLvoid *pixels);

// GL_SGIS_texture_color_mask

  void  glTextureColorMaskSGIS(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);

// GL_SGIS_texture_filter4

  void  glGetTexFilterFuncSGIS(GLenum target, GLenum filter, GLfloat *weights);
  void  glTexFilterFuncSGIS(GLenum target, GLenum filter, GLsizei n, const GLfloat *weights);

// GL_SGIX_async

  void  glAsyncMarkerSGIX(GLuint marker);
  void  glDeleteAsyncMarkersSGIX(GLuint marker, GLsizei range);
  GLint  glFinishAsyncSGIX(GLuint *markerp);
  GLuint  glGenAsyncMarkersSGIX(GLsizei range);
  GLboolean  glIsAsyncMarkerSGIX(GLuint marker);
  GLint  glPollAsyncSGIX(GLuint *markerp);

// GL_SGIX_flush_raster

  void  glFlushRasterSGIX(void);

// GL_SGIX_fragment_lighting

  void  glFragmentColorMaterialSGIX(GLenum face, GLenum mode);
  void  glFragmentLightModelfSGIX(GLenum pname, GLfloat param);
  void  glFragmentLightModelfvSGIX(GLenum pname, const GLfloat *params);
  void  glFragmentLightModeliSGIX(GLenum pname, GLint param);
  void  glFragmentLightModelivSGIX(GLenum pname, const GLint *params);
  void  glFragmentLightfSGIX(GLenum light, GLenum pname, GLfloat param);
  void  glFragmentLightfvSGIX(GLenum light, GLenum pname, const GLfloat *params);
  void  glFragmentLightiSGIX(GLenum light, GLenum pname, GLint param);
  void  glFragmentLightivSGIX(GLenum light, GLenum pname, const GLint *params);
  void  glFragmentMaterialfSGIX(GLenum face, GLenum pname, GLfloat param);
  void  glFragmentMaterialfvSGIX(GLenum face, GLenum pname, const GLfloat *params);
  void  glFragmentMaterialiSGIX(GLenum face, GLenum pname, GLint param);
  void  glFragmentMaterialivSGIX(GLenum face, GLenum pname, const GLint *params);
  void  glGetFragmentLightfvSGIX(GLenum light, GLenum pname, GLfloat *params);
  void  glGetFragmentLightivSGIX(GLenum light, GLenum pname, GLint *params);
  void  glGetFragmentMaterialfvSGIX(GLenum face, GLenum pname, GLfloat *params);
  void  glGetFragmentMaterialivSGIX(GLenum face, GLenum pname, GLint *params);
  void  glLightEnviSGIX(GLenum pname, GLint param);

// GL_SGIX_framezoom

  void  glFrameZoomSGIX(GLint factor);

// GL_SGIX_igloo_interface

  void  glIglooInterfaceSGIX(GLenum pname, const GLvoid *params);

// GL_SGIX_instruments

  GLint  glGetInstrumentsSGIX(void);
  void  glInstrumentsBufferSGIX(GLsizei size, GLint *buffer);
  GLint  glPollInstrumentsSGIX(GLint *marker_p);
  void  glReadInstrumentsSGIX(GLint marker);
  void  glStartInstrumentsSGIX(void);
  void  glStopInstrumentsSGIX(GLint marker);

// GL_SGIX_list_priority

  void  glGetListParameterfvSGIX(GLuint list, GLenum pname, GLfloat *params);
  void  glGetListParameterivSGIX(GLuint list, GLenum pname, GLint *params);
  void  glListParameterfSGIX(GLuint list, GLenum pname, GLfloat param);
  void  glListParameterfvSGIX(GLuint list, GLenum pname, const GLfloat *params);
  void  glListParameteriSGIX(GLuint list, GLenum pname, GLint param);
  void  glListParameterivSGIX(GLuint list, GLenum pname, const GLint *params);

// GL_SGIX_pixel_texture

  void  glPixelTexGenSGIX(GLenum mode);

// GL_SGIX_polynomial_ffd

  void  glDeformSGIX(GLbitfield mask);
  void  glDeformationMap3dSGIX(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, GLdouble w1, GLdouble w2, GLint wstride, GLint worder, const GLdouble *points);
  void  glDeformationMap3fSGIX(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, GLfloat w1, GLfloat w2, GLint wstride, GLint worder, const GLfloat *points);
  void  glLoadIdentityDeformationMapSGIX(GLbitfield mask);

// GL_SGIX_reference_plane

  void  glReferencePlaneSGIX(const GLdouble *equation);

// GL_SGIX_sprite

  void  glSpriteParameterfSGIX(GLenum pname, GLfloat param);
  void  glSpriteParameterfvSGIX(GLenum pname, const GLfloat *params);
  void  glSpriteParameteriSGIX(GLenum pname, GLint param);
  void  glSpriteParameterivSGIX(GLenum pname, const GLint *params);

// GL_SGIX_tag_sample_buffer

  void  glTagSampleBufferSGIX(void);

// GL_SGI_color_table

  void  glColorTableParameterfvSGI(GLenum target, GLenum pname, const GLfloat *params);
  void  glColorTableParameterivSGI(GLenum target, GLenum pname, const GLint *params);
  void  glColorTableSGI(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table);
  void  glCopyColorTableSGI(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
  void  glGetColorTableParameterfvSGI(GLenum target, GLenum pname, GLfloat *params);
  void  glGetColorTableParameterivSGI(GLenum target, GLenum pname, GLint *params);
  void  glGetColorTableSGI(GLenum target, GLenum format, GLenum type, GLvoid *table);

// GL_SUNX_constant_data

  void  glFinishTextureSUNX(void);

// GL_SUN_global_alpha

  void  glGlobalAlphaFactorbSUN(GLbyte factor);
  void  glGlobalAlphaFactordSUN(GLdouble factor);
  void  glGlobalAlphaFactorfSUN(GLfloat factor);
  void  glGlobalAlphaFactoriSUN(GLint factor);
  void  glGlobalAlphaFactorsSUN(GLshort factor);
  void  glGlobalAlphaFactorubSUN(GLubyte factor);
  void  glGlobalAlphaFactoruiSUN(GLuint factor);
  void  glGlobalAlphaFactorusSUN(GLushort factor);

// GL_SUN_mesh_array

  void  glDrawMeshArraysSUN(GLenum mode, GLint first, GLsizei count, GLsizei width);

// GL_SUN_triangle_list

  void  glReplacementCodePointerSUN(GLenum type, GLsizei stride, const GLvoid **pointer);
  void  glReplacementCodeubSUN(GLubyte code);
  void  glReplacementCodeubvSUN(const GLubyte *code);
  void  glReplacementCodeuiSUN(GLuint code);
  void  glReplacementCodeuivSUN(const GLuint *code);
  void  glReplacementCodeusSUN(GLushort code);
  void  glReplacementCodeusvSUN(const GLushort *code);

// GL_SUN_vertex

  void  glColor3fVertex3fSUN(GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
  void  glColor3fVertex3fvSUN(const GLfloat *c, const GLfloat *v);
  void  glColor4fNormal3fVertex3fSUN(GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
  void  glColor4fNormal3fVertex3fvSUN(const GLfloat *c, const GLfloat *n, const GLfloat *v);
  void  glColor4ubVertex2fSUN(GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y);
  void  glColor4ubVertex2fvSUN(const GLubyte *c, const GLfloat *v);
  void  glColor4ubVertex3fSUN(GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
  void  glColor4ubVertex3fvSUN(const GLubyte *c, const GLfloat *v);
  void  glNormal3fVertex3fSUN(GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
  void  glNormal3fVertex3fvSUN(const GLfloat *n, const GLfloat *v);
  void  glReplacementCodeuiColor3fVertex3fSUN(GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
  void  glReplacementCodeuiColor3fVertex3fvSUN(const GLuint *rc, const GLfloat *c, const GLfloat *v);
  void  glReplacementCodeuiColor4fNormal3fVertex3fSUN(GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
  void  glReplacementCodeuiColor4fNormal3fVertex3fvSUN(const GLuint *rc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
  void  glReplacementCodeuiColor4ubVertex3fSUN(GLuint rc, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
  void  glReplacementCodeuiColor4ubVertex3fvSUN(const GLuint *rc, const GLubyte *c, const GLfloat *v);
  void  glReplacementCodeuiNormal3fVertex3fSUN(GLuint rc, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
  void  glReplacementCodeuiNormal3fVertex3fvSUN(const GLuint *rc, const GLfloat *n, const GLfloat *v);
  void  glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(GLuint rc, GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
  void  glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(const GLuint *rc, const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
  void  glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(GLuint rc, GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
  void  glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(const GLuint *rc, const GLfloat *tc, const GLfloat *n, const GLfloat *v);
  void  glReplacementCodeuiTexCoord2fVertex3fSUN(GLuint rc, GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z);
  void  glReplacementCodeuiTexCoord2fVertex3fvSUN(const GLuint *rc, const GLfloat *tc, const GLfloat *v);
  void  glReplacementCodeuiVertex3fSUN(GLuint rc, GLfloat x, GLfloat y, GLfloat z);
  void  glReplacementCodeuiVertex3fvSUN(const GLuint *rc, const GLfloat *v);
  void  glTexCoord2fColor3fVertex3fSUN(GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
  void  glTexCoord2fColor3fVertex3fvSUN(const GLfloat *tc, const GLfloat *c, const GLfloat *v);
  void  glTexCoord2fColor4fNormal3fVertex3fSUN(GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
  void  glTexCoord2fColor4fNormal3fVertex3fvSUN(const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
  void  glTexCoord2fColor4ubVertex3fSUN(GLfloat s, GLfloat t, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
  void  glTexCoord2fColor4ubVertex3fvSUN(const GLfloat *tc, const GLubyte *c, const GLfloat *v);
  void  glTexCoord2fNormal3fVertex3fSUN(GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
  void  glTexCoord2fNormal3fVertex3fvSUN(const GLfloat *tc, const GLfloat *n, const GLfloat *v);
  void  glTexCoord2fVertex3fSUN(GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z);
  void  glTexCoord2fVertex3fvSUN(const GLfloat *tc, const GLfloat *v);
  void  glTexCoord4fColor4fNormal3fVertex4fSUN(GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
  void  glTexCoord4fColor4fNormal3fVertex4fvSUN(const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
  void  glTexCoord4fVertex4fSUN(GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
  void  glTexCoord4fVertex4fvSUN(const GLfloat *tc, const GLfloat *v);

// GL_WIN_swap_hint

  void  glAddSwapHintRectWIN(GLint x, GLint y, GLsizei width, GLsizei height);

#if REGAL_SYS_WGL

// WGL_3DL_stereo_control

  BOOL  wglSetStereoEmitterState3DL(HDC hDC, UINT uState);

// WGL_AMD_gpu_association

  VOID  wglBlitContextFramebufferAMD(HGLRC dstCtx, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
  HGLRC  wglCreateAssociatedContextAMD(UINT id);
  HGLRC  wglCreateAssociatedContextAttribsAMD(UINT id, HGLRC hShareContext, const int *attribList);
  BOOL  wglDeleteAssociatedContextAMD(HGLRC hglrc);
  UINT  wglGetContextGPUIDAMD(HGLRC hglrc);
  HGLRC  wglGetCurrentAssociatedContextAMD(void);
  UINT  wglGetGPUIDsAMD(UINT maxCount, UINT *ids);
  INT  wglGetGPUInfoAMD(UINT id, int property, GLenum dataType, UINT size, void *data);
  BOOL  wglMakeAssociatedContextCurrentAMD(HGLRC hglrc);

// WGL_ARB_buffer_region

  HANDLE  wglCreateBufferRegionARB(HDC hDC, int iLayerPlane, UINT uType);
  VOID  wglDeleteBufferRegionARB(HANDLE hRegion);
  BOOL  wglRestoreBufferRegionARB(HANDLE hRegion, int x, int y, int width, int height, int xSrc, int ySrc);
  BOOL  wglSaveBufferRegionARB(HANDLE hRegion, int x, int y, int width, int height);

// WGL_ARB_create_context

  HGLRC  wglCreateContextAttribsARB(HDC hDC, HGLRC hShareContext, const int *piAttribList);

// WGL_ARB_extensions_string

  const char * wglGetExtensionsStringARB(HDC hDC);

// WGL_ARB_make_current_read

  HDC  wglGetCurrentReadDCARB(void);
  BOOL  wglMakeContextCurrentARB(HDC hDrawDC, HDC hReadDC, HGLRC hglrc);

// WGL_ARB_pbuffer

  HPBUFFERARB  wglCreatePbufferARB(HDC hDC, int iPixelFormat, int iWidth, int iHeight, const int *piAttribList);
  BOOL  wglDestroyPbufferARB(HPBUFFERARB hPbuffer);
  HDC  wglGetPbufferDCARB(HPBUFFERARB hPbuffer);
  BOOL  wglQueryPbufferARB(HPBUFFERARB hPbuffer, int iAttribute, int *piValue);
  int  wglReleasePbufferDCARB(HPBUFFERARB hPbuffer, HDC hDC);

// WGL_ARB_render_texture

  BOOL  wglBindTexImageARB(HPBUFFERARB hPbuffer, int iBuffer);
  BOOL  wglReleaseTexImageARB(HPBUFFERARB hPbuffer, int iBuffer);
  BOOL  wglSetPbufferAttribARB(HPBUFFERARB hPbuffer, const int *piAttribList);

// WGL_EXT_display_color_table

  GLboolean  wglBindDisplayColorTableEXT(GLushort id);
  GLboolean  wglCreateDisplayColorTableEXT(GLushort id);
  VOID  wglDestroyDisplayColorTableEXT(GLushort id);
  GLboolean  wglLoadDisplayColorTableEXT(const GLushort *table, GLuint length);

// WGL_EXT_extensions_string

  const char * wglGetExtensionsStringEXT(void);

// WGL_EXT_make_current_read

  HDC  wglGetCurrentReadDCEXT(void);
  BOOL  wglMakeContextCurrentEXT(HDC hDrawDC, HDC hReadDC, HGLRC hglrc);

// WGL_EXT_pbuffer

  HPBUFFEREXT  wglCreatePbufferEXT(HDC hDC, int iPixelFormat, int iWidth, int iHeight, const int *piAttribList);
  BOOL  wglDestroyPbufferEXT(HPBUFFEREXT hPbuffer);
  HDC  wglGetPbufferDCEXT(HPBUFFEREXT hPbuffer);
  BOOL  wglQueryPbufferEXT(HPBUFFEREXT hPbuffer, int iAttribute, int *piValue);
  int  wglReleasePbufferDCEXT(HPBUFFEREXT hPbuffer, HDC hDC);

// WGL_EXT_pixel_format

  BOOL  wglChoosePixelFormatEXT(HDC hDC, const int *piAttribIList, const FLOAT *pfAttribFList, UINT nMaxFormats, int *piFormats, UINT *nNumFormats);

// WGL_EXT_swap_control

  int  wglGetSwapIntervalEXT(void);
  BOOL  wglSwapIntervalEXT(int interval);

// WGL_GDI

  int  wglChoosePixelFormat(HDC hDC, const PIXELFORMATDESCRIPTOR *ppfd);
  int  wglDescribePixelFormat(HDC hDC, int iPixelFormat, UINT nBytes, LPPIXELFORMATDESCRIPTOR ppfd);
  int  wglGetPixelFormat(HDC hDC);
  BOOL  wglSetPixelFormat(HDC hDC, int iPixelFormat, const PIXELFORMATDESCRIPTOR *ppfd);
  BOOL  wglSwapBuffers(HDC hDC);

// WGL_I3D_digital_video_control

  BOOL  wglGetDigitalVideoParametersI3D(HDC hDC, int iAttribute, int *piValue);
  BOOL  wglSetDigitalVideoParametersI3D(HDC hDC, int iAttribute, const int *piValue);

// WGL_I3D_gamma

  BOOL  wglGetGammaTableI3D(HDC hDC, int iEntries, USHORT *puRed, USHORT *puGreen, USHORT *puBlue);
  BOOL  wglGetGammaTableParametersI3D(HDC hDC, int iAttribute, int *piValue);
  BOOL  wglSetGammaTableI3D(HDC hDC, int iEntries, const USHORT *puRed, const USHORT *puGreen, const USHORT *puBlue);
  BOOL  wglSetGammaTableParametersI3D(HDC hDC, int iAttribute, const int *piValue);

// WGL_I3D_genlock

  BOOL  wglDisableGenlockI3D(HDC hDC);
  BOOL  wglEnableGenlockI3D(HDC hDC);
  BOOL  wglGenlockSampleRateI3D(HDC hDC, UINT uRate);
  BOOL  wglGenlockSourceDelayI3D(HDC hDC, UINT uDelay);
  BOOL  wglGenlockSourceEdgeI3D(HDC hDC, UINT uEdge);
  BOOL  wglGenlockSourceI3D(HDC hDC, UINT uSource);
  BOOL  wglGetGenlockSampleRateI3D(HDC hDC, UINT *uRate);
  BOOL  wglGetGenlockSourceDelayI3D(HDC hDC, UINT *uDelay);
  BOOL  wglGetGenlockSourceEdgeI3D(HDC hDC, UINT *uEdge);
  BOOL  wglGetGenlockSourceI3D(HDC hDC, UINT *uSource);
  BOOL  wglIsEnabledGenlockI3D(HDC hDC, BOOL *pFlag);
  BOOL  wglQueryGenlockMaxSourceDelayI3D(HDC hDC, UINT *uMaxLineDelay, UINT *uMaxPixelDelay);

// WGL_I3D_image_buffer

  BOOL  wglAssociateImageBufferEventsI3D(HDC hDC, const HANDLE *pEvent, const LPVOID *pAddress, const DWORD *pSize, UINT count);
  LPVOID  wglCreateImageBufferI3D(HDC hDC, DWORD dwSize, UINT uFlags);
  BOOL  wglDestroyImageBufferI3D(HDC hDC, LPVOID pAddress);
  BOOL  wglReleaseImageBufferEventsI3D(HDC hDC, const LPVOID *pAddress, UINT count);

// WGL_I3D_swap_frame_lock

  BOOL  wglDisableFrameLockI3D(void);
  BOOL  wglEnableFrameLockI3D(void);
  BOOL  wglIsEnabledFrameLockI3D(BOOL *pFlag);
  BOOL  wglQueryFrameLockMasterI3D(BOOL *pFlag);

// WGL_I3D_swap_frame_usage

  BOOL  wglBeginFrameTrackingI3D(void);
  BOOL  wglEndFrameTrackingI3D(void);
  BOOL  wglGetFrameUsageI3D(float *pUsage);
  BOOL  wglQueryFrameTrackingI3D(DWORD *pFrameCount, DWORD *pMissedFrames, float *pLastMissedUsage);

// WGL_NV_DX_interop

  BOOL  wglDXCloseDeviceNV(HANDLE hDevice);
  BOOL  wglDXLockObjectsNV(HANDLE hDevice, GLint count, HANDLE *hObjects);
  BOOL  wglDXObjectAccessNV(HANDLE hObject, GLenum access);
  HANDLE  wglDXOpenDeviceNV(GLvoid *dxDevice);
  HANDLE  wglDXRegisterObjectNV(HANDLE hDevice, GLvoid *dxObject, GLuint name, GLenum type, GLenum access);
  BOOL  wglDXSetResourceShareHandleNV(GLvoid *dxObject, HANDLE shareHandle);
  BOOL  wglDXUnlockObjectsNV(HANDLE hDevice, GLint count, HANDLE *hObjects);
  BOOL  wglDXUnregisterObjectNV(HANDLE hDevice, HANDLE hObject);

// WGL_NV_copy_image

  BOOL  wglCopyImageSubDataNV(HGLRC hSrcRC, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, HGLRC hDstRC, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth);

// WGL_NV_gpu_affinity

  HDC  wglCreateAffinityDCNV(const HGPUNV *phGpuList);
  BOOL  wglDeleteDCNV(HDC hAffinityDC);
  BOOL  wglEnumGpusFromAffinityDCNV(HDC hAffinityDC, UINT iGpuIndex, HGPUNV *hGpu);
  BOOL  wglEnumGpusNV(UINT iGpuIndex, HGPUNV *phGpu);

// WGL_NV_present_video

  BOOL  wglBindVideoDeviceNV(HDC hDC, unsigned int uVideoSlot, HVIDEOOUTPUTDEVICENV hVideoDevice, const int *piAttribList);
  int  wglEnumerateVideoDevicesNV(HDC hDC, HVIDEOOUTPUTDEVICENV *phDeviceList);
  BOOL  wglQueryCurrentContextNV(int iAttribute, int *piValue);

// WGL_NV_swap_group

  BOOL  wglBindSwapBarrierNV(GLuint group, GLuint barrier);
  BOOL  wglJoinSwapGroupNV(HDC hDC, GLuint group);
  BOOL  wglQueryFrameCountNV(HDC hDC, GLuint *count);
  BOOL  wglQueryMaxSwapGroupsNV(HDC hDC, GLuint *maxGroups, GLuint *maxBarriers);
  BOOL  wglQuerySwapGroupNV(HDC hDC, GLuint *group, GLuint *barrier);
  BOOL  wglResetFrameCountNV(HDC hDC);

// WGL_NV_vertex_array_range

  void * wglAllocateMemoryNV(GLsizei size, GLfloat readfreq, GLfloat writefreq, GLfloat priority);
  void  wglFreeMemoryNV(void *pointer);

// WGL_NV_video_capture

  BOOL  wglBindVideoCaptureDeviceNV(UINT uVideoSlot, HVIDEOINPUTDEVICENV hDevice);
  UINT  wglEnumerateVideoCaptureDevicesNV(HDC hDC, HVIDEOINPUTDEVICENV *phDeviceList);
  BOOL  wglLockVideoCaptureDeviceNV(HDC hDC, HVIDEOINPUTDEVICENV hDevice);
  BOOL  wglQueryVideoCaptureDeviceNV(HDC hDC, HVIDEOINPUTDEVICENV hDevice, int iAttribute, int *piValue);
  BOOL  wglReleaseVideoCaptureDeviceNV(HDC hDC, HVIDEOINPUTDEVICENV hDevice);

// WGL_NV_video_output

  BOOL  wglBindVideoImageNV(HPVIDEODEV hVideoDevice, HPBUFFERARB hPbuffer, int iVideoBuffer);
  BOOL  wglGetVideoDeviceNV(HDC hDC, int numDevices, HPVIDEODEV *hVideoDevice);
  BOOL  wglGetVideoInfoNV(HPVIDEODEV hpVideoDevice, unsigned long *pulCounterOutputPbuffer, unsigned long *pulCounterOutputVideo);
  BOOL  wglReleaseVideoDeviceNV(HPVIDEODEV hVideoDevice);
  BOOL  wglReleaseVideoImageNV(HPBUFFERARB hPbuffer, int iVideoBuffer);
  BOOL  wglSendPbufferToVideoNV(HPBUFFERARB hPbuffer, int iBufferType, unsigned long *pulCounterPbuffer, BOOL bBlock);

// WGL_OML_sync_control

  BOOL  wglGetMscRateOML(HDC hDC, INT32 *numerator, INT32 *denominator);
  BOOL  wglGetSyncValuesOML(HDC hDC, INT64 *ust, INT64 *msc, INT64 *sbc);
  INT64  wglSwapBuffersMscOML(HDC hDC, INT64 target_msc, INT64 divisor, INT64 remainder);
  INT64  wglSwapLayerBuffersMscOML(HDC hDC, int fuPlanes, INT64 target_msc, INT64 divisor, INT64 remainder);
  BOOL  wglWaitForMscOML(HDC hDC, INT64 target_msc, INT64 divisor, INT64 remainder, INT64 *ust, INT64 *msc, INT64 *sbc);
  BOOL  wglWaitForSbcOML(HDC hDC, INT64 target_sbc, INT64 *ust, INT64 *msc, INT64 *sbc);

// WGL_core

  BOOL  wglCopyContext(HGLRC hglrcSrc, HGLRC hglrcDst, UINT mask);
  HGLRC  wglCreateContext(HDC hDC);
  HGLRC  wglCreateLayerContext(HDC hDC, int iLayerPlane);
  BOOL  wglDeleteContext(HGLRC hglrc);
  BOOL  wglDescribeLayerPlane(HDC hDC, int iPixelFormat, int iLayerPlane, UINT nBytes, LPLAYERPLANEDESCRIPTOR plpd);
  HGLRC  wglGetCurrentContext(void);
  HDC  wglGetCurrentDC(void);
  int  wglGetLayerPaletteEntries(HDC hDC, int iLayerPlane, int iStart, int nEntries, COLORREF *pcr);
  BOOL  wglMakeCurrent(HDC hDC, HGLRC hglrc);
  BOOL  wglRealizeLayerPalette(HDC hDC, int iLayerPlane, BOOL bRealize);
  int  wglSetLayerPaletteEntries(HDC hDC, int iLayerPlane, int iStart, int nEntries, const COLORREF *pcr);
  BOOL  wglShareLists(HGLRC hglrcShare, HGLRC hglrcSrc);
  BOOL  wglSwapLayerBuffers(HDC hDC, UINT fuPlanes);
  DWORD  wglSwapMultipleBuffers(UINT n, const WGLSWAP *ps);
  BOOL  wglUseFontBitmapsA(HDC hDC, DWORD first, DWORD count, DWORD listBase);
  BOOL  wglUseFontBitmapsW(HDC hDC, DWORD first, DWORD count, DWORD listBase);
  BOOL  wglUseFontOutlinesA(HDC hDC, DWORD first, DWORD count, DWORD listBase, FLOAT deviation, FLOAT extrusion, int format, LPGLYPHMETRICSFLOAT lpgmf);
  BOOL  wglUseFontOutlinesW(HDC hDC, DWORD first, DWORD count, DWORD listBase, FLOAT deviation, FLOAT extrusion, int format, LPGLYPHMETRICSFLOAT lpgmf);
#endif // REGAL_SYS_WGL

#if REGAL_SYS_GLX

// GLX_VERSION_1_0

  XVisualInfo * glXChooseVisual(Display *dpy, int screen, int *attribList);
  void  glXCopyContext(Display *dpy, GLXContext src, GLXContext dst, unsigned long mask);
  GLXContext  glXCreateContext(Display *dpy, XVisualInfo *vis, GLXContext shareList, Bool direct);
  GLXPixmap  glXCreateGLXPixmap(Display *dpy, XVisualInfo *vis, Pixmap pixmap);
  void  glXDestroyContext(Display *dpy, GLXContext ctx);
  void  glXDestroyGLXPixmap(Display *dpy, GLXPixmap pix);
  int  glXGetConfig(Display *dpy, XVisualInfo *vis, int attrib, int *value);
  GLXContext  glXGetCurrentContext(void);
  GLXDrawable  glXGetCurrentDrawable(void);
  Bool  glXIsDirect(Display *dpy, GLXContext ctx);
  Bool  glXMakeCurrent(Display *dpy, GLXDrawable drawable, GLXContext ctx);
  Bool  glXQueryExtension(Display *dpy, int *errorBase, int *eventBase);
  Bool  glXQueryVersion(Display *dpy, int *major, int *minor);
  void  glXSwapBuffers(Display *dpy, GLXDrawable drawable);
  void  glXUseXFont(Font font, int first, int count, int listBase);
  void  glXWaitGL(void);
  void  glXWaitX(void);

// GLX_VERSION_1_1

  const char * glXGetClientString(Display *dpy, int name);
  const char * glXQueryExtensionsString(Display *dpy, int screen);
  const char * glXQueryServerString(Display *dpy, int screen, int name);

// GLX_VERSION_1_2

  Display * glXGetCurrentDisplay(void);

// GLX_VERSION_1_3

  GLXFBConfig * glXChooseFBConfig(Display *dpy, int screen, const int *attrib_list, int *nelements);
  GLXContext  glXCreateNewContext(Display *dpy, GLXFBConfig config, int render_type, GLXContext share_list, Bool direct);
  GLXPbuffer  glXCreatePbuffer(Display *dpy, GLXFBConfig config, const int *attrib_list);
  GLXPixmap  glXCreatePixmap(Display *dpy, GLXFBConfig config, Pixmap pixmap, const int *attrib_list);
  GLXWindow  glXCreateWindow(Display *dpy, GLXFBConfig config, Window win, const int *attrib_list);
  void  glXDestroyPbuffer(Display *dpy, GLXPbuffer pbuf);
  void  glXDestroyPixmap(Display *dpy, GLXPixmap pixmap);
  void  glXDestroyWindow(Display *dpy, GLXWindow win);
  GLXDrawable  glXGetCurrentReadDrawable(void);
  int  glXGetFBConfigAttrib(Display *dpy, GLXFBConfig config, int attribute, int *value);
  GLXFBConfig * glXGetFBConfigs(Display *dpy, int screen, int *nelements);
  void  glXGetSelectedEvent(Display *dpy, GLXDrawable draw, unsigned long *event_mask);
  XVisualInfo * glXGetVisualFromFBConfig(Display *dpy, GLXFBConfig config);
  Bool  glXMakeContextCurrent(Display *display, GLXDrawable draw, GLXDrawable read, GLXContext ctx);
  int  glXQueryContext(Display *dpy, GLXContext ctx, int attribute, int *value);
  void  glXQueryDrawable(Display *dpy, GLXDrawable draw, int attribute, unsigned int *value);
  void  glXSelectEvent(Display *dpy, GLXDrawable draw, unsigned long event_mask);

// GLX_VERSION_1_4

  __GLXextFuncPtr  glXGetProcAddress(const GLubyte *procName);

// GLX_ARB_create_context

  GLXContext  glXCreateContextAttribsARB(Display *dpy, GLXFBConfig config, GLXContext share_context, Bool direct, const int *attrib_list);

// GLX_ARB_get_proc_address

  __GLXextFuncPtr  glXGetProcAddressARB(const GLubyte *procName);

// GLX_EXT_import_context

  void  glXFreeContextEXT(Display *dpy, GLXContext context);
  GLXContextID  glXGetContextIDEXT(const GLXContext context);
  GLXContext  glXImportContextEXT(Display *dpy, GLXContextID contextID);
  int  glXQueryContextInfoEXT(Display *dpy, GLXContext context, int attribute, int *value);

// GLX_EXT_swap_control

  void  glXSwapIntervalEXT(Display *dpy, GLXDrawable drawable, int interval);

// GLX_EXT_texture_from_pixmap

  void  glXBindTexImageEXT(Display *display, GLXDrawable drawable, int buffer, const int *attrib_list);
  void  glXReleaseTexImageEXT(Display *display, GLXDrawable drawable, int buffer);

// GLX_MESA_agp_offset

  unsigned int  glXGetAGPOffsetMESA(const void *pointer);

// GLX_MESA_copy_sub_buffer

  void  glXCopySubBufferMESA(Display *dpy, GLXDrawable drawable, int x, int y, int width, int height);

// GLX_MESA_pixmap_colormap

  GLXPixmap  glXCreateGLXPixmapMESA(Display *dpy, XVisualInfo *visual, Pixmap pixmap, Colormap cmap);

// GLX_MESA_release_buffers

  Bool  glXReleaseBuffersMESA(Display *dpy, GLXDrawable d);

// GLX_MESA_set_3dfx_mode

  GLboolean  glXSet3DfxModeMESA(GLint mode);

// GLX_MESA_swap_control

  int  glXGetSwapIntervalMESA(void);
  int  glXSwapIntervalMESA(unsigned int interval);

// GLX_NV_copy_image

  void  glXCopyImageSubDataNV(Display *dpy, GLXContext srcCtx, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLXContext dstCtx, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth);

// GLX_NV_present_video

  int  glXBindVideoDeviceNV(Display *dpy, unsigned int video_slot, unsigned int video_device, const int *attrib_list);
  unsigned int * glXEnumerateVideoDevicesNV(Display *dpy, int screen, int *nelements);

// GLX_NV_swap_group

  Bool  glXBindSwapBarrierNV(Display *dpy, GLuint group, GLuint barrier);
  Bool  glXJoinSwapGroupNV(Display *dpy, GLXDrawable drawable, GLuint group);
  Bool  glXQueryFrameCountNV(Display *dpy, int screen, GLuint *count);
  Bool  glXQueryMaxSwapGroupsNV(Display *dpy, int screen, GLuint *maxGroups, GLuint *maxBarriers);
  Bool  glXQuerySwapGroupNV(Display *dpy, GLXDrawable drawable, GLuint *group, GLuint *barrier);
  Bool  glXResetFrameCountNV(Display *dpy, int screen);

// GLX_NV_vertex_array_range

  void * glXAllocateMemoryNV(GLsizei size, GLfloat readFrequency, GLfloat writeFrequency, GLfloat priority);
  void  glXFreeMemoryNV(void *pointer);

// GLX_NV_video_capture

  int  glXBindVideoCaptureDeviceNV(Display *dpy, unsigned int video_capture_slot, GLXVideoCaptureDeviceNV device);
  GLXVideoCaptureDeviceNV * glXEnumerateVideoCaptureDevicesNV(Display *dpy, int screen, int *nelements);
  void  glXLockVideoCaptureDeviceNV(Display *dpy, GLXVideoCaptureDeviceNV device);
  int  glXQueryVideoCaptureDeviceNV(Display *dpy, GLXVideoCaptureDeviceNV device, int attribute, int *value);
  void  glXReleaseVideoCaptureDeviceNV(Display *dpy, GLXVideoCaptureDeviceNV device);

// GLX_NV_video_output

  int  glXBindVideoImageNV(Display *dpy, GLXVideoDeviceNV VideoDevice, GLXPbuffer pbuf, int iVideoBuffer);
  int  glXGetVideoDeviceNV(Display *dpy, int screen, int numVideoDevices, GLXVideoDeviceNV *pVideoDevice);
  int  glXGetVideoInfoNV(Display *dpy, int screen, GLXVideoDeviceNV VideoDevice, unsigned long *pulCounterOutputPbuffer, unsigned long *pulCounterOutputVideo);
  int  glXReleaseVideoDeviceNV(Display *dpy, int screen, GLXVideoDeviceNV VideoDevice);
  int  glXReleaseVideoImageNV(Display *dpy, GLXPbuffer pbuf);
  int  glXSendPbufferToVideoNV(Display *dpy, GLXPbuffer pbuf, int iBufferType, unsigned long *pulCounterPbuffer, GLboolean bBlock);

// GLX_OML_sync_control

  Bool  glXGetMscRateOML(Display *dpy, GLXDrawable drawable, int32_t *numerator, int32_t *denominator);
  Bool  glXGetSyncValuesOML(Display *dpy, GLXDrawable drawable, int64_t *ust, int64_t *msc, int64_t *sbc);
  int64_t  glXSwapBuffersMscOML(Display *dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder);
  Bool  glXWaitForMscOML(Display *dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder, int64_t *ust, int64_t *msc, int64_t *sbc);
  Bool  glXWaitForSbcOML(Display *dpy, GLXDrawable drawable, int64_t target_sbc, int64_t *ust, int64_t *msc, int64_t *sbc);

// GLX_SGIX_fbconfig

  GLXContext  glXCreateContextWithConfigSGIX(Display *dpy, GLXFBConfig config, int render_type, GLXContext share_list, Bool direct);
  GLXPixmap  glXCreateGLXPixmapWithConfigSGIX(Display *dpy, GLXFBConfig config, Pixmap pixmap);
  int  glXGetFBConfigAttribSGIX(Display *dpy, GLXFBConfigSGIX config, int attribute, int *value);
  GLXFBConfigSGIX  glXGetFBConfigFromVisualSGIX(Display *dpy, XVisualInfo *vis);
  XVisualInfo * glXGetVisualFromFBConfigSGIX(Display *dpy, GLXFBConfig config);

// GLX_SGIX_pbuffer

  GLXPbuffer  glXCreateGLXPbufferSGIX(Display *dpy, GLXFBConfig config, unsigned int width, unsigned int height, int *attrib_list);
  void  glXDestroyGLXPbufferSGIX(Display *dpy, GLXPbuffer pbuf);
  void  glXGetSelectedEventSGIX(Display *dpy, GLXDrawable drawable, unsigned long *mask);
  void  glXQueryGLXPbufferSGIX(Display *dpy, GLXPbuffer pbuf, int attribute, unsigned int *value);
  void  glXSelectEventSGIX(Display *dpy, GLXDrawable drawable, unsigned long mask);

// GLX_SGIX_swap_barrier

  void  glXBindSwapBarrierSGIX(Display *dpy, GLXDrawable drawable, int barrier);
  Bool  glXQueryMaxSwapBarriersSGIX(Display *dpy, int screen, int *max);

// GLX_SGIX_swap_group

  void  glXJoinSwapGroupSGIX(Display *dpy, GLXDrawable drawable, GLXDrawable member);

// GLX_SGIX_video_resize

  int  glXBindChannelToWindowSGIX(Display *display, int screen, int channel, Window window);
  int  glXChannelRectSGIX(Display *display, int screen, int channel, int x, int y, int w, int h);
  int  glXChannelRectSyncSGIX(Display *display, int screen, int channel, GLenum synctype);
  int  glXQueryChannelDeltasSGIX(Display *display, int screen, int channel, int *x, int *y, int *w, int *h);
  int  glXQueryChannelRectSGIX(Display *display, int screen, int channel, int *dx, int *dy, int *dw, int *dh);

// GLX_SGI_cushion

  void  glXCushionSGI(Display *dpy, Window window, float cushion);

// GLX_SGI_make_current_read

  GLXDrawable  glXGetCurrentReadDrawableSGI(void);
  Bool  glXMakeCurrentReadSGI(Display *dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx);

// GLX_SGI_swap_control

  int  glXSwapIntervalSGI(int interval);

// GLX_SGI_video_sync

  int  glXGetVideoSyncSGI(unsigned int *count);
  int  glXWaitVideoSyncSGI(int divisor, int remainder, unsigned int *count);
#endif // REGAL_SYS_GLX

#if REGAL_SYS_OSX

// CGL_VERSION_1_0

  CGLError  CGLChoosePixelFormat(const CGLPixelFormatAttribute *attribs, CGLPixelFormatObj *pix, GLint *npix);
  CGLError  CGLClearDrawable(CGLContextObj ctx);
  CGLError  CGLCopyContext(CGLContextObj src, CGLContextObj dst, GLbitfield mask);
  CGLError  CGLCreateContext(CGLPixelFormatObj pix, CGLContextObj share, CGLContextObj *ctx);
  CGLError  CGLDescribePixelFormat(CGLPixelFormatObj pix, GLint pix_num, CGLPixelFormatAttribute attrib, GLint *value);
  CGLError  CGLDescribeRenderer(CGLRendererInfoObj rend, GLint rend_num, CGLRendererProperty prop, GLint *value);
  CGLError  CGLDestroyContext(CGLContextObj ctx);
  CGLError  CGLDestroyPixelFormat(CGLPixelFormatObj pix);
  CGLError  CGLDestroyRendererInfo(CGLRendererInfoObj rend);
  CGLError  CGLDisable(CGLContextObj ctx, CGLContextEnable pname);
  CGLError  CGLEnable(CGLContextObj ctx, CGLContextEnable pname);
  const char * CGLErrorString(CGLError error);
  CGLError  CGLFlushDrawable(CGLContextObj ctx);
  CGLError  CGLGetOffScreen(CGLContextObj ctx, GLsizei *width, GLsizei *height, GLsizei *rowbytes, void **baseaddr);
  CGLError  CGLGetOption(CGLGlobalOption pname, GLint *param);
  CGLError  CGLGetParameter(CGLContextObj ctx, CGLContextParameter pname, GLint *params);
  void  CGLGetVersion(GLint *majorvers, GLint *minorvers);
  CGLError  CGLGetVirtualScreen(CGLContextObj ctx, GLint *screen);
  CGLError  CGLIsEnabled(CGLContextObj ctx, CGLContextEnable pname, GLint *enable);
  CGLError  CGLQueryRendererInfo(GLuint display_mask, CGLRendererInfoObj *rend, GLint *nrend);
  CGLError  CGLSetFullScreen(CGLContextObj ctx);
  CGLError  CGLSetOffScreen(CGLContextObj ctx, GLsizei width, GLsizei height, GLsizei rowbytes, void *baseaddr);
  CGLError  CGLSetOption(CGLGlobalOption pname, GLint param);
  CGLError  CGLSetParameter(CGLContextObj ctx, CGLContextParameter pname, const GLint *params);
  CGLError  CGLSetVirtualScreen(CGLContextObj ctx, GLint screen);

// CGL_VERSION_1_1

  CGLError  CGLCreatePBuffer(GLsizei width, GLsizei height, GLenum target, GLenum internalFormat, GLint max_level, CGLPBufferObj *pbuffer);
  CGLError  CGLDescribePBuffer(CGLPBufferObj pbuffer, GLsizei *width, GLsizei *height, GLenum *target, GLenum *internalFormat, GLint *mipmap);
  CGLError  CGLDestroyPBuffer(CGLPBufferObj pbuffer);
  CGLError  CGLGetPBuffer(CGLContextObj ctx, CGLPBufferObj *pbuffer, GLenum *face, GLint *level, GLint *screen);
  CGLError  CGLSetPBuffer(CGLContextObj ctx, CGLPBufferObj pbuffer, GLenum face, GLint level, GLint screen);
  CGLError  CGLTexImagePBuffer(CGLContextObj ctx, CGLPBufferObj pbuffer, GLenum source);

// CGL_VERSION_1_2

  GLuint  CGLGetContextRetainCount(CGLContextObj ctx);
  CGLError  CGLGetGlobalOption(CGLGlobalOption pname, GLint *params);
  GLuint  CGLGetPBufferRetainCount(CGLPBufferObj pbuffer);
  CGLPixelFormatObj  CGLGetPixelFormat(CGLContextObj ctx);
  GLuint  CGLGetPixelFormatRetainCount(CGLPixelFormatObj pix);
  CGLError  CGLLockContext(CGLContextObj ctx);
  void  CGLReleaseContext(CGLContextObj ctx);
  void  CGLReleasePBuffer(CGLPBufferObj pbuffer);
  void  CGLReleasePixelFormat(CGLPixelFormatObj pix);
  CGLContextObj  CGLRetainContext(CGLContextObj ctx);
  CGLPBufferObj  CGLRetainPBuffer(CGLPBufferObj pbuffer);
  CGLPixelFormatObj  CGLRetainPixelFormat(CGLPixelFormatObj pix);
  CGLError  CGLSetGlobalOption(CGLGlobalOption pname, const GLint *params);
  CGLError  CGLUnlockContext(CGLContextObj ctx);

// CGL_VERSION_1_3

  CGLContextObj  CGLGetCurrentContext(void);
  CGLShareGroupObj  CGLGetShareGroup(CGLContextObj ctx);
  CGLError  CGLGetSurface(CGLContextObj ctx, CGSConnectionID *conn, CGSWindowID *win, CGSSurfaceID *srf);
  CGLError  CGLSetCurrentContext(CGLContextObj ctx);
  CGLError  CGLSetSurface(CGLContextObj ctx, CGSConnectionID conn, CGSWindowID win, CGSSurfaceID srf);
  CGLError  CGLTexImageIOSurface2D(CGLContextObj ctx, GLenum target, GLenum internal_format, GLsizei width, GLsizei height, GLenum format, GLenum type, IOSurfaceRef ioSurface, GLuint plane);
  CGLError  CGLUpdateContext(CGLContextObj ctx);
#endif // REGAL_SYS_OSX

#if REGAL_SYS_EGL

// EGL_ANGLE_query_surface_pointer

  EGLBoolean  eglQuerySurfacePointerANGLE(EGLDisplay dpy, EGLSurface surface, EGLint attribute, GLvoid **value);

// EGL_KHR_fence_sync

  EGLint  eglClientWaitSyncKHR(EGLDisplay dpy, EGLSyncKHR GLsync, EGLint flags, EGLTimeKHR timeout);
  EGLSyncKHR  eglCreateSyncKHR(EGLDisplay dpy, EGLenum type, const EGLint *attrib_list);
  EGLBoolean  eglDestroySyncKHR(EGLDisplay dpy, EGLSyncKHR GLsync);
  EGLBoolean  eglGetSyncAttribKHR(EGLDisplay dpy, EGLSyncKHR GLsync, EGLint attribute, EGLint *value);

// EGL_KHR_image_base

  EGLImageKHR  eglCreateImageKHR(EGLDisplay dpy, EGLContext ctx, EGLenum target, EGLClientBuffer buffer, const EGLint *attrib_list);
  EGLBoolean  eglDestroyImageKHR(EGLDisplay dpy, EGLImageKHR image);

// EGL_KHR_lock_surface

  EGLBoolean  eglLockSurfaceKHR(EGLDisplay display, EGLSurface surface, const EGLint *attrib_list);
  EGLBoolean  eglUnlockSurfaceKHR(EGLDisplay display, EGLSurface surface);

// EGL_MESA_drm_image

  EGLImageKHR  eglCreateDRMImageMESA(EGLDisplay dpy, const EGLint *attrib_list);
  EGLBoolean  eglExportDRMImageMESA(EGLDisplay dpy, EGLImageKHR image, EGLint *name, EGLint *handle, EGLint *stride);

// EGL_NV_post_sub_buffer

  EGLBoolean  eglPostSubBufferNV(EGLDisplay dpy, EGLSurface surface, EGLint x, EGLint y, EGLint width, EGLint height);

// EGL_NV_sync

  EGLint  eglClientWaitSyncNV(EGLSyncNV GLsync, EGLint flags, EGLTimeNV timeout);
  EGLSyncNV  eglCreateFenceSyncNV(EGLDisplay dpy, EGLenum condition, const EGLint *attrib_list);
  EGLBoolean  eglDestroySyncNV(EGLSyncNV GLsync);
  EGLBoolean  eglFenceNV(EGLSyncNV GLsync);
  EGLBoolean  eglGetSyncAttribNV(EGLSyncNV GLsync, EGLint attribute, EGLint *value);
  EGLBoolean  eglSignalSyncNV(EGLSyncNV GLsync, EGLenum mode);

// EGL_NV_system_time

  EGLuint64NV  eglGetSystemTimeFrequencyNV(void);
  EGLuint64NV  eglGetSystemTimeNV(void);

// EGL_VERSION_1_0

  EGLBoolean  eglChooseConfig(EGLDisplay dpy, const EGLint *attrib_list, EGLConfig *configs, EGLint config_size, EGLint *num_config);
  EGLBoolean  eglCopyBuffers(EGLDisplay dpy, EGLSurface surface, EGLNativePixmapType target);
  EGLContext  eglCreateContext(EGLDisplay dpy, EGLConfig config, EGLContext share_context, const EGLint *attrib_list);
  EGLSurface  eglCreatePbufferSurface(EGLDisplay dpy, EGLConfig config, const EGLint *attrib_list);
  EGLSurface  eglCreatePixmapSurface(EGLDisplay dpy, EGLConfig config, EGLNativePixmapType pixmap, const EGLint *attrib_list);
  EGLSurface  eglCreateWindowSurface(EGLDisplay dpy, EGLConfig config, EGLNativeWindowType win, const EGLint *attrib_list);
  EGLBoolean  eglDestroyContext(EGLDisplay dpy, EGLContext ctx);
  EGLBoolean  eglDestroySurface(EGLDisplay dpy, EGLSurface surface);
  EGLBoolean  eglGetConfigAttrib(EGLDisplay dpy, EGLConfig config, EGLint attribute, EGLint *value);
  EGLBoolean  eglGetConfigs(EGLDisplay dpy, EGLConfig *configs, EGLint config_size, EGLint *num_config);
  EGLContext  eglGetCurrentContext(void);
  EGLDisplay  eglGetCurrentDisplay(void);
  EGLSurface  eglGetCurrentSurface(EGLint readdraw);
  EGLDisplay  eglGetDisplay(EGLNativeDisplayType display_id);
  EGLint  eglGetError(void);
  __eglMustCastToProperFunctionPointerType  eglGetProcAddress(const char *procname);
  EGLBoolean  eglInitialize(EGLDisplay dpy, EGLint *major, EGLint *minor);
  EGLBoolean  eglMakeCurrent(EGLDisplay dpy, EGLSurface draw, EGLSurface read, EGLContext ctx);
  EGLBoolean  eglQueryContext(EGLDisplay dpy, EGLContext ctx, EGLint attribute, EGLint *value);
  const char * eglQueryString(EGLDisplay dpy, EGLint name);
  EGLBoolean  eglQuerySurface(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint *value);
  EGLBoolean  eglSwapBuffers(EGLDisplay dpy, EGLSurface surface);
  EGLBoolean  eglTerminate(EGLDisplay dpy);
  EGLBoolean  eglWaitGL(void);
  EGLBoolean  eglWaitNative(EGLint engine);

// EGL_VERSION_1_1

  EGLBoolean  eglBindTexImage(EGLDisplay dpy, EGLSurface surface, EGLint buffer);
  EGLBoolean  eglReleaseTexImage(EGLDisplay dpy, EGLSurface surface, EGLint buffer);

// EGL_VERSION_1_2

  EGLBoolean  eglBindAPI(EGLenum api);
  EGLSurface  eglCreatePbufferFromClientBuffer(EGLDisplay dpy, EGLenum buftype, EGLClientBuffer buffer, EGLConfig config, const EGLint *attrib_list);
  EGLenum  eglQueryAPI(void);
  EGLBoolean  eglReleaseThread(void);
  EGLBoolean  eglSurfaceAttrib(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint value);
  EGLBoolean  eglSwapInterval(EGLDisplay dpy, EGLint interval);
  EGLBoolean  eglWaitClient(void);
#endif // REGAL_SYS_EGL

} // namespace Trace

// GL_VERSION_1_0

static void REGAL_CALL trace_glAccum(GLenum op, GLfloat value)
{
  Internal("trace_glAccum","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glAccum(op, value);
}

static void REGAL_CALL trace_glAlphaFunc(GLenum func, GLclampf ref)
{
  Internal("trace_glAlphaFunc","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glAlphaFunc(func, ref);
}

static void REGAL_CALL trace_glBegin(GLenum mode)
{
  Internal("trace_glBegin","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBegin(mode);
}

static void REGAL_CALL trace_glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap)
{
  Internal("trace_glBitmap","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBitmap(width, height, xorig, yorig, xmove, ymove, bitmap);
}

static void REGAL_CALL trace_glBlendFunc(GLenum sfactor, GLenum dfactor)
{
  Internal("trace_glBlendFunc","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBlendFunc(sfactor, dfactor);
}

static void REGAL_CALL trace_glCallList(GLuint list)
{
  Internal("trace_glCallList","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCallList(list);
}

static void REGAL_CALL trace_glCallLists(GLsizei n, GLenum type, const GLvoid *lists)
{
  Internal("trace_glCallLists","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCallLists(n, type, lists);
}

static void REGAL_CALL trace_glClear(GLbitfield mask)
{
  Internal("trace_glClear","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glClear(mask);
}

static void REGAL_CALL trace_glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
{
  Internal("trace_glClearAccum","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glClearAccum(red, green, blue, alpha);
}

static void REGAL_CALL trace_glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
{
  Internal("trace_glClearColor","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glClearColor(red, green, blue, alpha);
}

static void REGAL_CALL trace_glClearDepth(GLclampd depth)
{
  Internal("trace_glClearDepth","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glClearDepth(depth);
}

static void REGAL_CALL trace_glClearIndex(GLfloat c)
{
  Internal("trace_glClearIndex","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glClearIndex(c);
}

static void REGAL_CALL trace_glClearStencil(GLint s)
{
  Internal("trace_glClearStencil","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glClearStencil(s);
}

static void REGAL_CALL trace_glClipPlane(GLenum plane, const GLdouble *equation)
{
  Internal("trace_glClipPlane","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glClipPlane(plane, equation);
}

static void REGAL_CALL trace_glColor3b(GLbyte red, GLbyte green, GLbyte blue)
{
  Internal("trace_glColor3b","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColor3b(red, green, blue);
}

static void REGAL_CALL trace_glColor3bv(const GLbyte *v)
{
  Internal("trace_glColor3bv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColor3bv(v);
}

static void REGAL_CALL trace_glColor3d(GLdouble red, GLdouble green, GLdouble blue)
{
  Internal("trace_glColor3d","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColor3d(red, green, blue);
}

static void REGAL_CALL trace_glColor3dv(const GLdouble *v)
{
  Internal("trace_glColor3dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColor3dv(v);
}

static void REGAL_CALL trace_glColor3f(GLfloat red, GLfloat green, GLfloat blue)
{
  Internal("trace_glColor3f","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColor3f(red, green, blue);
}

static void REGAL_CALL trace_glColor3fv(const GLfloat *v)
{
  Internal("trace_glColor3fv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColor3fv(v);
}

static void REGAL_CALL trace_glColor3i(GLint red, GLint green, GLint blue)
{
  Internal("trace_glColor3i","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColor3i(red, green, blue);
}

static void REGAL_CALL trace_glColor3iv(const GLint *v)
{
  Internal("trace_glColor3iv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColor3iv(v);
}

static void REGAL_CALL trace_glColor3s(GLshort red, GLshort green, GLshort blue)
{
  Internal("trace_glColor3s","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColor3s(red, green, blue);
}

static void REGAL_CALL trace_glColor3sv(const GLshort *v)
{
  Internal("trace_glColor3sv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColor3sv(v);
}

static void REGAL_CALL trace_glColor3ub(GLubyte red, GLubyte green, GLubyte blue)
{
  Internal("trace_glColor3ub","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColor3ub(red, green, blue);
}

static void REGAL_CALL trace_glColor3ubv(const GLubyte *v)
{
  Internal("trace_glColor3ubv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColor3ubv(v);
}

static void REGAL_CALL trace_glColor3ui(GLuint red, GLuint green, GLuint blue)
{
  Internal("trace_glColor3ui","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColor3ui(red, green, blue);
}

static void REGAL_CALL trace_glColor3uiv(const GLuint *v)
{
  Internal("trace_glColor3uiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColor3uiv(v);
}

static void REGAL_CALL trace_glColor3us(GLushort red, GLushort green, GLushort blue)
{
  Internal("trace_glColor3us","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColor3us(red, green, blue);
}

static void REGAL_CALL trace_glColor3usv(const GLushort *v)
{
  Internal("trace_glColor3usv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColor3usv(v);
}

static void REGAL_CALL trace_glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha)
{
  Internal("trace_glColor4b","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColor4b(red, green, blue, alpha);
}

static void REGAL_CALL trace_glColor4bv(const GLbyte *v)
{
  Internal("trace_glColor4bv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColor4bv(v);
}

static void REGAL_CALL trace_glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha)
{
  Internal("trace_glColor4d","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColor4d(red, green, blue, alpha);
}

static void REGAL_CALL trace_glColor4dv(const GLdouble *v)
{
  Internal("trace_glColor4dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColor4dv(v);
}

static void REGAL_CALL trace_glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
{
  Internal("trace_glColor4f","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColor4f(red, green, blue, alpha);
}

static void REGAL_CALL trace_glColor4fv(const GLfloat *v)
{
  Internal("trace_glColor4fv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColor4fv(v);
}

static void REGAL_CALL trace_glColor4i(GLint red, GLint green, GLint blue, GLint alpha)
{
  Internal("trace_glColor4i","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColor4i(red, green, blue, alpha);
}

static void REGAL_CALL trace_glColor4iv(const GLint *v)
{
  Internal("trace_glColor4iv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColor4iv(v);
}

static void REGAL_CALL trace_glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha)
{
  Internal("trace_glColor4s","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColor4s(red, green, blue, alpha);
}

static void REGAL_CALL trace_glColor4sv(const GLshort *v)
{
  Internal("trace_glColor4sv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColor4sv(v);
}

static void REGAL_CALL trace_glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha)
{
  Internal("trace_glColor4ub","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColor4ub(red, green, blue, alpha);
}

static void REGAL_CALL trace_glColor4ubv(const GLubyte *v)
{
  Internal("trace_glColor4ubv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColor4ubv(v);
}

static void REGAL_CALL trace_glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha)
{
  Internal("trace_glColor4ui","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColor4ui(red, green, blue, alpha);
}

static void REGAL_CALL trace_glColor4uiv(const GLuint *v)
{
  Internal("trace_glColor4uiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColor4uiv(v);
}

static void REGAL_CALL trace_glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha)
{
  Internal("trace_glColor4us","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColor4us(red, green, blue, alpha);
}

static void REGAL_CALL trace_glColor4usv(const GLushort *v)
{
  Internal("trace_glColor4usv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColor4usv(v);
}

static void REGAL_CALL trace_glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
{
  Internal("trace_glColorMask","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColorMask(red, green, blue, alpha);
}

static void REGAL_CALL trace_glColorMaterial(GLenum face, GLenum mode)
{
  Internal("trace_glColorMaterial","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColorMaterial(face, mode);
}

static void REGAL_CALL trace_glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type)
{
  Internal("trace_glCopyPixels","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCopyPixels(x, y, width, height, type);
}

static void REGAL_CALL trace_glCullFace(GLenum mode)
{
  Internal("trace_glCullFace","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCullFace(mode);
}

static void REGAL_CALL trace_glDeleteLists(GLuint list, GLsizei range)
{
  Internal("trace_glDeleteLists","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDeleteLists(list, range);
}

static void REGAL_CALL trace_glDepthFunc(GLenum func)
{
  Internal("trace_glDepthFunc","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDepthFunc(func);
}

static void REGAL_CALL trace_glDepthMask(GLboolean flag)
{
  Internal("trace_glDepthMask","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDepthMask(flag);
}

static void REGAL_CALL trace_glDepthRange(GLclampd zNear, GLclampd zFar)
{
  Internal("trace_glDepthRange","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDepthRange(zNear, zFar);
}

static void REGAL_CALL trace_glDisable(GLenum cap)
{
  Internal("trace_glDisable","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDisable(cap);
}

static void REGAL_CALL trace_glDrawBuffer(GLenum mode)
{
  Internal("trace_glDrawBuffer","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDrawBuffer(mode);
}

static void REGAL_CALL trace_glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
{
  Internal("trace_glDrawPixels","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDrawPixels(width, height, format, type, pixels);
}

static void REGAL_CALL trace_glEdgeFlag(GLboolean flag)
{
  Internal("trace_glEdgeFlag","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glEdgeFlag(flag);
}

static void REGAL_CALL trace_glEdgeFlagv(const GLboolean *flag)
{
  Internal("trace_glEdgeFlagv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glEdgeFlagv(flag);
}

static void REGAL_CALL trace_glEnable(GLenum cap)
{
  Internal("trace_glEnable","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glEnable(cap);
}

static void REGAL_CALL trace_glEnd(void)
{
  Internal("trace_glEnd","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glEnd();
}

static void REGAL_CALL trace_glEndList(void)
{
  Internal("trace_glEndList","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glEndList();
}

static void REGAL_CALL trace_glEvalCoord1d(GLdouble u)
{
  Internal("trace_glEvalCoord1d","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glEvalCoord1d(u);
}

static void REGAL_CALL trace_glEvalCoord1dv(const GLdouble *u)
{
  Internal("trace_glEvalCoord1dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glEvalCoord1dv(u);
}

static void REGAL_CALL trace_glEvalCoord1f(GLfloat u)
{
  Internal("trace_glEvalCoord1f","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glEvalCoord1f(u);
}

static void REGAL_CALL trace_glEvalCoord1fv(const GLfloat *u)
{
  Internal("trace_glEvalCoord1fv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glEvalCoord1fv(u);
}

static void REGAL_CALL trace_glEvalCoord2d(GLdouble u, GLdouble v)
{
  Internal("trace_glEvalCoord2d","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glEvalCoord2d(u, v);
}

static void REGAL_CALL trace_glEvalCoord2dv(const GLdouble *u)
{
  Internal("trace_glEvalCoord2dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glEvalCoord2dv(u);
}

static void REGAL_CALL trace_glEvalCoord2f(GLfloat u, GLfloat v)
{
  Internal("trace_glEvalCoord2f","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glEvalCoord2f(u, v);
}

static void REGAL_CALL trace_glEvalCoord2fv(const GLfloat *u)
{
  Internal("trace_glEvalCoord2fv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glEvalCoord2fv(u);
}

static void REGAL_CALL trace_glEvalMesh1(GLenum mode, GLint i1, GLint i2)
{
  Internal("trace_glEvalMesh1","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glEvalMesh1(mode, i1, i2);
}

static void REGAL_CALL trace_glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2)
{
  Internal("trace_glEvalMesh2","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glEvalMesh2(mode, i1, i2, j1, j2);
}

static void REGAL_CALL trace_glEvalPoint1(GLint i)
{
  Internal("trace_glEvalPoint1","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glEvalPoint1(i);
}

static void REGAL_CALL trace_glEvalPoint2(GLint i, GLint j)
{
  Internal("trace_glEvalPoint2","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glEvalPoint2(i, j);
}

static void REGAL_CALL trace_glFeedbackBuffer(GLsizei size, GLenum type, GLfloat *buffer)
{
  Internal("trace_glFeedbackBuffer","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFeedbackBuffer(size, type, buffer);
}

static void REGAL_CALL trace_glFinish(void)
{
  Internal("trace_glFinish","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFinish();
}

static void REGAL_CALL trace_glFlush(void)
{
  Internal("trace_glFlush","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFlush();
}

static void REGAL_CALL trace_glFogf(GLenum pname, GLfloat param)
{
  Internal("trace_glFogf","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFogf(pname, param);
}

static void REGAL_CALL trace_glFogfv(GLenum pname, const GLfloat *params)
{
  Internal("trace_glFogfv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFogfv(pname, params);
}

static void REGAL_CALL trace_glFogi(GLenum pname, GLint param)
{
  Internal("trace_glFogi","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFogi(pname, param);
}

static void REGAL_CALL trace_glFogiv(GLenum pname, const GLint *params)
{
  Internal("trace_glFogiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFogiv(pname, params);
}

static void REGAL_CALL trace_glFrontFace(GLenum mode)
{
  Internal("trace_glFrontFace","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFrontFace(mode);
}

static void REGAL_CALL trace_glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
{
  Internal("trace_glFrustum","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFrustum(left, right, bottom, top, zNear, zFar);
}

static GLuint REGAL_CALL trace_glGenLists(GLsizei range)
{
  Internal("trace_glGenLists","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLuint  ret = Trace::glGenLists(range);
  return ret;
}

static void REGAL_CALL trace_glGetBooleanv(GLenum pname, GLboolean *params)
{
  Internal("trace_glGetBooleanv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetBooleanv(pname, params);
}

static void REGAL_CALL trace_glGetClipPlane(GLenum plane, GLdouble *equation)
{
  Internal("trace_glGetClipPlane","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetClipPlane(plane, equation);
}

static void REGAL_CALL trace_glGetDoublev(GLenum pname, GLdouble *params)
{
  Internal("trace_glGetDoublev","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetDoublev(pname, params);
}

static GLenum REGAL_CALL trace_glGetError(void)
{
  Internal("trace_glGetError","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLenum  ret = Trace::glGetError();
  return ret;
}

static void REGAL_CALL trace_glGetFloatv(GLenum pname, GLfloat *params)
{
  Internal("trace_glGetFloatv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetFloatv(pname, params);
}

static void REGAL_CALL trace_glGetIntegerv(GLenum pname, GLint *params)
{
  Internal("trace_glGetIntegerv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetIntegerv(pname, params);
}

static void REGAL_CALL trace_glGetLightfv(GLenum light, GLenum pname, GLfloat *params)
{
  Internal("trace_glGetLightfv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetLightfv(light, pname, params);
}

static void REGAL_CALL trace_glGetLightiv(GLenum light, GLenum pname, GLint *params)
{
  Internal("trace_glGetLightiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetLightiv(light, pname, params);
}

static void REGAL_CALL trace_glGetMapdv(GLenum target, GLenum query, GLdouble *v)
{
  Internal("trace_glGetMapdv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetMapdv(target, query, v);
}

static void REGAL_CALL trace_glGetMapfv(GLenum target, GLenum query, GLfloat *v)
{
  Internal("trace_glGetMapfv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetMapfv(target, query, v);
}

static void REGAL_CALL trace_glGetMapiv(GLenum target, GLenum query, GLint *v)
{
  Internal("trace_glGetMapiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetMapiv(target, query, v);
}

static void REGAL_CALL trace_glGetMaterialfv(GLenum face, GLenum pname, GLfloat *params)
{
  Internal("trace_glGetMaterialfv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetMaterialfv(face, pname, params);
}

static void REGAL_CALL trace_glGetMaterialiv(GLenum face, GLenum pname, GLint *params)
{
  Internal("trace_glGetMaterialiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetMaterialiv(face, pname, params);
}

static void REGAL_CALL trace_glGetPixelMapfv(GLenum map, GLfloat *values)
{
  Internal("trace_glGetPixelMapfv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetPixelMapfv(map, values);
}

static void REGAL_CALL trace_glGetPixelMapuiv(GLenum map, GLuint *values)
{
  Internal("trace_glGetPixelMapuiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetPixelMapuiv(map, values);
}

static void REGAL_CALL trace_glGetPixelMapusv(GLenum map, GLushort *values)
{
  Internal("trace_glGetPixelMapusv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetPixelMapusv(map, values);
}

static void REGAL_CALL trace_glGetPolygonStipple(GLubyte *mask)
{
  Internal("trace_glGetPolygonStipple","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetPolygonStipple(mask);
}

static const GLubyte *REGAL_CALL trace_glGetString(GLenum name)
{
  Internal("trace_glGetString","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  const GLubyte * ret = Trace::glGetString(name);
  return ret;
}

static void REGAL_CALL trace_glGetTexEnvfv(GLenum target, GLenum pname, GLfloat *params)
{
  Internal("trace_glGetTexEnvfv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetTexEnvfv(target, pname, params);
}

static void REGAL_CALL trace_glGetTexEnviv(GLenum target, GLenum pname, GLint *params)
{
  Internal("trace_glGetTexEnviv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetTexEnviv(target, pname, params);
}

static void REGAL_CALL trace_glGetTexGendv(GLenum coord, GLenum pname, GLdouble *params)
{
  Internal("trace_glGetTexGendv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetTexGendv(coord, pname, params);
}

static void REGAL_CALL trace_glGetTexGenfv(GLenum coord, GLenum pname, GLfloat *params)
{
  Internal("trace_glGetTexGenfv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetTexGenfv(coord, pname, params);
}

static void REGAL_CALL trace_glGetTexGeniv(GLenum coord, GLenum pname, GLint *params)
{
  Internal("trace_glGetTexGeniv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetTexGeniv(coord, pname, params);
}

static void REGAL_CALL trace_glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
{
  Internal("trace_glGetTexImage","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetTexImage(target, level, format, type, pixels);
}

static void REGAL_CALL trace_glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params)
{
  Internal("trace_glGetTexLevelParameterfv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetTexLevelParameterfv(target, level, pname, params);
}

static void REGAL_CALL trace_glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params)
{
  Internal("trace_glGetTexLevelParameteriv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetTexLevelParameteriv(target, level, pname, params);
}

static void REGAL_CALL trace_glGetTexParameterfv(GLenum target, GLenum pname, GLfloat *params)
{
  Internal("trace_glGetTexParameterfv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetTexParameterfv(target, pname, params);
}

static void REGAL_CALL trace_glGetTexParameteriv(GLenum target, GLenum pname, GLint *params)
{
  Internal("trace_glGetTexParameteriv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetTexParameteriv(target, pname, params);
}

static void REGAL_CALL trace_glHint(GLenum target, GLenum mode)
{
  Internal("trace_glHint","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glHint(target, mode);
}

static void REGAL_CALL trace_glIndexMask(GLuint mask)
{
  Internal("trace_glIndexMask","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glIndexMask(mask);
}

static void REGAL_CALL trace_glIndexd(GLdouble c)
{
  Internal("trace_glIndexd","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glIndexd(c);
}

static void REGAL_CALL trace_glIndexdv(const GLdouble *c)
{
  Internal("trace_glIndexdv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glIndexdv(c);
}

static void REGAL_CALL trace_glIndexf(GLfloat c)
{
  Internal("trace_glIndexf","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glIndexf(c);
}

static void REGAL_CALL trace_glIndexfv(const GLfloat *c)
{
  Internal("trace_glIndexfv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glIndexfv(c);
}

static void REGAL_CALL trace_glIndexi(GLint c)
{
  Internal("trace_glIndexi","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glIndexi(c);
}

static void REGAL_CALL trace_glIndexiv(const GLint *c)
{
  Internal("trace_glIndexiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glIndexiv(c);
}

static void REGAL_CALL trace_glIndexs(GLshort c)
{
  Internal("trace_glIndexs","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glIndexs(c);
}

static void REGAL_CALL trace_glIndexsv(const GLshort *c)
{
  Internal("trace_glIndexsv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glIndexsv(c);
}

static void REGAL_CALL trace_glInitNames(void)
{
  Internal("trace_glInitNames","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glInitNames();
}

static GLboolean REGAL_CALL trace_glIsEnabled(GLenum cap)
{
  Internal("trace_glIsEnabled","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glIsEnabled(cap);
  return ret;
}

static GLboolean REGAL_CALL trace_glIsList(GLuint list)
{
  Internal("trace_glIsList","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glIsList(list);
  return ret;
}

static void REGAL_CALL trace_glLightModelf(GLenum pname, GLfloat param)
{
  Internal("trace_glLightModelf","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glLightModelf(pname, param);
}

static void REGAL_CALL trace_glLightModelfv(GLenum pname, const GLfloat *params)
{
  Internal("trace_glLightModelfv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glLightModelfv(pname, params);
}

static void REGAL_CALL trace_glLightModeli(GLenum pname, GLint param)
{
  Internal("trace_glLightModeli","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glLightModeli(pname, param);
}

static void REGAL_CALL trace_glLightModeliv(GLenum pname, const GLint *params)
{
  Internal("trace_glLightModeliv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glLightModeliv(pname, params);
}

static void REGAL_CALL trace_glLightf(GLenum light, GLenum pname, GLfloat param)
{
  Internal("trace_glLightf","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glLightf(light, pname, param);
}

static void REGAL_CALL trace_glLightfv(GLenum light, GLenum pname, const GLfloat *params)
{
  Internal("trace_glLightfv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glLightfv(light, pname, params);
}

static void REGAL_CALL trace_glLighti(GLenum light, GLenum pname, GLint param)
{
  Internal("trace_glLighti","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glLighti(light, pname, param);
}

static void REGAL_CALL trace_glLightiv(GLenum light, GLenum pname, const GLint *params)
{
  Internal("trace_glLightiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glLightiv(light, pname, params);
}

static void REGAL_CALL trace_glLineStipple(GLint factor, GLushort pattern)
{
  Internal("trace_glLineStipple","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glLineStipple(factor, pattern);
}

static void REGAL_CALL trace_glLineWidth(GLfloat width)
{
  Internal("trace_glLineWidth","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glLineWidth(width);
}

static void REGAL_CALL trace_glListBase(GLuint base)
{
  Internal("trace_glListBase","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glListBase(base);
}

static void REGAL_CALL trace_glLoadIdentity(void)
{
  Internal("trace_glLoadIdentity","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glLoadIdentity();
}

static void REGAL_CALL trace_glLoadMatrixd(const GLdouble *m)
{
  Internal("trace_glLoadMatrixd","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glLoadMatrixd(m);
}

static void REGAL_CALL trace_glLoadMatrixf(const GLfloat *m)
{
  Internal("trace_glLoadMatrixf","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glLoadMatrixf(m);
}

static void REGAL_CALL trace_glLoadName(GLuint name)
{
  Internal("trace_glLoadName","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glLoadName(name);
}

static void REGAL_CALL trace_glLogicOp(GLenum opcode)
{
  Internal("trace_glLogicOp","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glLogicOp(opcode);
}

static void REGAL_CALL trace_glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points)
{
  Internal("trace_glMap1d","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMap1d(target, u1, u2, stride, order, points);
}

static void REGAL_CALL trace_glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points)
{
  Internal("trace_glMap1f","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMap1f(target, u1, u2, stride, order, points);
}

static void REGAL_CALL trace_glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points)
{
  Internal("trace_glMap2d","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMap2d(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
}

static void REGAL_CALL trace_glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points)
{
  Internal("trace_glMap2f","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMap2f(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
}

static void REGAL_CALL trace_glMapGrid1d(GLint un, GLdouble u1, GLdouble u2)
{
  Internal("trace_glMapGrid1d","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMapGrid1d(un, u1, u2);
}

static void REGAL_CALL trace_glMapGrid1f(GLint un, GLfloat u1, GLfloat u2)
{
  Internal("trace_glMapGrid1f","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMapGrid1f(un, u1, u2);
}

static void REGAL_CALL trace_glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2)
{
  Internal("trace_glMapGrid2d","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMapGrid2d(un, u1, u2, vn, v1, v2);
}

static void REGAL_CALL trace_glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2)
{
  Internal("trace_glMapGrid2f","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMapGrid2f(un, u1, u2, vn, v1, v2);
}

static void REGAL_CALL trace_glMaterialf(GLenum face, GLenum pname, GLfloat param)
{
  Internal("trace_glMaterialf","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMaterialf(face, pname, param);
}

static void REGAL_CALL trace_glMaterialfv(GLenum face, GLenum pname, const GLfloat *params)
{
  Internal("trace_glMaterialfv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMaterialfv(face, pname, params);
}

static void REGAL_CALL trace_glMateriali(GLenum face, GLenum pname, GLint param)
{
  Internal("trace_glMateriali","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMateriali(face, pname, param);
}

static void REGAL_CALL trace_glMaterialiv(GLenum face, GLenum pname, const GLint *params)
{
  Internal("trace_glMaterialiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMaterialiv(face, pname, params);
}

static void REGAL_CALL trace_glMatrixMode(GLenum mode)
{
  Internal("trace_glMatrixMode","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMatrixMode(mode);
}

static void REGAL_CALL trace_glMultMatrixd(const GLdouble *m)
{
  Internal("trace_glMultMatrixd","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultMatrixd(m);
}

static void REGAL_CALL trace_glMultMatrixf(const GLfloat *m)
{
  Internal("trace_glMultMatrixf","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultMatrixf(m);
}

static void REGAL_CALL trace_glNewList(GLuint list, GLenum mode)
{
  Internal("trace_glNewList","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNewList(list, mode);
}

static void REGAL_CALL trace_glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz)
{
  Internal("trace_glNormal3b","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNormal3b(nx, ny, nz);
}

static void REGAL_CALL trace_glNormal3bv(const GLbyte *v)
{
  Internal("trace_glNormal3bv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNormal3bv(v);
}

static void REGAL_CALL trace_glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz)
{
  Internal("trace_glNormal3d","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNormal3d(nx, ny, nz);
}

static void REGAL_CALL trace_glNormal3dv(const GLdouble *v)
{
  Internal("trace_glNormal3dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNormal3dv(v);
}

static void REGAL_CALL trace_glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz)
{
  Internal("trace_glNormal3f","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNormal3f(nx, ny, nz);
}

static void REGAL_CALL trace_glNormal3fv(const GLfloat *v)
{
  Internal("trace_glNormal3fv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNormal3fv(v);
}

static void REGAL_CALL trace_glNormal3i(GLint nx, GLint ny, GLint nz)
{
  Internal("trace_glNormal3i","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNormal3i(nx, ny, nz);
}

static void REGAL_CALL trace_glNormal3iv(const GLint *v)
{
  Internal("trace_glNormal3iv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNormal3iv(v);
}

static void REGAL_CALL trace_glNormal3s(GLshort nx, GLshort ny, GLshort nz)
{
  Internal("trace_glNormal3s","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNormal3s(nx, ny, nz);
}

static void REGAL_CALL trace_glNormal3sv(const GLshort *v)
{
  Internal("trace_glNormal3sv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNormal3sv(v);
}

static void REGAL_CALL trace_glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
{
  Internal("trace_glOrtho","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glOrtho(left, right, bottom, top, zNear, zFar);
}

static void REGAL_CALL trace_glPassThrough(GLfloat token)
{
  Internal("trace_glPassThrough","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPassThrough(token);
}

static void REGAL_CALL trace_glPixelMapfv(GLenum map, GLsizei mapsize, const GLfloat *values)
{
  Internal("trace_glPixelMapfv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPixelMapfv(map, mapsize, values);
}

static void REGAL_CALL trace_glPixelMapuiv(GLenum map, GLsizei mapsize, const GLuint *values)
{
  Internal("trace_glPixelMapuiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPixelMapuiv(map, mapsize, values);
}

static void REGAL_CALL trace_glPixelMapusv(GLenum map, GLsizei mapsize, const GLushort *values)
{
  Internal("trace_glPixelMapusv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPixelMapusv(map, mapsize, values);
}

static void REGAL_CALL trace_glPixelStoref(GLenum pname, GLfloat param)
{
  Internal("trace_glPixelStoref","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPixelStoref(pname, param);
}

static void REGAL_CALL trace_glPixelStorei(GLenum pname, GLint param)
{
  Internal("trace_glPixelStorei","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPixelStorei(pname, param);
}

static void REGAL_CALL trace_glPixelTransferf(GLenum pname, GLfloat param)
{
  Internal("trace_glPixelTransferf","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPixelTransferf(pname, param);
}

static void REGAL_CALL trace_glPixelTransferi(GLenum pname, GLint param)
{
  Internal("trace_glPixelTransferi","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPixelTransferi(pname, param);
}

static void REGAL_CALL trace_glPixelZoom(GLfloat xfactor, GLfloat yfactor)
{
  Internal("trace_glPixelZoom","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPixelZoom(xfactor, yfactor);
}

static void REGAL_CALL trace_glPointSize(GLfloat size)
{
  Internal("trace_glPointSize","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPointSize(size);
}

static void REGAL_CALL trace_glPolygonMode(GLenum face, GLenum mode)
{
  Internal("trace_glPolygonMode","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPolygonMode(face, mode);
}

static void REGAL_CALL trace_glPolygonStipple(const GLubyte *mask)
{
  Internal("trace_glPolygonStipple","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPolygonStipple(mask);
}

static void REGAL_CALL trace_glPopAttrib(void)
{
  Internal("trace_glPopAttrib","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPopAttrib();
}

static void REGAL_CALL trace_glPopMatrix(void)
{
  Internal("trace_glPopMatrix","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPopMatrix();
}

static void REGAL_CALL trace_glPopName(void)
{
  Internal("trace_glPopName","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPopName();
}

static void REGAL_CALL trace_glPushAttrib(GLbitfield mask)
{
  Internal("trace_glPushAttrib","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPushAttrib(mask);
}

static void REGAL_CALL trace_glPushMatrix(void)
{
  Internal("trace_glPushMatrix","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPushMatrix();
}

static void REGAL_CALL trace_glPushName(GLuint name)
{
  Internal("trace_glPushName","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPushName(name);
}

static void REGAL_CALL trace_glRasterPos2d(GLdouble x, GLdouble y)
{
  Internal("trace_glRasterPos2d","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glRasterPos2d(x, y);
}

static void REGAL_CALL trace_glRasterPos2dv(const GLdouble *v)
{
  Internal("trace_glRasterPos2dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glRasterPos2dv(v);
}

static void REGAL_CALL trace_glRasterPos2f(GLfloat x, GLfloat y)
{
  Internal("trace_glRasterPos2f","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glRasterPos2f(x, y);
}

static void REGAL_CALL trace_glRasterPos2fv(const GLfloat *v)
{
  Internal("trace_glRasterPos2fv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glRasterPos2fv(v);
}

static void REGAL_CALL trace_glRasterPos2i(GLint x, GLint y)
{
  Internal("trace_glRasterPos2i","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glRasterPos2i(x, y);
}

static void REGAL_CALL trace_glRasterPos2iv(const GLint *v)
{
  Internal("trace_glRasterPos2iv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glRasterPos2iv(v);
}

static void REGAL_CALL trace_glRasterPos2s(GLshort x, GLshort y)
{
  Internal("trace_glRasterPos2s","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glRasterPos2s(x, y);
}

static void REGAL_CALL trace_glRasterPos2sv(const GLshort *v)
{
  Internal("trace_glRasterPos2sv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glRasterPos2sv(v);
}

static void REGAL_CALL trace_glRasterPos3d(GLdouble x, GLdouble y, GLdouble z)
{
  Internal("trace_glRasterPos3d","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glRasterPos3d(x, y, z);
}

static void REGAL_CALL trace_glRasterPos3dv(const GLdouble *v)
{
  Internal("trace_glRasterPos3dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glRasterPos3dv(v);
}

static void REGAL_CALL trace_glRasterPos3f(GLfloat x, GLfloat y, GLfloat z)
{
  Internal("trace_glRasterPos3f","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glRasterPos3f(x, y, z);
}

static void REGAL_CALL trace_glRasterPos3fv(const GLfloat *v)
{
  Internal("trace_glRasterPos3fv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glRasterPos3fv(v);
}

static void REGAL_CALL trace_glRasterPos3i(GLint x, GLint y, GLint z)
{
  Internal("trace_glRasterPos3i","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glRasterPos3i(x, y, z);
}

static void REGAL_CALL trace_glRasterPos3iv(const GLint *v)
{
  Internal("trace_glRasterPos3iv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glRasterPos3iv(v);
}

static void REGAL_CALL trace_glRasterPos3s(GLshort x, GLshort y, GLshort z)
{
  Internal("trace_glRasterPos3s","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glRasterPos3s(x, y, z);
}

static void REGAL_CALL trace_glRasterPos3sv(const GLshort *v)
{
  Internal("trace_glRasterPos3sv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glRasterPos3sv(v);
}

static void REGAL_CALL trace_glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  Internal("trace_glRasterPos4d","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glRasterPos4d(x, y, z, w);
}

static void REGAL_CALL trace_glRasterPos4dv(const GLdouble *v)
{
  Internal("trace_glRasterPos4dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glRasterPos4dv(v);
}

static void REGAL_CALL trace_glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  Internal("trace_glRasterPos4f","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glRasterPos4f(x, y, z, w);
}

static void REGAL_CALL trace_glRasterPos4fv(const GLfloat *v)
{
  Internal("trace_glRasterPos4fv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glRasterPos4fv(v);
}

static void REGAL_CALL trace_glRasterPos4i(GLint x, GLint y, GLint z, GLint w)
{
  Internal("trace_glRasterPos4i","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glRasterPos4i(x, y, z, w);
}

static void REGAL_CALL trace_glRasterPos4iv(const GLint *v)
{
  Internal("trace_glRasterPos4iv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glRasterPos4iv(v);
}

static void REGAL_CALL trace_glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w)
{
  Internal("trace_glRasterPos4s","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glRasterPos4s(x, y, z, w);
}

static void REGAL_CALL trace_glRasterPos4sv(const GLshort *v)
{
  Internal("trace_glRasterPos4sv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glRasterPos4sv(v);
}

static void REGAL_CALL trace_glReadBuffer(GLenum mode)
{
  Internal("trace_glReadBuffer","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glReadBuffer(mode);
}

static void REGAL_CALL trace_glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels)
{
  Internal("trace_glReadPixels","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glReadPixels(x, y, width, height, format, type, pixels);
}

static void REGAL_CALL trace_glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2)
{
  Internal("trace_glRectd","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glRectd(x1, y1, x2, y2);
}

static void REGAL_CALL trace_glRectdv(const GLdouble *v1, const GLdouble *v2)
{
  Internal("trace_glRectdv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glRectdv(v1, v2);
}

static void REGAL_CALL trace_glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2)
{
  Internal("trace_glRectf","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glRectf(x1, y1, x2, y2);
}

static void REGAL_CALL trace_glRectfv(const GLfloat *v1, const GLfloat *v2)
{
  Internal("trace_glRectfv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glRectfv(v1, v2);
}

static void REGAL_CALL trace_glRecti(GLint x1, GLint y1, GLint x2, GLint y2)
{
  Internal("trace_glRecti","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glRecti(x1, y1, x2, y2);
}

static void REGAL_CALL trace_glRectiv(const GLint *v1, const GLint *v2)
{
  Internal("trace_glRectiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glRectiv(v1, v2);
}

static void REGAL_CALL trace_glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2)
{
  Internal("trace_glRects","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glRects(x1, y1, x2, y2);
}

static void REGAL_CALL trace_glRectsv(const GLshort *v1, const GLshort *v2)
{
  Internal("trace_glRectsv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glRectsv(v1, v2);
}

static GLint REGAL_CALL trace_glRenderMode(GLenum mode)
{
  Internal("trace_glRenderMode","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLint  ret = Trace::glRenderMode(mode);
  return ret;
}

static void REGAL_CALL trace_glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z)
{
  Internal("trace_glRotated","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glRotated(angle, x, y, z);
}

static void REGAL_CALL trace_glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z)
{
  Internal("trace_glRotatef","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glRotatef(angle, x, y, z);
}

static void REGAL_CALL trace_glScaled(GLdouble x, GLdouble y, GLdouble z)
{
  Internal("trace_glScaled","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glScaled(x, y, z);
}

static void REGAL_CALL trace_glScalef(GLfloat x, GLfloat y, GLfloat z)
{
  Internal("trace_glScalef","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glScalef(x, y, z);
}

static void REGAL_CALL trace_glScissor(GLint x, GLint y, GLsizei width, GLsizei height)
{
  Internal("trace_glScissor","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glScissor(x, y, width, height);
}

static void REGAL_CALL trace_glSelectBuffer(GLsizei size, GLuint *buffer)
{
  Internal("trace_glSelectBuffer","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSelectBuffer(size, buffer);
}

static void REGAL_CALL trace_glShadeModel(GLenum mode)
{
  Internal("trace_glShadeModel","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glShadeModel(mode);
}

static void REGAL_CALL trace_glStencilFunc(GLenum func, GLint ref, GLuint mask)
{
  Internal("trace_glStencilFunc","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glStencilFunc(func, ref, mask);
}

static void REGAL_CALL trace_glStencilMask(GLuint mask)
{
  Internal("trace_glStencilMask","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glStencilMask(mask);
}

static void REGAL_CALL trace_glStencilOp(GLenum fail, GLenum zfail, GLenum zpass)
{
  Internal("trace_glStencilOp","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glStencilOp(fail, zfail, zpass);
}

static void REGAL_CALL trace_glTexCoord1d(GLdouble s)
{
  Internal("trace_glTexCoord1d","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord1d(s);
}

static void REGAL_CALL trace_glTexCoord1dv(const GLdouble *v)
{
  Internal("trace_glTexCoord1dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord1dv(v);
}

static void REGAL_CALL trace_glTexCoord1f(GLfloat s)
{
  Internal("trace_glTexCoord1f","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord1f(s);
}

static void REGAL_CALL trace_glTexCoord1fv(const GLfloat *v)
{
  Internal("trace_glTexCoord1fv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord1fv(v);
}

static void REGAL_CALL trace_glTexCoord1i(GLint s)
{
  Internal("trace_glTexCoord1i","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord1i(s);
}

static void REGAL_CALL trace_glTexCoord1iv(const GLint *v)
{
  Internal("trace_glTexCoord1iv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord1iv(v);
}

static void REGAL_CALL trace_glTexCoord1s(GLshort s)
{
  Internal("trace_glTexCoord1s","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord1s(s);
}

static void REGAL_CALL trace_glTexCoord1sv(const GLshort *v)
{
  Internal("trace_glTexCoord1sv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord1sv(v);
}

static void REGAL_CALL trace_glTexCoord2d(GLdouble s, GLdouble t)
{
  Internal("trace_glTexCoord2d","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord2d(s, t);
}

static void REGAL_CALL trace_glTexCoord2dv(const GLdouble *v)
{
  Internal("trace_glTexCoord2dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord2dv(v);
}

static void REGAL_CALL trace_glTexCoord2f(GLfloat s, GLfloat t)
{
  Internal("trace_glTexCoord2f","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord2f(s, t);
}

static void REGAL_CALL trace_glTexCoord2fv(const GLfloat *v)
{
  Internal("trace_glTexCoord2fv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord2fv(v);
}

static void REGAL_CALL trace_glTexCoord2i(GLint s, GLint t)
{
  Internal("trace_glTexCoord2i","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord2i(s, t);
}

static void REGAL_CALL trace_glTexCoord2iv(const GLint *v)
{
  Internal("trace_glTexCoord2iv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord2iv(v);
}

static void REGAL_CALL trace_glTexCoord2s(GLshort s, GLshort t)
{
  Internal("trace_glTexCoord2s","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord2s(s, t);
}

static void REGAL_CALL trace_glTexCoord2sv(const GLshort *v)
{
  Internal("trace_glTexCoord2sv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord2sv(v);
}

static void REGAL_CALL trace_glTexCoord3d(GLdouble s, GLdouble t, GLdouble r)
{
  Internal("trace_glTexCoord3d","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord3d(s, t, r);
}

static void REGAL_CALL trace_glTexCoord3dv(const GLdouble *v)
{
  Internal("trace_glTexCoord3dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord3dv(v);
}

static void REGAL_CALL trace_glTexCoord3f(GLfloat s, GLfloat t, GLfloat r)
{
  Internal("trace_glTexCoord3f","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord3f(s, t, r);
}

static void REGAL_CALL trace_glTexCoord3fv(const GLfloat *v)
{
  Internal("trace_glTexCoord3fv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord3fv(v);
}

static void REGAL_CALL trace_glTexCoord3i(GLint s, GLint t, GLint r)
{
  Internal("trace_glTexCoord3i","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord3i(s, t, r);
}

static void REGAL_CALL trace_glTexCoord3iv(const GLint *v)
{
  Internal("trace_glTexCoord3iv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord3iv(v);
}

static void REGAL_CALL trace_glTexCoord3s(GLshort s, GLshort t, GLshort r)
{
  Internal("trace_glTexCoord3s","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord3s(s, t, r);
}

static void REGAL_CALL trace_glTexCoord3sv(const GLshort *v)
{
  Internal("trace_glTexCoord3sv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord3sv(v);
}

static void REGAL_CALL trace_glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q)
{
  Internal("trace_glTexCoord4d","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord4d(s, t, r, q);
}

static void REGAL_CALL trace_glTexCoord4dv(const GLdouble *v)
{
  Internal("trace_glTexCoord4dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord4dv(v);
}

static void REGAL_CALL trace_glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q)
{
  Internal("trace_glTexCoord4f","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord4f(s, t, r, q);
}

static void REGAL_CALL trace_glTexCoord4fv(const GLfloat *v)
{
  Internal("trace_glTexCoord4fv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord4fv(v);
}

static void REGAL_CALL trace_glTexCoord4i(GLint s, GLint t, GLint r, GLint q)
{
  Internal("trace_glTexCoord4i","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord4i(s, t, r, q);
}

static void REGAL_CALL trace_glTexCoord4iv(const GLint *v)
{
  Internal("trace_glTexCoord4iv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord4iv(v);
}

static void REGAL_CALL trace_glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q)
{
  Internal("trace_glTexCoord4s","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord4s(s, t, r, q);
}

static void REGAL_CALL trace_glTexCoord4sv(const GLshort *v)
{
  Internal("trace_glTexCoord4sv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord4sv(v);
}

static void REGAL_CALL trace_glTexEnvf(GLenum target, GLenum pname, GLfloat param)
{
  Internal("trace_glTexEnvf","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexEnvf(target, pname, param);
}

static void REGAL_CALL trace_glTexEnvfv(GLenum target, GLenum pname, const GLfloat *params)
{
  Internal("trace_glTexEnvfv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexEnvfv(target, pname, params);
}

static void REGAL_CALL trace_glTexEnvi(GLenum target, GLenum pname, GLint param)
{
  Internal("trace_glTexEnvi","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexEnvi(target, pname, param);
}

static void REGAL_CALL trace_glTexEnviv(GLenum target, GLenum pname, const GLint *params)
{
  Internal("trace_glTexEnviv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexEnviv(target, pname, params);
}

static void REGAL_CALL trace_glTexGend(GLenum coord, GLenum pname, GLdouble param)
{
  Internal("trace_glTexGend","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexGend(coord, pname, param);
}

static void REGAL_CALL trace_glTexGendv(GLenum coord, GLenum pname, const GLdouble *params)
{
  Internal("trace_glTexGendv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexGendv(coord, pname, params);
}

static void REGAL_CALL trace_glTexGenf(GLenum coord, GLenum pname, GLfloat param)
{
  Internal("trace_glTexGenf","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexGenf(coord, pname, param);
}

static void REGAL_CALL trace_glTexGenfv(GLenum coord, GLenum pname, const GLfloat *params)
{
  Internal("trace_glTexGenfv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexGenfv(coord, pname, params);
}

static void REGAL_CALL trace_glTexGeni(GLenum coord, GLenum pname, GLint param)
{
  Internal("trace_glTexGeni","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexGeni(coord, pname, param);
}

static void REGAL_CALL trace_glTexGeniv(GLenum coord, GLenum pname, const GLint *params)
{
  Internal("trace_glTexGeniv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexGeniv(coord, pname, params);
}

static void REGAL_CALL trace_glTexImage1D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
  Internal("trace_glTexImage1D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexImage1D(target, level, internalformat, width, border, format, type, pixels);
}

static void REGAL_CALL trace_glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
  Internal("trace_glTexImage2D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexImage2D(target, level, internalformat, width, height, border, format, type, pixels);
}

static void REGAL_CALL trace_glTexParameterf(GLenum target, GLenum pname, GLfloat param)
{
  Internal("trace_glTexParameterf","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexParameterf(target, pname, param);
}

static void REGAL_CALL trace_glTexParameterfv(GLenum target, GLenum pname, const GLfloat *params)
{
  Internal("trace_glTexParameterfv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexParameterfv(target, pname, params);
}

static void REGAL_CALL trace_glTexParameteri(GLenum target, GLenum pname, GLint param)
{
  Internal("trace_glTexParameteri","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexParameteri(target, pname, param);
}

static void REGAL_CALL trace_glTexParameteriv(GLenum target, GLenum pname, const GLint *params)
{
  Internal("trace_glTexParameteriv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexParameteriv(target, pname, params);
}

static void REGAL_CALL trace_glTranslated(GLdouble x, GLdouble y, GLdouble z)
{
  Internal("trace_glTranslated","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTranslated(x, y, z);
}

static void REGAL_CALL trace_glTranslatef(GLfloat x, GLfloat y, GLfloat z)
{
  Internal("trace_glTranslatef","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTranslatef(x, y, z);
}

static void REGAL_CALL trace_glVertex2d(GLdouble x, GLdouble y)
{
  Internal("trace_glVertex2d","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertex2d(x, y);
}

static void REGAL_CALL trace_glVertex2dv(const GLdouble *v)
{
  Internal("trace_glVertex2dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertex2dv(v);
}

static void REGAL_CALL trace_glVertex2f(GLfloat x, GLfloat y)
{
  Internal("trace_glVertex2f","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertex2f(x, y);
}

static void REGAL_CALL trace_glVertex2fv(const GLfloat *v)
{
  Internal("trace_glVertex2fv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertex2fv(v);
}

static void REGAL_CALL trace_glVertex2i(GLint x, GLint y)
{
  Internal("trace_glVertex2i","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertex2i(x, y);
}

static void REGAL_CALL trace_glVertex2iv(const GLint *v)
{
  Internal("trace_glVertex2iv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertex2iv(v);
}

static void REGAL_CALL trace_glVertex2s(GLshort x, GLshort y)
{
  Internal("trace_glVertex2s","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertex2s(x, y);
}

static void REGAL_CALL trace_glVertex2sv(const GLshort *v)
{
  Internal("trace_glVertex2sv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertex2sv(v);
}

static void REGAL_CALL trace_glVertex3d(GLdouble x, GLdouble y, GLdouble z)
{
  Internal("trace_glVertex3d","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertex3d(x, y, z);
}

static void REGAL_CALL trace_glVertex3dv(const GLdouble *v)
{
  Internal("trace_glVertex3dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertex3dv(v);
}

static void REGAL_CALL trace_glVertex3f(GLfloat x, GLfloat y, GLfloat z)
{
  Internal("trace_glVertex3f","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertex3f(x, y, z);
}

static void REGAL_CALL trace_glVertex3fv(const GLfloat *v)
{
  Internal("trace_glVertex3fv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertex3fv(v);
}

static void REGAL_CALL trace_glVertex3i(GLint x, GLint y, GLint z)
{
  Internal("trace_glVertex3i","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertex3i(x, y, z);
}

static void REGAL_CALL trace_glVertex3iv(const GLint *v)
{
  Internal("trace_glVertex3iv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertex3iv(v);
}

static void REGAL_CALL trace_glVertex3s(GLshort x, GLshort y, GLshort z)
{
  Internal("trace_glVertex3s","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertex3s(x, y, z);
}

static void REGAL_CALL trace_glVertex3sv(const GLshort *v)
{
  Internal("trace_glVertex3sv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertex3sv(v);
}

static void REGAL_CALL trace_glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  Internal("trace_glVertex4d","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertex4d(x, y, z, w);
}

static void REGAL_CALL trace_glVertex4dv(const GLdouble *v)
{
  Internal("trace_glVertex4dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertex4dv(v);
}

static void REGAL_CALL trace_glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  Internal("trace_glVertex4f","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertex4f(x, y, z, w);
}

static void REGAL_CALL trace_glVertex4fv(const GLfloat *v)
{
  Internal("trace_glVertex4fv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertex4fv(v);
}

static void REGAL_CALL trace_glVertex4i(GLint x, GLint y, GLint z, GLint w)
{
  Internal("trace_glVertex4i","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertex4i(x, y, z, w);
}

static void REGAL_CALL trace_glVertex4iv(const GLint *v)
{
  Internal("trace_glVertex4iv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertex4iv(v);
}

static void REGAL_CALL trace_glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w)
{
  Internal("trace_glVertex4s","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertex4s(x, y, z, w);
}

static void REGAL_CALL trace_glVertex4sv(const GLshort *v)
{
  Internal("trace_glVertex4sv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertex4sv(v);
}

static void REGAL_CALL trace_glViewport(GLint x, GLint y, GLsizei width, GLsizei height)
{
  Internal("trace_glViewport","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glViewport(x, y, width, height);
}

// GL_VERSION_1_1

static GLboolean REGAL_CALL trace_glAreTexturesResident(GLsizei n, const GLuint *textures, GLboolean *residences)
{
  Internal("trace_glAreTexturesResident","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glAreTexturesResident(n, textures, residences);
  return ret;
}

static void REGAL_CALL trace_glArrayElement(GLint index)
{
  Internal("trace_glArrayElement","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glArrayElement(index);
}

static void REGAL_CALL trace_glBindTexture(GLenum target, GLuint texture)
{
  Internal("trace_glBindTexture","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBindTexture(target, texture);
}

static void REGAL_CALL trace_glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
  Internal("trace_glColorPointer","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColorPointer(size, type, stride, pointer);
}

static void REGAL_CALL trace_glCopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
{
  Internal("trace_glCopyTexImage1D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCopyTexImage1D(target, level, internalformat, x, y, width, border);
}

static void REGAL_CALL trace_glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
{
  Internal("trace_glCopyTexImage2D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCopyTexImage2D(target, level, internalformat, x, y, width, height, border);
}

static void REGAL_CALL trace_glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
{
  Internal("trace_glCopyTexSubImage1D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCopyTexSubImage1D(target, level, xoffset, x, y, width);
}

static void REGAL_CALL trace_glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
  Internal("trace_glCopyTexSubImage2D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
}

static void REGAL_CALL trace_glDeleteTextures(GLsizei n, const GLuint *textures)
{
  Internal("trace_glDeleteTextures","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDeleteTextures(n, textures);
}

static void REGAL_CALL trace_glDisableClientState(GLenum cap)
{
  Internal("trace_glDisableClientState","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDisableClientState(cap);
}

static void REGAL_CALL trace_glDrawArrays(GLenum mode, GLint first, GLsizei count)
{
  Internal("trace_glDrawArrays","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDrawArrays(mode, first, count);
}

static void REGAL_CALL trace_glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)
{
  Internal("trace_glDrawElements","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDrawElements(mode, count, type, indices);
}

static void REGAL_CALL trace_glEdgeFlagPointer(GLsizei stride, const GLvoid *pointer)
{
  Internal("trace_glEdgeFlagPointer","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glEdgeFlagPointer(stride, pointer);
}

static void REGAL_CALL trace_glEnableClientState(GLenum cap)
{
  Internal("trace_glEnableClientState","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glEnableClientState(cap);
}

static void REGAL_CALL trace_glGenTextures(GLsizei n, GLuint *textures)
{
  Internal("trace_glGenTextures","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGenTextures(n, textures);
}

static void REGAL_CALL trace_glGetPointerv(GLenum pname, GLvoid **params)
{
  Internal("trace_glGetPointerv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetPointerv(pname, params);
}

static void REGAL_CALL trace_glIndexPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
{
  Internal("trace_glIndexPointer","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glIndexPointer(type, stride, pointer);
}

static void REGAL_CALL trace_glIndexub(GLubyte c)
{
  Internal("trace_glIndexub","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glIndexub(c);
}

static void REGAL_CALL trace_glIndexubv(const GLubyte *c)
{
  Internal("trace_glIndexubv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glIndexubv(c);
}

static void REGAL_CALL trace_glInterleavedArrays(GLenum format, GLsizei stride, const GLvoid *pointer)
{
  Internal("trace_glInterleavedArrays","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glInterleavedArrays(format, stride, pointer);
}

static GLboolean REGAL_CALL trace_glIsTexture(GLuint texture)
{
  Internal("trace_glIsTexture","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glIsTexture(texture);
  return ret;
}

static void REGAL_CALL trace_glNormalPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
{
  Internal("trace_glNormalPointer","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNormalPointer(type, stride, pointer);
}

static void REGAL_CALL trace_glPolygonOffset(GLfloat factor, GLfloat units)
{
  Internal("trace_glPolygonOffset","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPolygonOffset(factor, units);
}

static void REGAL_CALL trace_glPopClientAttrib(void)
{
  Internal("trace_glPopClientAttrib","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPopClientAttrib();
}

static void REGAL_CALL trace_glPrioritizeTextures(GLsizei n, const GLuint *textures, const GLclampf *priorities)
{
  Internal("trace_glPrioritizeTextures","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPrioritizeTextures(n, textures, priorities);
}

static void REGAL_CALL trace_glPushClientAttrib(GLbitfield mask)
{
  Internal("trace_glPushClientAttrib","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPushClientAttrib(mask);
}

static void REGAL_CALL trace_glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
  Internal("trace_glTexCoordPointer","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoordPointer(size, type, stride, pointer);
}

static void REGAL_CALL trace_glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
{
  Internal("trace_glTexSubImage1D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexSubImage1D(target, level, xoffset, width, format, type, pixels);
}

static void REGAL_CALL trace_glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
{
  Internal("trace_glTexSubImage2D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels);
}

static void REGAL_CALL trace_glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
  Internal("trace_glVertexPointer","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexPointer(size, type, stride, pointer);
}

// GL_VERSION_1_2

static void REGAL_CALL trace_glBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
{
  Internal("trace_glBlendColor","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBlendColor(red, green, blue, alpha);
}

static void REGAL_CALL trace_glBlendEquation(GLenum mode)
{
  Internal("trace_glBlendEquation","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBlendEquation(mode);
}

static void REGAL_CALL trace_glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
  Internal("trace_glCopyTexSubImage3D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCopyTexSubImage3D(target, level, xoffset, yoffset, zoffset, x, y, width, height);
}

static void REGAL_CALL trace_glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices)
{
  Internal("trace_glDrawRangeElements","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDrawRangeElements(mode, start, end, count, type, indices);
}

static void REGAL_CALL trace_glTexImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
  Internal("trace_glTexImage3D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexImage3D(target, level, internalformat, width, height, depth, border, format, type, pixels);
}

static void REGAL_CALL trace_glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
{
  Internal("trace_glTexSubImage3D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
}

// GL_VERSION_1_3

static void REGAL_CALL trace_glActiveTexture(GLenum texture)
{
  Internal("trace_glActiveTexture","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glActiveTexture(texture);
}

static void REGAL_CALL trace_glClientActiveTexture(GLenum texture)
{
  Internal("trace_glClientActiveTexture","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glClientActiveTexture(texture);
}

static void REGAL_CALL trace_glCompressedTexImage1D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data)
{
  Internal("trace_glCompressedTexImage1D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCompressedTexImage1D(target, level, internalformat, width, border, imageSize, data);
}

static void REGAL_CALL trace_glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data)
{
  Internal("trace_glCompressedTexImage2D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data);
}

static void REGAL_CALL trace_glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data)
{
  Internal("trace_glCompressedTexImage3D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCompressedTexImage3D(target, level, internalformat, width, height, depth, border, imageSize, data);
}

static void REGAL_CALL trace_glCompressedTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data)
{
  Internal("trace_glCompressedTexSubImage1D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCompressedTexSubImage1D(target, level, xoffset, width, format, imageSize, data);
}

static void REGAL_CALL trace_glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data)
{
  Internal("trace_glCompressedTexSubImage2D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data);
}

static void REGAL_CALL trace_glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data)
{
  Internal("trace_glCompressedTexSubImage3D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCompressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
}

static void REGAL_CALL trace_glGetCompressedTexImage(GLenum target, GLint lod, GLvoid *img)
{
  Internal("trace_glGetCompressedTexImage","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetCompressedTexImage(target, lod, img);
}

static void REGAL_CALL trace_glLoadTransposeMatrixd(const GLdouble *m)
{
  Internal("trace_glLoadTransposeMatrixd","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glLoadTransposeMatrixd(m);
}

static void REGAL_CALL trace_glLoadTransposeMatrixf(const GLfloat *m)
{
  Internal("trace_glLoadTransposeMatrixf","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glLoadTransposeMatrixf(m);
}

static void REGAL_CALL trace_glMultTransposeMatrixd(const GLdouble *m)
{
  Internal("trace_glMultTransposeMatrixd","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultTransposeMatrixd(m);
}

static void REGAL_CALL trace_glMultTransposeMatrixf(const GLfloat *m)
{
  Internal("trace_glMultTransposeMatrixf","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultTransposeMatrixf(m);
}

static void REGAL_CALL trace_glMultiTexCoord1d(GLenum target, GLdouble s)
{
  Internal("trace_glMultiTexCoord1d","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord1d(target, s);
}

static void REGAL_CALL trace_glMultiTexCoord1dv(GLenum target, const GLdouble *v)
{
  Internal("trace_glMultiTexCoord1dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord1dv(target, v);
}

static void REGAL_CALL trace_glMultiTexCoord1f(GLenum target, GLfloat s)
{
  Internal("trace_glMultiTexCoord1f","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord1f(target, s);
}

static void REGAL_CALL trace_glMultiTexCoord1fv(GLenum target, const GLfloat *v)
{
  Internal("trace_glMultiTexCoord1fv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord1fv(target, v);
}

static void REGAL_CALL trace_glMultiTexCoord1i(GLenum target, GLint s)
{
  Internal("trace_glMultiTexCoord1i","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord1i(target, s);
}

static void REGAL_CALL trace_glMultiTexCoord1iv(GLenum target, const GLint *v)
{
  Internal("trace_glMultiTexCoord1iv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord1iv(target, v);
}

static void REGAL_CALL trace_glMultiTexCoord1s(GLenum target, GLshort s)
{
  Internal("trace_glMultiTexCoord1s","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord1s(target, s);
}

static void REGAL_CALL trace_glMultiTexCoord1sv(GLenum target, const GLshort *v)
{
  Internal("trace_glMultiTexCoord1sv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord1sv(target, v);
}

static void REGAL_CALL trace_glMultiTexCoord2d(GLenum target, GLdouble s, GLdouble t)
{
  Internal("trace_glMultiTexCoord2d","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord2d(target, s, t);
}

static void REGAL_CALL trace_glMultiTexCoord2dv(GLenum target, const GLdouble *v)
{
  Internal("trace_glMultiTexCoord2dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord2dv(target, v);
}

static void REGAL_CALL trace_glMultiTexCoord2f(GLenum target, GLfloat s, GLfloat t)
{
  Internal("trace_glMultiTexCoord2f","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord2f(target, s, t);
}

static void REGAL_CALL trace_glMultiTexCoord2fv(GLenum target, const GLfloat *v)
{
  Internal("trace_glMultiTexCoord2fv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord2fv(target, v);
}

static void REGAL_CALL trace_glMultiTexCoord2i(GLenum target, GLint s, GLint t)
{
  Internal("trace_glMultiTexCoord2i","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord2i(target, s, t);
}

static void REGAL_CALL trace_glMultiTexCoord2iv(GLenum target, const GLint *v)
{
  Internal("trace_glMultiTexCoord2iv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord2iv(target, v);
}

static void REGAL_CALL trace_glMultiTexCoord2s(GLenum target, GLshort s, GLshort t)
{
  Internal("trace_glMultiTexCoord2s","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord2s(target, s, t);
}

static void REGAL_CALL trace_glMultiTexCoord2sv(GLenum target, const GLshort *v)
{
  Internal("trace_glMultiTexCoord2sv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord2sv(target, v);
}

static void REGAL_CALL trace_glMultiTexCoord3d(GLenum target, GLdouble s, GLdouble t, GLdouble r)
{
  Internal("trace_glMultiTexCoord3d","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord3d(target, s, t, r);
}

static void REGAL_CALL trace_glMultiTexCoord3dv(GLenum target, const GLdouble *v)
{
  Internal("trace_glMultiTexCoord3dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord3dv(target, v);
}

static void REGAL_CALL trace_glMultiTexCoord3f(GLenum target, GLfloat s, GLfloat t, GLfloat r)
{
  Internal("trace_glMultiTexCoord3f","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord3f(target, s, t, r);
}

static void REGAL_CALL trace_glMultiTexCoord3fv(GLenum target, const GLfloat *v)
{
  Internal("trace_glMultiTexCoord3fv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord3fv(target, v);
}

static void REGAL_CALL trace_glMultiTexCoord3i(GLenum target, GLint s, GLint t, GLint r)
{
  Internal("trace_glMultiTexCoord3i","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord3i(target, s, t, r);
}

static void REGAL_CALL trace_glMultiTexCoord3iv(GLenum target, const GLint *v)
{
  Internal("trace_glMultiTexCoord3iv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord3iv(target, v);
}

static void REGAL_CALL trace_glMultiTexCoord3s(GLenum target, GLshort s, GLshort t, GLshort r)
{
  Internal("trace_glMultiTexCoord3s","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord3s(target, s, t, r);
}

static void REGAL_CALL trace_glMultiTexCoord3sv(GLenum target, const GLshort *v)
{
  Internal("trace_glMultiTexCoord3sv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord3sv(target, v);
}

static void REGAL_CALL trace_glMultiTexCoord4d(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
{
  Internal("trace_glMultiTexCoord4d","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord4d(target, s, t, r, q);
}

static void REGAL_CALL trace_glMultiTexCoord4dv(GLenum target, const GLdouble *v)
{
  Internal("trace_glMultiTexCoord4dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord4dv(target, v);
}

static void REGAL_CALL trace_glMultiTexCoord4f(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
{
  Internal("trace_glMultiTexCoord4f","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord4f(target, s, t, r, q);
}

static void REGAL_CALL trace_glMultiTexCoord4fv(GLenum target, const GLfloat *v)
{
  Internal("trace_glMultiTexCoord4fv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord4fv(target, v);
}

static void REGAL_CALL trace_glMultiTexCoord4i(GLenum target, GLint s, GLint t, GLint r, GLint q)
{
  Internal("trace_glMultiTexCoord4i","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord4i(target, s, t, r, q);
}

static void REGAL_CALL trace_glMultiTexCoord4iv(GLenum target, const GLint *v)
{
  Internal("trace_glMultiTexCoord4iv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord4iv(target, v);
}

static void REGAL_CALL trace_glMultiTexCoord4s(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
{
  Internal("trace_glMultiTexCoord4s","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord4s(target, s, t, r, q);
}

static void REGAL_CALL trace_glMultiTexCoord4sv(GLenum target, const GLshort *v)
{
  Internal("trace_glMultiTexCoord4sv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord4sv(target, v);
}

static void REGAL_CALL trace_glSampleCoverage(GLclampf value, GLboolean invert)
{
  Internal("trace_glSampleCoverage","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSampleCoverage(value, invert);
}

// GL_VERSION_1_4

static void REGAL_CALL trace_glBlendFuncSeparate(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)
{
  Internal("trace_glBlendFuncSeparate","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBlendFuncSeparate(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
}

static void REGAL_CALL trace_glFogCoordPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
{
  Internal("trace_glFogCoordPointer","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFogCoordPointer(type, stride, pointer);
}

static void REGAL_CALL trace_glFogCoordd(GLdouble coord)
{
  Internal("trace_glFogCoordd","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFogCoordd(coord);
}

static void REGAL_CALL trace_glFogCoorddv(const GLdouble *coord)
{
  Internal("trace_glFogCoorddv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFogCoorddv(coord);
}

static void REGAL_CALL trace_glFogCoordf(GLfloat coord)
{
  Internal("trace_glFogCoordf","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFogCoordf(coord);
}

static void REGAL_CALL trace_glFogCoordfv(const GLfloat *coord)
{
  Internal("trace_glFogCoordfv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFogCoordfv(coord);
}

static void REGAL_CALL trace_glMultiDrawArrays(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount)
{
  Internal("trace_glMultiDrawArrays","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiDrawArrays(mode, first, count, primcount);
}

static void REGAL_CALL trace_glMultiDrawElements(GLenum mode, const GLsizei *count, GLenum type, const GLvoid * const *indices, GLsizei primcount)
{
  Internal("trace_glMultiDrawElements","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiDrawElements(mode, count, type, indices, primcount);
}

static void REGAL_CALL trace_glPointParameterf(GLenum pname, GLfloat param)
{
  Internal("trace_glPointParameterf","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPointParameterf(pname, param);
}

static void REGAL_CALL trace_glPointParameterfv(GLenum pname, const GLfloat *params)
{
  Internal("trace_glPointParameterfv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPointParameterfv(pname, params);
}

static void REGAL_CALL trace_glPointParameteri(GLenum pname, GLint param)
{
  Internal("trace_glPointParameteri","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPointParameteri(pname, param);
}

static void REGAL_CALL trace_glPointParameteriv(GLenum pname, const GLint *params)
{
  Internal("trace_glPointParameteriv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPointParameteriv(pname, params);
}

static void REGAL_CALL trace_glSecondaryColor3b(GLbyte red, GLbyte green, GLbyte blue)
{
  Internal("trace_glSecondaryColor3b","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSecondaryColor3b(red, green, blue);
}

static void REGAL_CALL trace_glSecondaryColor3bv(const GLbyte *v)
{
  Internal("trace_glSecondaryColor3bv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSecondaryColor3bv(v);
}

static void REGAL_CALL trace_glSecondaryColor3d(GLdouble red, GLdouble green, GLdouble blue)
{
  Internal("trace_glSecondaryColor3d","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSecondaryColor3d(red, green, blue);
}

static void REGAL_CALL trace_glSecondaryColor3dv(const GLdouble *v)
{
  Internal("trace_glSecondaryColor3dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSecondaryColor3dv(v);
}

static void REGAL_CALL trace_glSecondaryColor3f(GLfloat red, GLfloat green, GLfloat blue)
{
  Internal("trace_glSecondaryColor3f","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSecondaryColor3f(red, green, blue);
}

static void REGAL_CALL trace_glSecondaryColor3fv(const GLfloat *v)
{
  Internal("trace_glSecondaryColor3fv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSecondaryColor3fv(v);
}

static void REGAL_CALL trace_glSecondaryColor3i(GLint red, GLint green, GLint blue)
{
  Internal("trace_glSecondaryColor3i","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSecondaryColor3i(red, green, blue);
}

static void REGAL_CALL trace_glSecondaryColor3iv(const GLint *v)
{
  Internal("trace_glSecondaryColor3iv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSecondaryColor3iv(v);
}

static void REGAL_CALL trace_glSecondaryColor3s(GLshort red, GLshort green, GLshort blue)
{
  Internal("trace_glSecondaryColor3s","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSecondaryColor3s(red, green, blue);
}

static void REGAL_CALL trace_glSecondaryColor3sv(const GLshort *v)
{
  Internal("trace_glSecondaryColor3sv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSecondaryColor3sv(v);
}

static void REGAL_CALL trace_glSecondaryColor3ub(GLubyte red, GLubyte green, GLubyte blue)
{
  Internal("trace_glSecondaryColor3ub","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSecondaryColor3ub(red, green, blue);
}

static void REGAL_CALL trace_glSecondaryColor3ubv(const GLubyte *v)
{
  Internal("trace_glSecondaryColor3ubv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSecondaryColor3ubv(v);
}

static void REGAL_CALL trace_glSecondaryColor3ui(GLuint red, GLuint green, GLuint blue)
{
  Internal("trace_glSecondaryColor3ui","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSecondaryColor3ui(red, green, blue);
}

static void REGAL_CALL trace_glSecondaryColor3uiv(const GLuint *v)
{
  Internal("trace_glSecondaryColor3uiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSecondaryColor3uiv(v);
}

static void REGAL_CALL trace_glSecondaryColor3us(GLushort red, GLushort green, GLushort blue)
{
  Internal("trace_glSecondaryColor3us","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSecondaryColor3us(red, green, blue);
}

static void REGAL_CALL trace_glSecondaryColor3usv(const GLushort *v)
{
  Internal("trace_glSecondaryColor3usv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSecondaryColor3usv(v);
}

static void REGAL_CALL trace_glSecondaryColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
  Internal("trace_glSecondaryColorPointer","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSecondaryColorPointer(size, type, stride, pointer);
}

static void REGAL_CALL trace_glWindowPos2d(GLdouble x, GLdouble y)
{
  Internal("trace_glWindowPos2d","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos2d(x, y);
}

static void REGAL_CALL trace_glWindowPos2dv(const GLdouble *p)
{
  Internal("trace_glWindowPos2dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos2dv(p);
}

static void REGAL_CALL trace_glWindowPos2f(GLfloat x, GLfloat y)
{
  Internal("trace_glWindowPos2f","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos2f(x, y);
}

static void REGAL_CALL trace_glWindowPos2fv(const GLfloat *p)
{
  Internal("trace_glWindowPos2fv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos2fv(p);
}

static void REGAL_CALL trace_glWindowPos2i(GLint x, GLint y)
{
  Internal("trace_glWindowPos2i","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos2i(x, y);
}

static void REGAL_CALL trace_glWindowPos2iv(const GLint *p)
{
  Internal("trace_glWindowPos2iv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos2iv(p);
}

static void REGAL_CALL trace_glWindowPos2s(GLshort x, GLshort y)
{
  Internal("trace_glWindowPos2s","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos2s(x, y);
}

static void REGAL_CALL trace_glWindowPos2sv(const GLshort *p)
{
  Internal("trace_glWindowPos2sv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos2sv(p);
}

static void REGAL_CALL trace_glWindowPos3d(GLdouble x, GLdouble y, GLdouble z)
{
  Internal("trace_glWindowPos3d","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos3d(x, y, z);
}

static void REGAL_CALL trace_glWindowPos3dv(const GLdouble *p)
{
  Internal("trace_glWindowPos3dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos3dv(p);
}

static void REGAL_CALL trace_glWindowPos3f(GLfloat x, GLfloat y, GLfloat z)
{
  Internal("trace_glWindowPos3f","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos3f(x, y, z);
}

static void REGAL_CALL trace_glWindowPos3fv(const GLfloat *p)
{
  Internal("trace_glWindowPos3fv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos3fv(p);
}

static void REGAL_CALL trace_glWindowPos3i(GLint x, GLint y, GLint z)
{
  Internal("trace_glWindowPos3i","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos3i(x, y, z);
}

static void REGAL_CALL trace_glWindowPos3iv(const GLint *p)
{
  Internal("trace_glWindowPos3iv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos3iv(p);
}

static void REGAL_CALL trace_glWindowPos3s(GLshort x, GLshort y, GLshort z)
{
  Internal("trace_glWindowPos3s","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos3s(x, y, z);
}

static void REGAL_CALL trace_glWindowPos3sv(const GLshort *p)
{
  Internal("trace_glWindowPos3sv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos3sv(p);
}

// GL_VERSION_1_5

static void REGAL_CALL trace_glBeginQuery(GLenum target, GLuint id)
{
  Internal("trace_glBeginQuery","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBeginQuery(target, id);
}

static void REGAL_CALL trace_glBindBuffer(GLenum target, GLuint buffer)
{
  Internal("trace_glBindBuffer","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBindBuffer(target, buffer);
}

static void REGAL_CALL trace_glBufferData(GLenum target, GLsizeiptr size, const GLvoid *data, GLenum usage)
{
  Internal("trace_glBufferData","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBufferData(target, size, data, usage);
}

static void REGAL_CALL trace_glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *data)
{
  Internal("trace_glBufferSubData","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBufferSubData(target, offset, size, data);
}

static void REGAL_CALL trace_glDeleteBuffers(GLsizei n, const GLuint *buffers)
{
  Internal("trace_glDeleteBuffers","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDeleteBuffers(n, buffers);
}

static void REGAL_CALL trace_glDeleteQueries(GLsizei n, const GLuint *ids)
{
  Internal("trace_glDeleteQueries","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDeleteQueries(n, ids);
}

static void REGAL_CALL trace_glEndQuery(GLenum target)
{
  Internal("trace_glEndQuery","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glEndQuery(target);
}

static void REGAL_CALL trace_glGenBuffers(GLsizei n, GLuint *buffers)
{
  Internal("trace_glGenBuffers","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGenBuffers(n, buffers);
}

static void REGAL_CALL trace_glGenQueries(GLsizei n, GLuint *ids)
{
  Internal("trace_glGenQueries","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGenQueries(n, ids);
}

static void REGAL_CALL trace_glGetBufferParameteriv(GLenum target, GLenum pname, GLint *params)
{
  Internal("trace_glGetBufferParameteriv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetBufferParameteriv(target, pname, params);
}

static void REGAL_CALL trace_glGetBufferPointerv(GLenum target, GLenum pname, GLvoid **params)
{
  Internal("trace_glGetBufferPointerv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetBufferPointerv(target, pname, params);
}

static void REGAL_CALL trace_glGetBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, GLvoid *data)
{
  Internal("trace_glGetBufferSubData","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetBufferSubData(target, offset, size, data);
}

static void REGAL_CALL trace_glGetQueryObjectiv(GLuint id, GLenum pname, GLint *params)
{
  Internal("trace_glGetQueryObjectiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetQueryObjectiv(id, pname, params);
}

static void REGAL_CALL trace_glGetQueryObjectuiv(GLuint id, GLenum pname, GLuint *params)
{
  Internal("trace_glGetQueryObjectuiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetQueryObjectuiv(id, pname, params);
}

static void REGAL_CALL trace_glGetQueryiv(GLenum target, GLenum pname, GLint *params)
{
  Internal("trace_glGetQueryiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetQueryiv(target, pname, params);
}

static GLboolean REGAL_CALL trace_glIsBuffer(GLuint buffer)
{
  Internal("trace_glIsBuffer","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glIsBuffer(buffer);
  return ret;
}

static GLboolean REGAL_CALL trace_glIsQuery(GLuint id)
{
  Internal("trace_glIsQuery","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glIsQuery(id);
  return ret;
}

static GLvoid *REGAL_CALL trace_glMapBuffer(GLenum target, GLenum access)
{
  Internal("trace_glMapBuffer","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLvoid * ret = Trace::glMapBuffer(target, access);
  return ret;
}

static GLboolean REGAL_CALL trace_glUnmapBuffer(GLenum target)
{
  Internal("trace_glUnmapBuffer","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glUnmapBuffer(target);
  return ret;
}

// GL_VERSION_2_0

static void REGAL_CALL trace_glAttachShader(GLuint program, GLuint shader)
{
  Internal("trace_glAttachShader","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glAttachShader(program, shader);
}

static void REGAL_CALL trace_glBindAttribLocation(GLuint program, GLuint index, const GLchar *name)
{
  Internal("trace_glBindAttribLocation","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBindAttribLocation(program, index, name);
}

static void REGAL_CALL trace_glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha)
{
  Internal("trace_glBlendEquationSeparate","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBlendEquationSeparate(modeRGB, modeAlpha);
}

static void REGAL_CALL trace_glCompileShader(GLuint shader)
{
  Internal("trace_glCompileShader","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCompileShader(shader);
}

static GLuint REGAL_CALL trace_glCreateProgram(void)
{
  Internal("trace_glCreateProgram","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLuint  ret = Trace::glCreateProgram();
  return ret;
}

static GLuint REGAL_CALL trace_glCreateShader(GLenum type)
{
  Internal("trace_glCreateShader","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLuint  ret = Trace::glCreateShader(type);
  return ret;
}

static void REGAL_CALL trace_glDeleteProgram(GLuint program)
{
  Internal("trace_glDeleteProgram","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDeleteProgram(program);
}

static void REGAL_CALL trace_glDeleteShader(GLuint shader)
{
  Internal("trace_glDeleteShader","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDeleteShader(shader);
}

static void REGAL_CALL trace_glDetachShader(GLuint program, GLuint shader)
{
  Internal("trace_glDetachShader","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDetachShader(program, shader);
}

static void REGAL_CALL trace_glDisableVertexAttribArray(GLuint index)
{
  Internal("trace_glDisableVertexAttribArray","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDisableVertexAttribArray(index);
}

static void REGAL_CALL trace_glDrawBuffers(GLsizei n, const GLenum *bufs)
{
  Internal("trace_glDrawBuffers","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDrawBuffers(n, bufs);
}

static void REGAL_CALL trace_glEnableVertexAttribArray(GLuint index)
{
  Internal("trace_glEnableVertexAttribArray","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glEnableVertexAttribArray(index);
}

static void REGAL_CALL trace_glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name)
{
  Internal("trace_glGetActiveAttrib","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetActiveAttrib(program, index, bufSize, length, size, type, name);
}

static void REGAL_CALL trace_glGetActiveUniform(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name)
{
  Internal("trace_glGetActiveUniform","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetActiveUniform(program, index, bufSize, length, size, type, name);
}

static void REGAL_CALL trace_glGetAttachedShaders(GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders)
{
  Internal("trace_glGetAttachedShaders","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetAttachedShaders(program, maxCount, count, shaders);
}

static GLint REGAL_CALL trace_glGetAttribLocation(GLuint program, const GLchar *name)
{
  Internal("trace_glGetAttribLocation","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLint  ret = Trace::glGetAttribLocation(program, name);
  return ret;
}

static void REGAL_CALL trace_glGetProgramInfoLog(GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog)
{
  Internal("trace_glGetProgramInfoLog","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetProgramInfoLog(program, bufSize, length, infoLog);
}

static void REGAL_CALL trace_glGetProgramiv(GLuint program, GLenum pname, GLint *params)
{
  Internal("trace_glGetProgramiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetProgramiv(program, pname, params);
}

static void REGAL_CALL trace_glGetShaderInfoLog(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog)
{
  Internal("trace_glGetShaderInfoLog","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetShaderInfoLog(shader, bufSize, length, infoLog);
}

static void REGAL_CALL trace_glGetShaderSource(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source)
{
  Internal("trace_glGetShaderSource","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetShaderSource(shader, bufSize, length, source);
}

static void REGAL_CALL trace_glGetShaderiv(GLuint shader, GLenum pname, GLint *params)
{
  Internal("trace_glGetShaderiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetShaderiv(shader, pname, params);
}

static GLint REGAL_CALL trace_glGetUniformLocation(GLuint program, const GLchar *name)
{
  Internal("trace_glGetUniformLocation","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLint  ret = Trace::glGetUniformLocation(program, name);
  return ret;
}

static void REGAL_CALL trace_glGetUniformfv(GLuint program, GLint location, GLfloat *params)
{
  Internal("trace_glGetUniformfv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetUniformfv(program, location, params);
}

static void REGAL_CALL trace_glGetUniformiv(GLuint program, GLint location, GLint *params)
{
  Internal("trace_glGetUniformiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetUniformiv(program, location, params);
}

static void REGAL_CALL trace_glGetVertexAttribPointerv(GLuint index, GLenum pname, GLvoid **pointer)
{
  Internal("trace_glGetVertexAttribPointerv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetVertexAttribPointerv(index, pname, pointer);
}

static void REGAL_CALL trace_glGetVertexAttribdv(GLuint index, GLenum pname, GLdouble *params)
{
  Internal("trace_glGetVertexAttribdv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetVertexAttribdv(index, pname, params);
}

static void REGAL_CALL trace_glGetVertexAttribfv(GLuint index, GLenum pname, GLfloat *params)
{
  Internal("trace_glGetVertexAttribfv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetVertexAttribfv(index, pname, params);
}

static void REGAL_CALL trace_glGetVertexAttribiv(GLuint index, GLenum pname, GLint *params)
{
  Internal("trace_glGetVertexAttribiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetVertexAttribiv(index, pname, params);
}

static GLboolean REGAL_CALL trace_glIsProgram(GLuint program)
{
  Internal("trace_glIsProgram","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glIsProgram(program);
  return ret;
}

static GLboolean REGAL_CALL trace_glIsShader(GLuint shader)
{
  Internal("trace_glIsShader","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glIsShader(shader);
  return ret;
}

static void REGAL_CALL trace_glLinkProgram(GLuint program)
{
  Internal("trace_glLinkProgram","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glLinkProgram(program);
}

static void REGAL_CALL trace_glShaderSource(GLuint shader, GLsizei count, const GLchar * const *string, const GLint *length)
{
  Internal("trace_glShaderSource","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glShaderSource(shader, count, string, length);
}

static void REGAL_CALL trace_glStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask)
{
  Internal("trace_glStencilFuncSeparate","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glStencilFuncSeparate(face, func, ref, mask);
}

static void REGAL_CALL trace_glStencilMaskSeparate(GLenum face, GLuint mask)
{
  Internal("trace_glStencilMaskSeparate","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glStencilMaskSeparate(face, mask);
}

static void REGAL_CALL trace_glStencilOpSeparate(GLenum face, GLenum fail, GLenum zfail, GLenum zpass)
{
  Internal("trace_glStencilOpSeparate","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glStencilOpSeparate(face, fail, zfail, zpass);
}

static void REGAL_CALL trace_glUniform1f(GLint location, GLfloat v0)
{
  Internal("trace_glUniform1f","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform1f(location, v0);
}

static void REGAL_CALL trace_glUniform1fv(GLint location, GLsizei count, const GLfloat *value)
{
  Internal("trace_glUniform1fv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform1fv(location, count, value);
}

static void REGAL_CALL trace_glUniform1i(GLint location, GLint v0)
{
  Internal("trace_glUniform1i","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform1i(location, v0);
}

static void REGAL_CALL trace_glUniform1iv(GLint location, GLsizei count, const GLint *value)
{
  Internal("trace_glUniform1iv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform1iv(location, count, value);
}

static void REGAL_CALL trace_glUniform2f(GLint location, GLfloat v0, GLfloat v1)
{
  Internal("trace_glUniform2f","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform2f(location, v0, v1);
}

static void REGAL_CALL trace_glUniform2fv(GLint location, GLsizei count, const GLfloat *value)
{
  Internal("trace_glUniform2fv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform2fv(location, count, value);
}

static void REGAL_CALL trace_glUniform2i(GLint location, GLint v0, GLint v1)
{
  Internal("trace_glUniform2i","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform2i(location, v0, v1);
}

static void REGAL_CALL trace_glUniform2iv(GLint location, GLsizei count, const GLint *value)
{
  Internal("trace_glUniform2iv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform2iv(location, count, value);
}

static void REGAL_CALL trace_glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
{
  Internal("trace_glUniform3f","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform3f(location, v0, v1, v2);
}

static void REGAL_CALL trace_glUniform3fv(GLint location, GLsizei count, const GLfloat *value)
{
  Internal("trace_glUniform3fv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform3fv(location, count, value);
}

static void REGAL_CALL trace_glUniform3i(GLint location, GLint v0, GLint v1, GLint v2)
{
  Internal("trace_glUniform3i","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform3i(location, v0, v1, v2);
}

static void REGAL_CALL trace_glUniform3iv(GLint location, GLsizei count, const GLint *value)
{
  Internal("trace_glUniform3iv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform3iv(location, count, value);
}

static void REGAL_CALL trace_glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
{
  Internal("trace_glUniform4f","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform4f(location, v0, v1, v2, v3);
}

static void REGAL_CALL trace_glUniform4fv(GLint location, GLsizei count, const GLfloat *value)
{
  Internal("trace_glUniform4fv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform4fv(location, count, value);
}

static void REGAL_CALL trace_glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
{
  Internal("trace_glUniform4i","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform4i(location, v0, v1, v2, v3);
}

static void REGAL_CALL trace_glUniform4iv(GLint location, GLsizei count, const GLint *value)
{
  Internal("trace_glUniform4iv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform4iv(location, count, value);
}

static void REGAL_CALL trace_glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  Internal("trace_glUniformMatrix2fv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniformMatrix2fv(location, count, transpose, value);
}

static void REGAL_CALL trace_glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  Internal("trace_glUniformMatrix3fv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniformMatrix3fv(location, count, transpose, value);
}

static void REGAL_CALL trace_glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  Internal("trace_glUniformMatrix4fv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniformMatrix4fv(location, count, transpose, value);
}

static void REGAL_CALL trace_glUseProgram(GLuint program)
{
  Internal("trace_glUseProgram","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUseProgram(program);
}

static void REGAL_CALL trace_glValidateProgram(GLuint program)
{
  Internal("trace_glValidateProgram","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glValidateProgram(program);
}

static void REGAL_CALL trace_glVertexAttrib1d(GLuint index, GLdouble x)
{
  Internal("trace_glVertexAttrib1d","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib1d(index, x);
}

static void REGAL_CALL trace_glVertexAttrib1dv(GLuint index, const GLdouble *v)
{
  Internal("trace_glVertexAttrib1dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib1dv(index, v);
}

static void REGAL_CALL trace_glVertexAttrib1f(GLuint index, GLfloat x)
{
  Internal("trace_glVertexAttrib1f","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib1f(index, x);
}

static void REGAL_CALL trace_glVertexAttrib1fv(GLuint index, const GLfloat *v)
{
  Internal("trace_glVertexAttrib1fv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib1fv(index, v);
}

static void REGAL_CALL trace_glVertexAttrib1s(GLuint index, GLshort x)
{
  Internal("trace_glVertexAttrib1s","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib1s(index, x);
}

static void REGAL_CALL trace_glVertexAttrib1sv(GLuint index, const GLshort *v)
{
  Internal("trace_glVertexAttrib1sv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib1sv(index, v);
}

static void REGAL_CALL trace_glVertexAttrib2d(GLuint index, GLdouble x, GLdouble y)
{
  Internal("trace_glVertexAttrib2d","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib2d(index, x, y);
}

static void REGAL_CALL trace_glVertexAttrib2dv(GLuint index, const GLdouble *v)
{
  Internal("trace_glVertexAttrib2dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib2dv(index, v);
}

static void REGAL_CALL trace_glVertexAttrib2f(GLuint index, GLfloat x, GLfloat y)
{
  Internal("trace_glVertexAttrib2f","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib2f(index, x, y);
}

static void REGAL_CALL trace_glVertexAttrib2fv(GLuint index, const GLfloat *v)
{
  Internal("trace_glVertexAttrib2fv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib2fv(index, v);
}

static void REGAL_CALL trace_glVertexAttrib2s(GLuint index, GLshort x, GLshort y)
{
  Internal("trace_glVertexAttrib2s","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib2s(index, x, y);
}

static void REGAL_CALL trace_glVertexAttrib2sv(GLuint index, const GLshort *v)
{
  Internal("trace_glVertexAttrib2sv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib2sv(index, v);
}

static void REGAL_CALL trace_glVertexAttrib3d(GLuint index, GLdouble x, GLdouble y, GLdouble z)
{
  Internal("trace_glVertexAttrib3d","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib3d(index, x, y, z);
}

static void REGAL_CALL trace_glVertexAttrib3dv(GLuint index, const GLdouble *v)
{
  Internal("trace_glVertexAttrib3dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib3dv(index, v);
}

static void REGAL_CALL trace_glVertexAttrib3f(GLuint index, GLfloat x, GLfloat y, GLfloat z)
{
  Internal("trace_glVertexAttrib3f","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib3f(index, x, y, z);
}

static void REGAL_CALL trace_glVertexAttrib3fv(GLuint index, const GLfloat *v)
{
  Internal("trace_glVertexAttrib3fv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib3fv(index, v);
}

static void REGAL_CALL trace_glVertexAttrib3s(GLuint index, GLshort x, GLshort y, GLshort z)
{
  Internal("trace_glVertexAttrib3s","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib3s(index, x, y, z);
}

static void REGAL_CALL trace_glVertexAttrib3sv(GLuint index, const GLshort *v)
{
  Internal("trace_glVertexAttrib3sv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib3sv(index, v);
}

static void REGAL_CALL trace_glVertexAttrib4Nbv(GLuint index, const GLbyte *v)
{
  Internal("trace_glVertexAttrib4Nbv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib4Nbv(index, v);
}

static void REGAL_CALL trace_glVertexAttrib4Niv(GLuint index, const GLint *v)
{
  Internal("trace_glVertexAttrib4Niv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib4Niv(index, v);
}

static void REGAL_CALL trace_glVertexAttrib4Nsv(GLuint index, const GLshort *v)
{
  Internal("trace_glVertexAttrib4Nsv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib4Nsv(index, v);
}

static void REGAL_CALL trace_glVertexAttrib4Nub(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
{
  Internal("trace_glVertexAttrib4Nub","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib4Nub(index, x, y, z, w);
}

static void REGAL_CALL trace_glVertexAttrib4Nubv(GLuint index, const GLubyte *v)
{
  Internal("trace_glVertexAttrib4Nubv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib4Nubv(index, v);
}

static void REGAL_CALL trace_glVertexAttrib4Nuiv(GLuint index, const GLuint *v)
{
  Internal("trace_glVertexAttrib4Nuiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib4Nuiv(index, v);
}

static void REGAL_CALL trace_glVertexAttrib4Nusv(GLuint index, const GLushort *v)
{
  Internal("trace_glVertexAttrib4Nusv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib4Nusv(index, v);
}

static void REGAL_CALL trace_glVertexAttrib4bv(GLuint index, const GLbyte *v)
{
  Internal("trace_glVertexAttrib4bv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib4bv(index, v);
}

static void REGAL_CALL trace_glVertexAttrib4d(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  Internal("trace_glVertexAttrib4d","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib4d(index, x, y, z, w);
}

static void REGAL_CALL trace_glVertexAttrib4dv(GLuint index, const GLdouble *v)
{
  Internal("trace_glVertexAttrib4dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib4dv(index, v);
}

static void REGAL_CALL trace_glVertexAttrib4f(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  Internal("trace_glVertexAttrib4f","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib4f(index, x, y, z, w);
}

static void REGAL_CALL trace_glVertexAttrib4fv(GLuint index, const GLfloat *v)
{
  Internal("trace_glVertexAttrib4fv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib4fv(index, v);
}

static void REGAL_CALL trace_glVertexAttrib4iv(GLuint index, const GLint *v)
{
  Internal("trace_glVertexAttrib4iv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib4iv(index, v);
}

static void REGAL_CALL trace_glVertexAttrib4s(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
{
  Internal("trace_glVertexAttrib4s","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib4s(index, x, y, z, w);
}

static void REGAL_CALL trace_glVertexAttrib4sv(GLuint index, const GLshort *v)
{
  Internal("trace_glVertexAttrib4sv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib4sv(index, v);
}

static void REGAL_CALL trace_glVertexAttrib4ubv(GLuint index, const GLubyte *v)
{
  Internal("trace_glVertexAttrib4ubv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib4ubv(index, v);
}

static void REGAL_CALL trace_glVertexAttrib4uiv(GLuint index, const GLuint *v)
{
  Internal("trace_glVertexAttrib4uiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib4uiv(index, v);
}

static void REGAL_CALL trace_glVertexAttrib4usv(GLuint index, const GLushort *v)
{
  Internal("trace_glVertexAttrib4usv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib4usv(index, v);
}

static void REGAL_CALL trace_glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer)
{
  Internal("trace_glVertexAttribPointer","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribPointer(index, size, type, normalized, stride, pointer);
}

// GL_VERSION_2_1

static void REGAL_CALL trace_glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  Internal("trace_glUniformMatrix2x3fv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniformMatrix2x3fv(location, count, transpose, value);
}

static void REGAL_CALL trace_glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  Internal("trace_glUniformMatrix2x4fv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniformMatrix2x4fv(location, count, transpose, value);
}

static void REGAL_CALL trace_glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  Internal("trace_glUniformMatrix3x2fv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniformMatrix3x2fv(location, count, transpose, value);
}

static void REGAL_CALL trace_glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  Internal("trace_glUniformMatrix3x4fv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniformMatrix3x4fv(location, count, transpose, value);
}

static void REGAL_CALL trace_glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  Internal("trace_glUniformMatrix4x2fv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniformMatrix4x2fv(location, count, transpose, value);
}

static void REGAL_CALL trace_glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  Internal("trace_glUniformMatrix4x3fv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniformMatrix4x3fv(location, count, transpose, value);
}

// GL_VERSION_3_0

static void REGAL_CALL trace_glBeginConditionalRender(GLuint id, GLenum mode)
{
  Internal("trace_glBeginConditionalRender","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBeginConditionalRender(id, mode);
}

static void REGAL_CALL trace_glBeginTransformFeedback(GLenum primitiveMode)
{
  Internal("trace_glBeginTransformFeedback","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBeginTransformFeedback(primitiveMode);
}

static void REGAL_CALL trace_glBindFragDataLocation(GLuint program, GLuint color, const GLchar *name)
{
  Internal("trace_glBindFragDataLocation","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBindFragDataLocation(program, color, name);
}

static void REGAL_CALL trace_glClampColor(GLenum target, GLenum clamp)
{
  Internal("trace_glClampColor","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glClampColor(target, clamp);
}

static void REGAL_CALL trace_glClearBufferfi(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil)
{
  Internal("trace_glClearBufferfi","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glClearBufferfi(buffer, drawbuffer, depth, stencil);
}

static void REGAL_CALL trace_glClearBufferfv(GLenum buffer, GLint drawbuffer, const GLfloat *value)
{
  Internal("trace_glClearBufferfv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glClearBufferfv(buffer, drawbuffer, value);
}

static void REGAL_CALL trace_glClearBufferiv(GLenum buffer, GLint drawbuffer, const GLint *value)
{
  Internal("trace_glClearBufferiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glClearBufferiv(buffer, drawbuffer, value);
}

static void REGAL_CALL trace_glClearBufferuiv(GLenum buffer, GLint drawbuffer, const GLuint *value)
{
  Internal("trace_glClearBufferuiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glClearBufferuiv(buffer, drawbuffer, value);
}

static void REGAL_CALL trace_glColorMaski(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a)
{
  Internal("trace_glColorMaski","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColorMaski(index, r, g, b, a);
}

static void REGAL_CALL trace_glDisablei(GLenum cap, GLuint index)
{
  Internal("trace_glDisablei","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDisablei(cap, index);
}

static void REGAL_CALL trace_glEnablei(GLenum cap, GLuint index)
{
  Internal("trace_glEnablei","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glEnablei(cap, index);
}

static void REGAL_CALL trace_glEndConditionalRender(void)
{
  Internal("trace_glEndConditionalRender","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glEndConditionalRender();
}

static void REGAL_CALL trace_glEndTransformFeedback(void)
{
  Internal("trace_glEndTransformFeedback","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glEndTransformFeedback();
}

static void REGAL_CALL trace_glGetBooleani_v(GLenum target, GLuint index, GLboolean *data)
{
  Internal("trace_glGetBooleani_v","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetBooleani_v(target, index, data);
}

static GLint REGAL_CALL trace_glGetFragDataLocation(GLuint program, const GLchar *name)
{
  Internal("trace_glGetFragDataLocation","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLint  ret = Trace::glGetFragDataLocation(program, name);
  return ret;
}

static const GLubyte *REGAL_CALL trace_glGetStringi(GLenum name, GLuint index)
{
  Internal("trace_glGetStringi","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  const GLubyte * ret = Trace::glGetStringi(name, index);
  return ret;
}

static void REGAL_CALL trace_glGetTexParameterIiv(GLenum target, GLenum pname, GLint *params)
{
  Internal("trace_glGetTexParameterIiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetTexParameterIiv(target, pname, params);
}

static void REGAL_CALL trace_glGetTexParameterIuiv(GLenum target, GLenum pname, GLuint *params)
{
  Internal("trace_glGetTexParameterIuiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetTexParameterIuiv(target, pname, params);
}

static void REGAL_CALL trace_glGetTransformFeedbackVarying(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name)
{
  Internal("trace_glGetTransformFeedbackVarying","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetTransformFeedbackVarying(program, index, bufSize, length, size, type, name);
}

static void REGAL_CALL trace_glGetUniformuiv(GLuint program, GLint location, GLuint *params)
{
  Internal("trace_glGetUniformuiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetUniformuiv(program, location, params);
}

static void REGAL_CALL trace_glGetVertexAttribIiv(GLuint index, GLenum pname, GLint *params)
{
  Internal("trace_glGetVertexAttribIiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetVertexAttribIiv(index, pname, params);
}

static void REGAL_CALL trace_glGetVertexAttribIuiv(GLuint index, GLenum pname, GLuint *params)
{
  Internal("trace_glGetVertexAttribIuiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetVertexAttribIuiv(index, pname, params);
}

static GLboolean REGAL_CALL trace_glIsEnabledi(GLenum target, GLuint index)
{
  Internal("trace_glIsEnabledi","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glIsEnabledi(target, index);
  return ret;
}

static void REGAL_CALL trace_glTexParameterIiv(GLenum target, GLenum pname, const GLint *params)
{
  Internal("trace_glTexParameterIiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexParameterIiv(target, pname, params);
}

static void REGAL_CALL trace_glTexParameterIuiv(GLenum target, GLenum pname, const GLuint *params)
{
  Internal("trace_glTexParameterIuiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexParameterIuiv(target, pname, params);
}

static void REGAL_CALL trace_glTransformFeedbackVaryings(GLuint program, GLsizei count, const GLchar * const *varyings, GLenum bufferMode)
{
  Internal("trace_glTransformFeedbackVaryings","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTransformFeedbackVaryings(program, count, varyings, bufferMode);
}

static void REGAL_CALL trace_glUniform1ui(GLint location, GLuint v0)
{
  Internal("trace_glUniform1ui","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform1ui(location, v0);
}

static void REGAL_CALL trace_glUniform1uiv(GLint location, GLsizei count, const GLuint *value)
{
  Internal("trace_glUniform1uiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform1uiv(location, count, value);
}

static void REGAL_CALL trace_glUniform2ui(GLint location, GLuint v0, GLuint v1)
{
  Internal("trace_glUniform2ui","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform2ui(location, v0, v1);
}

static void REGAL_CALL trace_glUniform2uiv(GLint location, GLsizei count, const GLuint *value)
{
  Internal("trace_glUniform2uiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform2uiv(location, count, value);
}

static void REGAL_CALL trace_glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2)
{
  Internal("trace_glUniform3ui","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform3ui(location, v0, v1, v2);
}

static void REGAL_CALL trace_glUniform3uiv(GLint location, GLsizei count, const GLuint *value)
{
  Internal("trace_glUniform3uiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform3uiv(location, count, value);
}

static void REGAL_CALL trace_glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3)
{
  Internal("trace_glUniform4ui","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform4ui(location, v0, v1, v2, v3);
}

static void REGAL_CALL trace_glUniform4uiv(GLint location, GLsizei count, const GLuint *value)
{
  Internal("trace_glUniform4uiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform4uiv(location, count, value);
}

static void REGAL_CALL trace_glVertexAttribI1i(GLuint index, GLint x)
{
  Internal("trace_glVertexAttribI1i","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribI1i(index, x);
}

static void REGAL_CALL trace_glVertexAttribI1iv(GLuint index, const GLint *v)
{
  Internal("trace_glVertexAttribI1iv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribI1iv(index, v);
}

static void REGAL_CALL trace_glVertexAttribI1ui(GLuint index, GLuint x)
{
  Internal("trace_glVertexAttribI1ui","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribI1ui(index, x);
}

static void REGAL_CALL trace_glVertexAttribI1uiv(GLuint index, const GLuint *v)
{
  Internal("trace_glVertexAttribI1uiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribI1uiv(index, v);
}

static void REGAL_CALL trace_glVertexAttribI2i(GLuint index, GLint x, GLint y)
{
  Internal("trace_glVertexAttribI2i","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribI2i(index, x, y);
}

static void REGAL_CALL trace_glVertexAttribI2iv(GLuint index, const GLint *v)
{
  Internal("trace_glVertexAttribI2iv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribI2iv(index, v);
}

static void REGAL_CALL trace_glVertexAttribI2ui(GLuint index, GLuint x, GLuint y)
{
  Internal("trace_glVertexAttribI2ui","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribI2ui(index, x, y);
}

static void REGAL_CALL trace_glVertexAttribI2uiv(GLuint index, const GLuint *v)
{
  Internal("trace_glVertexAttribI2uiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribI2uiv(index, v);
}

static void REGAL_CALL trace_glVertexAttribI3i(GLuint index, GLint x, GLint y, GLint z)
{
  Internal("trace_glVertexAttribI3i","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribI3i(index, x, y, z);
}

static void REGAL_CALL trace_glVertexAttribI3iv(GLuint index, const GLint *v)
{
  Internal("trace_glVertexAttribI3iv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribI3iv(index, v);
}

static void REGAL_CALL trace_glVertexAttribI3ui(GLuint index, GLuint x, GLuint y, GLuint z)
{
  Internal("trace_glVertexAttribI3ui","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribI3ui(index, x, y, z);
}

static void REGAL_CALL trace_glVertexAttribI3uiv(GLuint index, const GLuint *v)
{
  Internal("trace_glVertexAttribI3uiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribI3uiv(index, v);
}

static void REGAL_CALL trace_glVertexAttribI4bv(GLuint index, const GLbyte *v)
{
  Internal("trace_glVertexAttribI4bv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribI4bv(index, v);
}

static void REGAL_CALL trace_glVertexAttribI4i(GLuint index, GLint x, GLint y, GLint z, GLint w)
{
  Internal("trace_glVertexAttribI4i","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribI4i(index, x, y, z, w);
}

static void REGAL_CALL trace_glVertexAttribI4iv(GLuint index, const GLint *v)
{
  Internal("trace_glVertexAttribI4iv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribI4iv(index, v);
}

static void REGAL_CALL trace_glVertexAttribI4sv(GLuint index, const GLshort *v)
{
  Internal("trace_glVertexAttribI4sv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribI4sv(index, v);
}

static void REGAL_CALL trace_glVertexAttribI4ubv(GLuint index, const GLubyte *v)
{
  Internal("trace_glVertexAttribI4ubv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribI4ubv(index, v);
}

static void REGAL_CALL trace_glVertexAttribI4ui(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
{
  Internal("trace_glVertexAttribI4ui","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribI4ui(index, x, y, z, w);
}

static void REGAL_CALL trace_glVertexAttribI4uiv(GLuint index, const GLuint *v)
{
  Internal("trace_glVertexAttribI4uiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribI4uiv(index, v);
}

static void REGAL_CALL trace_glVertexAttribI4usv(GLuint index, const GLushort *v)
{
  Internal("trace_glVertexAttribI4usv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribI4usv(index, v);
}

static void REGAL_CALL trace_glVertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
  Internal("trace_glVertexAttribIPointer","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribIPointer(index, size, type, stride, pointer);
}

// GL_VERSION_3_1

static void REGAL_CALL trace_glDrawArraysInstanced(GLenum mode, GLint start, GLsizei count, GLsizei primcount)
{
  Internal("trace_glDrawArraysInstanced","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDrawArraysInstanced(mode, start, count, primcount);
}

static void REGAL_CALL trace_glDrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount)
{
  Internal("trace_glDrawElementsInstanced","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDrawElementsInstanced(mode, count, type, indices, primcount);
}

static void REGAL_CALL trace_glPrimitiveRestartIndex(GLuint index)
{
  Internal("trace_glPrimitiveRestartIndex","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPrimitiveRestartIndex(index);
}

static void REGAL_CALL trace_glTexBuffer(GLenum target, GLenum internalformat, GLuint buffer)
{
  Internal("trace_glTexBuffer","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexBuffer(target, internalformat, buffer);
}

// GL_VERSION_3_2

static void REGAL_CALL trace_glFramebufferTexture(GLenum target, GLenum attachment, GLuint texture, GLint level)
{
  Internal("trace_glFramebufferTexture","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFramebufferTexture(target, attachment, texture, level);
}

static void REGAL_CALL trace_glGetBufferParameteri64v(GLenum target, GLenum pname, GLint64 *params)
{
  Internal("trace_glGetBufferParameteri64v","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetBufferParameteri64v(target, pname, params);
}

static void REGAL_CALL trace_glGetInteger64i_v(GLenum target, GLuint index, GLint64 *data)
{
  Internal("trace_glGetInteger64i_v","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetInteger64i_v(target, index, data);
}

// GL_VERSION_3_3

static void REGAL_CALL trace_glVertexAttribDivisor(GLuint index, GLuint divisor)
{
  Internal("trace_glVertexAttribDivisor","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribDivisor(index, divisor);
}

// GL_VERSION_4_0

static void REGAL_CALL trace_glBlendEquationSeparatei(GLuint buf, GLenum modeRGB, GLenum modeAlpha)
{
  Internal("trace_glBlendEquationSeparatei","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBlendEquationSeparatei(buf, modeRGB, modeAlpha);
}

static void REGAL_CALL trace_glBlendEquationi(GLuint buf, GLenum mode)
{
  Internal("trace_glBlendEquationi","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBlendEquationi(buf, mode);
}

static void REGAL_CALL trace_glBlendFuncSeparatei(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
{
  Internal("trace_glBlendFuncSeparatei","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBlendFuncSeparatei(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
}

static void REGAL_CALL trace_glBlendFunci(GLuint buf, GLenum src, GLenum dst)
{
  Internal("trace_glBlendFunci","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBlendFunci(buf, src, dst);
}

// GL_3DFX_tbuffer

static void REGAL_CALL trace_glTbufferMask3DFX(GLuint mask)
{
  Internal("trace_glTbufferMask3DFX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTbufferMask3DFX(mask);
}

// GL_AMD_debug_output

static void REGAL_CALL trace_glDebugMessageCallbackAMD(GLDEBUGPROCAMD callback, GLvoid *userParam)
{
  Internal("trace_glDebugMessageCallbackAMD","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDebugMessageCallbackAMD(callback, userParam);
}

static void REGAL_CALL trace_glDebugMessageEnableAMD(GLenum category, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled)
{
  Internal("trace_glDebugMessageEnableAMD","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDebugMessageEnableAMD(category, severity, count, ids, enabled);
}

static void REGAL_CALL trace_glDebugMessageInsertAMD(GLenum category, GLenum severity, GLuint id, GLsizei length, const GLchar *buf)
{
  Internal("trace_glDebugMessageInsertAMD","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDebugMessageInsertAMD(category, severity, id, length, buf);
}

static GLuint REGAL_CALL trace_glGetDebugMessageLogAMD(GLuint count, GLsizei bufsize, GLenum *categories, GLuint *severities, GLuint *ids, GLsizei *lengths, GLchar *message)
{
  Internal("trace_glGetDebugMessageLogAMD","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLuint  ret = Trace::glGetDebugMessageLogAMD(count, bufsize, categories, severities, ids, lengths, message);
  return ret;
}

// GL_AMD_draw_buffers_blend

static void REGAL_CALL trace_glBlendEquationIndexedAMD(GLuint buf, GLenum mode)
{
  Internal("trace_glBlendEquationIndexedAMD","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBlendEquationIndexedAMD(buf, mode);
}

static void REGAL_CALL trace_glBlendEquationSeparateIndexedAMD(GLuint buf, GLenum modeRGB, GLenum modeAlpha)
{
  Internal("trace_glBlendEquationSeparateIndexedAMD","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBlendEquationSeparateIndexedAMD(buf, modeRGB, modeAlpha);
}

static void REGAL_CALL trace_glBlendFuncIndexedAMD(GLuint buf, GLenum src, GLenum dst)
{
  Internal("trace_glBlendFuncIndexedAMD","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBlendFuncIndexedAMD(buf, src, dst);
}

static void REGAL_CALL trace_glBlendFuncSeparateIndexedAMD(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
{
  Internal("trace_glBlendFuncSeparateIndexedAMD","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBlendFuncSeparateIndexedAMD(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
}

// GL_AMD_multi_draw_indirect

static void REGAL_CALL trace_glMultiDrawArraysIndirectAMD(GLenum mode, const GLvoid *indirect, GLsizei primcount, GLsizei stride)
{
  Internal("trace_glMultiDrawArraysIndirectAMD","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiDrawArraysIndirectAMD(mode, indirect, primcount, stride);
}

static void REGAL_CALL trace_glMultiDrawElementsIndirectAMD(GLenum mode, GLenum type, const GLvoid *indirect, GLsizei primcount, GLsizei stride)
{
  Internal("trace_glMultiDrawElementsIndirectAMD","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiDrawElementsIndirectAMD(mode, type, indirect, primcount, stride);
}

// GL_AMD_name_gen_delete

static void REGAL_CALL trace_glDeleteNamesAMD(GLenum identifier, GLuint num, const GLuint *names)
{
  Internal("trace_glDeleteNamesAMD","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDeleteNamesAMD(identifier, num, names);
}

static void REGAL_CALL trace_glGenNamesAMD(GLenum identifier, GLuint num, GLuint *names)
{
  Internal("trace_glGenNamesAMD","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGenNamesAMD(identifier, num, names);
}

static GLboolean REGAL_CALL trace_glIsNameAMD(GLenum identifier, GLuint name)
{
  Internal("trace_glIsNameAMD","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glIsNameAMD(identifier, name);
  return ret;
}

// GL_AMD_performance_monitor

static void REGAL_CALL trace_glBeginPerfMonitorAMD(GLuint monitor)
{
  Internal("trace_glBeginPerfMonitorAMD","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBeginPerfMonitorAMD(monitor);
}

static void REGAL_CALL trace_glDeletePerfMonitorsAMD(GLsizei n, GLuint *monitors)
{
  Internal("trace_glDeletePerfMonitorsAMD","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDeletePerfMonitorsAMD(n, monitors);
}

static void REGAL_CALL trace_glEndPerfMonitorAMD(GLuint monitor)
{
  Internal("trace_glEndPerfMonitorAMD","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glEndPerfMonitorAMD(monitor);
}

static void REGAL_CALL trace_glGenPerfMonitorsAMD(GLsizei n, GLuint *monitors)
{
  Internal("trace_glGenPerfMonitorsAMD","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGenPerfMonitorsAMD(n, monitors);
}

static void REGAL_CALL trace_glGetPerfMonitorCounterDataAMD(GLuint monitor, GLenum pname, GLsizei dataSize, GLuint *data, GLint *bytesWritten)
{
  Internal("trace_glGetPerfMonitorCounterDataAMD","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetPerfMonitorCounterDataAMD(monitor, pname, dataSize, data, bytesWritten);
}

static void REGAL_CALL trace_glGetPerfMonitorCounterInfoAMD(GLuint group, GLuint counter, GLenum pname, GLvoid *data)
{
  Internal("trace_glGetPerfMonitorCounterInfoAMD","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetPerfMonitorCounterInfoAMD(group, counter, pname, data);
}

static void REGAL_CALL trace_glGetPerfMonitorCounterStringAMD(GLuint group, GLuint counter, GLsizei bufSize, GLsizei *length, GLchar *counterString)
{
  Internal("trace_glGetPerfMonitorCounterStringAMD","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetPerfMonitorCounterStringAMD(group, counter, bufSize, length, counterString);
}

static void REGAL_CALL trace_glGetPerfMonitorCountersAMD(GLuint group, GLint *numCounters, GLint *maxActiveCounters, GLsizei countersSize, GLuint *counters)
{
  Internal("trace_glGetPerfMonitorCountersAMD","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetPerfMonitorCountersAMD(group, numCounters, maxActiveCounters, countersSize, counters);
}

static void REGAL_CALL trace_glGetPerfMonitorGroupStringAMD(GLuint group, GLsizei bufSize, GLsizei *length, GLchar *groupString)
{
  Internal("trace_glGetPerfMonitorGroupStringAMD","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetPerfMonitorGroupStringAMD(group, bufSize, length, groupString);
}

static void REGAL_CALL trace_glGetPerfMonitorGroupsAMD(GLint *numGroups, GLsizei groupsSize, GLuint *groups)
{
  Internal("trace_glGetPerfMonitorGroupsAMD","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetPerfMonitorGroupsAMD(numGroups, groupsSize, groups);
}

static void REGAL_CALL trace_glSelectPerfMonitorCountersAMD(GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint *counterList)
{
  Internal("trace_glSelectPerfMonitorCountersAMD","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSelectPerfMonitorCountersAMD(monitor, enable, group, numCounters, counterList);
}

// GL_AMD_sample_positions

static void REGAL_CALL trace_glSetMultisamplefvAMD(GLenum pname, GLuint index, const GLfloat *val)
{
  Internal("trace_glSetMultisamplefvAMD","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSetMultisamplefvAMD(pname, index, val);
}

// GL_AMD_vertex_shader_tessellator

static void REGAL_CALL trace_glTessellationFactorAMD(GLfloat factor)
{
  Internal("trace_glTessellationFactorAMD","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTessellationFactorAMD(factor);
}

static void REGAL_CALL trace_glTessellationModeAMD(GLenum mode)
{
  Internal("trace_glTessellationModeAMD","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTessellationModeAMD(mode);
}

// GL_ANGLE_framebuffer_blit

static void REGAL_CALL trace_glBlitFramebufferANGLE(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
{
  Internal("trace_glBlitFramebufferANGLE","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBlitFramebufferANGLE(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
}

// GL_ANGLE_framebuffer_multisample

static void REGAL_CALL trace_glRenderbufferStorageMultisampleANGLE(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
  Internal("trace_glRenderbufferStorageMultisampleANGLE","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glRenderbufferStorageMultisampleANGLE(target, samples, internalformat, width, height);
}

// GL_APPLE_element_array

static void REGAL_CALL trace_glDrawElementArrayAPPLE(GLenum mode, GLint first, GLsizei count)
{
  Internal("trace_glDrawElementArrayAPPLE","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDrawElementArrayAPPLE(mode, first, count);
}

static void REGAL_CALL trace_glDrawRangeElementArrayAPPLE(GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count)
{
  Internal("trace_glDrawRangeElementArrayAPPLE","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDrawRangeElementArrayAPPLE(mode, start, end, first, count);
}

static void REGAL_CALL trace_glElementPointerAPPLE(GLenum type, const GLvoid *pointer)
{
  Internal("trace_glElementPointerAPPLE","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glElementPointerAPPLE(type, pointer);
}

static void REGAL_CALL trace_glMultiDrawElementArrayAPPLE(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount)
{
  Internal("trace_glMultiDrawElementArrayAPPLE","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiDrawElementArrayAPPLE(mode, first, count, primcount);
}

static void REGAL_CALL trace_glMultiDrawRangeElementArrayAPPLE(GLenum mode, GLuint start, GLuint end, const GLint *first, const GLsizei *count, GLsizei primcount)
{
  Internal("trace_glMultiDrawRangeElementArrayAPPLE","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiDrawRangeElementArrayAPPLE(mode, start, end, first, count, primcount);
}

// GL_APPLE_fence

static void REGAL_CALL trace_glDeleteFencesAPPLE(GLsizei n, const GLuint *fences)
{
  Internal("trace_glDeleteFencesAPPLE","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDeleteFencesAPPLE(n, fences);
}

static void REGAL_CALL trace_glFinishFenceAPPLE(GLuint fence)
{
  Internal("trace_glFinishFenceAPPLE","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFinishFenceAPPLE(fence);
}

static void REGAL_CALL trace_glFinishObjectAPPLE(GLenum object, GLint name)
{
  Internal("trace_glFinishObjectAPPLE","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFinishObjectAPPLE(object, name);
}

static void REGAL_CALL trace_glGenFencesAPPLE(GLsizei n, GLuint *fences)
{
  Internal("trace_glGenFencesAPPLE","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGenFencesAPPLE(n, fences);
}

static GLboolean REGAL_CALL trace_glIsFenceAPPLE(GLuint fence)
{
  Internal("trace_glIsFenceAPPLE","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glIsFenceAPPLE(fence);
  return ret;
}

static void REGAL_CALL trace_glSetFenceAPPLE(GLuint fence)
{
  Internal("trace_glSetFenceAPPLE","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSetFenceAPPLE(fence);
}

static GLboolean REGAL_CALL trace_glTestFenceAPPLE(GLuint fence)
{
  Internal("trace_glTestFenceAPPLE","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glTestFenceAPPLE(fence);
  return ret;
}

static GLboolean REGAL_CALL trace_glTestObjectAPPLE(GLenum object, GLuint name)
{
  Internal("trace_glTestObjectAPPLE","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glTestObjectAPPLE(object, name);
  return ret;
}

// GL_APPLE_flush_buffer_range

static void REGAL_CALL trace_glBufferParameteriAPPLE(GLenum target, GLenum pname, GLint param)
{
  Internal("trace_glBufferParameteriAPPLE","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBufferParameteriAPPLE(target, pname, param);
}

static void REGAL_CALL trace_glFlushMappedBufferRangeAPPLE(GLenum target, GLintptr offset, GLsizeiptr size)
{
  Internal("trace_glFlushMappedBufferRangeAPPLE","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFlushMappedBufferRangeAPPLE(target, offset, size);
}

// GL_APPLE_flush_render

static void REGAL_CALL trace_glFinishRenderAPPLE(void)
{
  Internal("trace_glFinishRenderAPPLE","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFinishRenderAPPLE();
}

static void REGAL_CALL trace_glFlushRenderAPPLE(void)
{
  Internal("trace_glFlushRenderAPPLE","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFlushRenderAPPLE();
}

static void REGAL_CALL trace_glSwapAPPLE(void)
{
  Internal("trace_glSwapAPPLE","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSwapAPPLE();
}

// GL_APPLE_framebuffer_multisample

static void REGAL_CALL trace_glRenderbufferStorageMultisampleAPPLE(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
  Internal("trace_glRenderbufferStorageMultisampleAPPLE","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glRenderbufferStorageMultisampleAPPLE(target, samples, internalformat, width, height);
}

static void REGAL_CALL trace_glResolveMultisampleFramebufferAPPLE(void)
{
  Internal("trace_glResolveMultisampleFramebufferAPPLE","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glResolveMultisampleFramebufferAPPLE();
}

// GL_APPLE_object_purgeable

static void REGAL_CALL trace_glGetObjectParameterivAPPLE(GLenum objectType, GLuint name, GLenum pname, GLint *params)
{
  Internal("trace_glGetObjectParameterivAPPLE","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetObjectParameterivAPPLE(objectType, name, pname, params);
}

static GLenum REGAL_CALL trace_glObjectPurgeableAPPLE(GLenum objectType, GLuint name, GLenum option)
{
  Internal("trace_glObjectPurgeableAPPLE","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLenum  ret = Trace::glObjectPurgeableAPPLE(objectType, name, option);
  return ret;
}

static GLenum REGAL_CALL trace_glObjectUnpurgeableAPPLE(GLenum objectType, GLuint name, GLenum option)
{
  Internal("trace_glObjectUnpurgeableAPPLE","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLenum  ret = Trace::glObjectUnpurgeableAPPLE(objectType, name, option);
  return ret;
}

// GL_APPLE_texture_range

static void REGAL_CALL trace_glGetTexParameterPointervAPPLE(GLenum target, GLenum pname, GLvoid **params)
{
  Internal("trace_glGetTexParameterPointervAPPLE","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetTexParameterPointervAPPLE(target, pname, params);
}

static void REGAL_CALL trace_glTextureRangeAPPLE(GLenum target, GLsizei length, const GLvoid *pointer)
{
  Internal("trace_glTextureRangeAPPLE","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTextureRangeAPPLE(target, length, pointer);
}

// GL_APPLE_vertex_array_object

static void REGAL_CALL trace_glBindVertexArrayAPPLE(GLuint array)
{
  Internal("trace_glBindVertexArrayAPPLE","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBindVertexArrayAPPLE(array);
}

static void REGAL_CALL trace_glDeleteVertexArraysAPPLE(GLsizei n, const GLuint *arrays)
{
  Internal("trace_glDeleteVertexArraysAPPLE","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDeleteVertexArraysAPPLE(n, arrays);
}

static void REGAL_CALL trace_glGenVertexArraysAPPLE(GLsizei n, GLuint *arrays)
{
  Internal("trace_glGenVertexArraysAPPLE","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGenVertexArraysAPPLE(n, arrays);
}

static GLboolean REGAL_CALL trace_glIsVertexArrayAPPLE(GLuint array)
{
  Internal("trace_glIsVertexArrayAPPLE","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glIsVertexArrayAPPLE(array);
  return ret;
}

// GL_APPLE_vertex_array_range

static void REGAL_CALL trace_glFlushVertexArrayRangeAPPLE(GLsizei length, GLvoid *pointer)
{
  Internal("trace_glFlushVertexArrayRangeAPPLE","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFlushVertexArrayRangeAPPLE(length, pointer);
}

static void REGAL_CALL trace_glVertexArrayParameteriAPPLE(GLenum pname, GLint param)
{
  Internal("trace_glVertexArrayParameteriAPPLE","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexArrayParameteriAPPLE(pname, param);
}

static void REGAL_CALL trace_glVertexArrayRangeAPPLE(GLsizei length, GLvoid *pointer)
{
  Internal("trace_glVertexArrayRangeAPPLE","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexArrayRangeAPPLE(length, pointer);
}

// GL_APPLE_vertex_program_evaluators

static void REGAL_CALL trace_glDisableVertexAttribAPPLE(GLuint index, GLenum pname)
{
  Internal("trace_glDisableVertexAttribAPPLE","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDisableVertexAttribAPPLE(index, pname);
}

static void REGAL_CALL trace_glEnableVertexAttribAPPLE(GLuint index, GLenum pname)
{
  Internal("trace_glEnableVertexAttribAPPLE","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glEnableVertexAttribAPPLE(index, pname);
}

static GLboolean REGAL_CALL trace_glIsVertexAttribEnabledAPPLE(GLuint index, GLenum pname)
{
  Internal("trace_glIsVertexAttribEnabledAPPLE","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glIsVertexAttribEnabledAPPLE(index, pname);
  return ret;
}

static void REGAL_CALL trace_glMapVertexAttrib1dAPPLE(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points)
{
  Internal("trace_glMapVertexAttrib1dAPPLE","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMapVertexAttrib1dAPPLE(index, size, u1, u2, stride, order, points);
}

static void REGAL_CALL trace_glMapVertexAttrib1fAPPLE(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points)
{
  Internal("trace_glMapVertexAttrib1fAPPLE","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMapVertexAttrib1fAPPLE(index, size, u1, u2, stride, order, points);
}

static void REGAL_CALL trace_glMapVertexAttrib2dAPPLE(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points)
{
  Internal("trace_glMapVertexAttrib2dAPPLE","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMapVertexAttrib2dAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
}

static void REGAL_CALL trace_glMapVertexAttrib2fAPPLE(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points)
{
  Internal("trace_glMapVertexAttrib2fAPPLE","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMapVertexAttrib2fAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
}

// GL_ARB_ES2_compatibility

static void REGAL_CALL trace_glClearDepthf(GLclampf d)
{
  Internal("trace_glClearDepthf","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glClearDepthf(d);
}

static void REGAL_CALL trace_glDepthRangef(GLclampf n, GLclampf f)
{
  Internal("trace_glDepthRangef","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDepthRangef(n, f);
}

static void REGAL_CALL trace_glGetShaderPrecisionFormat(GLenum shadertype, GLenum precisiontype, GLint *range, GLint *precision)
{
  Internal("trace_glGetShaderPrecisionFormat","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetShaderPrecisionFormat(shadertype, precisiontype, range, precision);
}

static void REGAL_CALL trace_glReleaseShaderCompiler(void)
{
  Internal("trace_glReleaseShaderCompiler","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glReleaseShaderCompiler();
}

static void REGAL_CALL trace_glShaderBinary(GLsizei count, const GLuint *shaders, GLenum binaryformat, const GLvoid *binary, GLsizei length)
{
  Internal("trace_glShaderBinary","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glShaderBinary(count, shaders, binaryformat, binary, length);
}

// GL_ARB_base_instance

static void REGAL_CALL trace_glDrawArraysInstancedBaseInstance(GLenum mode, GLint first, GLsizei count, GLsizei primcount, GLuint baseinstance)
{
  Internal("trace_glDrawArraysInstancedBaseInstance","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDrawArraysInstancedBaseInstance(mode, first, count, primcount, baseinstance);
}

static void REGAL_CALL trace_glDrawElementsInstancedBaseInstance(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount, GLuint baseinstance)
{
  Internal("trace_glDrawElementsInstancedBaseInstance","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDrawElementsInstancedBaseInstance(mode, count, type, indices, primcount, baseinstance);
}

static void REGAL_CALL trace_glDrawElementsInstancedBaseVertexBaseInstance(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount, GLint basevertex, GLuint baseinstance)
{
  Internal("trace_glDrawElementsInstancedBaseVertexBaseInstance","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDrawElementsInstancedBaseVertexBaseInstance(mode, count, type, indices, primcount, basevertex, baseinstance);
}

// GL_ARB_blend_func_extended

static void REGAL_CALL trace_glBindFragDataLocationIndexed(GLuint program, GLuint colorNumber, GLuint index, const GLchar *name)
{
  Internal("trace_glBindFragDataLocationIndexed","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBindFragDataLocationIndexed(program, colorNumber, index, name);
}

static GLint REGAL_CALL trace_glGetFragDataIndex(GLuint program, const GLchar *name)
{
  Internal("trace_glGetFragDataIndex","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLint  ret = Trace::glGetFragDataIndex(program, name);
  return ret;
}

// GL_ARB_clear_buffer_object

static void REGAL_CALL trace_glClearBufferData(GLenum target, GLenum internalformat, GLenum format, GLenum type, const GLvoid *data)
{
  Internal("trace_glClearBufferData","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glClearBufferData(target, internalformat, format, type, data);
}

static void REGAL_CALL trace_glClearBufferSubData(GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const GLvoid *data)
{
  Internal("trace_glClearBufferSubData","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glClearBufferSubData(target, internalformat, offset, size, format, type, data);
}

static void REGAL_CALL trace_glClearNamedBufferDataEXT(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const GLvoid *data)
{
  Internal("trace_glClearNamedBufferDataEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glClearNamedBufferDataEXT(buffer, internalformat, format, type, data);
}

// GL_ARB_color_buffer_float

static void REGAL_CALL trace_glClampColorARB(GLenum target, GLenum clamp)
{
  Internal("trace_glClampColorARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glClampColorARB(target, clamp);
}

// GL_ARB_compute_shader

static void REGAL_CALL trace_glDispatchCompute(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z)
{
  Internal("trace_glDispatchCompute","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDispatchCompute(num_groups_x, num_groups_y, num_groups_z);
}

static void REGAL_CALL trace_glDispatchComputeIndirect(GLintptr indirect)
{
  Internal("trace_glDispatchComputeIndirect","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDispatchComputeIndirect(indirect);
}

// GL_ARB_copy_buffer

static void REGAL_CALL trace_glCopyBufferSubData(GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size)
{
  Internal("trace_glCopyBufferSubData","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCopyBufferSubData(readtarget, writetarget, readoffset, writeoffset, size);
}

// GL_ARB_copy_image

static void REGAL_CALL trace_glCopyImageSubData(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth)
{
  Internal("trace_glCopyImageSubData","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCopyImageSubData(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
}

// GL_ARB_debug_output

static void REGAL_CALL trace_glDebugMessageCallbackARB(GLDEBUGPROCARB callback, const GLvoid *userParam)
{
  Internal("trace_glDebugMessageCallbackARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDebugMessageCallbackARB(callback, userParam);
}

static void REGAL_CALL trace_glDebugMessageControlARB(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled)
{
  Internal("trace_glDebugMessageControlARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDebugMessageControlARB(source, type, severity, count, ids, enabled);
}

static void REGAL_CALL trace_glDebugMessageInsertARB(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf)
{
  Internal("trace_glDebugMessageInsertARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDebugMessageInsertARB(source, type, id, severity, length, buf);
}

static GLuint REGAL_CALL trace_glGetDebugMessageLogARB(GLuint count, GLsizei bufsize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog)
{
  Internal("trace_glGetDebugMessageLogARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLuint  ret = Trace::glGetDebugMessageLogARB(count, bufsize, sources, types, ids, severities, lengths, messageLog);
  return ret;
}

// GL_ARB_draw_buffers

static void REGAL_CALL trace_glDrawBuffersARB(GLsizei n, const GLenum *bufs)
{
  Internal("trace_glDrawBuffersARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDrawBuffersARB(n, bufs);
}

// GL_ARB_draw_buffers_blend

static void REGAL_CALL trace_glBlendEquationSeparateiARB(GLuint buf, GLenum modeRGB, GLenum modeAlpha)
{
  Internal("trace_glBlendEquationSeparateiARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBlendEquationSeparateiARB(buf, modeRGB, modeAlpha);
}

static void REGAL_CALL trace_glBlendEquationiARB(GLuint buf, GLenum mode)
{
  Internal("trace_glBlendEquationiARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBlendEquationiARB(buf, mode);
}

static void REGAL_CALL trace_glBlendFuncSeparateiARB(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
{
  Internal("trace_glBlendFuncSeparateiARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBlendFuncSeparateiARB(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
}

static void REGAL_CALL trace_glBlendFunciARB(GLuint buf, GLenum src, GLenum dst)
{
  Internal("trace_glBlendFunciARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBlendFunciARB(buf, src, dst);
}

// GL_ARB_draw_elements_base_vertex

static void REGAL_CALL trace_glDrawElementsBaseVertex(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLint basevertex)
{
  Internal("trace_glDrawElementsBaseVertex","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDrawElementsBaseVertex(mode, count, type, indices, basevertex);
}

static void REGAL_CALL trace_glDrawElementsInstancedBaseVertex(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount, GLint basevertex)
{
  Internal("trace_glDrawElementsInstancedBaseVertex","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDrawElementsInstancedBaseVertex(mode, count, type, indices, primcount, basevertex);
}

static void REGAL_CALL trace_glDrawRangeElementsBaseVertex(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices, GLint basevertex)
{
  Internal("trace_glDrawRangeElementsBaseVertex","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDrawRangeElementsBaseVertex(mode, start, end, count, type, indices, basevertex);
}

static void REGAL_CALL trace_glMultiDrawElementsBaseVertex(GLenum mode, const GLsizei *count, GLenum type, const GLvoid * const *indices, GLsizei primcount, const GLint *basevertex)
{
  Internal("trace_glMultiDrawElementsBaseVertex","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiDrawElementsBaseVertex(mode, count, type, indices, primcount, basevertex);
}

// GL_ARB_draw_indirect

static void REGAL_CALL trace_glDrawArraysIndirect(GLenum mode, const GLvoid *indirect)
{
  Internal("trace_glDrawArraysIndirect","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDrawArraysIndirect(mode, indirect);
}

static void REGAL_CALL trace_glDrawElementsIndirect(GLenum mode, GLenum type, const GLvoid *indirect)
{
  Internal("trace_glDrawElementsIndirect","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDrawElementsIndirect(mode, type, indirect);
}

// GL_ARB_draw_instanced

static void REGAL_CALL trace_glDrawArraysInstancedARB(GLenum mode, GLint start, GLsizei count, GLsizei primcount)
{
  Internal("trace_glDrawArraysInstancedARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDrawArraysInstancedARB(mode, start, count, primcount);
}

static void REGAL_CALL trace_glDrawElementsInstancedARB(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount)
{
  Internal("trace_glDrawElementsInstancedARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDrawElementsInstancedARB(mode, count, type, indices, primcount);
}

// GL_ARB_framebuffer_no_attachments

static void REGAL_CALL trace_glFramebufferParameteri(GLenum target, GLenum pname, GLint param)
{
  Internal("trace_glFramebufferParameteri","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFramebufferParameteri(target, pname, param);
}

static void REGAL_CALL trace_glGetFramebufferParameteriv(GLenum target, GLenum pname, GLint *params)
{
  Internal("trace_glGetFramebufferParameteriv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetFramebufferParameteriv(target, pname, params);
}

static void REGAL_CALL trace_glGetNamedFramebufferParameterivEXT(GLuint framebuffer, GLenum pname, GLint *params)
{
  Internal("trace_glGetNamedFramebufferParameterivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetNamedFramebufferParameterivEXT(framebuffer, pname, params);
}

static void REGAL_CALL trace_glNamedFramebufferParameteriEXT(GLuint framebuffer, GLenum pname, GLint param)
{
  Internal("trace_glNamedFramebufferParameteriEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNamedFramebufferParameteriEXT(framebuffer, pname, param);
}

// GL_ARB_framebuffer_object

static void REGAL_CALL trace_glBindFramebuffer(GLenum target, GLuint framebuffer)
{
  Internal("trace_glBindFramebuffer","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBindFramebuffer(target, framebuffer);
}

static void REGAL_CALL trace_glBindRenderbuffer(GLenum target, GLuint renderbuffer)
{
  Internal("trace_glBindRenderbuffer","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBindRenderbuffer(target, renderbuffer);
}

static void REGAL_CALL trace_glBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
{
  Internal("trace_glBlitFramebuffer","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBlitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
}

static GLenum REGAL_CALL trace_glCheckFramebufferStatus(GLenum target)
{
  Internal("trace_glCheckFramebufferStatus","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLenum  ret = Trace::glCheckFramebufferStatus(target);
  return ret;
}

static void REGAL_CALL trace_glDeleteFramebuffers(GLsizei n, const GLuint *framebuffers)
{
  Internal("trace_glDeleteFramebuffers","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDeleteFramebuffers(n, framebuffers);
}

static void REGAL_CALL trace_glDeleteRenderbuffers(GLsizei n, const GLuint *renderbuffers)
{
  Internal("trace_glDeleteRenderbuffers","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDeleteRenderbuffers(n, renderbuffers);
}

static void REGAL_CALL trace_glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{
  Internal("trace_glFramebufferRenderbuffer","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFramebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer);
}

static void REGAL_CALL trace_glFramebufferTexture1D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
  Internal("trace_glFramebufferTexture1D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFramebufferTexture1D(target, attachment, textarget, texture, level);
}

static void REGAL_CALL trace_glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
  Internal("trace_glFramebufferTexture2D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFramebufferTexture2D(target, attachment, textarget, texture, level);
}

static void REGAL_CALL trace_glFramebufferTexture3D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint layer)
{
  Internal("trace_glFramebufferTexture3D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFramebufferTexture3D(target, attachment, textarget, texture, level, layer);
}

static void REGAL_CALL trace_glFramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)
{
  Internal("trace_glFramebufferTextureLayer","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFramebufferTextureLayer(target, attachment, texture, level, layer);
}

static void REGAL_CALL trace_glGenFramebuffers(GLsizei n, GLuint *framebuffers)
{
  Internal("trace_glGenFramebuffers","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGenFramebuffers(n, framebuffers);
}

static void REGAL_CALL trace_glGenRenderbuffers(GLsizei n, GLuint *renderbuffers)
{
  Internal("trace_glGenRenderbuffers","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGenRenderbuffers(n, renderbuffers);
}

static void REGAL_CALL trace_glGenerateMipmap(GLenum target)
{
  Internal("trace_glGenerateMipmap","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGenerateMipmap(target);
}

static void REGAL_CALL trace_glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint *params)
{
  Internal("trace_glGetFramebufferAttachmentParameteriv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetFramebufferAttachmentParameteriv(target, attachment, pname, params);
}

static void REGAL_CALL trace_glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint *params)
{
  Internal("trace_glGetRenderbufferParameteriv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetRenderbufferParameteriv(target, pname, params);
}

static GLboolean REGAL_CALL trace_glIsFramebuffer(GLuint framebuffer)
{
  Internal("trace_glIsFramebuffer","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glIsFramebuffer(framebuffer);
  return ret;
}

static GLboolean REGAL_CALL trace_glIsRenderbuffer(GLuint renderbuffer)
{
  Internal("trace_glIsRenderbuffer","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glIsRenderbuffer(renderbuffer);
  return ret;
}

static void REGAL_CALL trace_glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
{
  Internal("trace_glRenderbufferStorage","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glRenderbufferStorage(target, internalformat, width, height);
}

static void REGAL_CALL trace_glRenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
  Internal("trace_glRenderbufferStorageMultisample","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glRenderbufferStorageMultisample(target, samples, internalformat, width, height);
}

// GL_ARB_geometry_shader4

static void REGAL_CALL trace_glFramebufferTextureARB(GLenum target, GLenum attachment, GLuint texture, GLint level)
{
  Internal("trace_glFramebufferTextureARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFramebufferTextureARB(target, attachment, texture, level);
}

static void REGAL_CALL trace_glFramebufferTextureFaceARB(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face)
{
  Internal("trace_glFramebufferTextureFaceARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFramebufferTextureFaceARB(target, attachment, texture, level, face);
}

static void REGAL_CALL trace_glFramebufferTextureLayerARB(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)
{
  Internal("trace_glFramebufferTextureLayerARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFramebufferTextureLayerARB(target, attachment, texture, level, layer);
}

static void REGAL_CALL trace_glProgramParameteriARB(GLuint program, GLenum pname, GLint value)
{
  Internal("trace_glProgramParameteriARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramParameteriARB(program, pname, value);
}

// GL_ARB_get_program_binary

static void REGAL_CALL trace_glGetProgramBinary(GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, GLvoid *binary)
{
  Internal("trace_glGetProgramBinary","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetProgramBinary(program, bufSize, length, binaryFormat, binary);
}

static void REGAL_CALL trace_glProgramBinary(GLuint program, GLenum binaryFormat, const GLvoid *binary, GLsizei length)
{
  Internal("trace_glProgramBinary","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramBinary(program, binaryFormat, binary, length);
}

static void REGAL_CALL trace_glProgramParameteri(GLuint program, GLenum pname, GLint value)
{
  Internal("trace_glProgramParameteri","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramParameteri(program, pname, value);
}

// GL_ARB_gpu_shader_fp64

static void REGAL_CALL trace_glGetUniformdv(GLuint program, GLint location, GLdouble *params)
{
  Internal("trace_glGetUniformdv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetUniformdv(program, location, params);
}

static void REGAL_CALL trace_glUniform1d(GLint location, GLdouble x)
{
  Internal("trace_glUniform1d","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform1d(location, x);
}

static void REGAL_CALL trace_glUniform1dv(GLint location, GLsizei count, const GLdouble *value)
{
  Internal("trace_glUniform1dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform1dv(location, count, value);
}

static void REGAL_CALL trace_glUniform2d(GLint location, GLdouble x, GLdouble y)
{
  Internal("trace_glUniform2d","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform2d(location, x, y);
}

static void REGAL_CALL trace_glUniform2dv(GLint location, GLsizei count, const GLdouble *value)
{
  Internal("trace_glUniform2dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform2dv(location, count, value);
}

static void REGAL_CALL trace_glUniform3d(GLint location, GLdouble x, GLdouble y, GLdouble z)
{
  Internal("trace_glUniform3d","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform3d(location, x, y, z);
}

static void REGAL_CALL trace_glUniform3dv(GLint location, GLsizei count, const GLdouble *value)
{
  Internal("trace_glUniform3dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform3dv(location, count, value);
}

static void REGAL_CALL trace_glUniform4d(GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  Internal("trace_glUniform4d","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform4d(location, x, y, z, w);
}

static void REGAL_CALL trace_glUniform4dv(GLint location, GLsizei count, const GLdouble *value)
{
  Internal("trace_glUniform4dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform4dv(location, count, value);
}

static void REGAL_CALL trace_glUniformMatrix2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  Internal("trace_glUniformMatrix2dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniformMatrix2dv(location, count, transpose, value);
}

static void REGAL_CALL trace_glUniformMatrix2x3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  Internal("trace_glUniformMatrix2x3dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniformMatrix2x3dv(location, count, transpose, value);
}

static void REGAL_CALL trace_glUniformMatrix2x4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  Internal("trace_glUniformMatrix2x4dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniformMatrix2x4dv(location, count, transpose, value);
}

static void REGAL_CALL trace_glUniformMatrix3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  Internal("trace_glUniformMatrix3dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniformMatrix3dv(location, count, transpose, value);
}

static void REGAL_CALL trace_glUniformMatrix3x2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  Internal("trace_glUniformMatrix3x2dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniformMatrix3x2dv(location, count, transpose, value);
}

static void REGAL_CALL trace_glUniformMatrix3x4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  Internal("trace_glUniformMatrix3x4dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniformMatrix3x4dv(location, count, transpose, value);
}

static void REGAL_CALL trace_glUniformMatrix4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  Internal("trace_glUniformMatrix4dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniformMatrix4dv(location, count, transpose, value);
}

static void REGAL_CALL trace_glUniformMatrix4x2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  Internal("trace_glUniformMatrix4x2dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniformMatrix4x2dv(location, count, transpose, value);
}

static void REGAL_CALL trace_glUniformMatrix4x3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  Internal("trace_glUniformMatrix4x3dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniformMatrix4x3dv(location, count, transpose, value);
}

// GL_ARB_imaging

static void REGAL_CALL trace_glColorSubTable(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data)
{
  Internal("trace_glColorSubTable","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColorSubTable(target, start, count, format, type, data);
}

static void REGAL_CALL trace_glColorTable(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table)
{
  Internal("trace_glColorTable","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColorTable(target, internalformat, width, format, type, table);
}

static void REGAL_CALL trace_glColorTableParameterfv(GLenum target, GLenum pname, const GLfloat *params)
{
  Internal("trace_glColorTableParameterfv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColorTableParameterfv(target, pname, params);
}

static void REGAL_CALL trace_glColorTableParameteriv(GLenum target, GLenum pname, const GLint *params)
{
  Internal("trace_glColorTableParameteriv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColorTableParameteriv(target, pname, params);
}

static void REGAL_CALL trace_glConvolutionFilter1D(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image)
{
  Internal("trace_glConvolutionFilter1D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glConvolutionFilter1D(target, internalformat, width, format, type, image);
}

static void REGAL_CALL trace_glConvolutionFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image)
{
  Internal("trace_glConvolutionFilter2D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glConvolutionFilter2D(target, internalformat, width, height, format, type, image);
}

static void REGAL_CALL trace_glConvolutionParameterf(GLenum target, GLenum pname, GLfloat params)
{
  Internal("trace_glConvolutionParameterf","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glConvolutionParameterf(target, pname, params);
}

static void REGAL_CALL trace_glConvolutionParameterfv(GLenum target, GLenum pname, const GLfloat *params)
{
  Internal("trace_glConvolutionParameterfv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glConvolutionParameterfv(target, pname, params);
}

static void REGAL_CALL trace_glConvolutionParameteri(GLenum target, GLenum pname, GLint params)
{
  Internal("trace_glConvolutionParameteri","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glConvolutionParameteri(target, pname, params);
}

static void REGAL_CALL trace_glConvolutionParameteriv(GLenum target, GLenum pname, const GLint *params)
{
  Internal("trace_glConvolutionParameteriv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glConvolutionParameteriv(target, pname, params);
}

static void REGAL_CALL trace_glCopyColorSubTable(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width)
{
  Internal("trace_glCopyColorSubTable","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCopyColorSubTable(target, start, x, y, width);
}

static void REGAL_CALL trace_glCopyColorTable(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
{
  Internal("trace_glCopyColorTable","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCopyColorTable(target, internalformat, x, y, width);
}

static void REGAL_CALL trace_glCopyConvolutionFilter1D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
{
  Internal("trace_glCopyConvolutionFilter1D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCopyConvolutionFilter1D(target, internalformat, x, y, width);
}

static void REGAL_CALL trace_glCopyConvolutionFilter2D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height)
{
  Internal("trace_glCopyConvolutionFilter2D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCopyConvolutionFilter2D(target, internalformat, x, y, width, height);
}

static void REGAL_CALL trace_glGetColorTable(GLenum target, GLenum format, GLenum type, GLvoid *table)
{
  Internal("trace_glGetColorTable","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetColorTable(target, format, type, table);
}

static void REGAL_CALL trace_glGetColorTableParameterfv(GLenum target, GLenum pname, GLfloat *params)
{
  Internal("trace_glGetColorTableParameterfv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetColorTableParameterfv(target, pname, params);
}

static void REGAL_CALL trace_glGetColorTableParameteriv(GLenum target, GLenum pname, GLint *params)
{
  Internal("trace_glGetColorTableParameteriv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetColorTableParameteriv(target, pname, params);
}

static void REGAL_CALL trace_glGetConvolutionFilter(GLenum target, GLenum format, GLenum type, GLvoid *image)
{
  Internal("trace_glGetConvolutionFilter","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetConvolutionFilter(target, format, type, image);
}

static void REGAL_CALL trace_glGetConvolutionParameterfv(GLenum target, GLenum pname, GLfloat *params)
{
  Internal("trace_glGetConvolutionParameterfv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetConvolutionParameterfv(target, pname, params);
}

static void REGAL_CALL trace_glGetConvolutionParameteriv(GLenum target, GLenum pname, GLint *params)
{
  Internal("trace_glGetConvolutionParameteriv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetConvolutionParameteriv(target, pname, params);
}

static void REGAL_CALL trace_glGetHistogram(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values)
{
  Internal("trace_glGetHistogram","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetHistogram(target, reset, format, type, values);
}

static void REGAL_CALL trace_glGetHistogramParameterfv(GLenum target, GLenum pname, GLfloat *params)
{
  Internal("trace_glGetHistogramParameterfv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetHistogramParameterfv(target, pname, params);
}

static void REGAL_CALL trace_glGetHistogramParameteriv(GLenum target, GLenum pname, GLint *params)
{
  Internal("trace_glGetHistogramParameteriv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetHistogramParameteriv(target, pname, params);
}

static void REGAL_CALL trace_glGetMinmax(GLenum target, GLboolean reset, GLenum format, GLenum types, GLvoid *values)
{
  Internal("trace_glGetMinmax","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetMinmax(target, reset, format, types, values);
}

static void REGAL_CALL trace_glGetMinmaxParameterfv(GLenum target, GLenum pname, GLfloat *params)
{
  Internal("trace_glGetMinmaxParameterfv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetMinmaxParameterfv(target, pname, params);
}

static void REGAL_CALL trace_glGetMinmaxParameteriv(GLenum target, GLenum pname, GLint *params)
{
  Internal("trace_glGetMinmaxParameteriv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetMinmaxParameteriv(target, pname, params);
}

static void REGAL_CALL trace_glGetSeparableFilter(GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span)
{
  Internal("trace_glGetSeparableFilter","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetSeparableFilter(target, format, type, row, column, span);
}

static void REGAL_CALL trace_glHistogram(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink)
{
  Internal("trace_glHistogram","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glHistogram(target, width, internalformat, sink);
}

static void REGAL_CALL trace_glMinmax(GLenum target, GLenum internalformat, GLboolean sink)
{
  Internal("trace_glMinmax","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMinmax(target, internalformat, sink);
}

static void REGAL_CALL trace_glResetHistogram(GLenum target)
{
  Internal("trace_glResetHistogram","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glResetHistogram(target);
}

static void REGAL_CALL trace_glResetMinmax(GLenum target)
{
  Internal("trace_glResetMinmax","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glResetMinmax(target);
}

static void REGAL_CALL trace_glSeparableFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column)
{
  Internal("trace_glSeparableFilter2D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSeparableFilter2D(target, internalformat, width, height, format, type, row, column);
}

// GL_ARB_instanced_arrays

static void REGAL_CALL trace_glVertexAttribDivisorARB(GLuint index, GLuint divisor)
{
  Internal("trace_glVertexAttribDivisorARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribDivisorARB(index, divisor);
}

// GL_ARB_internalformat_query

static void REGAL_CALL trace_glGetInternalformativ(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *params)
{
  Internal("trace_glGetInternalformativ","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetInternalformativ(target, internalformat, pname, bufSize, params);
}

// GL_ARB_internalformat_query2

static void REGAL_CALL trace_glGetInternalformati64v(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint64 *params)
{
  Internal("trace_glGetInternalformati64v","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetInternalformati64v(target, internalformat, pname, bufSize, params);
}

// GL_ARB_invalidate_subdata

static void REGAL_CALL trace_glInvalidateBufferData(GLuint buffer)
{
  Internal("trace_glInvalidateBufferData","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glInvalidateBufferData(buffer);
}

static void REGAL_CALL trace_glInvalidateBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr length)
{
  Internal("trace_glInvalidateBufferSubData","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glInvalidateBufferSubData(buffer, offset, length);
}

static void REGAL_CALL trace_glInvalidateFramebuffer(GLenum target, GLsizei numAttachments, const GLenum *attachments)
{
  Internal("trace_glInvalidateFramebuffer","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glInvalidateFramebuffer(target, numAttachments, attachments);
}

static void REGAL_CALL trace_glInvalidateSubFramebuffer(GLenum target, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height)
{
  Internal("trace_glInvalidateSubFramebuffer","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glInvalidateSubFramebuffer(target, numAttachments, attachments, x, y, width, height);
}

static void REGAL_CALL trace_glInvalidateTexImage(GLuint texture, GLint level)
{
  Internal("trace_glInvalidateTexImage","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glInvalidateTexImage(texture, level);
}

static void REGAL_CALL trace_glInvalidateTexSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth)
{
  Internal("trace_glInvalidateTexSubImage","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glInvalidateTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth);
}

// GL_ARB_map_buffer_range

static void REGAL_CALL trace_glFlushMappedBufferRange(GLenum target, GLintptr offset, GLsizeiptr length)
{
  Internal("trace_glFlushMappedBufferRange","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFlushMappedBufferRange(target, offset, length);
}

static GLvoid *REGAL_CALL trace_glMapBufferRange(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access)
{
  Internal("trace_glMapBufferRange","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLvoid * ret = Trace::glMapBufferRange(target, offset, length, access);
  return ret;
}

// GL_ARB_matrix_palette

static void REGAL_CALL trace_glCurrentPaletteMatrixARB(GLint index)
{
  Internal("trace_glCurrentPaletteMatrixARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCurrentPaletteMatrixARB(index);
}

static void REGAL_CALL trace_glMatrixIndexPointerARB(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
  Internal("trace_glMatrixIndexPointerARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMatrixIndexPointerARB(size, type, stride, pointer);
}

static void REGAL_CALL trace_glMatrixIndexubvARB(GLint size, const GLubyte *indices)
{
  Internal("trace_glMatrixIndexubvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMatrixIndexubvARB(size, indices);
}

static void REGAL_CALL trace_glMatrixIndexuivARB(GLint size, const GLuint *indices)
{
  Internal("trace_glMatrixIndexuivARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMatrixIndexuivARB(size, indices);
}

static void REGAL_CALL trace_glMatrixIndexusvARB(GLint size, const GLushort *indices)
{
  Internal("trace_glMatrixIndexusvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMatrixIndexusvARB(size, indices);
}

// GL_ARB_multi_draw_indirect

static void REGAL_CALL trace_glMultiDrawArraysIndirect(GLenum mode, const GLvoid *indirect, GLsizei primcount, GLsizei stride)
{
  Internal("trace_glMultiDrawArraysIndirect","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiDrawArraysIndirect(mode, indirect, primcount, stride);
}

static void REGAL_CALL trace_glMultiDrawElementsIndirect(GLenum mode, GLenum type, const GLvoid *indirect, GLsizei primcount, GLsizei stride)
{
  Internal("trace_glMultiDrawElementsIndirect","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiDrawElementsIndirect(mode, type, indirect, primcount, stride);
}

// GL_ARB_multisample

static void REGAL_CALL trace_glSampleCoverageARB(GLclampf value, GLboolean invert)
{
  Internal("trace_glSampleCoverageARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSampleCoverageARB(value, invert);
}

// GL_ARB_multitexture

static void REGAL_CALL trace_glActiveTextureARB(GLenum texture)
{
  Internal("trace_glActiveTextureARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glActiveTextureARB(texture);
}

static void REGAL_CALL trace_glClientActiveTextureARB(GLenum texture)
{
  Internal("trace_glClientActiveTextureARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glClientActiveTextureARB(texture);
}

static void REGAL_CALL trace_glMultiTexCoord1dARB(GLenum target, GLdouble s)
{
  Internal("trace_glMultiTexCoord1dARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord1dARB(target, s);
}

static void REGAL_CALL trace_glMultiTexCoord1dvARB(GLenum target, const GLdouble *v)
{
  Internal("trace_glMultiTexCoord1dvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord1dvARB(target, v);
}

static void REGAL_CALL trace_glMultiTexCoord1fARB(GLenum target, GLfloat s)
{
  Internal("trace_glMultiTexCoord1fARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord1fARB(target, s);
}

static void REGAL_CALL trace_glMultiTexCoord1fvARB(GLenum target, const GLfloat *v)
{
  Internal("trace_glMultiTexCoord1fvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord1fvARB(target, v);
}

static void REGAL_CALL trace_glMultiTexCoord1iARB(GLenum target, GLint s)
{
  Internal("trace_glMultiTexCoord1iARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord1iARB(target, s);
}

static void REGAL_CALL trace_glMultiTexCoord1ivARB(GLenum target, const GLint *v)
{
  Internal("trace_glMultiTexCoord1ivARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord1ivARB(target, v);
}

static void REGAL_CALL trace_glMultiTexCoord1sARB(GLenum target, GLshort s)
{
  Internal("trace_glMultiTexCoord1sARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord1sARB(target, s);
}

static void REGAL_CALL trace_glMultiTexCoord1svARB(GLenum target, const GLshort *v)
{
  Internal("trace_glMultiTexCoord1svARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord1svARB(target, v);
}

static void REGAL_CALL trace_glMultiTexCoord2dARB(GLenum target, GLdouble s, GLdouble t)
{
  Internal("trace_glMultiTexCoord2dARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord2dARB(target, s, t);
}

static void REGAL_CALL trace_glMultiTexCoord2dvARB(GLenum target, const GLdouble *v)
{
  Internal("trace_glMultiTexCoord2dvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord2dvARB(target, v);
}

static void REGAL_CALL trace_glMultiTexCoord2fARB(GLenum target, GLfloat s, GLfloat t)
{
  Internal("trace_glMultiTexCoord2fARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord2fARB(target, s, t);
}

static void REGAL_CALL trace_glMultiTexCoord2fvARB(GLenum target, const GLfloat *v)
{
  Internal("trace_glMultiTexCoord2fvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord2fvARB(target, v);
}

static void REGAL_CALL trace_glMultiTexCoord2iARB(GLenum target, GLint s, GLint t)
{
  Internal("trace_glMultiTexCoord2iARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord2iARB(target, s, t);
}

static void REGAL_CALL trace_glMultiTexCoord2ivARB(GLenum target, const GLint *v)
{
  Internal("trace_glMultiTexCoord2ivARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord2ivARB(target, v);
}

static void REGAL_CALL trace_glMultiTexCoord2sARB(GLenum target, GLshort s, GLshort t)
{
  Internal("trace_glMultiTexCoord2sARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord2sARB(target, s, t);
}

static void REGAL_CALL trace_glMultiTexCoord2svARB(GLenum target, const GLshort *v)
{
  Internal("trace_glMultiTexCoord2svARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord2svARB(target, v);
}

static void REGAL_CALL trace_glMultiTexCoord3dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r)
{
  Internal("trace_glMultiTexCoord3dARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord3dARB(target, s, t, r);
}

static void REGAL_CALL trace_glMultiTexCoord3dvARB(GLenum target, const GLdouble *v)
{
  Internal("trace_glMultiTexCoord3dvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord3dvARB(target, v);
}

static void REGAL_CALL trace_glMultiTexCoord3fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r)
{
  Internal("trace_glMultiTexCoord3fARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord3fARB(target, s, t, r);
}

static void REGAL_CALL trace_glMultiTexCoord3fvARB(GLenum target, const GLfloat *v)
{
  Internal("trace_glMultiTexCoord3fvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord3fvARB(target, v);
}

static void REGAL_CALL trace_glMultiTexCoord3iARB(GLenum target, GLint s, GLint t, GLint r)
{
  Internal("trace_glMultiTexCoord3iARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord3iARB(target, s, t, r);
}

static void REGAL_CALL trace_glMultiTexCoord3ivARB(GLenum target, const GLint *v)
{
  Internal("trace_glMultiTexCoord3ivARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord3ivARB(target, v);
}

static void REGAL_CALL trace_glMultiTexCoord3sARB(GLenum target, GLshort s, GLshort t, GLshort r)
{
  Internal("trace_glMultiTexCoord3sARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord3sARB(target, s, t, r);
}

static void REGAL_CALL trace_glMultiTexCoord3svARB(GLenum target, const GLshort *v)
{
  Internal("trace_glMultiTexCoord3svARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord3svARB(target, v);
}

static void REGAL_CALL trace_glMultiTexCoord4dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
{
  Internal("trace_glMultiTexCoord4dARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord4dARB(target, s, t, r, q);
}

static void REGAL_CALL trace_glMultiTexCoord4dvARB(GLenum target, const GLdouble *v)
{
  Internal("trace_glMultiTexCoord4dvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord4dvARB(target, v);
}

static void REGAL_CALL trace_glMultiTexCoord4fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
{
  Internal("trace_glMultiTexCoord4fARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord4fARB(target, s, t, r, q);
}

static void REGAL_CALL trace_glMultiTexCoord4fvARB(GLenum target, const GLfloat *v)
{
  Internal("trace_glMultiTexCoord4fvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord4fvARB(target, v);
}

static void REGAL_CALL trace_glMultiTexCoord4iARB(GLenum target, GLint s, GLint t, GLint r, GLint q)
{
  Internal("trace_glMultiTexCoord4iARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord4iARB(target, s, t, r, q);
}

static void REGAL_CALL trace_glMultiTexCoord4ivARB(GLenum target, const GLint *v)
{
  Internal("trace_glMultiTexCoord4ivARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord4ivARB(target, v);
}

static void REGAL_CALL trace_glMultiTexCoord4sARB(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
{
  Internal("trace_glMultiTexCoord4sARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord4sARB(target, s, t, r, q);
}

static void REGAL_CALL trace_glMultiTexCoord4svARB(GLenum target, const GLshort *v)
{
  Internal("trace_glMultiTexCoord4svARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord4svARB(target, v);
}

// GL_ARB_occlusion_query

static void REGAL_CALL trace_glBeginQueryARB(GLenum target, GLuint id)
{
  Internal("trace_glBeginQueryARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBeginQueryARB(target, id);
}

static void REGAL_CALL trace_glDeleteQueriesARB(GLsizei n, const GLuint *ids)
{
  Internal("trace_glDeleteQueriesARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDeleteQueriesARB(n, ids);
}

static void REGAL_CALL trace_glEndQueryARB(GLenum target)
{
  Internal("trace_glEndQueryARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glEndQueryARB(target);
}

static void REGAL_CALL trace_glGenQueriesARB(GLsizei n, GLuint *ids)
{
  Internal("trace_glGenQueriesARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGenQueriesARB(n, ids);
}

static void REGAL_CALL trace_glGetQueryObjectivARB(GLuint id, GLenum pname, GLint *params)
{
  Internal("trace_glGetQueryObjectivARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetQueryObjectivARB(id, pname, params);
}

static void REGAL_CALL trace_glGetQueryObjectuivARB(GLuint id, GLenum pname, GLuint *params)
{
  Internal("trace_glGetQueryObjectuivARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetQueryObjectuivARB(id, pname, params);
}

static void REGAL_CALL trace_glGetQueryivARB(GLenum target, GLenum pname, GLint *params)
{
  Internal("trace_glGetQueryivARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetQueryivARB(target, pname, params);
}

static GLboolean REGAL_CALL trace_glIsQueryARB(GLuint id)
{
  Internal("trace_glIsQueryARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glIsQueryARB(id);
  return ret;
}

// GL_ARB_point_parameters

static void REGAL_CALL trace_glPointParameterfARB(GLenum pname, GLfloat param)
{
  Internal("trace_glPointParameterfARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPointParameterfARB(pname, param);
}

static void REGAL_CALL trace_glPointParameterfvARB(GLenum pname, const GLfloat *params)
{
  Internal("trace_glPointParameterfvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPointParameterfvARB(pname, params);
}

// GL_ARB_program_interface_query

static void REGAL_CALL trace_glGetProgramInterfaceiv(GLuint program, GLenum programInterface, GLenum pname, GLint *params)
{
  Internal("trace_glGetProgramInterfaceiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetProgramInterfaceiv(program, programInterface, pname, params);
}

static GLuint REGAL_CALL trace_glGetProgramResourceIndex(GLuint program, GLenum programInterface, const GLchar *name)
{
  Internal("trace_glGetProgramResourceIndex","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLuint  ret = Trace::glGetProgramResourceIndex(program, programInterface, name);
  return ret;
}

static GLint REGAL_CALL trace_glGetProgramResourceLocation(GLuint program, GLenum programInterface, const GLchar *name)
{
  Internal("trace_glGetProgramResourceLocation","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLint  ret = Trace::glGetProgramResourceLocation(program, programInterface, name);
  return ret;
}

static GLint REGAL_CALL trace_glGetProgramResourceLocationIndex(GLuint program, GLenum programInterface, const GLchar *name)
{
  Internal("trace_glGetProgramResourceLocationIndex","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLint  ret = Trace::glGetProgramResourceLocationIndex(program, programInterface, name);
  return ret;
}

static void REGAL_CALL trace_glGetProgramResourceName(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name)
{
  Internal("trace_glGetProgramResourceName","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetProgramResourceName(program, programInterface, index, bufSize, length, name);
}

static void REGAL_CALL trace_glGetProgramResourceiv(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum *props, GLsizei bufSize, GLsizei *length, GLint *params)
{
  Internal("trace_glGetProgramResourceiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetProgramResourceiv(program, programInterface, index, propCount, props, bufSize, length, params);
}

// GL_ARB_provoking_vertex

static void REGAL_CALL trace_glProvokingVertex(GLenum mode)
{
  Internal("trace_glProvokingVertex","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProvokingVertex(mode);
}

// GL_ARB_robustness

static GLenum REGAL_CALL trace_glGetGraphicsResetStatusARB(void)
{
  Internal("trace_glGetGraphicsResetStatusARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLenum  ret = Trace::glGetGraphicsResetStatusARB();
  return ret;
}

static void REGAL_CALL trace_glGetnColorTableARB(GLenum target, GLenum format, GLenum type, GLsizei bufSize, GLvoid *table)
{
  Internal("trace_glGetnColorTableARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetnColorTableARB(target, format, type, bufSize, table);
}

static void REGAL_CALL trace_glGetnCompressedTexImageARB(GLenum target, GLint lod, GLsizei bufSize, GLvoid *img)
{
  Internal("trace_glGetnCompressedTexImageARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetnCompressedTexImageARB(target, lod, bufSize, img);
}

static void REGAL_CALL trace_glGetnConvolutionFilterARB(GLenum target, GLenum format, GLenum type, GLsizei bufSize, GLvoid *image)
{
  Internal("trace_glGetnConvolutionFilterARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetnConvolutionFilterARB(target, format, type, bufSize, image);
}

static void REGAL_CALL trace_glGetnHistogramARB(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, GLvoid *values)
{
  Internal("trace_glGetnHistogramARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetnHistogramARB(target, reset, format, type, bufSize, values);
}

static void REGAL_CALL trace_glGetnMapdvARB(GLenum target, GLenum query, GLsizei bufSize, GLdouble *v)
{
  Internal("trace_glGetnMapdvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetnMapdvARB(target, query, bufSize, v);
}

static void REGAL_CALL trace_glGetnMapfvARB(GLenum target, GLenum query, GLsizei bufSize, GLfloat *v)
{
  Internal("trace_glGetnMapfvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetnMapfvARB(target, query, bufSize, v);
}

static void REGAL_CALL trace_glGetnMapivARB(GLenum target, GLenum query, GLsizei bufSize, GLint *v)
{
  Internal("trace_glGetnMapivARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetnMapivARB(target, query, bufSize, v);
}

static void REGAL_CALL trace_glGetnMinmaxARB(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, GLvoid *values)
{
  Internal("trace_glGetnMinmaxARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetnMinmaxARB(target, reset, format, type, bufSize, values);
}

static void REGAL_CALL trace_glGetnPixelMapfvARB(GLenum map, GLsizei bufSize, GLfloat *values)
{
  Internal("trace_glGetnPixelMapfvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetnPixelMapfvARB(map, bufSize, values);
}

static void REGAL_CALL trace_glGetnPixelMapuivARB(GLenum map, GLsizei bufSize, GLuint *values)
{
  Internal("trace_glGetnPixelMapuivARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetnPixelMapuivARB(map, bufSize, values);
}

static void REGAL_CALL trace_glGetnPixelMapusvARB(GLenum map, GLsizei bufSize, GLushort *values)
{
  Internal("trace_glGetnPixelMapusvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetnPixelMapusvARB(map, bufSize, values);
}

static void REGAL_CALL trace_glGetnPolygonStippleARB(GLsizei bufSize, GLubyte *pattern)
{
  Internal("trace_glGetnPolygonStippleARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetnPolygonStippleARB(bufSize, pattern);
}

static void REGAL_CALL trace_glGetnSeparableFilterARB(GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, GLvoid *row, GLsizei columnBufSize, GLvoid *column, GLvoid *span)
{
  Internal("trace_glGetnSeparableFilterARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetnSeparableFilterARB(target, format, type, rowBufSize, row, columnBufSize, column, span);
}

static void REGAL_CALL trace_glGetnTexImageARB(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, GLvoid *img)
{
  Internal("trace_glGetnTexImageARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetnTexImageARB(target, level, format, type, bufSize, img);
}

static void REGAL_CALL trace_glGetnUniformdvARB(GLuint program, GLint location, GLsizei bufSize, GLdouble *params)
{
  Internal("trace_glGetnUniformdvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetnUniformdvARB(program, location, bufSize, params);
}

static void REGAL_CALL trace_glGetnUniformfvARB(GLuint program, GLint location, GLsizei bufSize, GLfloat *params)
{
  Internal("trace_glGetnUniformfvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetnUniformfvARB(program, location, bufSize, params);
}

static void REGAL_CALL trace_glGetnUniformivARB(GLuint program, GLint location, GLsizei bufSize, GLint *params)
{
  Internal("trace_glGetnUniformivARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetnUniformivARB(program, location, bufSize, params);
}

static void REGAL_CALL trace_glGetnUniformuivARB(GLuint program, GLint location, GLsizei bufSize, GLuint *params)
{
  Internal("trace_glGetnUniformuivARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetnUniformuivARB(program, location, bufSize, params);
}

static void REGAL_CALL trace_glReadnPixelsARB(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, GLvoid *data)
{
  Internal("trace_glReadnPixelsARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glReadnPixelsARB(x, y, width, height, format, type, bufSize, data);
}

// GL_ARB_sample_shading

static void REGAL_CALL trace_glMinSampleShading(GLclampf value)
{
  Internal("trace_glMinSampleShading","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMinSampleShading(value);
}

static void REGAL_CALL trace_glMinSampleShadingARB(GLclampf value)
{
  Internal("trace_glMinSampleShadingARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMinSampleShadingARB(value);
}

// GL_ARB_sampler_objects

static void REGAL_CALL trace_glBindSampler(GLuint unit, GLuint sampler)
{
  Internal("trace_glBindSampler","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBindSampler(unit, sampler);
}

static void REGAL_CALL trace_glDeleteSamplers(GLsizei count, const GLuint *samplers)
{
  Internal("trace_glDeleteSamplers","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDeleteSamplers(count, samplers);
}

static void REGAL_CALL trace_glGenSamplers(GLsizei count, GLuint *samplers)
{
  Internal("trace_glGenSamplers","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGenSamplers(count, samplers);
}

static void REGAL_CALL trace_glGetSamplerParameterIiv(GLuint sampler, GLenum pname, GLint *params)
{
  Internal("trace_glGetSamplerParameterIiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetSamplerParameterIiv(sampler, pname, params);
}

static void REGAL_CALL trace_glGetSamplerParameterIuiv(GLuint sampler, GLenum pname, GLuint *params)
{
  Internal("trace_glGetSamplerParameterIuiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetSamplerParameterIuiv(sampler, pname, params);
}

static void REGAL_CALL trace_glGetSamplerParameterfv(GLuint sampler, GLenum pname, GLfloat *params)
{
  Internal("trace_glGetSamplerParameterfv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetSamplerParameterfv(sampler, pname, params);
}

static void REGAL_CALL trace_glGetSamplerParameteriv(GLuint sampler, GLenum pname, GLint *params)
{
  Internal("trace_glGetSamplerParameteriv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetSamplerParameteriv(sampler, pname, params);
}

static GLboolean REGAL_CALL trace_glIsSampler(GLuint sampler)
{
  Internal("trace_glIsSampler","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glIsSampler(sampler);
  return ret;
}

static void REGAL_CALL trace_glSamplerParameterIiv(GLuint sampler, GLenum pname, const GLint *params)
{
  Internal("trace_glSamplerParameterIiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSamplerParameterIiv(sampler, pname, params);
}

static void REGAL_CALL trace_glSamplerParameterIuiv(GLuint sampler, GLenum pname, const GLuint *params)
{
  Internal("trace_glSamplerParameterIuiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSamplerParameterIuiv(sampler, pname, params);
}

static void REGAL_CALL trace_glSamplerParameterf(GLuint sampler, GLenum pname, GLfloat param)
{
  Internal("trace_glSamplerParameterf","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSamplerParameterf(sampler, pname, param);
}

static void REGAL_CALL trace_glSamplerParameterfv(GLuint sampler, GLenum pname, const GLfloat *params)
{
  Internal("trace_glSamplerParameterfv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSamplerParameterfv(sampler, pname, params);
}

static void REGAL_CALL trace_glSamplerParameteri(GLuint sampler, GLenum pname, GLint param)
{
  Internal("trace_glSamplerParameteri","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSamplerParameteri(sampler, pname, param);
}

static void REGAL_CALL trace_glSamplerParameteriv(GLuint sampler, GLenum pname, const GLint *params)
{
  Internal("trace_glSamplerParameteriv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSamplerParameteriv(sampler, pname, params);
}

// GL_ARB_separate_shader_objects

static void REGAL_CALL trace_glActiveShaderProgram(GLuint pipeline, GLuint program)
{
  Internal("trace_glActiveShaderProgram","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glActiveShaderProgram(pipeline, program);
}

static void REGAL_CALL trace_glBindProgramPipeline(GLuint pipeline)
{
  Internal("trace_glBindProgramPipeline","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBindProgramPipeline(pipeline);
}

static GLuint REGAL_CALL trace_glCreateShaderProgramv(GLenum type, GLsizei count, const GLchar * const *strings)
{
  Internal("trace_glCreateShaderProgramv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLuint  ret = Trace::glCreateShaderProgramv(type, count, strings);
  return ret;
}

static void REGAL_CALL trace_glDeleteProgramPipelines(GLsizei n, const GLuint *pipelines)
{
  Internal("trace_glDeleteProgramPipelines","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDeleteProgramPipelines(n, pipelines);
}

static void REGAL_CALL trace_glGenProgramPipelines(GLsizei n, GLuint *pipelines)
{
  Internal("trace_glGenProgramPipelines","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGenProgramPipelines(n, pipelines);
}

static void REGAL_CALL trace_glGetProgramPipelineInfoLog(GLuint pipeline, GLsizei bufSize, GLsizei *length, GLchar *infoLog)
{
  Internal("trace_glGetProgramPipelineInfoLog","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetProgramPipelineInfoLog(pipeline, bufSize, length, infoLog);
}

static void REGAL_CALL trace_glGetProgramPipelineiv(GLuint pipeline, GLenum pname, GLint *params)
{
  Internal("trace_glGetProgramPipelineiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetProgramPipelineiv(pipeline, pname, params);
}

static GLboolean REGAL_CALL trace_glIsProgramPipeline(GLuint pipeline)
{
  Internal("trace_glIsProgramPipeline","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glIsProgramPipeline(pipeline);
  return ret;
}

static void REGAL_CALL trace_glProgramUniform1d(GLuint program, GLint location, GLdouble x)
{
  Internal("trace_glProgramUniform1d","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform1d(program, location, x);
}

static void REGAL_CALL trace_glProgramUniform1dv(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
  Internal("trace_glProgramUniform1dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform1dv(program, location, count, value);
}

static void REGAL_CALL trace_glProgramUniform1f(GLuint program, GLint location, GLfloat x)
{
  Internal("trace_glProgramUniform1f","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform1f(program, location, x);
}

static void REGAL_CALL trace_glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
  Internal("trace_glProgramUniform1fv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform1fv(program, location, count, value);
}

static void REGAL_CALL trace_glProgramUniform1i(GLuint program, GLint location, GLint x)
{
  Internal("trace_glProgramUniform1i","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform1i(program, location, x);
}

static void REGAL_CALL trace_glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value)
{
  Internal("trace_glProgramUniform1iv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform1iv(program, location, count, value);
}

static void REGAL_CALL trace_glProgramUniform1ui(GLuint program, GLint location, GLuint v0)
{
  Internal("trace_glProgramUniform1ui","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform1ui(program, location, v0);
}

static void REGAL_CALL trace_glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
  Internal("trace_glProgramUniform1uiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform1uiv(program, location, count, value);
}

static void REGAL_CALL trace_glProgramUniform2d(GLuint program, GLint location, GLdouble x, GLdouble y)
{
  Internal("trace_glProgramUniform2d","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform2d(program, location, x, y);
}

static void REGAL_CALL trace_glProgramUniform2dv(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
  Internal("trace_glProgramUniform2dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform2dv(program, location, count, value);
}

static void REGAL_CALL trace_glProgramUniform2f(GLuint program, GLint location, GLfloat x, GLfloat y)
{
  Internal("trace_glProgramUniform2f","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform2f(program, location, x, y);
}

static void REGAL_CALL trace_glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
  Internal("trace_glProgramUniform2fv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform2fv(program, location, count, value);
}

static void REGAL_CALL trace_glProgramUniform2i(GLuint program, GLint location, GLint x, GLint y)
{
  Internal("trace_glProgramUniform2i","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform2i(program, location, x, y);
}

static void REGAL_CALL trace_glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value)
{
  Internal("trace_glProgramUniform2iv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform2iv(program, location, count, value);
}

static void REGAL_CALL trace_glProgramUniform2ui(GLuint program, GLint location, GLuint x, GLuint y)
{
  Internal("trace_glProgramUniform2ui","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform2ui(program, location, x, y);
}

static void REGAL_CALL trace_glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
  Internal("trace_glProgramUniform2uiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform2uiv(program, location, count, value);
}

static void REGAL_CALL trace_glProgramUniform3d(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z)
{
  Internal("trace_glProgramUniform3d","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform3d(program, location, x, y, z);
}

static void REGAL_CALL trace_glProgramUniform3dv(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
  Internal("trace_glProgramUniform3dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform3dv(program, location, count, value);
}

static void REGAL_CALL trace_glProgramUniform3f(GLuint program, GLint location, GLfloat x, GLfloat y, GLfloat z)
{
  Internal("trace_glProgramUniform3f","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform3f(program, location, x, y, z);
}

static void REGAL_CALL trace_glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
  Internal("trace_glProgramUniform3fv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform3fv(program, location, count, value);
}

static void REGAL_CALL trace_glProgramUniform3i(GLuint program, GLint location, GLint x, GLint y, GLint z)
{
  Internal("trace_glProgramUniform3i","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform3i(program, location, x, y, z);
}

static void REGAL_CALL trace_glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value)
{
  Internal("trace_glProgramUniform3iv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform3iv(program, location, count, value);
}

static void REGAL_CALL trace_glProgramUniform3ui(GLuint program, GLint location, GLuint x, GLuint y, GLuint z)
{
  Internal("trace_glProgramUniform3ui","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform3ui(program, location, x, y, z);
}

static void REGAL_CALL trace_glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
  Internal("trace_glProgramUniform3uiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform3uiv(program, location, count, value);
}

static void REGAL_CALL trace_glProgramUniform4d(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  Internal("trace_glProgramUniform4d","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform4d(program, location, x, y, z, w);
}

static void REGAL_CALL trace_glProgramUniform4dv(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
  Internal("trace_glProgramUniform4dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform4dv(program, location, count, value);
}

static void REGAL_CALL trace_glProgramUniform4f(GLuint program, GLint location, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  Internal("trace_glProgramUniform4f","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform4f(program, location, x, y, z, w);
}

static void REGAL_CALL trace_glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
  Internal("trace_glProgramUniform4fv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform4fv(program, location, count, value);
}

static void REGAL_CALL trace_glProgramUniform4i(GLuint program, GLint location, GLint x, GLint y, GLint z, GLint w)
{
  Internal("trace_glProgramUniform4i","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform4i(program, location, x, y, z, w);
}

static void REGAL_CALL trace_glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value)
{
  Internal("trace_glProgramUniform4iv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform4iv(program, location, count, value);
}

static void REGAL_CALL trace_glProgramUniform4ui(GLuint program, GLint location, GLuint x, GLuint y, GLuint z, GLuint w)
{
  Internal("trace_glProgramUniform4ui","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform4ui(program, location, x, y, z, w);
}

static void REGAL_CALL trace_glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
  Internal("trace_glProgramUniform4uiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform4uiv(program, location, count, value);
}

static void REGAL_CALL trace_glProgramUniformMatrix2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  Internal("trace_glProgramUniformMatrix2dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniformMatrix2dv(program, location, count, transpose, value);
}

static void REGAL_CALL trace_glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  Internal("trace_glProgramUniformMatrix2fv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniformMatrix2fv(program, location, count, transpose, value);
}

static void REGAL_CALL trace_glProgramUniformMatrix2x3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  Internal("trace_glProgramUniformMatrix2x3dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniformMatrix2x3dv(program, location, count, transpose, value);
}

static void REGAL_CALL trace_glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  Internal("trace_glProgramUniformMatrix2x3fv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniformMatrix2x3fv(program, location, count, transpose, value);
}

static void REGAL_CALL trace_glProgramUniformMatrix2x4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  Internal("trace_glProgramUniformMatrix2x4dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniformMatrix2x4dv(program, location, count, transpose, value);
}

static void REGAL_CALL trace_glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  Internal("trace_glProgramUniformMatrix2x4fv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniformMatrix2x4fv(program, location, count, transpose, value);
}

static void REGAL_CALL trace_glProgramUniformMatrix3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  Internal("trace_glProgramUniformMatrix3dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniformMatrix3dv(program, location, count, transpose, value);
}

static void REGAL_CALL trace_glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  Internal("trace_glProgramUniformMatrix3fv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniformMatrix3fv(program, location, count, transpose, value);
}

static void REGAL_CALL trace_glProgramUniformMatrix3x2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  Internal("trace_glProgramUniformMatrix3x2dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniformMatrix3x2dv(program, location, count, transpose, value);
}

static void REGAL_CALL trace_glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  Internal("trace_glProgramUniformMatrix3x2fv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniformMatrix3x2fv(program, location, count, transpose, value);
}

static void REGAL_CALL trace_glProgramUniformMatrix3x4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  Internal("trace_glProgramUniformMatrix3x4dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniformMatrix3x4dv(program, location, count, transpose, value);
}

static void REGAL_CALL trace_glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  Internal("trace_glProgramUniformMatrix3x4fv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniformMatrix3x4fv(program, location, count, transpose, value);
}

static void REGAL_CALL trace_glProgramUniformMatrix4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  Internal("trace_glProgramUniformMatrix4dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniformMatrix4dv(program, location, count, transpose, value);
}

static void REGAL_CALL trace_glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  Internal("trace_glProgramUniformMatrix4fv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniformMatrix4fv(program, location, count, transpose, value);
}

static void REGAL_CALL trace_glProgramUniformMatrix4x2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  Internal("trace_glProgramUniformMatrix4x2dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniformMatrix4x2dv(program, location, count, transpose, value);
}

static void REGAL_CALL trace_glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  Internal("trace_glProgramUniformMatrix4x2fv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniformMatrix4x2fv(program, location, count, transpose, value);
}

static void REGAL_CALL trace_glProgramUniformMatrix4x3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  Internal("trace_glProgramUniformMatrix4x3dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniformMatrix4x3dv(program, location, count, transpose, value);
}

static void REGAL_CALL trace_glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  Internal("trace_glProgramUniformMatrix4x3fv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniformMatrix4x3fv(program, location, count, transpose, value);
}

static void REGAL_CALL trace_glUseProgramStages(GLuint pipeline, GLbitfield stages, GLuint program)
{
  Internal("trace_glUseProgramStages","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUseProgramStages(pipeline, stages, program);
}

static void REGAL_CALL trace_glValidateProgramPipeline(GLuint pipeline)
{
  Internal("trace_glValidateProgramPipeline","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glValidateProgramPipeline(pipeline);
}

// GL_ARB_shader_atomic_counters

static void REGAL_CALL trace_glGetActiveAtomicCounterBufferiv(GLuint program, GLuint bufferIndex, GLenum pname, GLint *params)
{
  Internal("trace_glGetActiveAtomicCounterBufferiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetActiveAtomicCounterBufferiv(program, bufferIndex, pname, params);
}

// GL_ARB_shader_image_load_store

static void REGAL_CALL trace_glBindImageTexture(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format)
{
  Internal("trace_glBindImageTexture","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBindImageTexture(unit, texture, level, layered, layer, access, format);
}

static void REGAL_CALL trace_glMemoryBarrier(GLbitfield barriers)
{
  Internal("trace_glMemoryBarrier","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMemoryBarrier(barriers);
}

// GL_ARB_shader_objects

static void REGAL_CALL trace_glAttachObjectARB(GLhandleARB containerObj, GLhandleARB obj)
{
  Internal("trace_glAttachObjectARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glAttachObjectARB(containerObj, obj);
}

static void REGAL_CALL trace_glCompileShaderARB(GLhandleARB shaderObj)
{
  Internal("trace_glCompileShaderARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCompileShaderARB(shaderObj);
}

static GLhandleARB REGAL_CALL trace_glCreateProgramObjectARB(void)
{
  Internal("trace_glCreateProgramObjectARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLhandleARB  ret = Trace::glCreateProgramObjectARB();
  return ret;
}

static GLhandleARB REGAL_CALL trace_glCreateShaderObjectARB(GLenum shaderType)
{
  Internal("trace_glCreateShaderObjectARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLhandleARB  ret = Trace::glCreateShaderObjectARB(shaderType);
  return ret;
}

static void REGAL_CALL trace_glDeleteObjectARB(GLhandleARB obj)
{
  Internal("trace_glDeleteObjectARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDeleteObjectARB(obj);
}

static void REGAL_CALL trace_glDetachObjectARB(GLhandleARB containerObj, GLhandleARB attachedObj)
{
  Internal("trace_glDetachObjectARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDetachObjectARB(containerObj, attachedObj);
}

static void REGAL_CALL trace_glGetActiveUniformARB(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name)
{
  Internal("trace_glGetActiveUniformARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetActiveUniformARB(programObj, index, maxLength, length, size, type, name);
}

static void REGAL_CALL trace_glGetAttachedObjectsARB(GLhandleARB containerObj, GLsizei maxCount, GLsizei *count, GLhandleARB *obj)
{
  Internal("trace_glGetAttachedObjectsARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetAttachedObjectsARB(containerObj, maxCount, count, obj);
}

static GLhandleARB REGAL_CALL trace_glGetHandleARB(GLenum pname)
{
  Internal("trace_glGetHandleARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLhandleARB  ret = Trace::glGetHandleARB(pname);
  return ret;
}

static void REGAL_CALL trace_glGetInfoLogARB(GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *infoLog)
{
  Internal("trace_glGetInfoLogARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetInfoLogARB(obj, maxLength, length, infoLog);
}

static void REGAL_CALL trace_glGetObjectParameterfvARB(GLhandleARB obj, GLenum pname, GLfloat *params)
{
  Internal("trace_glGetObjectParameterfvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetObjectParameterfvARB(obj, pname, params);
}

static void REGAL_CALL trace_glGetObjectParameterivARB(GLhandleARB obj, GLenum pname, GLint *params)
{
  Internal("trace_glGetObjectParameterivARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetObjectParameterivARB(obj, pname, params);
}

static void REGAL_CALL trace_glGetShaderSourceARB(GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *source)
{
  Internal("trace_glGetShaderSourceARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetShaderSourceARB(obj, maxLength, length, source);
}

static GLint REGAL_CALL trace_glGetUniformLocationARB(GLhandleARB programObj, const GLcharARB *name)
{
  Internal("trace_glGetUniformLocationARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLint  ret = Trace::glGetUniformLocationARB(programObj, name);
  return ret;
}

static void REGAL_CALL trace_glGetUniformfvARB(GLhandleARB programObj, GLint location, GLfloat *params)
{
  Internal("trace_glGetUniformfvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetUniformfvARB(programObj, location, params);
}

static void REGAL_CALL trace_glGetUniformivARB(GLhandleARB programObj, GLint location, GLint *params)
{
  Internal("trace_glGetUniformivARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetUniformivARB(programObj, location, params);
}

static void REGAL_CALL trace_glLinkProgramARB(GLhandleARB programObj)
{
  Internal("trace_glLinkProgramARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glLinkProgramARB(programObj);
}

static void REGAL_CALL trace_glShaderSourceARB(GLhandleARB shaderObj, GLsizei count, const GLcharARB ** const string, const GLint *length)
{
  Internal("trace_glShaderSourceARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glShaderSourceARB(shaderObj, count, string, length);
}

static void REGAL_CALL trace_glUniform1fARB(GLint location, GLfloat v0)
{
  Internal("trace_glUniform1fARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform1fARB(location, v0);
}

static void REGAL_CALL trace_glUniform1fvARB(GLint location, GLsizei count, const GLfloat *value)
{
  Internal("trace_glUniform1fvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform1fvARB(location, count, value);
}

static void REGAL_CALL trace_glUniform1iARB(GLint location, GLint v0)
{
  Internal("trace_glUniform1iARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform1iARB(location, v0);
}

static void REGAL_CALL trace_glUniform1ivARB(GLint location, GLsizei count, const GLint *value)
{
  Internal("trace_glUniform1ivARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform1ivARB(location, count, value);
}

static void REGAL_CALL trace_glUniform2fARB(GLint location, GLfloat v0, GLfloat v1)
{
  Internal("trace_glUniform2fARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform2fARB(location, v0, v1);
}

static void REGAL_CALL trace_glUniform2fvARB(GLint location, GLsizei count, const GLfloat *value)
{
  Internal("trace_glUniform2fvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform2fvARB(location, count, value);
}

static void REGAL_CALL trace_glUniform2iARB(GLint location, GLint v0, GLint v1)
{
  Internal("trace_glUniform2iARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform2iARB(location, v0, v1);
}

static void REGAL_CALL trace_glUniform2ivARB(GLint location, GLsizei count, const GLint *value)
{
  Internal("trace_glUniform2ivARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform2ivARB(location, count, value);
}

static void REGAL_CALL trace_glUniform3fARB(GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
{
  Internal("trace_glUniform3fARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform3fARB(location, v0, v1, v2);
}

static void REGAL_CALL trace_glUniform3fvARB(GLint location, GLsizei count, const GLfloat *value)
{
  Internal("trace_glUniform3fvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform3fvARB(location, count, value);
}

static void REGAL_CALL trace_glUniform3iARB(GLint location, GLint v0, GLint v1, GLint v2)
{
  Internal("trace_glUniform3iARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform3iARB(location, v0, v1, v2);
}

static void REGAL_CALL trace_glUniform3ivARB(GLint location, GLsizei count, const GLint *value)
{
  Internal("trace_glUniform3ivARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform3ivARB(location, count, value);
}

static void REGAL_CALL trace_glUniform4fARB(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
{
  Internal("trace_glUniform4fARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform4fARB(location, v0, v1, v2, v3);
}

static void REGAL_CALL trace_glUniform4fvARB(GLint location, GLsizei count, const GLfloat *value)
{
  Internal("trace_glUniform4fvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform4fvARB(location, count, value);
}

static void REGAL_CALL trace_glUniform4iARB(GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
{
  Internal("trace_glUniform4iARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform4iARB(location, v0, v1, v2, v3);
}

static void REGAL_CALL trace_glUniform4ivARB(GLint location, GLsizei count, const GLint *value)
{
  Internal("trace_glUniform4ivARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform4ivARB(location, count, value);
}

static void REGAL_CALL trace_glUniformMatrix2fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  Internal("trace_glUniformMatrix2fvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniformMatrix2fvARB(location, count, transpose, value);
}

static void REGAL_CALL trace_glUniformMatrix3fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  Internal("trace_glUniformMatrix3fvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniformMatrix3fvARB(location, count, transpose, value);
}

static void REGAL_CALL trace_glUniformMatrix4fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  Internal("trace_glUniformMatrix4fvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniformMatrix4fvARB(location, count, transpose, value);
}

static void REGAL_CALL trace_glUseProgramObjectARB(GLhandleARB programObj)
{
  Internal("trace_glUseProgramObjectARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUseProgramObjectARB(programObj);
}

static void REGAL_CALL trace_glValidateProgramARB(GLhandleARB programObj)
{
  Internal("trace_glValidateProgramARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glValidateProgramARB(programObj);
}

// GL_ARB_shader_storage_buffer_object

static void REGAL_CALL trace_glShaderStorageBlockBinding(GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding)
{
  Internal("trace_glShaderStorageBlockBinding","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glShaderStorageBlockBinding(program, storageBlockIndex, storageBlockBinding);
}

// GL_ARB_shader_subroutine

static void REGAL_CALL trace_glGetActiveSubroutineName(GLuint program, GLenum shaderType, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name)
{
  Internal("trace_glGetActiveSubroutineName","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetActiveSubroutineName(program, shaderType, index, bufSize, length, name);
}

static void REGAL_CALL trace_glGetActiveSubroutineUniformName(GLuint program, GLenum shaderType, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name)
{
  Internal("trace_glGetActiveSubroutineUniformName","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetActiveSubroutineUniformName(program, shaderType, index, bufSize, length, name);
}

static void REGAL_CALL trace_glGetActiveSubroutineUniformiv(GLuint program, GLenum shaderType, GLuint index, GLenum pname, GLint *values)
{
  Internal("trace_glGetActiveSubroutineUniformiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetActiveSubroutineUniformiv(program, shaderType, index, pname, values);
}

static void REGAL_CALL trace_glGetProgramStageiv(GLuint program, GLenum shaderType, GLenum pname, GLint *values)
{
  Internal("trace_glGetProgramStageiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetProgramStageiv(program, shaderType, pname, values);
}

static void REGAL_CALL trace_glGetProgramSubroutineParameteruivNV(GLenum target, GLuint index, GLuint *params)
{
  Internal("trace_glGetProgramSubroutineParameteruivNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetProgramSubroutineParameteruivNV(target, index, params);
}

static GLuint REGAL_CALL trace_glGetSubroutineIndex(GLuint program, GLenum shaderType, const GLchar *name)
{
  Internal("trace_glGetSubroutineIndex","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLuint  ret = Trace::glGetSubroutineIndex(program, shaderType, name);
  return ret;
}

static GLint REGAL_CALL trace_glGetSubroutineUniformLocation(GLuint program, GLenum shaderType, const GLchar *name)
{
  Internal("trace_glGetSubroutineUniformLocation","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLint  ret = Trace::glGetSubroutineUniformLocation(program, shaderType, name);
  return ret;
}

static void REGAL_CALL trace_glGetUniformSubroutineuiv(GLenum shaderType, GLint location, GLuint *params)
{
  Internal("trace_glGetUniformSubroutineuiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetUniformSubroutineuiv(shaderType, location, params);
}

static void REGAL_CALL trace_glProgramSubroutineParametersuivNV(GLenum target, GLsizei count, const GLuint *params)
{
  Internal("trace_glProgramSubroutineParametersuivNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramSubroutineParametersuivNV(target, count, params);
}

static void REGAL_CALL trace_glUniformSubroutinesuiv(GLenum shaderType, GLsizei count, const GLuint *indices)
{
  Internal("trace_glUniformSubroutinesuiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniformSubroutinesuiv(shaderType, count, indices);
}

// GL_ARB_shading_language_include

static void REGAL_CALL trace_glCompileShaderIncludeARB(GLuint shader, GLsizei count, const GLchar **path, const GLint *length)
{
  Internal("trace_glCompileShaderIncludeARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCompileShaderIncludeARB(shader, count, path, length);
}

static void REGAL_CALL trace_glDeleteNamedStringARB(GLint namelen, const GLchar *name)
{
  Internal("trace_glDeleteNamedStringARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDeleteNamedStringARB(namelen, name);
}

static void REGAL_CALL trace_glGetNamedStringARB(GLint namelen, const GLchar *name, GLsizei bufSize, GLint *stringlen, GLchar *string)
{
  Internal("trace_glGetNamedStringARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetNamedStringARB(namelen, name, bufSize, stringlen, string);
}

static void REGAL_CALL trace_glGetNamedStringivARB(GLint namelen, const GLchar *name, GLenum pname, GLint *params)
{
  Internal("trace_glGetNamedStringivARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetNamedStringivARB(namelen, name, pname, params);
}

static GLboolean REGAL_CALL trace_glIsNamedStringARB(GLint namelen, const GLchar *name)
{
  Internal("trace_glIsNamedStringARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glIsNamedStringARB(namelen, name);
  return ret;
}

static void REGAL_CALL trace_glNamedStringARB(GLenum type, GLint namelen, const GLchar *name, GLint stringlen, const GLchar *string)
{
  Internal("trace_glNamedStringARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNamedStringARB(type, namelen, name, stringlen, string);
}

// GL_ARB_sync

static GLenum REGAL_CALL trace_glClientWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout)
{
  Internal("trace_glClientWaitSync","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLenum  ret = Trace::glClientWaitSync(sync, flags, timeout);
  return ret;
}

static void REGAL_CALL trace_glDeleteSync(GLsync sync)
{
  Internal("trace_glDeleteSync","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDeleteSync(sync);
}

static GLsync REGAL_CALL trace_glFenceSync(GLenum condition, GLbitfield flags)
{
  Internal("trace_glFenceSync","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLsync  ret = Trace::glFenceSync(condition, flags);
  return ret;
}

static void REGAL_CALL trace_glGetInteger64v(GLenum pname, GLint64 *params)
{
  Internal("trace_glGetInteger64v","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetInteger64v(pname, params);
}

static void REGAL_CALL trace_glGetSynciv(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values)
{
  Internal("trace_glGetSynciv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetSynciv(sync, pname, bufSize, length, values);
}

static GLboolean REGAL_CALL trace_glIsSync(GLsync sync)
{
  Internal("trace_glIsSync","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glIsSync(sync);
  return ret;
}

static void REGAL_CALL trace_glWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout)
{
  Internal("trace_glWaitSync","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWaitSync(sync, flags, timeout);
}

// GL_ARB_tessellation_shader

static void REGAL_CALL trace_glPatchParameterfv(GLenum pname, const GLfloat *values)
{
  Internal("trace_glPatchParameterfv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPatchParameterfv(pname, values);
}

static void REGAL_CALL trace_glPatchParameteri(GLenum pname, GLint value)
{
  Internal("trace_glPatchParameteri","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPatchParameteri(pname, value);
}

// GL_ARB_texture_buffer_object

static void REGAL_CALL trace_glTexBufferARB(GLenum target, GLenum internalformat, GLuint buffer)
{
  Internal("trace_glTexBufferARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexBufferARB(target, internalformat, buffer);
}

// GL_ARB_texture_buffer_range

static void REGAL_CALL trace_glTexBufferRange(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
  Internal("trace_glTexBufferRange","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexBufferRange(target, internalformat, buffer, offset, size);
}

static void REGAL_CALL trace_glTextureBufferRangeEXT(GLuint texture, GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
  Internal("trace_glTextureBufferRangeEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTextureBufferRangeEXT(texture, target, internalformat, buffer, offset, size);
}

// GL_ARB_texture_compression

static void REGAL_CALL trace_glCompressedTexImage1DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data)
{
  Internal("trace_glCompressedTexImage1DARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCompressedTexImage1DARB(target, level, internalformat, width, border, imageSize, data);
}

static void REGAL_CALL trace_glCompressedTexImage2DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data)
{
  Internal("trace_glCompressedTexImage2DARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCompressedTexImage2DARB(target, level, internalformat, width, height, border, imageSize, data);
}

static void REGAL_CALL trace_glCompressedTexImage3DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data)
{
  Internal("trace_glCompressedTexImage3DARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCompressedTexImage3DARB(target, level, internalformat, width, height, depth, border, imageSize, data);
}

static void REGAL_CALL trace_glCompressedTexSubImage1DARB(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data)
{
  Internal("trace_glCompressedTexSubImage1DARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCompressedTexSubImage1DARB(target, level, xoffset, width, format, imageSize, data);
}

static void REGAL_CALL trace_glCompressedTexSubImage2DARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data)
{
  Internal("trace_glCompressedTexSubImage2DARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCompressedTexSubImage2DARB(target, level, xoffset, yoffset, width, height, format, imageSize, data);
}

static void REGAL_CALL trace_glCompressedTexSubImage3DARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data)
{
  Internal("trace_glCompressedTexSubImage3DARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCompressedTexSubImage3DARB(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
}

static void REGAL_CALL trace_glGetCompressedTexImageARB(GLenum target, GLint lod, GLvoid *img)
{
  Internal("trace_glGetCompressedTexImageARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetCompressedTexImageARB(target, lod, img);
}

// GL_ARB_texture_multisample

static void REGAL_CALL trace_glGetMultisamplefv(GLenum pname, GLuint index, GLfloat *val)
{
  Internal("trace_glGetMultisamplefv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetMultisamplefv(pname, index, val);
}

static void REGAL_CALL trace_glSampleMaski(GLuint index, GLbitfield mask)
{
  Internal("trace_glSampleMaski","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSampleMaski(index, mask);
}

static void REGAL_CALL trace_glTexImage2DMultisample(GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations)
{
  Internal("trace_glTexImage2DMultisample","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexImage2DMultisample(target, samples, internalformat, width, height, fixedsamplelocations);
}

static void REGAL_CALL trace_glTexImage3DMultisample(GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations)
{
  Internal("trace_glTexImage3DMultisample","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexImage3DMultisample(target, samples, internalformat, width, height, depth, fixedsamplelocations);
}

// GL_ARB_texture_storage

static void REGAL_CALL trace_glTexStorage1D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width)
{
  Internal("trace_glTexStorage1D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexStorage1D(target, levels, internalformat, width);
}

static void REGAL_CALL trace_glTexStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height)
{
  Internal("trace_glTexStorage2D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexStorage2D(target, levels, internalformat, width, height);
}

static void REGAL_CALL trace_glTexStorage3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth)
{
  Internal("trace_glTexStorage3D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexStorage3D(target, levels, internalformat, width, height, depth);
}

static void REGAL_CALL trace_glTextureStorage1DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width)
{
  Internal("trace_glTextureStorage1DEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTextureStorage1DEXT(texture, target, levels, internalformat, width);
}

static void REGAL_CALL trace_glTextureStorage2DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height)
{
  Internal("trace_glTextureStorage2DEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTextureStorage2DEXT(texture, target, levels, internalformat, width, height);
}

static void REGAL_CALL trace_glTextureStorage3DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth)
{
  Internal("trace_glTextureStorage3DEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTextureStorage3DEXT(texture, target, levels, internalformat, width, height, depth);
}

// GL_ARB_texture_storage_multisample

static void REGAL_CALL trace_glTexStorage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations)
{
  Internal("trace_glTexStorage2DMultisample","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexStorage2DMultisample(target, samples, internalformat, width, height, fixedsamplelocations);
}

static void REGAL_CALL trace_glTexStorage3DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations)
{
  Internal("trace_glTexStorage3DMultisample","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexStorage3DMultisample(target, samples, internalformat, width, height, depth, fixedsamplelocations);
}

static void REGAL_CALL trace_glTextureStorage2DMultisampleEXT(GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations)
{
  Internal("trace_glTextureStorage2DMultisampleEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTextureStorage2DMultisampleEXT(texture, target, samples, internalformat, width, height, fixedsamplelocations);
}

static void REGAL_CALL trace_glTextureStorage3DMultisampleEXT(GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations)
{
  Internal("trace_glTextureStorage3DMultisampleEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTextureStorage3DMultisampleEXT(texture, target, samples, internalformat, width, height, depth, fixedsamplelocations);
}

// GL_ARB_texture_view

static void REGAL_CALL trace_glTextureView(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers)
{
  Internal("trace_glTextureView","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTextureView(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
}

// GL_ARB_timer_query

static void REGAL_CALL trace_glGetQueryObjecti64v(GLuint id, GLenum pname, GLint64 *params)
{
  Internal("trace_glGetQueryObjecti64v","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetQueryObjecti64v(id, pname, params);
}

static void REGAL_CALL trace_glGetQueryObjectui64v(GLuint id, GLenum pname, GLuint64 *params)
{
  Internal("trace_glGetQueryObjectui64v","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetQueryObjectui64v(id, pname, params);
}

static void REGAL_CALL trace_glQueryCounter(GLuint id, GLenum target)
{
  Internal("trace_glQueryCounter","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glQueryCounter(id, target);
}

// GL_ARB_transform_feedback2

static void REGAL_CALL trace_glBindTransformFeedback(GLenum target, GLuint id)
{
  Internal("trace_glBindTransformFeedback","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBindTransformFeedback(target, id);
}

static void REGAL_CALL trace_glDeleteTransformFeedbacks(GLsizei n, const GLuint *ids)
{
  Internal("trace_glDeleteTransformFeedbacks","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDeleteTransformFeedbacks(n, ids);
}

static void REGAL_CALL trace_glDrawTransformFeedback(GLenum mode, GLuint name)
{
  Internal("trace_glDrawTransformFeedback","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDrawTransformFeedback(mode, name);
}

static void REGAL_CALL trace_glGenTransformFeedbacks(GLsizei n, GLuint *ids)
{
  Internal("trace_glGenTransformFeedbacks","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGenTransformFeedbacks(n, ids);
}

static GLboolean REGAL_CALL trace_glIsTransformFeedback(GLuint id)
{
  Internal("trace_glIsTransformFeedback","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glIsTransformFeedback(id);
  return ret;
}

static void REGAL_CALL trace_glPauseTransformFeedback(void)
{
  Internal("trace_glPauseTransformFeedback","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPauseTransformFeedback();
}

static void REGAL_CALL trace_glResumeTransformFeedback(void)
{
  Internal("trace_glResumeTransformFeedback","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glResumeTransformFeedback();
}

// GL_ARB_transform_feedback3

static void REGAL_CALL trace_glBeginQueryIndexed(GLenum target, GLuint index, GLuint id)
{
  Internal("trace_glBeginQueryIndexed","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBeginQueryIndexed(target, index, id);
}

static void REGAL_CALL trace_glDrawTransformFeedbackStream(GLenum mode, GLuint id, GLuint stream)
{
  Internal("trace_glDrawTransformFeedbackStream","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDrawTransformFeedbackStream(mode, id, stream);
}

static void REGAL_CALL trace_glEndQueryIndexed(GLenum target, GLuint index)
{
  Internal("trace_glEndQueryIndexed","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glEndQueryIndexed(target, index);
}

static void REGAL_CALL trace_glGetQueryIndexediv(GLenum target, GLuint index, GLenum pname, GLint *params)
{
  Internal("trace_glGetQueryIndexediv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetQueryIndexediv(target, index, pname, params);
}

// GL_ARB_transform_feedback_instanced

static void REGAL_CALL trace_glDrawTransformFeedbackInstanced(GLenum mode, GLuint id, GLsizei primcount)
{
  Internal("trace_glDrawTransformFeedbackInstanced","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDrawTransformFeedbackInstanced(mode, id, primcount);
}

static void REGAL_CALL trace_glDrawTransformFeedbackStreamInstanced(GLenum mode, GLuint id, GLuint stream, GLsizei primcount)
{
  Internal("trace_glDrawTransformFeedbackStreamInstanced","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDrawTransformFeedbackStreamInstanced(mode, id, stream, primcount);
}

// GL_ARB_transpose_matrix

static void REGAL_CALL trace_glLoadTransposeMatrixdARB(const GLdouble *m)
{
  Internal("trace_glLoadTransposeMatrixdARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glLoadTransposeMatrixdARB(m);
}

static void REGAL_CALL trace_glLoadTransposeMatrixfARB(const GLfloat *m)
{
  Internal("trace_glLoadTransposeMatrixfARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glLoadTransposeMatrixfARB(m);
}

static void REGAL_CALL trace_glMultTransposeMatrixdARB(const GLdouble *m)
{
  Internal("trace_glMultTransposeMatrixdARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultTransposeMatrixdARB(m);
}

static void REGAL_CALL trace_glMultTransposeMatrixfARB(const GLfloat *m)
{
  Internal("trace_glMultTransposeMatrixfARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultTransposeMatrixfARB(m);
}

// GL_ARB_uniform_buffer_object

static void REGAL_CALL trace_glBindBufferBase(GLenum target, GLuint index, GLuint buffer)
{
  Internal("trace_glBindBufferBase","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBindBufferBase(target, index, buffer);
}

static void REGAL_CALL trace_glBindBufferRange(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
  Internal("trace_glBindBufferRange","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBindBufferRange(target, index, buffer, offset, size);
}

static void REGAL_CALL trace_glGetActiveUniformBlockName(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName)
{
  Internal("trace_glGetActiveUniformBlockName","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetActiveUniformBlockName(program, uniformBlockIndex, bufSize, length, uniformBlockName);
}

static void REGAL_CALL trace_glGetActiveUniformBlockiv(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params)
{
  Internal("trace_glGetActiveUniformBlockiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetActiveUniformBlockiv(program, uniformBlockIndex, pname, params);
}

static void REGAL_CALL trace_glGetActiveUniformName(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformName)
{
  Internal("trace_glGetActiveUniformName","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetActiveUniformName(program, uniformIndex, bufSize, length, uniformName);
}

static void REGAL_CALL trace_glGetActiveUniformsiv(GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params)
{
  Internal("trace_glGetActiveUniformsiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetActiveUniformsiv(program, uniformCount, uniformIndices, pname, params);
}

static void REGAL_CALL trace_glGetIntegeri_v(GLenum target, GLuint index, GLint *data)
{
  Internal("trace_glGetIntegeri_v","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetIntegeri_v(target, index, data);
}

static GLuint REGAL_CALL trace_glGetUniformBlockIndex(GLuint program, const GLchar *uniformBlockName)
{
  Internal("trace_glGetUniformBlockIndex","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLuint  ret = Trace::glGetUniformBlockIndex(program, uniformBlockName);
  return ret;
}

static void REGAL_CALL trace_glGetUniformIndices(GLuint program, GLsizei uniformCount, const GLchar * const *uniformNames, GLuint *uniformIndices)
{
  Internal("trace_glGetUniformIndices","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetUniformIndices(program, uniformCount, uniformNames, uniformIndices);
}

static void REGAL_CALL trace_glUniformBlockBinding(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding)
{
  Internal("trace_glUniformBlockBinding","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniformBlockBinding(program, uniformBlockIndex, uniformBlockBinding);
}

// GL_ARB_vertex_array_object

static void REGAL_CALL trace_glBindVertexArray(GLuint array)
{
  Internal("trace_glBindVertexArray","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBindVertexArray(array);
}

static void REGAL_CALL trace_glDeleteVertexArrays(GLsizei n, const GLuint *arrays)
{
  Internal("trace_glDeleteVertexArrays","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDeleteVertexArrays(n, arrays);
}

static void REGAL_CALL trace_glGenVertexArrays(GLsizei n, GLuint *arrays)
{
  Internal("trace_glGenVertexArrays","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGenVertexArrays(n, arrays);
}

static GLboolean REGAL_CALL trace_glIsVertexArray(GLuint array)
{
  Internal("trace_glIsVertexArray","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glIsVertexArray(array);
  return ret;
}

// GL_ARB_vertex_attrib_64bit

static void REGAL_CALL trace_glGetVertexAttribLdv(GLuint index, GLenum pname, GLdouble *params)
{
  Internal("trace_glGetVertexAttribLdv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetVertexAttribLdv(index, pname, params);
}

static void REGAL_CALL trace_glVertexAttribL1d(GLuint index, GLdouble x)
{
  Internal("trace_glVertexAttribL1d","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribL1d(index, x);
}

static void REGAL_CALL trace_glVertexAttribL1dv(GLuint index, const GLdouble *v)
{
  Internal("trace_glVertexAttribL1dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribL1dv(index, v);
}

static void REGAL_CALL trace_glVertexAttribL2d(GLuint index, GLdouble x, GLdouble y)
{
  Internal("trace_glVertexAttribL2d","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribL2d(index, x, y);
}

static void REGAL_CALL trace_glVertexAttribL2dv(GLuint index, const GLdouble *v)
{
  Internal("trace_glVertexAttribL2dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribL2dv(index, v);
}

static void REGAL_CALL trace_glVertexAttribL3d(GLuint index, GLdouble x, GLdouble y, GLdouble z)
{
  Internal("trace_glVertexAttribL3d","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribL3d(index, x, y, z);
}

static void REGAL_CALL trace_glVertexAttribL3dv(GLuint index, const GLdouble *v)
{
  Internal("trace_glVertexAttribL3dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribL3dv(index, v);
}

static void REGAL_CALL trace_glVertexAttribL4d(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  Internal("trace_glVertexAttribL4d","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribL4d(index, x, y, z, w);
}

static void REGAL_CALL trace_glVertexAttribL4dv(GLuint index, const GLdouble *v)
{
  Internal("trace_glVertexAttribL4dv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribL4dv(index, v);
}

static void REGAL_CALL trace_glVertexAttribLPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
  Internal("trace_glVertexAttribLPointer","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribLPointer(index, size, type, stride, pointer);
}

// GL_ARB_vertex_attrib_binding

static void REGAL_CALL trace_glBindVertexBuffer(GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride)
{
  Internal("trace_glBindVertexBuffer","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBindVertexBuffer(bindingindex, buffer, offset, stride);
}

static void REGAL_CALL trace_glVertexAttribBinding(GLuint attribindex, GLuint bindingindex)
{
  Internal("trace_glVertexAttribBinding","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribBinding(attribindex, bindingindex);
}

static void REGAL_CALL trace_glVertexAttribFormat(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset)
{
  Internal("trace_glVertexAttribFormat","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribFormat(attribindex, size, type, normalized, relativeoffset);
}

static void REGAL_CALL trace_glVertexAttribIFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset)
{
  Internal("trace_glVertexAttribIFormat","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribIFormat(attribindex, size, type, relativeoffset);
}

static void REGAL_CALL trace_glVertexAttribLFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset)
{
  Internal("trace_glVertexAttribLFormat","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribLFormat(attribindex, size, type, relativeoffset);
}

static void REGAL_CALL trace_glVertexBindingDivisor(GLuint bindingindex, GLuint divisor)
{
  Internal("trace_glVertexBindingDivisor","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexBindingDivisor(bindingindex, divisor);
}

// GL_ARB_vertex_blend

static void REGAL_CALL trace_glVertexBlendARB(GLint count)
{
  Internal("trace_glVertexBlendARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexBlendARB(count);
}

static void REGAL_CALL trace_glWeightPointerARB(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
  Internal("trace_glWeightPointerARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWeightPointerARB(size, type, stride, pointer);
}

static void REGAL_CALL trace_glWeightbvARB(GLint size, const GLbyte *weights)
{
  Internal("trace_glWeightbvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWeightbvARB(size, weights);
}

static void REGAL_CALL trace_glWeightdvARB(GLint size, const GLdouble *weights)
{
  Internal("trace_glWeightdvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWeightdvARB(size, weights);
}

static void REGAL_CALL trace_glWeightfvARB(GLint size, const GLfloat *weights)
{
  Internal("trace_glWeightfvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWeightfvARB(size, weights);
}

static void REGAL_CALL trace_glWeightivARB(GLint size, const GLint *weights)
{
  Internal("trace_glWeightivARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWeightivARB(size, weights);
}

static void REGAL_CALL trace_glWeightsvARB(GLint size, const GLshort *weights)
{
  Internal("trace_glWeightsvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWeightsvARB(size, weights);
}

static void REGAL_CALL trace_glWeightubvARB(GLint size, const GLubyte *weights)
{
  Internal("trace_glWeightubvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWeightubvARB(size, weights);
}

static void REGAL_CALL trace_glWeightuivARB(GLint size, const GLuint *weights)
{
  Internal("trace_glWeightuivARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWeightuivARB(size, weights);
}

static void REGAL_CALL trace_glWeightusvARB(GLint size, const GLushort *weights)
{
  Internal("trace_glWeightusvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWeightusvARB(size, weights);
}

// GL_ARB_vertex_buffer_object

static void REGAL_CALL trace_glBindBufferARB(GLenum target, GLuint buffer)
{
  Internal("trace_glBindBufferARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBindBufferARB(target, buffer);
}

static void REGAL_CALL trace_glBufferDataARB(GLenum target, GLsizeiptrARB size, const GLvoid *data, GLenum usage)
{
  Internal("trace_glBufferDataARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBufferDataARB(target, size, data, usage);
}

static void REGAL_CALL trace_glBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid *data)
{
  Internal("trace_glBufferSubDataARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBufferSubDataARB(target, offset, size, data);
}

static void REGAL_CALL trace_glDeleteBuffersARB(GLsizei n, const GLuint *buffers)
{
  Internal("trace_glDeleteBuffersARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDeleteBuffersARB(n, buffers);
}

static void REGAL_CALL trace_glGenBuffersARB(GLsizei n, GLuint *buffers)
{
  Internal("trace_glGenBuffersARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGenBuffersARB(n, buffers);
}

static void REGAL_CALL trace_glGetBufferParameterivARB(GLenum target, GLenum pname, GLint *params)
{
  Internal("trace_glGetBufferParameterivARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetBufferParameterivARB(target, pname, params);
}

static void REGAL_CALL trace_glGetBufferPointervARB(GLenum target, GLenum pname, GLvoid **params)
{
  Internal("trace_glGetBufferPointervARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetBufferPointervARB(target, pname, params);
}

static void REGAL_CALL trace_glGetBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, GLvoid *data)
{
  Internal("trace_glGetBufferSubDataARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetBufferSubDataARB(target, offset, size, data);
}

static GLboolean REGAL_CALL trace_glIsBufferARB(GLuint buffer)
{
  Internal("trace_glIsBufferARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glIsBufferARB(buffer);
  return ret;
}

static GLvoid *REGAL_CALL trace_glMapBufferARB(GLenum target, GLenum access)
{
  Internal("trace_glMapBufferARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLvoid * ret = Trace::glMapBufferARB(target, access);
  return ret;
}

static GLboolean REGAL_CALL trace_glUnmapBufferARB(GLenum target)
{
  Internal("trace_glUnmapBufferARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glUnmapBufferARB(target);
  return ret;
}

// GL_ARB_vertex_program

static void REGAL_CALL trace_glBindProgramARB(GLenum target, GLuint program)
{
  Internal("trace_glBindProgramARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBindProgramARB(target, program);
}

static void REGAL_CALL trace_glDeleteProgramsARB(GLsizei n, const GLuint *programs)
{
  Internal("trace_glDeleteProgramsARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDeleteProgramsARB(n, programs);
}

static void REGAL_CALL trace_glDisableVertexAttribArrayARB(GLuint index)
{
  Internal("trace_glDisableVertexAttribArrayARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDisableVertexAttribArrayARB(index);
}

static void REGAL_CALL trace_glEnableVertexAttribArrayARB(GLuint index)
{
  Internal("trace_glEnableVertexAttribArrayARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glEnableVertexAttribArrayARB(index);
}

static void REGAL_CALL trace_glGenProgramsARB(GLsizei n, GLuint *programs)
{
  Internal("trace_glGenProgramsARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGenProgramsARB(n, programs);
}

static void REGAL_CALL trace_glGetProgramEnvParameterdvARB(GLenum target, GLuint index, GLdouble *params)
{
  Internal("trace_glGetProgramEnvParameterdvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetProgramEnvParameterdvARB(target, index, params);
}

static void REGAL_CALL trace_glGetProgramEnvParameterfvARB(GLenum target, GLuint index, GLfloat *params)
{
  Internal("trace_glGetProgramEnvParameterfvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetProgramEnvParameterfvARB(target, index, params);
}

static void REGAL_CALL trace_glGetProgramLocalParameterdvARB(GLenum target, GLuint index, GLdouble *params)
{
  Internal("trace_glGetProgramLocalParameterdvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetProgramLocalParameterdvARB(target, index, params);
}

static void REGAL_CALL trace_glGetProgramLocalParameterfvARB(GLenum target, GLuint index, GLfloat *params)
{
  Internal("trace_glGetProgramLocalParameterfvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetProgramLocalParameterfvARB(target, index, params);
}

static void REGAL_CALL trace_glGetProgramStringARB(GLenum target, GLenum pname, GLvoid *string)
{
  Internal("trace_glGetProgramStringARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetProgramStringARB(target, pname, string);
}

static void REGAL_CALL trace_glGetProgramivARB(GLenum target, GLenum pname, GLint *params)
{
  Internal("trace_glGetProgramivARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetProgramivARB(target, pname, params);
}

static void REGAL_CALL trace_glGetVertexAttribPointervARB(GLuint index, GLenum pname, GLvoid **pointer)
{
  Internal("trace_glGetVertexAttribPointervARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetVertexAttribPointervARB(index, pname, pointer);
}

static void REGAL_CALL trace_glGetVertexAttribdvARB(GLuint index, GLenum pname, GLdouble *params)
{
  Internal("trace_glGetVertexAttribdvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetVertexAttribdvARB(index, pname, params);
}

static void REGAL_CALL trace_glGetVertexAttribfvARB(GLuint index, GLenum pname, GLfloat *params)
{
  Internal("trace_glGetVertexAttribfvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetVertexAttribfvARB(index, pname, params);
}

static void REGAL_CALL trace_glGetVertexAttribivARB(GLuint index, GLenum pname, GLint *params)
{
  Internal("trace_glGetVertexAttribivARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetVertexAttribivARB(index, pname, params);
}

static GLboolean REGAL_CALL trace_glIsProgramARB(GLuint program)
{
  Internal("trace_glIsProgramARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glIsProgramARB(program);
  return ret;
}

static void REGAL_CALL trace_glProgramEnvParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  Internal("trace_glProgramEnvParameter4dARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramEnvParameter4dARB(target, index, x, y, z, w);
}

static void REGAL_CALL trace_glProgramEnvParameter4dvARB(GLenum target, GLuint index, const GLdouble *params)
{
  Internal("trace_glProgramEnvParameter4dvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramEnvParameter4dvARB(target, index, params);
}

static void REGAL_CALL trace_glProgramEnvParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  Internal("trace_glProgramEnvParameter4fARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramEnvParameter4fARB(target, index, x, y, z, w);
}

static void REGAL_CALL trace_glProgramEnvParameter4fvARB(GLenum target, GLuint index, const GLfloat *params)
{
  Internal("trace_glProgramEnvParameter4fvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramEnvParameter4fvARB(target, index, params);
}

static void REGAL_CALL trace_glProgramLocalParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  Internal("trace_glProgramLocalParameter4dARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramLocalParameter4dARB(target, index, x, y, z, w);
}

static void REGAL_CALL trace_glProgramLocalParameter4dvARB(GLenum target, GLuint index, const GLdouble *params)
{
  Internal("trace_glProgramLocalParameter4dvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramLocalParameter4dvARB(target, index, params);
}

static void REGAL_CALL trace_glProgramLocalParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  Internal("trace_glProgramLocalParameter4fARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramLocalParameter4fARB(target, index, x, y, z, w);
}

static void REGAL_CALL trace_glProgramLocalParameter4fvARB(GLenum target, GLuint index, const GLfloat *params)
{
  Internal("trace_glProgramLocalParameter4fvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramLocalParameter4fvARB(target, index, params);
}

static void REGAL_CALL trace_glProgramStringARB(GLenum target, GLenum format, GLsizei len, const GLvoid *string)
{
  Internal("trace_glProgramStringARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramStringARB(target, format, len, string);
}

static void REGAL_CALL trace_glVertexAttrib1dARB(GLuint index, GLdouble x)
{
  Internal("trace_glVertexAttrib1dARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib1dARB(index, x);
}

static void REGAL_CALL trace_glVertexAttrib1dvARB(GLuint index, const GLdouble *v)
{
  Internal("trace_glVertexAttrib1dvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib1dvARB(index, v);
}

static void REGAL_CALL trace_glVertexAttrib1fARB(GLuint index, GLfloat x)
{
  Internal("trace_glVertexAttrib1fARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib1fARB(index, x);
}

static void REGAL_CALL trace_glVertexAttrib1fvARB(GLuint index, const GLfloat *v)
{
  Internal("trace_glVertexAttrib1fvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib1fvARB(index, v);
}

static void REGAL_CALL trace_glVertexAttrib1sARB(GLuint index, GLshort x)
{
  Internal("trace_glVertexAttrib1sARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib1sARB(index, x);
}

static void REGAL_CALL trace_glVertexAttrib1svARB(GLuint index, const GLshort *v)
{
  Internal("trace_glVertexAttrib1svARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib1svARB(index, v);
}

static void REGAL_CALL trace_glVertexAttrib2dARB(GLuint index, GLdouble x, GLdouble y)
{
  Internal("trace_glVertexAttrib2dARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib2dARB(index, x, y);
}

static void REGAL_CALL trace_glVertexAttrib2dvARB(GLuint index, const GLdouble *v)
{
  Internal("trace_glVertexAttrib2dvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib2dvARB(index, v);
}

static void REGAL_CALL trace_glVertexAttrib2fARB(GLuint index, GLfloat x, GLfloat y)
{
  Internal("trace_glVertexAttrib2fARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib2fARB(index, x, y);
}

static void REGAL_CALL trace_glVertexAttrib2fvARB(GLuint index, const GLfloat *v)
{
  Internal("trace_glVertexAttrib2fvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib2fvARB(index, v);
}

static void REGAL_CALL trace_glVertexAttrib2sARB(GLuint index, GLshort x, GLshort y)
{
  Internal("trace_glVertexAttrib2sARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib2sARB(index, x, y);
}

static void REGAL_CALL trace_glVertexAttrib2svARB(GLuint index, const GLshort *v)
{
  Internal("trace_glVertexAttrib2svARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib2svARB(index, v);
}

static void REGAL_CALL trace_glVertexAttrib3dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z)
{
  Internal("trace_glVertexAttrib3dARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib3dARB(index, x, y, z);
}

static void REGAL_CALL trace_glVertexAttrib3dvARB(GLuint index, const GLdouble *v)
{
  Internal("trace_glVertexAttrib3dvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib3dvARB(index, v);
}

static void REGAL_CALL trace_glVertexAttrib3fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z)
{
  Internal("trace_glVertexAttrib3fARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib3fARB(index, x, y, z);
}

static void REGAL_CALL trace_glVertexAttrib3fvARB(GLuint index, const GLfloat *v)
{
  Internal("trace_glVertexAttrib3fvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib3fvARB(index, v);
}

static void REGAL_CALL trace_glVertexAttrib3sARB(GLuint index, GLshort x, GLshort y, GLshort z)
{
  Internal("trace_glVertexAttrib3sARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib3sARB(index, x, y, z);
}

static void REGAL_CALL trace_glVertexAttrib3svARB(GLuint index, const GLshort *v)
{
  Internal("trace_glVertexAttrib3svARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib3svARB(index, v);
}

static void REGAL_CALL trace_glVertexAttrib4NbvARB(GLuint index, const GLbyte *v)
{
  Internal("trace_glVertexAttrib4NbvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib4NbvARB(index, v);
}

static void REGAL_CALL trace_glVertexAttrib4NivARB(GLuint index, const GLint *v)
{
  Internal("trace_glVertexAttrib4NivARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib4NivARB(index, v);
}

static void REGAL_CALL trace_glVertexAttrib4NsvARB(GLuint index, const GLshort *v)
{
  Internal("trace_glVertexAttrib4NsvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib4NsvARB(index, v);
}

static void REGAL_CALL trace_glVertexAttrib4NubARB(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
{
  Internal("trace_glVertexAttrib4NubARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib4NubARB(index, x, y, z, w);
}

static void REGAL_CALL trace_glVertexAttrib4NubvARB(GLuint index, const GLubyte *v)
{
  Internal("trace_glVertexAttrib4NubvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib4NubvARB(index, v);
}

static void REGAL_CALL trace_glVertexAttrib4NuivARB(GLuint index, const GLuint *v)
{
  Internal("trace_glVertexAttrib4NuivARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib4NuivARB(index, v);
}

static void REGAL_CALL trace_glVertexAttrib4NusvARB(GLuint index, const GLushort *v)
{
  Internal("trace_glVertexAttrib4NusvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib4NusvARB(index, v);
}

static void REGAL_CALL trace_glVertexAttrib4bvARB(GLuint index, const GLbyte *v)
{
  Internal("trace_glVertexAttrib4bvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib4bvARB(index, v);
}

static void REGAL_CALL trace_glVertexAttrib4dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  Internal("trace_glVertexAttrib4dARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib4dARB(index, x, y, z, w);
}

static void REGAL_CALL trace_glVertexAttrib4dvARB(GLuint index, const GLdouble *v)
{
  Internal("trace_glVertexAttrib4dvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib4dvARB(index, v);
}

static void REGAL_CALL trace_glVertexAttrib4fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  Internal("trace_glVertexAttrib4fARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib4fARB(index, x, y, z, w);
}

static void REGAL_CALL trace_glVertexAttrib4fvARB(GLuint index, const GLfloat *v)
{
  Internal("trace_glVertexAttrib4fvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib4fvARB(index, v);
}

static void REGAL_CALL trace_glVertexAttrib4ivARB(GLuint index, const GLint *v)
{
  Internal("trace_glVertexAttrib4ivARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib4ivARB(index, v);
}

static void REGAL_CALL trace_glVertexAttrib4sARB(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
{
  Internal("trace_glVertexAttrib4sARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib4sARB(index, x, y, z, w);
}

static void REGAL_CALL trace_glVertexAttrib4svARB(GLuint index, const GLshort *v)
{
  Internal("trace_glVertexAttrib4svARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib4svARB(index, v);
}

static void REGAL_CALL trace_glVertexAttrib4ubvARB(GLuint index, const GLubyte *v)
{
  Internal("trace_glVertexAttrib4ubvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib4ubvARB(index, v);
}

static void REGAL_CALL trace_glVertexAttrib4uivARB(GLuint index, const GLuint *v)
{
  Internal("trace_glVertexAttrib4uivARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib4uivARB(index, v);
}

static void REGAL_CALL trace_glVertexAttrib4usvARB(GLuint index, const GLushort *v)
{
  Internal("trace_glVertexAttrib4usvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib4usvARB(index, v);
}

static void REGAL_CALL trace_glVertexAttribPointerARB(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer)
{
  Internal("trace_glVertexAttribPointerARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribPointerARB(index, size, type, normalized, stride, pointer);
}

// GL_ARB_vertex_shader

static void REGAL_CALL trace_glBindAttribLocationARB(GLhandleARB programObj, GLuint index, const GLcharARB *name)
{
  Internal("trace_glBindAttribLocationARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBindAttribLocationARB(programObj, index, name);
}

static void REGAL_CALL trace_glGetActiveAttribARB(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name)
{
  Internal("trace_glGetActiveAttribARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetActiveAttribARB(programObj, index, maxLength, length, size, type, name);
}

static GLint REGAL_CALL trace_glGetAttribLocationARB(GLhandleARB programObj, const GLcharARB *name)
{
  Internal("trace_glGetAttribLocationARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLint  ret = Trace::glGetAttribLocationARB(programObj, name);
  return ret;
}

// GL_ARB_vertex_type_2_10_10_10_rev

static void REGAL_CALL trace_glColorP3ui(GLenum type, GLuint color)
{
  Internal("trace_glColorP3ui","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColorP3ui(type, color);
}

static void REGAL_CALL trace_glColorP3uiv(GLenum type, const GLuint *color)
{
  Internal("trace_glColorP3uiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColorP3uiv(type, color);
}

static void REGAL_CALL trace_glColorP4ui(GLenum type, GLuint color)
{
  Internal("trace_glColorP4ui","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColorP4ui(type, color);
}

static void REGAL_CALL trace_glColorP4uiv(GLenum type, const GLuint *color)
{
  Internal("trace_glColorP4uiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColorP4uiv(type, color);
}

static void REGAL_CALL trace_glMultiTexCoordP1ui(GLenum texture, GLenum type, GLuint coords)
{
  Internal("trace_glMultiTexCoordP1ui","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoordP1ui(texture, type, coords);
}

static void REGAL_CALL trace_glMultiTexCoordP1uiv(GLenum texture, GLenum type, const GLuint *coords)
{
  Internal("trace_glMultiTexCoordP1uiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoordP1uiv(texture, type, coords);
}

static void REGAL_CALL trace_glMultiTexCoordP2ui(GLenum texture, GLenum type, GLuint coords)
{
  Internal("trace_glMultiTexCoordP2ui","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoordP2ui(texture, type, coords);
}

static void REGAL_CALL trace_glMultiTexCoordP2uiv(GLenum texture, GLenum type, const GLuint *coords)
{
  Internal("trace_glMultiTexCoordP2uiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoordP2uiv(texture, type, coords);
}

static void REGAL_CALL trace_glMultiTexCoordP3ui(GLenum texture, GLenum type, GLuint coords)
{
  Internal("trace_glMultiTexCoordP3ui","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoordP3ui(texture, type, coords);
}

static void REGAL_CALL trace_glMultiTexCoordP3uiv(GLenum texture, GLenum type, const GLuint *coords)
{
  Internal("trace_glMultiTexCoordP3uiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoordP3uiv(texture, type, coords);
}

static void REGAL_CALL trace_glMultiTexCoordP4ui(GLenum texture, GLenum type, GLuint coords)
{
  Internal("trace_glMultiTexCoordP4ui","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoordP4ui(texture, type, coords);
}

static void REGAL_CALL trace_glMultiTexCoordP4uiv(GLenum texture, GLenum type, const GLuint *coords)
{
  Internal("trace_glMultiTexCoordP4uiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoordP4uiv(texture, type, coords);
}

static void REGAL_CALL trace_glNormalP3ui(GLenum type, GLuint coords)
{
  Internal("trace_glNormalP3ui","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNormalP3ui(type, coords);
}

static void REGAL_CALL trace_glNormalP3uiv(GLenum type, const GLuint *coords)
{
  Internal("trace_glNormalP3uiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNormalP3uiv(type, coords);
}

static void REGAL_CALL trace_glSecondaryColorP3ui(GLenum type, GLuint color)
{
  Internal("trace_glSecondaryColorP3ui","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSecondaryColorP3ui(type, color);
}

static void REGAL_CALL trace_glSecondaryColorP3uiv(GLenum type, const GLuint *color)
{
  Internal("trace_glSecondaryColorP3uiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSecondaryColorP3uiv(type, color);
}

static void REGAL_CALL trace_glTexCoordP1ui(GLenum type, GLuint coords)
{
  Internal("trace_glTexCoordP1ui","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoordP1ui(type, coords);
}

static void REGAL_CALL trace_glTexCoordP1uiv(GLenum type, const GLuint *coords)
{
  Internal("trace_glTexCoordP1uiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoordP1uiv(type, coords);
}

static void REGAL_CALL trace_glTexCoordP2ui(GLenum type, GLuint coords)
{
  Internal("trace_glTexCoordP2ui","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoordP2ui(type, coords);
}

static void REGAL_CALL trace_glTexCoordP2uiv(GLenum type, const GLuint *coords)
{
  Internal("trace_glTexCoordP2uiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoordP2uiv(type, coords);
}

static void REGAL_CALL trace_glTexCoordP3ui(GLenum type, GLuint coords)
{
  Internal("trace_glTexCoordP3ui","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoordP3ui(type, coords);
}

static void REGAL_CALL trace_glTexCoordP3uiv(GLenum type, const GLuint *coords)
{
  Internal("trace_glTexCoordP3uiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoordP3uiv(type, coords);
}

static void REGAL_CALL trace_glTexCoordP4ui(GLenum type, GLuint coords)
{
  Internal("trace_glTexCoordP4ui","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoordP4ui(type, coords);
}

static void REGAL_CALL trace_glTexCoordP4uiv(GLenum type, const GLuint *coords)
{
  Internal("trace_glTexCoordP4uiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoordP4uiv(type, coords);
}

static void REGAL_CALL trace_glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value)
{
  Internal("trace_glVertexAttribP1ui","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribP1ui(index, type, normalized, value);
}

static void REGAL_CALL trace_glVertexAttribP1uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint *value)
{
  Internal("trace_glVertexAttribP1uiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribP1uiv(index, type, normalized, value);
}

static void REGAL_CALL trace_glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value)
{
  Internal("trace_glVertexAttribP2ui","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribP2ui(index, type, normalized, value);
}

static void REGAL_CALL trace_glVertexAttribP2uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint *value)
{
  Internal("trace_glVertexAttribP2uiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribP2uiv(index, type, normalized, value);
}

static void REGAL_CALL trace_glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value)
{
  Internal("trace_glVertexAttribP3ui","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribP3ui(index, type, normalized, value);
}

static void REGAL_CALL trace_glVertexAttribP3uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint *value)
{
  Internal("trace_glVertexAttribP3uiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribP3uiv(index, type, normalized, value);
}

static void REGAL_CALL trace_glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value)
{
  Internal("trace_glVertexAttribP4ui","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribP4ui(index, type, normalized, value);
}

static void REGAL_CALL trace_glVertexAttribP4uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint *value)
{
  Internal("trace_glVertexAttribP4uiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribP4uiv(index, type, normalized, value);
}

static void REGAL_CALL trace_glVertexP2ui(GLenum type, GLuint coords)
{
  Internal("trace_glVertexP2ui","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexP2ui(type, coords);
}

static void REGAL_CALL trace_glVertexP2uiv(GLenum type, const GLuint *coords)
{
  Internal("trace_glVertexP2uiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexP2uiv(type, coords);
}

static void REGAL_CALL trace_glVertexP3ui(GLenum type, GLuint coords)
{
  Internal("trace_glVertexP3ui","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexP3ui(type, coords);
}

static void REGAL_CALL trace_glVertexP3uiv(GLenum type, const GLuint *coords)
{
  Internal("trace_glVertexP3uiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexP3uiv(type, coords);
}

static void REGAL_CALL trace_glVertexP4ui(GLenum type, GLuint coords)
{
  Internal("trace_glVertexP4ui","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexP4ui(type, coords);
}

static void REGAL_CALL trace_glVertexP4uiv(GLenum type, const GLuint *coords)
{
  Internal("trace_glVertexP4uiv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexP4uiv(type, coords);
}

// GL_ARB_viewport_array

static void REGAL_CALL trace_glDepthRangeArrayv(GLuint first, GLsizei count, const GLclampd *v)
{
  Internal("trace_glDepthRangeArrayv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDepthRangeArrayv(first, count, v);
}

static void REGAL_CALL trace_glDepthRangeIndexed(GLuint index, GLclampd n, GLclampd f)
{
  Internal("trace_glDepthRangeIndexed","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDepthRangeIndexed(index, n, f);
}

static void REGAL_CALL trace_glGetDoublei_v(GLenum target, GLuint index, GLdouble *v)
{
  Internal("trace_glGetDoublei_v","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetDoublei_v(target, index, v);
}

static void REGAL_CALL trace_glGetFloati_v(GLenum target, GLuint index, GLfloat *v)
{
  Internal("trace_glGetFloati_v","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetFloati_v(target, index, v);
}

static void REGAL_CALL trace_glScissorArrayv(GLuint first, GLsizei count, const GLint *v)
{
  Internal("trace_glScissorArrayv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glScissorArrayv(first, count, v);
}

static void REGAL_CALL trace_glScissorIndexed(GLuint index, GLint left, GLint bottom, GLint width, GLint height)
{
  Internal("trace_glScissorIndexed","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glScissorIndexed(index, left, bottom, width, height);
}

static void REGAL_CALL trace_glScissorIndexedv(GLuint index, const GLint *v)
{
  Internal("trace_glScissorIndexedv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glScissorIndexedv(index, v);
}

static void REGAL_CALL trace_glViewportArrayv(GLuint first, GLsizei count, const GLfloat *v)
{
  Internal("trace_glViewportArrayv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glViewportArrayv(first, count, v);
}

static void REGAL_CALL trace_glViewportIndexedf(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h)
{
  Internal("trace_glViewportIndexedf","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glViewportIndexedf(index, x, y, w, h);
}

static void REGAL_CALL trace_glViewportIndexedfv(GLuint index, const GLfloat *v)
{
  Internal("trace_glViewportIndexedfv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glViewportIndexedfv(index, v);
}

// GL_ARB_window_pos

static void REGAL_CALL trace_glWindowPos2dARB(GLdouble x, GLdouble y)
{
  Internal("trace_glWindowPos2dARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos2dARB(x, y);
}

static void REGAL_CALL trace_glWindowPos2dvARB(const GLdouble *p)
{
  Internal("trace_glWindowPos2dvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos2dvARB(p);
}

static void REGAL_CALL trace_glWindowPos2fARB(GLfloat x, GLfloat y)
{
  Internal("trace_glWindowPos2fARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos2fARB(x, y);
}

static void REGAL_CALL trace_glWindowPos2fvARB(const GLfloat *p)
{
  Internal("trace_glWindowPos2fvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos2fvARB(p);
}

static void REGAL_CALL trace_glWindowPos2iARB(GLint x, GLint y)
{
  Internal("trace_glWindowPos2iARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos2iARB(x, y);
}

static void REGAL_CALL trace_glWindowPos2ivARB(const GLint *p)
{
  Internal("trace_glWindowPos2ivARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos2ivARB(p);
}

static void REGAL_CALL trace_glWindowPos2sARB(GLshort x, GLshort y)
{
  Internal("trace_glWindowPos2sARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos2sARB(x, y);
}

static void REGAL_CALL trace_glWindowPos2svARB(const GLshort *p)
{
  Internal("trace_glWindowPos2svARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos2svARB(p);
}

static void REGAL_CALL trace_glWindowPos3dARB(GLdouble x, GLdouble y, GLdouble z)
{
  Internal("trace_glWindowPos3dARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos3dARB(x, y, z);
}

static void REGAL_CALL trace_glWindowPos3dvARB(const GLdouble *p)
{
  Internal("trace_glWindowPos3dvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos3dvARB(p);
}

static void REGAL_CALL trace_glWindowPos3fARB(GLfloat x, GLfloat y, GLfloat z)
{
  Internal("trace_glWindowPos3fARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos3fARB(x, y, z);
}

static void REGAL_CALL trace_glWindowPos3fvARB(const GLfloat *p)
{
  Internal("trace_glWindowPos3fvARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos3fvARB(p);
}

static void REGAL_CALL trace_glWindowPos3iARB(GLint x, GLint y, GLint z)
{
  Internal("trace_glWindowPos3iARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos3iARB(x, y, z);
}

static void REGAL_CALL trace_glWindowPos3ivARB(const GLint *p)
{
  Internal("trace_glWindowPos3ivARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos3ivARB(p);
}

static void REGAL_CALL trace_glWindowPos3sARB(GLshort x, GLshort y, GLshort z)
{
  Internal("trace_glWindowPos3sARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos3sARB(x, y, z);
}

static void REGAL_CALL trace_glWindowPos3svARB(const GLshort *p)
{
  Internal("trace_glWindowPos3svARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos3svARB(p);
}

// GL_ATI_draw_buffers

static void REGAL_CALL trace_glDrawBuffersATI(GLsizei n, const GLenum *bufs)
{
  Internal("trace_glDrawBuffersATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDrawBuffersATI(n, bufs);
}

// GL_ATI_element_array

static void REGAL_CALL trace_glDrawElementArrayATI(GLenum mode, GLsizei count)
{
  Internal("trace_glDrawElementArrayATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDrawElementArrayATI(mode, count);
}

static void REGAL_CALL trace_glDrawRangeElementArrayATI(GLenum mode, GLuint start, GLuint end, GLsizei count)
{
  Internal("trace_glDrawRangeElementArrayATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDrawRangeElementArrayATI(mode, start, end, count);
}

static void REGAL_CALL trace_glElementPointerATI(GLenum type, const GLvoid *pointer)
{
  Internal("trace_glElementPointerATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glElementPointerATI(type, pointer);
}

// GL_ATI_envmap_bumpmap

static void REGAL_CALL trace_glGetTexBumpParameterfvATI(GLenum pname, GLfloat *param)
{
  Internal("trace_glGetTexBumpParameterfvATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetTexBumpParameterfvATI(pname, param);
}

static void REGAL_CALL trace_glGetTexBumpParameterivATI(GLenum pname, GLint *param)
{
  Internal("trace_glGetTexBumpParameterivATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetTexBumpParameterivATI(pname, param);
}

static void REGAL_CALL trace_glTexBumpParameterfvATI(GLenum pname, const GLfloat *param)
{
  Internal("trace_glTexBumpParameterfvATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexBumpParameterfvATI(pname, param);
}

static void REGAL_CALL trace_glTexBumpParameterivATI(GLenum pname, const GLint *param)
{
  Internal("trace_glTexBumpParameterivATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexBumpParameterivATI(pname, param);
}

// GL_ATI_fragment_shader

static void REGAL_CALL trace_glAlphaFragmentOp1ATI(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod)
{
  Internal("trace_glAlphaFragmentOp1ATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glAlphaFragmentOp1ATI(op, dst, dstMod, arg1, arg1Rep, arg1Mod);
}

static void REGAL_CALL trace_glAlphaFragmentOp2ATI(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod)
{
  Internal("trace_glAlphaFragmentOp2ATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glAlphaFragmentOp2ATI(op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);
}

static void REGAL_CALL trace_glAlphaFragmentOp3ATI(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod)
{
  Internal("trace_glAlphaFragmentOp3ATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glAlphaFragmentOp3ATI(op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);
}

static void REGAL_CALL trace_glBeginFragmentShaderATI(void)
{
  Internal("trace_glBeginFragmentShaderATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBeginFragmentShaderATI();
}

static void REGAL_CALL trace_glBindFragmentShaderATI(GLuint id)
{
  Internal("trace_glBindFragmentShaderATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBindFragmentShaderATI(id);
}

static void REGAL_CALL trace_glColorFragmentOp1ATI(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod)
{
  Internal("trace_glColorFragmentOp1ATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColorFragmentOp1ATI(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod);
}

static void REGAL_CALL trace_glColorFragmentOp2ATI(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod)
{
  Internal("trace_glColorFragmentOp2ATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColorFragmentOp2ATI(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);
}

static void REGAL_CALL trace_glColorFragmentOp3ATI(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod)
{
  Internal("trace_glColorFragmentOp3ATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColorFragmentOp3ATI(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);
}

static void REGAL_CALL trace_glDeleteFragmentShaderATI(GLuint id)
{
  Internal("trace_glDeleteFragmentShaderATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDeleteFragmentShaderATI(id);
}

static void REGAL_CALL trace_glEndFragmentShaderATI(void)
{
  Internal("trace_glEndFragmentShaderATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glEndFragmentShaderATI();
}

static GLuint REGAL_CALL trace_glGenFragmentShadersATI(GLuint range)
{
  Internal("trace_glGenFragmentShadersATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLuint  ret = Trace::glGenFragmentShadersATI(range);
  return ret;
}

static void REGAL_CALL trace_glPassTexCoordATI(GLuint dst, GLuint coord, GLenum swizzle)
{
  Internal("trace_glPassTexCoordATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPassTexCoordATI(dst, coord, swizzle);
}

static void REGAL_CALL trace_glSampleMapATI(GLuint dst, GLuint interp, GLenum swizzle)
{
  Internal("trace_glSampleMapATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSampleMapATI(dst, interp, swizzle);
}

static void REGAL_CALL trace_glSetFragmentShaderConstantATI(GLuint dst, const GLfloat *value)
{
  Internal("trace_glSetFragmentShaderConstantATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSetFragmentShaderConstantATI(dst, value);
}

// GL_ATI_map_object_buffer

static GLvoid *REGAL_CALL trace_glMapObjectBufferATI(GLuint buffer)
{
  Internal("trace_glMapObjectBufferATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLvoid * ret = Trace::glMapObjectBufferATI(buffer);
  return ret;
}

static void REGAL_CALL trace_glUnmapObjectBufferATI(GLuint buffer)
{
  Internal("trace_glUnmapObjectBufferATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUnmapObjectBufferATI(buffer);
}

// GL_ATI_pn_triangles

static void REGAL_CALL trace_glPNTrianglesfATI(GLenum pname, GLfloat param)
{
  Internal("trace_glPNTrianglesfATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPNTrianglesfATI(pname, param);
}

static void REGAL_CALL trace_glPNTrianglesiATI(GLenum pname, GLint param)
{
  Internal("trace_glPNTrianglesiATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPNTrianglesiATI(pname, param);
}

// GL_ATI_separate_stencil

static void REGAL_CALL trace_glStencilFuncSeparateATI(GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask)
{
  Internal("trace_glStencilFuncSeparateATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glStencilFuncSeparateATI(frontfunc, backfunc, ref, mask);
}

static void REGAL_CALL trace_glStencilOpSeparateATI(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass)
{
  Internal("trace_glStencilOpSeparateATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glStencilOpSeparateATI(face, sfail, dpfail, dppass);
}

// GL_ATI_vertex_array_object

static void REGAL_CALL trace_glArrayObjectATI(GLenum array, GLint size, GLenum type, GLsizei stride, GLuint buffer, GLuint offset)
{
  Internal("trace_glArrayObjectATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glArrayObjectATI(array, size, type, stride, buffer, offset);
}

static void REGAL_CALL trace_glFreeObjectBufferATI(GLuint buffer)
{
  Internal("trace_glFreeObjectBufferATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFreeObjectBufferATI(buffer);
}

static void REGAL_CALL trace_glGetArrayObjectfvATI(GLenum array, GLenum pname, GLfloat *params)
{
  Internal("trace_glGetArrayObjectfvATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetArrayObjectfvATI(array, pname, params);
}

static void REGAL_CALL trace_glGetArrayObjectivATI(GLenum array, GLenum pname, GLint *params)
{
  Internal("trace_glGetArrayObjectivATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetArrayObjectivATI(array, pname, params);
}

static void REGAL_CALL trace_glGetObjectBufferfvATI(GLuint buffer, GLenum pname, GLfloat *params)
{
  Internal("trace_glGetObjectBufferfvATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetObjectBufferfvATI(buffer, pname, params);
}

static void REGAL_CALL trace_glGetObjectBufferivATI(GLuint buffer, GLenum pname, GLint *params)
{
  Internal("trace_glGetObjectBufferivATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetObjectBufferivATI(buffer, pname, params);
}

static void REGAL_CALL trace_glGetVariantArrayObjectfvATI(GLuint id, GLenum pname, GLfloat *params)
{
  Internal("trace_glGetVariantArrayObjectfvATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetVariantArrayObjectfvATI(id, pname, params);
}

static void REGAL_CALL trace_glGetVariantArrayObjectivATI(GLuint id, GLenum pname, GLint *params)
{
  Internal("trace_glGetVariantArrayObjectivATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetVariantArrayObjectivATI(id, pname, params);
}

static GLboolean REGAL_CALL trace_glIsObjectBufferATI(GLuint buffer)
{
  Internal("trace_glIsObjectBufferATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glIsObjectBufferATI(buffer);
  return ret;
}

static GLuint REGAL_CALL trace_glNewObjectBufferATI(GLsizei size, const GLvoid *pointer, GLenum usage)
{
  Internal("trace_glNewObjectBufferATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLuint  ret = Trace::glNewObjectBufferATI(size, pointer, usage);
  return ret;
}

static void REGAL_CALL trace_glUpdateObjectBufferATI(GLuint buffer, GLuint offset, GLsizei size, const GLvoid *pointer, GLenum preserve)
{
  Internal("trace_glUpdateObjectBufferATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUpdateObjectBufferATI(buffer, offset, size, pointer, preserve);
}

static void REGAL_CALL trace_glVariantArrayObjectATI(GLuint id, GLenum type, GLsizei stride, GLuint buffer, GLuint offset)
{
  Internal("trace_glVariantArrayObjectATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVariantArrayObjectATI(id, type, stride, buffer, offset);
}

// GL_ATI_vertex_attrib_array_object

static void REGAL_CALL trace_glGetVertexAttribArrayObjectfvATI(GLuint index, GLenum pname, GLfloat *params)
{
  Internal("trace_glGetVertexAttribArrayObjectfvATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetVertexAttribArrayObjectfvATI(index, pname, params);
}

static void REGAL_CALL trace_glGetVertexAttribArrayObjectivATI(GLuint index, GLenum pname, GLint *params)
{
  Internal("trace_glGetVertexAttribArrayObjectivATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetVertexAttribArrayObjectivATI(index, pname, params);
}

static void REGAL_CALL trace_glVertexAttribArrayObjectATI(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLuint buffer, GLuint offset)
{
  Internal("trace_glVertexAttribArrayObjectATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribArrayObjectATI(index, size, type, normalized, stride, buffer, offset);
}

// GL_ATI_vertex_streams

static void REGAL_CALL trace_glClientActiveVertexStreamATI(GLenum stream)
{
  Internal("trace_glClientActiveVertexStreamATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glClientActiveVertexStreamATI(stream);
}

static void REGAL_CALL trace_glNormalStream3bATI(GLenum stream, GLbyte x, GLbyte y, GLbyte z)
{
  Internal("trace_glNormalStream3bATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNormalStream3bATI(stream, x, y, z);
}

static void REGAL_CALL trace_glNormalStream3bvATI(GLenum stream, const GLbyte *coords)
{
  Internal("trace_glNormalStream3bvATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNormalStream3bvATI(stream, coords);
}

static void REGAL_CALL trace_glNormalStream3dATI(GLenum stream, GLdouble x, GLdouble y, GLdouble z)
{
  Internal("trace_glNormalStream3dATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNormalStream3dATI(stream, x, y, z);
}

static void REGAL_CALL trace_glNormalStream3dvATI(GLenum stream, const GLdouble *coords)
{
  Internal("trace_glNormalStream3dvATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNormalStream3dvATI(stream, coords);
}

static void REGAL_CALL trace_glNormalStream3fATI(GLenum stream, GLfloat x, GLfloat y, GLfloat z)
{
  Internal("trace_glNormalStream3fATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNormalStream3fATI(stream, x, y, z);
}

static void REGAL_CALL trace_glNormalStream3fvATI(GLenum stream, const GLfloat *coords)
{
  Internal("trace_glNormalStream3fvATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNormalStream3fvATI(stream, coords);
}

static void REGAL_CALL trace_glNormalStream3iATI(GLenum stream, GLint x, GLint y, GLint z)
{
  Internal("trace_glNormalStream3iATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNormalStream3iATI(stream, x, y, z);
}

static void REGAL_CALL trace_glNormalStream3ivATI(GLenum stream, const GLint *coords)
{
  Internal("trace_glNormalStream3ivATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNormalStream3ivATI(stream, coords);
}

static void REGAL_CALL trace_glNormalStream3sATI(GLenum stream, GLshort x, GLshort y, GLshort z)
{
  Internal("trace_glNormalStream3sATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNormalStream3sATI(stream, x, y, z);
}

static void REGAL_CALL trace_glNormalStream3svATI(GLenum stream, const GLshort *coords)
{
  Internal("trace_glNormalStream3svATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNormalStream3svATI(stream, coords);
}

static void REGAL_CALL trace_glVertexBlendEnvfATI(GLenum pname, GLfloat param)
{
  Internal("trace_glVertexBlendEnvfATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexBlendEnvfATI(pname, param);
}

static void REGAL_CALL trace_glVertexBlendEnviATI(GLenum pname, GLint param)
{
  Internal("trace_glVertexBlendEnviATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexBlendEnviATI(pname, param);
}

static void REGAL_CALL trace_glVertexStream1dATI(GLenum stream, GLdouble x)
{
  Internal("trace_glVertexStream1dATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexStream1dATI(stream, x);
}

static void REGAL_CALL trace_glVertexStream1dvATI(GLenum stream, const GLdouble *coords)
{
  Internal("trace_glVertexStream1dvATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexStream1dvATI(stream, coords);
}

static void REGAL_CALL trace_glVertexStream1fATI(GLenum stream, GLfloat x)
{
  Internal("trace_glVertexStream1fATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexStream1fATI(stream, x);
}

static void REGAL_CALL trace_glVertexStream1fvATI(GLenum stream, const GLfloat *coords)
{
  Internal("trace_glVertexStream1fvATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexStream1fvATI(stream, coords);
}

static void REGAL_CALL trace_glVertexStream1iATI(GLenum stream, GLint x)
{
  Internal("trace_glVertexStream1iATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexStream1iATI(stream, x);
}

static void REGAL_CALL trace_glVertexStream1ivATI(GLenum stream, const GLint *coords)
{
  Internal("trace_glVertexStream1ivATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexStream1ivATI(stream, coords);
}

static void REGAL_CALL trace_glVertexStream1sATI(GLenum stream, GLshort x)
{
  Internal("trace_glVertexStream1sATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexStream1sATI(stream, x);
}

static void REGAL_CALL trace_glVertexStream1svATI(GLenum stream, const GLshort *coords)
{
  Internal("trace_glVertexStream1svATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexStream1svATI(stream, coords);
}

static void REGAL_CALL trace_glVertexStream2dATI(GLenum stream, GLdouble x, GLdouble y)
{
  Internal("trace_glVertexStream2dATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexStream2dATI(stream, x, y);
}

static void REGAL_CALL trace_glVertexStream2dvATI(GLenum stream, const GLdouble *coords)
{
  Internal("trace_glVertexStream2dvATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexStream2dvATI(stream, coords);
}

static void REGAL_CALL trace_glVertexStream2fATI(GLenum stream, GLfloat x, GLfloat y)
{
  Internal("trace_glVertexStream2fATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexStream2fATI(stream, x, y);
}

static void REGAL_CALL trace_glVertexStream2fvATI(GLenum stream, const GLfloat *coords)
{
  Internal("trace_glVertexStream2fvATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexStream2fvATI(stream, coords);
}

static void REGAL_CALL trace_glVertexStream2iATI(GLenum stream, GLint x, GLint y)
{
  Internal("trace_glVertexStream2iATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexStream2iATI(stream, x, y);
}

static void REGAL_CALL trace_glVertexStream2ivATI(GLenum stream, const GLint *coords)
{
  Internal("trace_glVertexStream2ivATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexStream2ivATI(stream, coords);
}

static void REGAL_CALL trace_glVertexStream2sATI(GLenum stream, GLshort x, GLshort y)
{
  Internal("trace_glVertexStream2sATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexStream2sATI(stream, x, y);
}

static void REGAL_CALL trace_glVertexStream2svATI(GLenum stream, const GLshort *coords)
{
  Internal("trace_glVertexStream2svATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexStream2svATI(stream, coords);
}

static void REGAL_CALL trace_glVertexStream3dATI(GLenum stream, GLdouble x, GLdouble y, GLdouble z)
{
  Internal("trace_glVertexStream3dATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexStream3dATI(stream, x, y, z);
}

static void REGAL_CALL trace_glVertexStream3dvATI(GLenum stream, const GLdouble *coords)
{
  Internal("trace_glVertexStream3dvATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexStream3dvATI(stream, coords);
}

static void REGAL_CALL trace_glVertexStream3fATI(GLenum stream, GLfloat x, GLfloat y, GLfloat z)
{
  Internal("trace_glVertexStream3fATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexStream3fATI(stream, x, y, z);
}

static void REGAL_CALL trace_glVertexStream3fvATI(GLenum stream, const GLfloat *coords)
{
  Internal("trace_glVertexStream3fvATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexStream3fvATI(stream, coords);
}

static void REGAL_CALL trace_glVertexStream3iATI(GLenum stream, GLint x, GLint y, GLint z)
{
  Internal("trace_glVertexStream3iATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexStream3iATI(stream, x, y, z);
}

static void REGAL_CALL trace_glVertexStream3ivATI(GLenum stream, const GLint *coords)
{
  Internal("trace_glVertexStream3ivATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexStream3ivATI(stream, coords);
}

static void REGAL_CALL trace_glVertexStream3sATI(GLenum stream, GLshort x, GLshort y, GLshort z)
{
  Internal("trace_glVertexStream3sATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexStream3sATI(stream, x, y, z);
}

static void REGAL_CALL trace_glVertexStream3svATI(GLenum stream, const GLshort *coords)
{
  Internal("trace_glVertexStream3svATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexStream3svATI(stream, coords);
}

static void REGAL_CALL trace_glVertexStream4dATI(GLenum stream, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  Internal("trace_glVertexStream4dATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexStream4dATI(stream, x, y, z, w);
}

static void REGAL_CALL trace_glVertexStream4dvATI(GLenum stream, const GLdouble *coords)
{
  Internal("trace_glVertexStream4dvATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexStream4dvATI(stream, coords);
}

static void REGAL_CALL trace_glVertexStream4fATI(GLenum stream, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  Internal("trace_glVertexStream4fATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexStream4fATI(stream, x, y, z, w);
}

static void REGAL_CALL trace_glVertexStream4fvATI(GLenum stream, const GLfloat *coords)
{
  Internal("trace_glVertexStream4fvATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexStream4fvATI(stream, coords);
}

static void REGAL_CALL trace_glVertexStream4iATI(GLenum stream, GLint x, GLint y, GLint z, GLint w)
{
  Internal("trace_glVertexStream4iATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexStream4iATI(stream, x, y, z, w);
}

static void REGAL_CALL trace_glVertexStream4ivATI(GLenum stream, const GLint *coords)
{
  Internal("trace_glVertexStream4ivATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexStream4ivATI(stream, coords);
}

static void REGAL_CALL trace_glVertexStream4sATI(GLenum stream, GLshort x, GLshort y, GLshort z, GLshort w)
{
  Internal("trace_glVertexStream4sATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexStream4sATI(stream, x, y, z, w);
}

static void REGAL_CALL trace_glVertexStream4svATI(GLenum stream, const GLshort *coords)
{
  Internal("trace_glVertexStream4svATI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexStream4svATI(stream, coords);
}

// GL_EXT_bindable_uniform

static GLint REGAL_CALL trace_glGetUniformBufferSizeEXT(GLuint program, GLint location)
{
  Internal("trace_glGetUniformBufferSizeEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLint  ret = Trace::glGetUniformBufferSizeEXT(program, location);
  return ret;
}

static GLintptr REGAL_CALL trace_glGetUniformOffsetEXT(GLuint program, GLint location)
{
  Internal("trace_glGetUniformOffsetEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLintptr  ret = Trace::glGetUniformOffsetEXT(program, location);
  return ret;
}

static void REGAL_CALL trace_glUniformBufferEXT(GLuint program, GLint location, GLuint buffer)
{
  Internal("trace_glUniformBufferEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniformBufferEXT(program, location, buffer);
}

// GL_EXT_blend_color

static void REGAL_CALL trace_glBlendColorEXT(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
{
  Internal("trace_glBlendColorEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBlendColorEXT(red, green, blue, alpha);
}

// GL_EXT_blend_equation_separate

static void REGAL_CALL trace_glBlendEquationSeparateEXT(GLenum modeRGB, GLenum modeAlpha)
{
  Internal("trace_glBlendEquationSeparateEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBlendEquationSeparateEXT(modeRGB, modeAlpha);
}

// GL_EXT_blend_func_separate

static void REGAL_CALL trace_glBlendFuncSeparateEXT(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)
{
  Internal("trace_glBlendFuncSeparateEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBlendFuncSeparateEXT(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
}

// GL_EXT_blend_minmax

static void REGAL_CALL trace_glBlendEquationEXT(GLenum mode)
{
  Internal("trace_glBlendEquationEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBlendEquationEXT(mode);
}

// GL_EXT_color_subtable

static void REGAL_CALL trace_glColorSubTableEXT(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *table)
{
  Internal("trace_glColorSubTableEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColorSubTableEXT(target, start, count, format, type, table);
}

static void REGAL_CALL trace_glCopyColorSubTableEXT(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width)
{
  Internal("trace_glCopyColorSubTableEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCopyColorSubTableEXT(target, start, x, y, width);
}

// GL_EXT_compiled_vertex_array

static void REGAL_CALL trace_glLockArraysEXT(GLint first, GLsizei count)
{
  Internal("trace_glLockArraysEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glLockArraysEXT(first, count);
}

static void REGAL_CALL trace_glUnlockArraysEXT(void)
{
  Internal("trace_glUnlockArraysEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUnlockArraysEXT();
}

// GL_EXT_convolution

static void REGAL_CALL trace_glConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image)
{
  Internal("trace_glConvolutionFilter1DEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glConvolutionFilter1DEXT(target, internalformat, width, format, type, image);
}

static void REGAL_CALL trace_glConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image)
{
  Internal("trace_glConvolutionFilter2DEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glConvolutionFilter2DEXT(target, internalformat, width, height, format, type, image);
}

static void REGAL_CALL trace_glConvolutionParameterfEXT(GLenum target, GLenum pname, GLfloat param)
{
  Internal("trace_glConvolutionParameterfEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glConvolutionParameterfEXT(target, pname, param);
}

static void REGAL_CALL trace_glConvolutionParameterfvEXT(GLenum target, GLenum pname, const GLfloat *params)
{
  Internal("trace_glConvolutionParameterfvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glConvolutionParameterfvEXT(target, pname, params);
}

static void REGAL_CALL trace_glConvolutionParameteriEXT(GLenum target, GLenum pname, GLint param)
{
  Internal("trace_glConvolutionParameteriEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glConvolutionParameteriEXT(target, pname, param);
}

static void REGAL_CALL trace_glConvolutionParameterivEXT(GLenum target, GLenum pname, const GLint *params)
{
  Internal("trace_glConvolutionParameterivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glConvolutionParameterivEXT(target, pname, params);
}

static void REGAL_CALL trace_glCopyConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
{
  Internal("trace_glCopyConvolutionFilter1DEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCopyConvolutionFilter1DEXT(target, internalformat, x, y, width);
}

static void REGAL_CALL trace_glCopyConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height)
{
  Internal("trace_glCopyConvolutionFilter2DEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCopyConvolutionFilter2DEXT(target, internalformat, x, y, width, height);
}

static void REGAL_CALL trace_glGetConvolutionFilterEXT(GLenum target, GLenum format, GLenum type, GLvoid *image)
{
  Internal("trace_glGetConvolutionFilterEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetConvolutionFilterEXT(target, format, type, image);
}

static void REGAL_CALL trace_glGetConvolutionParameterfvEXT(GLenum target, GLenum pname, GLfloat *params)
{
  Internal("trace_glGetConvolutionParameterfvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetConvolutionParameterfvEXT(target, pname, params);
}

static void REGAL_CALL trace_glGetConvolutionParameterivEXT(GLenum target, GLenum pname, GLint *params)
{
  Internal("trace_glGetConvolutionParameterivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetConvolutionParameterivEXT(target, pname, params);
}

static void REGAL_CALL trace_glGetSeparableFilterEXT(GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span)
{
  Internal("trace_glGetSeparableFilterEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetSeparableFilterEXT(target, format, type, row, column, span);
}

static void REGAL_CALL trace_glSeparableFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column)
{
  Internal("trace_glSeparableFilter2DEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSeparableFilter2DEXT(target, internalformat, width, height, format, type, row, column);
}

// GL_EXT_coordinate_frame

static void REGAL_CALL trace_glBinormal3bEXT(GLbyte bx, GLbyte by, GLbyte bz)
{
  Internal("trace_glBinormal3bEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBinormal3bEXT(bx, by, bz);
}

static void REGAL_CALL trace_glBinormal3bvEXT(const GLbyte *v)
{
  Internal("trace_glBinormal3bvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBinormal3bvEXT(v);
}

static void REGAL_CALL trace_glBinormal3dEXT(GLdouble bx, GLdouble by, GLdouble bz)
{
  Internal("trace_glBinormal3dEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBinormal3dEXT(bx, by, bz);
}

static void REGAL_CALL trace_glBinormal3dvEXT(const GLdouble *v)
{
  Internal("trace_glBinormal3dvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBinormal3dvEXT(v);
}

static void REGAL_CALL trace_glBinormal3fEXT(GLfloat bx, GLfloat by, GLfloat bz)
{
  Internal("trace_glBinormal3fEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBinormal3fEXT(bx, by, bz);
}

static void REGAL_CALL trace_glBinormal3fvEXT(const GLfloat *v)
{
  Internal("trace_glBinormal3fvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBinormal3fvEXT(v);
}

static void REGAL_CALL trace_glBinormal3iEXT(GLint bx, GLint by, GLint bz)
{
  Internal("trace_glBinormal3iEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBinormal3iEXT(bx, by, bz);
}

static void REGAL_CALL trace_glBinormal3ivEXT(const GLint *v)
{
  Internal("trace_glBinormal3ivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBinormal3ivEXT(v);
}

static void REGAL_CALL trace_glBinormal3sEXT(GLshort bx, GLshort by, GLshort bz)
{
  Internal("trace_glBinormal3sEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBinormal3sEXT(bx, by, bz);
}

static void REGAL_CALL trace_glBinormal3svEXT(const GLshort *v)
{
  Internal("trace_glBinormal3svEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBinormal3svEXT(v);
}

static void REGAL_CALL trace_glBinormalPointerEXT(GLenum type, GLsizei stride, const GLvoid *pointer)
{
  Internal("trace_glBinormalPointerEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBinormalPointerEXT(type, stride, pointer);
}

static void REGAL_CALL trace_glTangent3bEXT(GLbyte tx, GLbyte ty, GLbyte tz)
{
  Internal("trace_glTangent3bEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTangent3bEXT(tx, ty, tz);
}

static void REGAL_CALL trace_glTangent3bvEXT(const GLbyte *v)
{
  Internal("trace_glTangent3bvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTangent3bvEXT(v);
}

static void REGAL_CALL trace_glTangent3dEXT(GLdouble tx, GLdouble ty, GLdouble tz)
{
  Internal("trace_glTangent3dEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTangent3dEXT(tx, ty, tz);
}

static void REGAL_CALL trace_glTangent3dvEXT(const GLdouble *v)
{
  Internal("trace_glTangent3dvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTangent3dvEXT(v);
}

static void REGAL_CALL trace_glTangent3fEXT(GLfloat tx, GLfloat ty, GLfloat tz)
{
  Internal("trace_glTangent3fEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTangent3fEXT(tx, ty, tz);
}

static void REGAL_CALL trace_glTangent3fvEXT(const GLfloat *v)
{
  Internal("trace_glTangent3fvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTangent3fvEXT(v);
}

static void REGAL_CALL trace_glTangent3iEXT(GLint tx, GLint ty, GLint tz)
{
  Internal("trace_glTangent3iEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTangent3iEXT(tx, ty, tz);
}

static void REGAL_CALL trace_glTangent3ivEXT(const GLint *v)
{
  Internal("trace_glTangent3ivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTangent3ivEXT(v);
}

static void REGAL_CALL trace_glTangent3sEXT(GLshort tx, GLshort ty, GLshort tz)
{
  Internal("trace_glTangent3sEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTangent3sEXT(tx, ty, tz);
}

static void REGAL_CALL trace_glTangent3svEXT(const GLshort *v)
{
  Internal("trace_glTangent3svEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTangent3svEXT(v);
}

static void REGAL_CALL trace_glTangentPointerEXT(GLenum type, GLsizei stride, const GLvoid *pointer)
{
  Internal("trace_glTangentPointerEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTangentPointerEXT(type, stride, pointer);
}

// GL_EXT_copy_texture

static void REGAL_CALL trace_glCopyTexImage1DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
{
  Internal("trace_glCopyTexImage1DEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCopyTexImage1DEXT(target, level, internalformat, x, y, width, border);
}

static void REGAL_CALL trace_glCopyTexImage2DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
{
  Internal("trace_glCopyTexImage2DEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCopyTexImage2DEXT(target, level, internalformat, x, y, width, height, border);
}

static void REGAL_CALL trace_glCopyTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
{
  Internal("trace_glCopyTexSubImage1DEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCopyTexSubImage1DEXT(target, level, xoffset, x, y, width);
}

static void REGAL_CALL trace_glCopyTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
  Internal("trace_glCopyTexSubImage2DEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCopyTexSubImage2DEXT(target, level, xoffset, yoffset, x, y, width, height);
}

static void REGAL_CALL trace_glCopyTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
  Internal("trace_glCopyTexSubImage3DEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCopyTexSubImage3DEXT(target, level, xoffset, yoffset, zoffset, x, y, width, height);
}

// GL_EXT_cull_vertex

static void REGAL_CALL trace_glCullParameterdvEXT(GLenum pname, GLdouble *params)
{
  Internal("trace_glCullParameterdvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCullParameterdvEXT(pname, params);
}

static void REGAL_CALL trace_glCullParameterfvEXT(GLenum pname, GLfloat *params)
{
  Internal("trace_glCullParameterfvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCullParameterfvEXT(pname, params);
}

// GL_EXT_debug_label

static void REGAL_CALL trace_glGetObjectLabelEXT(GLenum type, GLuint object, GLsizei bufSize, GLsizei *length, GLchar *label)
{
  Internal("trace_glGetObjectLabelEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetObjectLabelEXT(type, object, bufSize, length, label);
}

static void REGAL_CALL trace_glLabelObjectEXT(GLenum type, GLuint object, GLsizei length, const GLchar *label)
{
  Internal("trace_glLabelObjectEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glLabelObjectEXT(type, object, length, label);
}

// GL_EXT_debug_marker

static void REGAL_CALL trace_glInsertEventMarkerEXT(GLsizei length, const GLchar *marker)
{
  Internal("trace_glInsertEventMarkerEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glInsertEventMarkerEXT(length, marker);
}

static void REGAL_CALL trace_glPopGroupMarkerEXT(void)
{
  Internal("trace_glPopGroupMarkerEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPopGroupMarkerEXT();
}

static void REGAL_CALL trace_glPushGroupMarkerEXT(GLsizei length, const GLchar *marker)
{
  Internal("trace_glPushGroupMarkerEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPushGroupMarkerEXT(length, marker);
}

// GL_EXT_depth_bounds_test

static void REGAL_CALL trace_glDepthBoundsEXT(GLclampd zmin, GLclampd zmax)
{
  Internal("trace_glDepthBoundsEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDepthBoundsEXT(zmin, zmax);
}

// GL_EXT_direct_state_access

static void REGAL_CALL trace_glBindMultiTextureEXT(GLenum texunit, GLenum target, GLuint texture)
{
  Internal("trace_glBindMultiTextureEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBindMultiTextureEXT(texunit, target, texture);
}

static GLenum REGAL_CALL trace_glCheckNamedFramebufferStatusEXT(GLuint framebuffer, GLenum target)
{
  Internal("trace_glCheckNamedFramebufferStatusEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLenum  ret = Trace::glCheckNamedFramebufferStatusEXT(framebuffer, target);
  return ret;
}

static void REGAL_CALL trace_glClientAttribDefaultEXT(GLbitfield mask)
{
  Internal("trace_glClientAttribDefaultEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glClientAttribDefaultEXT(mask);
}

static void REGAL_CALL trace_glCompressedMultiTexImage1DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data)
{
  Internal("trace_glCompressedMultiTexImage1DEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCompressedMultiTexImage1DEXT(texunit, target, level, internalformat, width, border, imageSize, data);
}

static void REGAL_CALL trace_glCompressedMultiTexImage2DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *bits)
{
  Internal("trace_glCompressedMultiTexImage2DEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCompressedMultiTexImage2DEXT(texunit, target, level, internalformat, width, height, border, imageSize, bits);
}

static void REGAL_CALL trace_glCompressedMultiTexImage3DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *bits)
{
  Internal("trace_glCompressedMultiTexImage3DEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCompressedMultiTexImage3DEXT(texunit, target, level, internalformat, width, height, depth, border, imageSize, bits);
}

static void REGAL_CALL trace_glCompressedMultiTexSubImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data)
{
  Internal("trace_glCompressedMultiTexSubImage1DEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCompressedMultiTexSubImage1DEXT(texunit, target, level, xoffset, width, format, imageSize, data);
}

static void REGAL_CALL trace_glCompressedMultiTexSubImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data)
{
  Internal("trace_glCompressedMultiTexSubImage2DEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCompressedMultiTexSubImage2DEXT(texunit, target, level, xoffset, yoffset, width, height, format, imageSize, data);
}

static void REGAL_CALL trace_glCompressedMultiTexSubImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data)
{
  Internal("trace_glCompressedMultiTexSubImage3DEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCompressedMultiTexSubImage3DEXT(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
}

static void REGAL_CALL trace_glCompressedTextureImage1DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *bits)
{
  Internal("trace_glCompressedTextureImage1DEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCompressedTextureImage1DEXT(texture, target, level, internalformat, width, border, imageSize, bits);
}

static void REGAL_CALL trace_glCompressedTextureImage2DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *bits)
{
  Internal("trace_glCompressedTextureImage2DEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCompressedTextureImage2DEXT(texture, target, level, internalformat, width, height, border, imageSize, bits);
}

static void REGAL_CALL trace_glCompressedTextureImage3DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *bits)
{
  Internal("trace_glCompressedTextureImage3DEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCompressedTextureImage3DEXT(texture, target, level, internalformat, width, height, depth, border, imageSize, bits);
}

static void REGAL_CALL trace_glCompressedTextureSubImage1DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *bits)
{
  Internal("trace_glCompressedTextureSubImage1DEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCompressedTextureSubImage1DEXT(texture, target, level, xoffset, width, format, imageSize, bits);
}

static void REGAL_CALL trace_glCompressedTextureSubImage2DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *bits)
{
  Internal("trace_glCompressedTextureSubImage2DEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCompressedTextureSubImage2DEXT(texture, target, level, xoffset, yoffset, width, height, format, imageSize, bits);
}

static void REGAL_CALL trace_glCompressedTextureSubImage3DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *bits)
{
  Internal("trace_glCompressedTextureSubImage3DEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCompressedTextureSubImage3DEXT(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits);
}

static void REGAL_CALL trace_glCopyMultiTexImage1DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
{
  Internal("trace_glCopyMultiTexImage1DEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCopyMultiTexImage1DEXT(texunit, target, level, internalformat, x, y, width, border);
}

static void REGAL_CALL trace_glCopyMultiTexImage2DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
{
  Internal("trace_glCopyMultiTexImage2DEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCopyMultiTexImage2DEXT(texunit, target, level, internalformat, x, y, width, height, border);
}

static void REGAL_CALL trace_glCopyMultiTexSubImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
{
  Internal("trace_glCopyMultiTexSubImage1DEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCopyMultiTexSubImage1DEXT(texunit, target, level, xoffset, x, y, width);
}

static void REGAL_CALL trace_glCopyMultiTexSubImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
  Internal("trace_glCopyMultiTexSubImage2DEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCopyMultiTexSubImage2DEXT(texunit, target, level, xoffset, yoffset, x, y, width, height);
}

static void REGAL_CALL trace_glCopyMultiTexSubImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
  Internal("trace_glCopyMultiTexSubImage3DEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCopyMultiTexSubImage3DEXT(texunit, target, level, xoffset, yoffset, zoffset, x, y, width, height);
}

static void REGAL_CALL trace_glCopyTextureImage1DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
{
  Internal("trace_glCopyTextureImage1DEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCopyTextureImage1DEXT(texture, target, level, internalformat, x, y, width, border);
}

static void REGAL_CALL trace_glCopyTextureImage2DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
{
  Internal("trace_glCopyTextureImage2DEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCopyTextureImage2DEXT(texture, target, level, internalformat, x, y, width, height, border);
}

static void REGAL_CALL trace_glCopyTextureSubImage1DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
{
  Internal("trace_glCopyTextureSubImage1DEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCopyTextureSubImage1DEXT(texture, target, level, xoffset, x, y, width);
}

static void REGAL_CALL trace_glCopyTextureSubImage2DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
  Internal("trace_glCopyTextureSubImage2DEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCopyTextureSubImage2DEXT(texture, target, level, xoffset, yoffset, x, y, width, height);
}

static void REGAL_CALL trace_glCopyTextureSubImage3DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
  Internal("trace_glCopyTextureSubImage3DEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCopyTextureSubImage3DEXT(texture, target, level, xoffset, yoffset, zoffset, x, y, width, height);
}

static void REGAL_CALL trace_glDisableClientStateIndexedEXT(GLenum array, GLuint index)
{
  Internal("trace_glDisableClientStateIndexedEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDisableClientStateIndexedEXT(array, index);
}

static void REGAL_CALL trace_glDisableVertexArrayAttribEXT(GLuint vaobj, GLenum array)
{
  Internal("trace_glDisableVertexArrayAttribEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDisableVertexArrayAttribEXT(vaobj, array);
}

static void REGAL_CALL trace_glDisableVertexArrayEXT(GLuint vaobj, GLenum array)
{
  Internal("trace_glDisableVertexArrayEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDisableVertexArrayEXT(vaobj, array);
}

static void REGAL_CALL trace_glEnableClientStateIndexedEXT(GLenum array, GLuint index)
{
  Internal("trace_glEnableClientStateIndexedEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glEnableClientStateIndexedEXT(array, index);
}

static void REGAL_CALL trace_glEnableVertexArrayAttribEXT(GLuint vaobj, GLenum array)
{
  Internal("trace_glEnableVertexArrayAttribEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glEnableVertexArrayAttribEXT(vaobj, array);
}

static void REGAL_CALL trace_glEnableVertexArrayEXT(GLuint vaobj, GLenum array)
{
  Internal("trace_glEnableVertexArrayEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glEnableVertexArrayEXT(vaobj, array);
}

static void REGAL_CALL trace_glFlushMappedNamedBufferRangeEXT(GLuint buffer, GLintptr offset, GLsizeiptr length)
{
  Internal("trace_glFlushMappedNamedBufferRangeEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFlushMappedNamedBufferRangeEXT(buffer, offset, length);
}

static void REGAL_CALL trace_glFramebufferDrawBufferEXT(GLuint framebuffer, GLenum mode)
{
  Internal("trace_glFramebufferDrawBufferEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFramebufferDrawBufferEXT(framebuffer, mode);
}

static void REGAL_CALL trace_glFramebufferDrawBuffersEXT(GLuint framebuffer, GLsizei n, const GLenum *bufs)
{
  Internal("trace_glFramebufferDrawBuffersEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFramebufferDrawBuffersEXT(framebuffer, n, bufs);
}

static void REGAL_CALL trace_glFramebufferReadBufferEXT(GLuint framebuffer, GLenum mode)
{
  Internal("trace_glFramebufferReadBufferEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFramebufferReadBufferEXT(framebuffer, mode);
}

static void REGAL_CALL trace_glGenerateMultiTexMipmapEXT(GLenum texunit, GLenum target)
{
  Internal("trace_glGenerateMultiTexMipmapEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGenerateMultiTexMipmapEXT(texunit, target);
}

static void REGAL_CALL trace_glGenerateTextureMipmapEXT(GLuint texture, GLenum target)
{
  Internal("trace_glGenerateTextureMipmapEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGenerateTextureMipmapEXT(texture, target);
}

static void REGAL_CALL trace_glGetCompressedMultiTexImageEXT(GLenum texunit, GLenum target, GLint lod, GLvoid *img)
{
  Internal("trace_glGetCompressedMultiTexImageEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetCompressedMultiTexImageEXT(texunit, target, lod, img);
}

static void REGAL_CALL trace_glGetCompressedTextureImageEXT(GLuint texture, GLenum target, GLint lod, GLvoid *img)
{
  Internal("trace_glGetCompressedTextureImageEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetCompressedTextureImageEXT(texture, target, lod, img);
}

static void REGAL_CALL trace_glGetDoubleIndexedvEXT(GLenum target, GLuint index, GLdouble *data)
{
  Internal("trace_glGetDoubleIndexedvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetDoubleIndexedvEXT(target, index, data);
}

static void REGAL_CALL trace_glGetFloatIndexedvEXT(GLenum target, GLuint index, GLfloat *data)
{
  Internal("trace_glGetFloatIndexedvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetFloatIndexedvEXT(target, index, data);
}

static void REGAL_CALL trace_glGetFramebufferParameterivEXT(GLuint framebuffer, GLenum pname, GLint *params)
{
  Internal("trace_glGetFramebufferParameterivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetFramebufferParameterivEXT(framebuffer, pname, params);
}

static void REGAL_CALL trace_glGetMultiTexEnvfvEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat *params)
{
  Internal("trace_glGetMultiTexEnvfvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetMultiTexEnvfvEXT(texunit, target, pname, params);
}

static void REGAL_CALL trace_glGetMultiTexEnvivEXT(GLenum texunit, GLenum target, GLenum pname, GLint *params)
{
  Internal("trace_glGetMultiTexEnvivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetMultiTexEnvivEXT(texunit, target, pname, params);
}

static void REGAL_CALL trace_glGetMultiTexGendvEXT(GLenum texunit, GLenum coord, GLenum pname, GLdouble *params)
{
  Internal("trace_glGetMultiTexGendvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetMultiTexGendvEXT(texunit, coord, pname, params);
}

static void REGAL_CALL trace_glGetMultiTexGenfvEXT(GLenum texunit, GLenum coord, GLenum pname, GLfloat *params)
{
  Internal("trace_glGetMultiTexGenfvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetMultiTexGenfvEXT(texunit, coord, pname, params);
}

static void REGAL_CALL trace_glGetMultiTexGenivEXT(GLenum texunit, GLenum coord, GLenum pname, GLint *params)
{
  Internal("trace_glGetMultiTexGenivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetMultiTexGenivEXT(texunit, coord, pname, params);
}

static void REGAL_CALL trace_glGetMultiTexImageEXT(GLenum texunit, GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
{
  Internal("trace_glGetMultiTexImageEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetMultiTexImageEXT(texunit, target, level, format, type, pixels);
}

static void REGAL_CALL trace_glGetMultiTexLevelParameterfvEXT(GLenum texunit, GLenum target, GLint level, GLenum pname, GLfloat *params)
{
  Internal("trace_glGetMultiTexLevelParameterfvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetMultiTexLevelParameterfvEXT(texunit, target, level, pname, params);
}

static void REGAL_CALL trace_glGetMultiTexLevelParameterivEXT(GLenum texunit, GLenum target, GLint level, GLenum pname, GLint *params)
{
  Internal("trace_glGetMultiTexLevelParameterivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetMultiTexLevelParameterivEXT(texunit, target, level, pname, params);
}

static void REGAL_CALL trace_glGetMultiTexParameterIivEXT(GLenum texunit, GLenum target, GLenum pname, GLint *params)
{
  Internal("trace_glGetMultiTexParameterIivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetMultiTexParameterIivEXT(texunit, target, pname, params);
}

static void REGAL_CALL trace_glGetMultiTexParameterIuivEXT(GLenum texunit, GLenum target, GLenum pname, GLuint *params)
{
  Internal("trace_glGetMultiTexParameterIuivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetMultiTexParameterIuivEXT(texunit, target, pname, params);
}

static void REGAL_CALL trace_glGetMultiTexParameterfvEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat *params)
{
  Internal("trace_glGetMultiTexParameterfvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetMultiTexParameterfvEXT(texunit, target, pname, params);
}

static void REGAL_CALL trace_glGetMultiTexParameterivEXT(GLenum texunit, GLenum target, GLenum pname, GLint *params)
{
  Internal("trace_glGetMultiTexParameterivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetMultiTexParameterivEXT(texunit, target, pname, params);
}

static void REGAL_CALL trace_glGetNamedBufferParameterivEXT(GLuint buffer, GLenum pname, GLint *params)
{
  Internal("trace_glGetNamedBufferParameterivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetNamedBufferParameterivEXT(buffer, pname, params);
}

static void REGAL_CALL trace_glGetNamedBufferPointervEXT(GLuint buffer, GLenum pname, GLvoid **params)
{
  Internal("trace_glGetNamedBufferPointervEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetNamedBufferPointervEXT(buffer, pname, params);
}

static void REGAL_CALL trace_glGetNamedBufferSubDataEXT(GLuint buffer, GLintptr offset, GLsizeiptr size, GLvoid *data)
{
  Internal("trace_glGetNamedBufferSubDataEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetNamedBufferSubDataEXT(buffer, offset, size, data);
}

static void REGAL_CALL trace_glGetNamedFramebufferAttachmentParameterivEXT(GLuint framebuffer, GLenum attachment, GLenum pname, GLint *params)
{
  Internal("trace_glGetNamedFramebufferAttachmentParameterivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetNamedFramebufferAttachmentParameterivEXT(framebuffer, attachment, pname, params);
}

static void REGAL_CALL trace_glGetNamedProgramLocalParameterIivEXT(GLuint program, GLenum target, GLuint index, GLint *params)
{
  Internal("trace_glGetNamedProgramLocalParameterIivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetNamedProgramLocalParameterIivEXT(program, target, index, params);
}

static void REGAL_CALL trace_glGetNamedProgramLocalParameterIuivEXT(GLuint program, GLenum target, GLuint index, GLuint *params)
{
  Internal("trace_glGetNamedProgramLocalParameterIuivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetNamedProgramLocalParameterIuivEXT(program, target, index, params);
}

static void REGAL_CALL trace_glGetNamedProgramLocalParameterdvEXT(GLuint program, GLenum target, GLuint index, GLdouble *params)
{
  Internal("trace_glGetNamedProgramLocalParameterdvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetNamedProgramLocalParameterdvEXT(program, target, index, params);
}

static void REGAL_CALL trace_glGetNamedProgramLocalParameterfvEXT(GLuint program, GLenum target, GLuint index, GLfloat *params)
{
  Internal("trace_glGetNamedProgramLocalParameterfvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetNamedProgramLocalParameterfvEXT(program, target, index, params);
}

static void REGAL_CALL trace_glGetNamedProgramStringEXT(GLuint program, GLenum target, GLenum pname, GLvoid *string)
{
  Internal("trace_glGetNamedProgramStringEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetNamedProgramStringEXT(program, target, pname, string);
}

static void REGAL_CALL trace_glGetNamedProgramivEXT(GLuint program, GLenum target, GLenum pname, GLint *params)
{
  Internal("trace_glGetNamedProgramivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetNamedProgramivEXT(program, target, pname, params);
}

static void REGAL_CALL trace_glGetNamedRenderbufferParameterivEXT(GLuint renderbuffer, GLenum pname, GLint *params)
{
  Internal("trace_glGetNamedRenderbufferParameterivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetNamedRenderbufferParameterivEXT(renderbuffer, pname, params);
}

static void REGAL_CALL trace_glGetPointerIndexedvEXT(GLenum target, GLuint index, GLvoid **data)
{
  Internal("trace_glGetPointerIndexedvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetPointerIndexedvEXT(target, index, data);
}

static void REGAL_CALL trace_glGetTextureImageEXT(GLuint texture, GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
{
  Internal("trace_glGetTextureImageEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetTextureImageEXT(texture, target, level, format, type, pixels);
}

static void REGAL_CALL trace_glGetTextureLevelParameterfvEXT(GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat *params)
{
  Internal("trace_glGetTextureLevelParameterfvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetTextureLevelParameterfvEXT(texture, target, level, pname, params);
}

static void REGAL_CALL trace_glGetTextureLevelParameterivEXT(GLuint texture, GLenum target, GLint level, GLenum pname, GLint *params)
{
  Internal("trace_glGetTextureLevelParameterivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetTextureLevelParameterivEXT(texture, target, level, pname, params);
}

static void REGAL_CALL trace_glGetTextureParameterIivEXT(GLuint texture, GLenum target, GLenum pname, GLint *params)
{
  Internal("trace_glGetTextureParameterIivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetTextureParameterIivEXT(texture, target, pname, params);
}

static void REGAL_CALL trace_glGetTextureParameterIuivEXT(GLuint texture, GLenum target, GLenum pname, GLuint *params)
{
  Internal("trace_glGetTextureParameterIuivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetTextureParameterIuivEXT(texture, target, pname, params);
}

static void REGAL_CALL trace_glGetTextureParameterfvEXT(GLuint texture, GLenum target, GLenum pname, GLfloat *params)
{
  Internal("trace_glGetTextureParameterfvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetTextureParameterfvEXT(texture, target, pname, params);
}

static void REGAL_CALL trace_glGetTextureParameterivEXT(GLuint texture, GLenum target, GLenum pname, GLint *params)
{
  Internal("trace_glGetTextureParameterivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetTextureParameterivEXT(texture, target, pname, params);
}

static void REGAL_CALL trace_glGetVertexArrayIntegeri_vEXT(GLuint vaobj, GLuint index, GLenum pname, GLint *param)
{
  Internal("trace_glGetVertexArrayIntegeri_vEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetVertexArrayIntegeri_vEXT(vaobj, index, pname, param);
}

static void REGAL_CALL trace_glGetVertexArrayIntegervEXT(GLuint vaobj, GLenum pname, GLint *param)
{
  Internal("trace_glGetVertexArrayIntegervEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetVertexArrayIntegervEXT(vaobj, pname, param);
}

static void REGAL_CALL trace_glGetVertexArrayPointeri_vEXT(GLuint vaobj, GLuint index, GLenum pname, GLvoid **param)
{
  Internal("trace_glGetVertexArrayPointeri_vEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetVertexArrayPointeri_vEXT(vaobj, index, pname, param);
}

static void REGAL_CALL trace_glGetVertexArrayPointervEXT(GLuint vaobj, GLenum pname, GLvoid **param)
{
  Internal("trace_glGetVertexArrayPointervEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetVertexArrayPointervEXT(vaobj, pname, param);
}

static GLvoid *REGAL_CALL trace_glMapNamedBufferEXT(GLuint buffer, GLenum access)
{
  Internal("trace_glMapNamedBufferEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLvoid * ret = Trace::glMapNamedBufferEXT(buffer, access);
  return ret;
}

static GLvoid *REGAL_CALL trace_glMapNamedBufferRangeEXT(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access)
{
  Internal("trace_glMapNamedBufferRangeEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLvoid * ret = Trace::glMapNamedBufferRangeEXT(buffer, offset, length, access);
  return ret;
}

static void REGAL_CALL trace_glMatrixFrustumEXT(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
{
  Internal("trace_glMatrixFrustumEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMatrixFrustumEXT(mode, left, right, bottom, top, zNear, zFar);
}

static void REGAL_CALL trace_glMatrixLoadIdentityEXT(GLenum mode)
{
  Internal("trace_glMatrixLoadIdentityEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMatrixLoadIdentityEXT(mode);
}

static void REGAL_CALL trace_glMatrixLoadTransposedEXT(GLenum mode, const GLdouble *m)
{
  Internal("trace_glMatrixLoadTransposedEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMatrixLoadTransposedEXT(mode, m);
}

static void REGAL_CALL trace_glMatrixLoadTransposefEXT(GLenum mode, const GLfloat *m)
{
  Internal("trace_glMatrixLoadTransposefEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMatrixLoadTransposefEXT(mode, m);
}

static void REGAL_CALL trace_glMatrixLoaddEXT(GLenum mode, const GLdouble *m)
{
  Internal("trace_glMatrixLoaddEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMatrixLoaddEXT(mode, m);
}

static void REGAL_CALL trace_glMatrixLoadfEXT(GLenum mode, const GLfloat *m)
{
  Internal("trace_glMatrixLoadfEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMatrixLoadfEXT(mode, m);
}

static void REGAL_CALL trace_glMatrixMultTransposedEXT(GLenum mode, const GLdouble *m)
{
  Internal("trace_glMatrixMultTransposedEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMatrixMultTransposedEXT(mode, m);
}

static void REGAL_CALL trace_glMatrixMultTransposefEXT(GLenum mode, const GLfloat *m)
{
  Internal("trace_glMatrixMultTransposefEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMatrixMultTransposefEXT(mode, m);
}

static void REGAL_CALL trace_glMatrixMultdEXT(GLenum mode, const GLdouble *m)
{
  Internal("trace_glMatrixMultdEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMatrixMultdEXT(mode, m);
}

static void REGAL_CALL trace_glMatrixMultfEXT(GLenum mode, const GLfloat *m)
{
  Internal("trace_glMatrixMultfEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMatrixMultfEXT(mode, m);
}

static void REGAL_CALL trace_glMatrixOrthoEXT(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
{
  Internal("trace_glMatrixOrthoEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMatrixOrthoEXT(mode, left, right, bottom, top, zNear, zFar);
}

static void REGAL_CALL trace_glMatrixPopEXT(GLenum mode)
{
  Internal("trace_glMatrixPopEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMatrixPopEXT(mode);
}

static void REGAL_CALL trace_glMatrixPushEXT(GLenum mode)
{
  Internal("trace_glMatrixPushEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMatrixPushEXT(mode);
}

static void REGAL_CALL trace_glMatrixRotatedEXT(GLenum mode, GLdouble angle, GLdouble x, GLdouble y, GLdouble z)
{
  Internal("trace_glMatrixRotatedEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMatrixRotatedEXT(mode, angle, x, y, z);
}

static void REGAL_CALL trace_glMatrixRotatefEXT(GLenum mode, GLfloat angle, GLfloat x, GLfloat y, GLfloat z)
{
  Internal("trace_glMatrixRotatefEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMatrixRotatefEXT(mode, angle, x, y, z);
}

static void REGAL_CALL trace_glMatrixScaledEXT(GLenum mode, GLdouble x, GLdouble y, GLdouble z)
{
  Internal("trace_glMatrixScaledEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMatrixScaledEXT(mode, x, y, z);
}

static void REGAL_CALL trace_glMatrixScalefEXT(GLenum mode, GLfloat x, GLfloat y, GLfloat z)
{
  Internal("trace_glMatrixScalefEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMatrixScalefEXT(mode, x, y, z);
}

static void REGAL_CALL trace_glMatrixTranslatedEXT(GLenum mode, GLdouble x, GLdouble y, GLdouble z)
{
  Internal("trace_glMatrixTranslatedEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMatrixTranslatedEXT(mode, x, y, z);
}

static void REGAL_CALL trace_glMatrixTranslatefEXT(GLenum mode, GLfloat x, GLfloat y, GLfloat z)
{
  Internal("trace_glMatrixTranslatefEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMatrixTranslatefEXT(mode, x, y, z);
}

static void REGAL_CALL trace_glMultiTexBufferEXT(GLenum texunit, GLenum target, GLenum internalformat, GLuint buffer)
{
  Internal("trace_glMultiTexBufferEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexBufferEXT(texunit, target, internalformat, buffer);
}

static void REGAL_CALL trace_glMultiTexCoordPointerEXT(GLenum texunit, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
  Internal("trace_glMultiTexCoordPointerEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoordPointerEXT(texunit, size, type, stride, pointer);
}

static void REGAL_CALL trace_glMultiTexEnvfEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat param)
{
  Internal("trace_glMultiTexEnvfEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexEnvfEXT(texunit, target, pname, param);
}

static void REGAL_CALL trace_glMultiTexEnvfvEXT(GLenum texunit, GLenum target, GLenum pname, const GLfloat *params)
{
  Internal("trace_glMultiTexEnvfvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexEnvfvEXT(texunit, target, pname, params);
}

static void REGAL_CALL trace_glMultiTexEnviEXT(GLenum texunit, GLenum target, GLenum pname, GLint param)
{
  Internal("trace_glMultiTexEnviEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexEnviEXT(texunit, target, pname, param);
}

static void REGAL_CALL trace_glMultiTexEnvivEXT(GLenum texunit, GLenum target, GLenum pname, const GLint *params)
{
  Internal("trace_glMultiTexEnvivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexEnvivEXT(texunit, target, pname, params);
}

static void REGAL_CALL trace_glMultiTexGendEXT(GLenum texunit, GLenum coord, GLenum pname, GLdouble param)
{
  Internal("trace_glMultiTexGendEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexGendEXT(texunit, coord, pname, param);
}

static void REGAL_CALL trace_glMultiTexGendvEXT(GLenum texunit, GLenum coord, GLenum pname, const GLdouble *params)
{
  Internal("trace_glMultiTexGendvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexGendvEXT(texunit, coord, pname, params);
}

static void REGAL_CALL trace_glMultiTexGenfEXT(GLenum texunit, GLenum coord, GLenum pname, GLfloat param)
{
  Internal("trace_glMultiTexGenfEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexGenfEXT(texunit, coord, pname, param);
}

static void REGAL_CALL trace_glMultiTexGenfvEXT(GLenum texunit, GLenum coord, GLenum pname, const GLfloat *params)
{
  Internal("trace_glMultiTexGenfvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexGenfvEXT(texunit, coord, pname, params);
}

static void REGAL_CALL trace_glMultiTexGeniEXT(GLenum texunit, GLenum coord, GLenum pname, GLint param)
{
  Internal("trace_glMultiTexGeniEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexGeniEXT(texunit, coord, pname, param);
}

static void REGAL_CALL trace_glMultiTexGenivEXT(GLenum texunit, GLenum coord, GLenum pname, const GLint *params)
{
  Internal("trace_glMultiTexGenivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexGenivEXT(texunit, coord, pname, params);
}

static void REGAL_CALL trace_glMultiTexParameterIivEXT(GLenum texunit, GLenum target, GLenum pname, const GLint *params)
{
  Internal("trace_glMultiTexParameterIivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexParameterIivEXT(texunit, target, pname, params);
}

static void REGAL_CALL trace_glMultiTexParameterIuivEXT(GLenum texunit, GLenum target, GLenum pname, const GLuint *params)
{
  Internal("trace_glMultiTexParameterIuivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexParameterIuivEXT(texunit, target, pname, params);
}

static void REGAL_CALL trace_glMultiTexParameterfEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat param)
{
  Internal("trace_glMultiTexParameterfEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexParameterfEXT(texunit, target, pname, param);
}

static void REGAL_CALL trace_glMultiTexParameterfvEXT(GLenum texunit, GLenum target, GLenum pname, const GLfloat *param)
{
  Internal("trace_glMultiTexParameterfvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexParameterfvEXT(texunit, target, pname, param);
}

static void REGAL_CALL trace_glMultiTexParameteriEXT(GLenum texunit, GLenum target, GLenum pname, GLint param)
{
  Internal("trace_glMultiTexParameteriEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexParameteriEXT(texunit, target, pname, param);
}

static void REGAL_CALL trace_glMultiTexParameterivEXT(GLenum texunit, GLenum target, GLenum pname, const GLint *param)
{
  Internal("trace_glMultiTexParameterivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexParameterivEXT(texunit, target, pname, param);
}

static void REGAL_CALL trace_glMultiTexRenderbufferEXT(GLenum texunit, GLenum target, GLuint renderbuffer)
{
  Internal("trace_glMultiTexRenderbufferEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexRenderbufferEXT(texunit, target, renderbuffer);
}

static void REGAL_CALL trace_glMultiTexSubImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
{
  Internal("trace_glMultiTexSubImage1DEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexSubImage1DEXT(texunit, target, level, xoffset, width, format, type, pixels);
}

static void REGAL_CALL trace_glMultiTexSubImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
{
  Internal("trace_glMultiTexSubImage2DEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexSubImage2DEXT(texunit, target, level, xoffset, yoffset, width, height, format, type, pixels);
}

static void REGAL_CALL trace_glMultiTexSubImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
{
  Internal("trace_glMultiTexSubImage3DEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexSubImage3DEXT(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
}

static void REGAL_CALL trace_glNamedBufferDataEXT(GLuint buffer, GLsizeiptr size, const GLvoid *data, GLenum usage)
{
  Internal("trace_glNamedBufferDataEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNamedBufferDataEXT(buffer, size, data, usage);
}

static void REGAL_CALL trace_glNamedBufferSubDataEXT(GLuint buffer, GLintptr offset, GLsizeiptr size, const GLvoid *data)
{
  Internal("trace_glNamedBufferSubDataEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNamedBufferSubDataEXT(buffer, offset, size, data);
}

static void REGAL_CALL trace_glNamedCopyBufferSubDataEXT(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size)
{
  Internal("trace_glNamedCopyBufferSubDataEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNamedCopyBufferSubDataEXT(readBuffer, writeBuffer, readOffset, writeOffset, size);
}

static void REGAL_CALL trace_glNamedFramebufferRenderbufferEXT(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{
  Internal("trace_glNamedFramebufferRenderbufferEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNamedFramebufferRenderbufferEXT(framebuffer, attachment, renderbuffertarget, renderbuffer);
}

static void REGAL_CALL trace_glNamedFramebufferTexture1DEXT(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
  Internal("trace_glNamedFramebufferTexture1DEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNamedFramebufferTexture1DEXT(framebuffer, attachment, textarget, texture, level);
}

static void REGAL_CALL trace_glNamedFramebufferTexture2DEXT(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
  Internal("trace_glNamedFramebufferTexture2DEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNamedFramebufferTexture2DEXT(framebuffer, attachment, textarget, texture, level);
}

static void REGAL_CALL trace_glNamedFramebufferTexture3DEXT(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)
{
  Internal("trace_glNamedFramebufferTexture3DEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNamedFramebufferTexture3DEXT(framebuffer, attachment, textarget, texture, level, zoffset);
}

static void REGAL_CALL trace_glNamedFramebufferTextureEXT(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level)
{
  Internal("trace_glNamedFramebufferTextureEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNamedFramebufferTextureEXT(framebuffer, attachment, texture, level);
}

static void REGAL_CALL trace_glNamedFramebufferTextureFaceEXT(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLenum face)
{
  Internal("trace_glNamedFramebufferTextureFaceEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNamedFramebufferTextureFaceEXT(framebuffer, attachment, texture, level, face);
}

static void REGAL_CALL trace_glNamedFramebufferTextureLayerEXT(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer)
{
  Internal("trace_glNamedFramebufferTextureLayerEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNamedFramebufferTextureLayerEXT(framebuffer, attachment, texture, level, layer);
}

static void REGAL_CALL trace_glNamedProgramLocalParameter4dEXT(GLuint program, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  Internal("trace_glNamedProgramLocalParameter4dEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNamedProgramLocalParameter4dEXT(program, target, index, x, y, z, w);
}

static void REGAL_CALL trace_glNamedProgramLocalParameter4dvEXT(GLuint program, GLenum target, GLuint index, const GLdouble *params)
{
  Internal("trace_glNamedProgramLocalParameter4dvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNamedProgramLocalParameter4dvEXT(program, target, index, params);
}

static void REGAL_CALL trace_glNamedProgramLocalParameter4fEXT(GLuint program, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  Internal("trace_glNamedProgramLocalParameter4fEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNamedProgramLocalParameter4fEXT(program, target, index, x, y, z, w);
}

static void REGAL_CALL trace_glNamedProgramLocalParameter4fvEXT(GLuint program, GLenum target, GLuint index, const GLfloat *params)
{
  Internal("trace_glNamedProgramLocalParameter4fvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNamedProgramLocalParameter4fvEXT(program, target, index, params);
}

static void REGAL_CALL trace_glNamedProgramLocalParameterI4iEXT(GLuint program, GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w)
{
  Internal("trace_glNamedProgramLocalParameterI4iEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNamedProgramLocalParameterI4iEXT(program, target, index, x, y, z, w);
}

static void REGAL_CALL trace_glNamedProgramLocalParameterI4ivEXT(GLuint program, GLenum target, GLuint index, const GLint *params)
{
  Internal("trace_glNamedProgramLocalParameterI4ivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNamedProgramLocalParameterI4ivEXT(program, target, index, params);
}

static void REGAL_CALL trace_glNamedProgramLocalParameterI4uiEXT(GLuint program, GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
{
  Internal("trace_glNamedProgramLocalParameterI4uiEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNamedProgramLocalParameterI4uiEXT(program, target, index, x, y, z, w);
}

static void REGAL_CALL trace_glNamedProgramLocalParameterI4uivEXT(GLuint program, GLenum target, GLuint index, const GLuint *params)
{
  Internal("trace_glNamedProgramLocalParameterI4uivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNamedProgramLocalParameterI4uivEXT(program, target, index, params);
}

static void REGAL_CALL trace_glNamedProgramLocalParameters4fvEXT(GLuint program, GLenum target, GLuint index, GLsizei count, const GLfloat *params)
{
  Internal("trace_glNamedProgramLocalParameters4fvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNamedProgramLocalParameters4fvEXT(program, target, index, count, params);
}

static void REGAL_CALL trace_glNamedProgramLocalParametersI4ivEXT(GLuint program, GLenum target, GLuint index, GLsizei count, const GLint *params)
{
  Internal("trace_glNamedProgramLocalParametersI4ivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNamedProgramLocalParametersI4ivEXT(program, target, index, count, params);
}

static void REGAL_CALL trace_glNamedProgramLocalParametersI4uivEXT(GLuint program, GLenum target, GLuint index, GLsizei count, const GLuint *params)
{
  Internal("trace_glNamedProgramLocalParametersI4uivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNamedProgramLocalParametersI4uivEXT(program, target, index, count, params);
}

static void REGAL_CALL trace_glNamedProgramStringEXT(GLuint program, GLenum target, GLenum format, GLsizei len, const GLvoid *string)
{
  Internal("trace_glNamedProgramStringEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNamedProgramStringEXT(program, target, format, len, string);
}

static void REGAL_CALL trace_glNamedRenderbufferStorageEXT(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height)
{
  Internal("trace_glNamedRenderbufferStorageEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNamedRenderbufferStorageEXT(renderbuffer, internalformat, width, height);
}

static void REGAL_CALL trace_glNamedRenderbufferStorageMultisampleCoverageEXT(GLuint renderbuffer, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height)
{
  Internal("trace_glNamedRenderbufferStorageMultisampleCoverageEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNamedRenderbufferStorageMultisampleCoverageEXT(renderbuffer, coverageSamples, colorSamples, internalformat, width, height);
}

static void REGAL_CALL trace_glNamedRenderbufferStorageMultisampleEXT(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
  Internal("trace_glNamedRenderbufferStorageMultisampleEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNamedRenderbufferStorageMultisampleEXT(renderbuffer, samples, internalformat, width, height);
}

static void REGAL_CALL trace_glProgramUniform1dEXT(GLuint program, GLint location, GLdouble x)
{
  Internal("trace_glProgramUniform1dEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform1dEXT(program, location, x);
}

static void REGAL_CALL trace_glProgramUniform1dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
  Internal("trace_glProgramUniform1dvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform1dvEXT(program, location, count, value);
}

static void REGAL_CALL trace_glProgramUniform1fEXT(GLuint program, GLint location, GLfloat v0)
{
  Internal("trace_glProgramUniform1fEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform1fEXT(program, location, v0);
}

static void REGAL_CALL trace_glProgramUniform1fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
  Internal("trace_glProgramUniform1fvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform1fvEXT(program, location, count, value);
}

static void REGAL_CALL trace_glProgramUniform1iEXT(GLuint program, GLint location, GLint v0)
{
  Internal("trace_glProgramUniform1iEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform1iEXT(program, location, v0);
}

static void REGAL_CALL trace_glProgramUniform1ivEXT(GLuint program, GLint location, GLsizei count, const GLint *value)
{
  Internal("trace_glProgramUniform1ivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform1ivEXT(program, location, count, value);
}

static void REGAL_CALL trace_glProgramUniform1uiEXT(GLuint program, GLint location, GLuint v0)
{
  Internal("trace_glProgramUniform1uiEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform1uiEXT(program, location, v0);
}

static void REGAL_CALL trace_glProgramUniform1uivEXT(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
  Internal("trace_glProgramUniform1uivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform1uivEXT(program, location, count, value);
}

static void REGAL_CALL trace_glProgramUniform2dEXT(GLuint program, GLint location, GLdouble x, GLdouble y)
{
  Internal("trace_glProgramUniform2dEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform2dEXT(program, location, x, y);
}

static void REGAL_CALL trace_glProgramUniform2dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
  Internal("trace_glProgramUniform2dvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform2dvEXT(program, location, count, value);
}

static void REGAL_CALL trace_glProgramUniform2fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1)
{
  Internal("trace_glProgramUniform2fEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform2fEXT(program, location, v0, v1);
}

static void REGAL_CALL trace_glProgramUniform2fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
  Internal("trace_glProgramUniform2fvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform2fvEXT(program, location, count, value);
}

static void REGAL_CALL trace_glProgramUniform2iEXT(GLuint program, GLint location, GLint v0, GLint v1)
{
  Internal("trace_glProgramUniform2iEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform2iEXT(program, location, v0, v1);
}

static void REGAL_CALL trace_glProgramUniform2ivEXT(GLuint program, GLint location, GLsizei count, const GLint *value)
{
  Internal("trace_glProgramUniform2ivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform2ivEXT(program, location, count, value);
}

static void REGAL_CALL trace_glProgramUniform2uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1)
{
  Internal("trace_glProgramUniform2uiEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform2uiEXT(program, location, v0, v1);
}

static void REGAL_CALL trace_glProgramUniform2uivEXT(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
  Internal("trace_glProgramUniform2uivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform2uivEXT(program, location, count, value);
}

static void REGAL_CALL trace_glProgramUniform3dEXT(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z)
{
  Internal("trace_glProgramUniform3dEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform3dEXT(program, location, x, y, z);
}

static void REGAL_CALL trace_glProgramUniform3dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
  Internal("trace_glProgramUniform3dvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform3dvEXT(program, location, count, value);
}

static void REGAL_CALL trace_glProgramUniform3fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
{
  Internal("trace_glProgramUniform3fEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform3fEXT(program, location, v0, v1, v2);
}

static void REGAL_CALL trace_glProgramUniform3fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
  Internal("trace_glProgramUniform3fvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform3fvEXT(program, location, count, value);
}

static void REGAL_CALL trace_glProgramUniform3iEXT(GLuint program, GLint location, GLint v0, GLint v1, GLint v2)
{
  Internal("trace_glProgramUniform3iEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform3iEXT(program, location, v0, v1, v2);
}

static void REGAL_CALL trace_glProgramUniform3ivEXT(GLuint program, GLint location, GLsizei count, const GLint *value)
{
  Internal("trace_glProgramUniform3ivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform3ivEXT(program, location, count, value);
}

static void REGAL_CALL trace_glProgramUniform3uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2)
{
  Internal("trace_glProgramUniform3uiEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform3uiEXT(program, location, v0, v1, v2);
}

static void REGAL_CALL trace_glProgramUniform3uivEXT(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
  Internal("trace_glProgramUniform3uivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform3uivEXT(program, location, count, value);
}

static void REGAL_CALL trace_glProgramUniform4dEXT(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  Internal("trace_glProgramUniform4dEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform4dEXT(program, location, x, y, z, w);
}

static void REGAL_CALL trace_glProgramUniform4dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
  Internal("trace_glProgramUniform4dvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform4dvEXT(program, location, count, value);
}

static void REGAL_CALL trace_glProgramUniform4fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
{
  Internal("trace_glProgramUniform4fEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform4fEXT(program, location, v0, v1, v2, v3);
}

static void REGAL_CALL trace_glProgramUniform4fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
  Internal("trace_glProgramUniform4fvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform4fvEXT(program, location, count, value);
}

static void REGAL_CALL trace_glProgramUniform4iEXT(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
{
  Internal("trace_glProgramUniform4iEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform4iEXT(program, location, v0, v1, v2, v3);
}

static void REGAL_CALL trace_glProgramUniform4ivEXT(GLuint program, GLint location, GLsizei count, const GLint *value)
{
  Internal("trace_glProgramUniform4ivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform4ivEXT(program, location, count, value);
}

static void REGAL_CALL trace_glProgramUniform4uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3)
{
  Internal("trace_glProgramUniform4uiEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform4uiEXT(program, location, v0, v1, v2, v3);
}

static void REGAL_CALL trace_glProgramUniform4uivEXT(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
  Internal("trace_glProgramUniform4uivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform4uivEXT(program, location, count, value);
}

static void REGAL_CALL trace_glProgramUniformMatrix2dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  Internal("trace_glProgramUniformMatrix2dvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniformMatrix2dvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL trace_glProgramUniformMatrix2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  Internal("trace_glProgramUniformMatrix2fvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniformMatrix2fvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL trace_glProgramUniformMatrix2x3dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  Internal("trace_glProgramUniformMatrix2x3dvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniformMatrix2x3dvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL trace_glProgramUniformMatrix2x3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  Internal("trace_glProgramUniformMatrix2x3fvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniformMatrix2x3fvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL trace_glProgramUniformMatrix2x4dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  Internal("trace_glProgramUniformMatrix2x4dvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniformMatrix2x4dvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL trace_glProgramUniformMatrix2x4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  Internal("trace_glProgramUniformMatrix2x4fvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniformMatrix2x4fvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL trace_glProgramUniformMatrix3dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  Internal("trace_glProgramUniformMatrix3dvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniformMatrix3dvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL trace_glProgramUniformMatrix3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  Internal("trace_glProgramUniformMatrix3fvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniformMatrix3fvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL trace_glProgramUniformMatrix3x2dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  Internal("trace_glProgramUniformMatrix3x2dvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniformMatrix3x2dvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL trace_glProgramUniformMatrix3x2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  Internal("trace_glProgramUniformMatrix3x2fvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniformMatrix3x2fvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL trace_glProgramUniformMatrix3x4dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  Internal("trace_glProgramUniformMatrix3x4dvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniformMatrix3x4dvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL trace_glProgramUniformMatrix3x4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  Internal("trace_glProgramUniformMatrix3x4fvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniformMatrix3x4fvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL trace_glProgramUniformMatrix4dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  Internal("trace_glProgramUniformMatrix4dvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniformMatrix4dvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL trace_glProgramUniformMatrix4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  Internal("trace_glProgramUniformMatrix4fvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniformMatrix4fvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL trace_glProgramUniformMatrix4x2dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  Internal("trace_glProgramUniformMatrix4x2dvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniformMatrix4x2dvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL trace_glProgramUniformMatrix4x2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  Internal("trace_glProgramUniformMatrix4x2fvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniformMatrix4x2fvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL trace_glProgramUniformMatrix4x3dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  Internal("trace_glProgramUniformMatrix4x3dvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniformMatrix4x3dvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL trace_glProgramUniformMatrix4x3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  Internal("trace_glProgramUniformMatrix4x3fvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniformMatrix4x3fvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL trace_glPushClientAttribDefaultEXT(GLbitfield mask)
{
  Internal("trace_glPushClientAttribDefaultEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPushClientAttribDefaultEXT(mask);
}

static void REGAL_CALL trace_glTextureBufferEXT(GLuint texture, GLenum target, GLenum internalformat, GLuint buffer)
{
  Internal("trace_glTextureBufferEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTextureBufferEXT(texture, target, internalformat, buffer);
}

static void REGAL_CALL trace_glTextureParameterIivEXT(GLuint texture, GLenum target, GLenum pname, const GLint *params)
{
  Internal("trace_glTextureParameterIivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTextureParameterIivEXT(texture, target, pname, params);
}

static void REGAL_CALL trace_glTextureParameterIuivEXT(GLuint texture, GLenum target, GLenum pname, const GLuint *params)
{
  Internal("trace_glTextureParameterIuivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTextureParameterIuivEXT(texture, target, pname, params);
}

static void REGAL_CALL trace_glTextureParameterfEXT(GLuint texture, GLenum target, GLenum pname, GLfloat param)
{
  Internal("trace_glTextureParameterfEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTextureParameterfEXT(texture, target, pname, param);
}

static void REGAL_CALL trace_glTextureParameterfvEXT(GLuint texture, GLenum target, GLenum pname, const GLfloat *param)
{
  Internal("trace_glTextureParameterfvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTextureParameterfvEXT(texture, target, pname, param);
}

static void REGAL_CALL trace_glTextureParameteriEXT(GLuint texture, GLenum target, GLenum pname, GLint param)
{
  Internal("trace_glTextureParameteriEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTextureParameteriEXT(texture, target, pname, param);
}

static void REGAL_CALL trace_glTextureParameterivEXT(GLuint texture, GLenum target, GLenum pname, const GLint *param)
{
  Internal("trace_glTextureParameterivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTextureParameterivEXT(texture, target, pname, param);
}

static void REGAL_CALL trace_glTextureRenderbufferEXT(GLuint texture, GLenum target, GLuint renderbuffer)
{
  Internal("trace_glTextureRenderbufferEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTextureRenderbufferEXT(texture, target, renderbuffer);
}

static void REGAL_CALL trace_glTextureSubImage1DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
{
  Internal("trace_glTextureSubImage1DEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTextureSubImage1DEXT(texture, target, level, xoffset, width, format, type, pixels);
}

static void REGAL_CALL trace_glTextureSubImage2DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
{
  Internal("trace_glTextureSubImage2DEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTextureSubImage2DEXT(texture, target, level, xoffset, yoffset, width, height, format, type, pixels);
}

static void REGAL_CALL trace_glTextureSubImage3DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
{
  Internal("trace_glTextureSubImage3DEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTextureSubImage3DEXT(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
}

static GLboolean REGAL_CALL trace_glUnmapNamedBufferEXT(GLuint buffer)
{
  Internal("trace_glUnmapNamedBufferEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glUnmapNamedBufferEXT(buffer);
  return ret;
}

static void REGAL_CALL trace_glVertexArrayColorOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, const GLintptr offset)
{
  Internal("trace_glVertexArrayColorOffsetEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexArrayColorOffsetEXT(vaobj, buffer, size, type, stride, offset);
}

static void REGAL_CALL trace_glVertexArrayEdgeFlagOffsetEXT(GLuint vaobj, GLuint buffer, GLsizei stride, const GLintptr offset)
{
  Internal("trace_glVertexArrayEdgeFlagOffsetEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexArrayEdgeFlagOffsetEXT(vaobj, buffer, stride, offset);
}

static void REGAL_CALL trace_glVertexArrayFogCoordOffsetEXT(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, const GLintptr offset)
{
  Internal("trace_glVertexArrayFogCoordOffsetEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexArrayFogCoordOffsetEXT(vaobj, buffer, type, stride, offset);
}

static void REGAL_CALL trace_glVertexArrayIndexOffsetEXT(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, const GLintptr offset)
{
  Internal("trace_glVertexArrayIndexOffsetEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexArrayIndexOffsetEXT(vaobj, buffer, type, stride, offset);
}

static void REGAL_CALL trace_glVertexArrayMultiTexCoordOffsetEXT(GLuint vaobj, GLuint buffer, GLenum texunit, GLint size, GLenum type, GLsizei stride, const GLintptr offset)
{
  Internal("trace_glVertexArrayMultiTexCoordOffsetEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexArrayMultiTexCoordOffsetEXT(vaobj, buffer, texunit, size, type, stride, offset);
}

static void REGAL_CALL trace_glVertexArrayNormalOffsetEXT(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, const GLintptr offset)
{
  Internal("trace_glVertexArrayNormalOffsetEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexArrayNormalOffsetEXT(vaobj, buffer, type, stride, offset);
}

static void REGAL_CALL trace_glVertexArraySecondaryColorOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, const GLintptr offset)
{
  Internal("trace_glVertexArraySecondaryColorOffsetEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexArraySecondaryColorOffsetEXT(vaobj, buffer, size, type, stride, offset);
}

static void REGAL_CALL trace_glVertexArrayTexCoordOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, const GLintptr offset)
{
  Internal("trace_glVertexArrayTexCoordOffsetEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexArrayTexCoordOffsetEXT(vaobj, buffer, size, type, stride, offset);
}

static void REGAL_CALL trace_glVertexArrayVertexAttribIOffsetEXT(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, const GLintptr offset)
{
  Internal("trace_glVertexArrayVertexAttribIOffsetEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexArrayVertexAttribIOffsetEXT(vaobj, buffer, index, size, type, stride, offset);
}

static void REGAL_CALL trace_glVertexArrayVertexAttribOffsetEXT(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLintptr offset)
{
  Internal("trace_glVertexArrayVertexAttribOffsetEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexArrayVertexAttribOffsetEXT(vaobj, buffer, index, size, type, normalized, stride, offset);
}

static void REGAL_CALL trace_glVertexArrayVertexOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, const GLintptr offset)
{
  Internal("trace_glVertexArrayVertexOffsetEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexArrayVertexOffsetEXT(vaobj, buffer, size, type, stride, offset);
}

// GL_EXT_discard_framebuffer

static void REGAL_CALL trace_glDiscardFramebufferEXT(GLenum target, GLsizei numAttachments, const GLenum *attachments)
{
  Internal("trace_glDiscardFramebufferEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDiscardFramebufferEXT(target, numAttachments, attachments);
}

// GL_EXT_draw_buffers2

static void REGAL_CALL trace_glColorMaskIndexedEXT(GLuint buf, GLboolean r, GLboolean g, GLboolean b, GLboolean a)
{
  Internal("trace_glColorMaskIndexedEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColorMaskIndexedEXT(buf, r, g, b, a);
}

static void REGAL_CALL trace_glDisableIndexedEXT(GLenum target, GLuint index)
{
  Internal("trace_glDisableIndexedEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDisableIndexedEXT(target, index);
}

static void REGAL_CALL trace_glEnableIndexedEXT(GLenum target, GLuint index)
{
  Internal("trace_glEnableIndexedEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glEnableIndexedEXT(target, index);
}

static void REGAL_CALL trace_glGetBooleanIndexedvEXT(GLenum value, GLuint index, GLboolean *data)
{
  Internal("trace_glGetBooleanIndexedvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetBooleanIndexedvEXT(value, index, data);
}

static void REGAL_CALL trace_glGetIntegerIndexedvEXT(GLenum value, GLuint index, GLint *data)
{
  Internal("trace_glGetIntegerIndexedvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetIntegerIndexedvEXT(value, index, data);
}

static GLboolean REGAL_CALL trace_glIsEnabledIndexedEXT(GLenum target, GLuint index)
{
  Internal("trace_glIsEnabledIndexedEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glIsEnabledIndexedEXT(target, index);
  return ret;
}

// GL_EXT_draw_instanced

static void REGAL_CALL trace_glDrawArraysInstancedEXT(GLenum mode, GLint start, GLsizei count, GLsizei primcount)
{
  Internal("trace_glDrawArraysInstancedEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDrawArraysInstancedEXT(mode, start, count, primcount);
}

static void REGAL_CALL trace_glDrawElementsInstancedEXT(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount)
{
  Internal("trace_glDrawElementsInstancedEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDrawElementsInstancedEXT(mode, count, type, indices, primcount);
}

// GL_EXT_draw_range_elements

static void REGAL_CALL trace_glDrawRangeElementsEXT(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices)
{
  Internal("trace_glDrawRangeElementsEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDrawRangeElementsEXT(mode, start, end, count, type, indices);
}

// GL_EXT_fog_coord

static void REGAL_CALL trace_glFogCoordPointerEXT(GLenum type, GLsizei stride, const GLvoid *pointer)
{
  Internal("trace_glFogCoordPointerEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFogCoordPointerEXT(type, stride, pointer);
}

static void REGAL_CALL trace_glFogCoorddEXT(GLdouble coord)
{
  Internal("trace_glFogCoorddEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFogCoorddEXT(coord);
}

static void REGAL_CALL trace_glFogCoorddvEXT(const GLdouble *coord)
{
  Internal("trace_glFogCoorddvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFogCoorddvEXT(coord);
}

static void REGAL_CALL trace_glFogCoordfEXT(GLfloat coord)
{
  Internal("trace_glFogCoordfEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFogCoordfEXT(coord);
}

static void REGAL_CALL trace_glFogCoordfvEXT(const GLfloat *coord)
{
  Internal("trace_glFogCoordfvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFogCoordfvEXT(coord);
}

// GL_EXT_framebuffer_blit

static void REGAL_CALL trace_glBlitFramebufferEXT(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
{
  Internal("trace_glBlitFramebufferEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBlitFramebufferEXT(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
}

// GL_EXT_framebuffer_multisample

static void REGAL_CALL trace_glRenderbufferStorageMultisampleEXT(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
  Internal("trace_glRenderbufferStorageMultisampleEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glRenderbufferStorageMultisampleEXT(target, samples, internalformat, width, height);
}

// GL_EXT_framebuffer_object

static void REGAL_CALL trace_glBindFramebufferEXT(GLenum target, GLuint framebuffer)
{
  Internal("trace_glBindFramebufferEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBindFramebufferEXT(target, framebuffer);
}

static void REGAL_CALL trace_glBindRenderbufferEXT(GLenum target, GLuint renderbuffer)
{
  Internal("trace_glBindRenderbufferEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBindRenderbufferEXT(target, renderbuffer);
}

static GLenum REGAL_CALL trace_glCheckFramebufferStatusEXT(GLenum target)
{
  Internal("trace_glCheckFramebufferStatusEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLenum  ret = Trace::glCheckFramebufferStatusEXT(target);
  return ret;
}

static void REGAL_CALL trace_glDeleteFramebuffersEXT(GLsizei n, const GLuint *framebuffers)
{
  Internal("trace_glDeleteFramebuffersEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDeleteFramebuffersEXT(n, framebuffers);
}

static void REGAL_CALL trace_glDeleteRenderbuffersEXT(GLsizei n, const GLuint *renderbuffers)
{
  Internal("trace_glDeleteRenderbuffersEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDeleteRenderbuffersEXT(n, renderbuffers);
}

static void REGAL_CALL trace_glFramebufferRenderbufferEXT(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{
  Internal("trace_glFramebufferRenderbufferEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFramebufferRenderbufferEXT(target, attachment, renderbuffertarget, renderbuffer);
}

static void REGAL_CALL trace_glFramebufferTexture1DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
  Internal("trace_glFramebufferTexture1DEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFramebufferTexture1DEXT(target, attachment, textarget, texture, level);
}

static void REGAL_CALL trace_glFramebufferTexture2DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
  Internal("trace_glFramebufferTexture2DEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFramebufferTexture2DEXT(target, attachment, textarget, texture, level);
}

static void REGAL_CALL trace_glFramebufferTexture3DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)
{
  Internal("trace_glFramebufferTexture3DEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFramebufferTexture3DEXT(target, attachment, textarget, texture, level, zoffset);
}

static void REGAL_CALL trace_glGenFramebuffersEXT(GLsizei n, GLuint *framebuffers)
{
  Internal("trace_glGenFramebuffersEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGenFramebuffersEXT(n, framebuffers);
}

static void REGAL_CALL trace_glGenRenderbuffersEXT(GLsizei n, GLuint *renderbuffers)
{
  Internal("trace_glGenRenderbuffersEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGenRenderbuffersEXT(n, renderbuffers);
}

static void REGAL_CALL trace_glGenerateMipmapEXT(GLenum target)
{
  Internal("trace_glGenerateMipmapEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGenerateMipmapEXT(target);
}

static void REGAL_CALL trace_glGetFramebufferAttachmentParameterivEXT(GLenum target, GLenum attachment, GLenum pname, GLint *params)
{
  Internal("trace_glGetFramebufferAttachmentParameterivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetFramebufferAttachmentParameterivEXT(target, attachment, pname, params);
}

static void REGAL_CALL trace_glGetRenderbufferParameterivEXT(GLenum target, GLenum pname, GLint *params)
{
  Internal("trace_glGetRenderbufferParameterivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetRenderbufferParameterivEXT(target, pname, params);
}

static GLboolean REGAL_CALL trace_glIsFramebufferEXT(GLuint framebuffer)
{
  Internal("trace_glIsFramebufferEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glIsFramebufferEXT(framebuffer);
  return ret;
}

static GLboolean REGAL_CALL trace_glIsRenderbufferEXT(GLuint renderbuffer)
{
  Internal("trace_glIsRenderbufferEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glIsRenderbufferEXT(renderbuffer);
  return ret;
}

static void REGAL_CALL trace_glRenderbufferStorageEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
{
  Internal("trace_glRenderbufferStorageEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glRenderbufferStorageEXT(target, internalformat, width, height);
}

// GL_EXT_geometry_shader4

static void REGAL_CALL trace_glFramebufferTextureEXT(GLenum target, GLenum attachment, GLuint texture, GLint level)
{
  Internal("trace_glFramebufferTextureEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFramebufferTextureEXT(target, attachment, texture, level);
}

static void REGAL_CALL trace_glFramebufferTextureFaceEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face)
{
  Internal("trace_glFramebufferTextureFaceEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFramebufferTextureFaceEXT(target, attachment, texture, level, face);
}

static void REGAL_CALL trace_glProgramParameteriEXT(GLuint program, GLenum pname, GLint value)
{
  Internal("trace_glProgramParameteriEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramParameteriEXT(program, pname, value);
}

// GL_EXT_gpu_program_parameters

static void REGAL_CALL trace_glProgramEnvParameters4fvEXT(GLenum target, GLuint index, GLsizei count, const GLfloat *params)
{
  Internal("trace_glProgramEnvParameters4fvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramEnvParameters4fvEXT(target, index, count, params);
}

static void REGAL_CALL trace_glProgramLocalParameters4fvEXT(GLenum target, GLuint index, GLsizei count, const GLfloat *params)
{
  Internal("trace_glProgramLocalParameters4fvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramLocalParameters4fvEXT(target, index, count, params);
}

// GL_EXT_gpu_shader4

static void REGAL_CALL trace_glBindFragDataLocationEXT(GLuint program, GLuint color, const GLchar *name)
{
  Internal("trace_glBindFragDataLocationEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBindFragDataLocationEXT(program, color, name);
}

static GLint REGAL_CALL trace_glGetFragDataLocationEXT(GLuint program, const GLchar *name)
{
  Internal("trace_glGetFragDataLocationEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLint  ret = Trace::glGetFragDataLocationEXT(program, name);
  return ret;
}

static void REGAL_CALL trace_glGetUniformuivEXT(GLuint program, GLint location, GLuint *params)
{
  Internal("trace_glGetUniformuivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetUniformuivEXT(program, location, params);
}

static void REGAL_CALL trace_glGetVertexAttribIivEXT(GLuint index, GLenum pname, GLint *params)
{
  Internal("trace_glGetVertexAttribIivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetVertexAttribIivEXT(index, pname, params);
}

static void REGAL_CALL trace_glGetVertexAttribIuivEXT(GLuint index, GLenum pname, GLuint *params)
{
  Internal("trace_glGetVertexAttribIuivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetVertexAttribIuivEXT(index, pname, params);
}

static void REGAL_CALL trace_glUniform1uiEXT(GLint location, GLuint v0)
{
  Internal("trace_glUniform1uiEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform1uiEXT(location, v0);
}

static void REGAL_CALL trace_glUniform1uivEXT(GLint location, GLsizei count, const GLuint *value)
{
  Internal("trace_glUniform1uivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform1uivEXT(location, count, value);
}

static void REGAL_CALL trace_glUniform2uiEXT(GLint location, GLuint v0, GLuint v1)
{
  Internal("trace_glUniform2uiEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform2uiEXT(location, v0, v1);
}

static void REGAL_CALL trace_glUniform2uivEXT(GLint location, GLsizei count, const GLuint *value)
{
  Internal("trace_glUniform2uivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform2uivEXT(location, count, value);
}

static void REGAL_CALL trace_glUniform3uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2)
{
  Internal("trace_glUniform3uiEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform3uiEXT(location, v0, v1, v2);
}

static void REGAL_CALL trace_glUniform3uivEXT(GLint location, GLsizei count, const GLuint *value)
{
  Internal("trace_glUniform3uivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform3uivEXT(location, count, value);
}

static void REGAL_CALL trace_glUniform4uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3)
{
  Internal("trace_glUniform4uiEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform4uiEXT(location, v0, v1, v2, v3);
}

static void REGAL_CALL trace_glUniform4uivEXT(GLint location, GLsizei count, const GLuint *value)
{
  Internal("trace_glUniform4uivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform4uivEXT(location, count, value);
}

static void REGAL_CALL trace_glVertexAttribI1iEXT(GLuint index, GLint x)
{
  Internal("trace_glVertexAttribI1iEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribI1iEXT(index, x);
}

static void REGAL_CALL trace_glVertexAttribI1ivEXT(GLuint index, const GLint *v)
{
  Internal("trace_glVertexAttribI1ivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribI1ivEXT(index, v);
}

static void REGAL_CALL trace_glVertexAttribI1uiEXT(GLuint index, GLuint x)
{
  Internal("trace_glVertexAttribI1uiEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribI1uiEXT(index, x);
}

static void REGAL_CALL trace_glVertexAttribI1uivEXT(GLuint index, const GLuint *v)
{
  Internal("trace_glVertexAttribI1uivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribI1uivEXT(index, v);
}

static void REGAL_CALL trace_glVertexAttribI2iEXT(GLuint index, GLint x, GLint y)
{
  Internal("trace_glVertexAttribI2iEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribI2iEXT(index, x, y);
}

static void REGAL_CALL trace_glVertexAttribI2ivEXT(GLuint index, const GLint *v)
{
  Internal("trace_glVertexAttribI2ivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribI2ivEXT(index, v);
}

static void REGAL_CALL trace_glVertexAttribI2uiEXT(GLuint index, GLuint x, GLuint y)
{
  Internal("trace_glVertexAttribI2uiEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribI2uiEXT(index, x, y);
}

static void REGAL_CALL trace_glVertexAttribI2uivEXT(GLuint index, const GLuint *v)
{
  Internal("trace_glVertexAttribI2uivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribI2uivEXT(index, v);
}

static void REGAL_CALL trace_glVertexAttribI3iEXT(GLuint index, GLint x, GLint y, GLint z)
{
  Internal("trace_glVertexAttribI3iEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribI3iEXT(index, x, y, z);
}

static void REGAL_CALL trace_glVertexAttribI3ivEXT(GLuint index, const GLint *v)
{
  Internal("trace_glVertexAttribI3ivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribI3ivEXT(index, v);
}

static void REGAL_CALL trace_glVertexAttribI3uiEXT(GLuint index, GLuint x, GLuint y, GLuint z)
{
  Internal("trace_glVertexAttribI3uiEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribI3uiEXT(index, x, y, z);
}

static void REGAL_CALL trace_glVertexAttribI3uivEXT(GLuint index, const GLuint *v)
{
  Internal("trace_glVertexAttribI3uivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribI3uivEXT(index, v);
}

static void REGAL_CALL trace_glVertexAttribI4bvEXT(GLuint index, const GLbyte *v)
{
  Internal("trace_glVertexAttribI4bvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribI4bvEXT(index, v);
}

static void REGAL_CALL trace_glVertexAttribI4iEXT(GLuint index, GLint x, GLint y, GLint z, GLint w)
{
  Internal("trace_glVertexAttribI4iEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribI4iEXT(index, x, y, z, w);
}

static void REGAL_CALL trace_glVertexAttribI4ivEXT(GLuint index, const GLint *v)
{
  Internal("trace_glVertexAttribI4ivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribI4ivEXT(index, v);
}

static void REGAL_CALL trace_glVertexAttribI4svEXT(GLuint index, const GLshort *v)
{
  Internal("trace_glVertexAttribI4svEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribI4svEXT(index, v);
}

static void REGAL_CALL trace_glVertexAttribI4ubvEXT(GLuint index, const GLubyte *v)
{
  Internal("trace_glVertexAttribI4ubvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribI4ubvEXT(index, v);
}

static void REGAL_CALL trace_glVertexAttribI4uiEXT(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
{
  Internal("trace_glVertexAttribI4uiEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribI4uiEXT(index, x, y, z, w);
}

static void REGAL_CALL trace_glVertexAttribI4uivEXT(GLuint index, const GLuint *v)
{
  Internal("trace_glVertexAttribI4uivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribI4uivEXT(index, v);
}

static void REGAL_CALL trace_glVertexAttribI4usvEXT(GLuint index, const GLushort *v)
{
  Internal("trace_glVertexAttribI4usvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribI4usvEXT(index, v);
}

static void REGAL_CALL trace_glVertexAttribIPointerEXT(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
  Internal("trace_glVertexAttribIPointerEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribIPointerEXT(index, size, type, stride, pointer);
}

// GL_EXT_histogram

static void REGAL_CALL trace_glGetHistogramEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values)
{
  Internal("trace_glGetHistogramEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetHistogramEXT(target, reset, format, type, values);
}

static void REGAL_CALL trace_glGetHistogramParameterfvEXT(GLenum target, GLenum pname, GLfloat *params)
{
  Internal("trace_glGetHistogramParameterfvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetHistogramParameterfvEXT(target, pname, params);
}

static void REGAL_CALL trace_glGetHistogramParameterivEXT(GLenum target, GLenum pname, GLint *params)
{
  Internal("trace_glGetHistogramParameterivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetHistogramParameterivEXT(target, pname, params);
}

static void REGAL_CALL trace_glGetMinmaxEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values)
{
  Internal("trace_glGetMinmaxEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetMinmaxEXT(target, reset, format, type, values);
}

static void REGAL_CALL trace_glGetMinmaxParameterfvEXT(GLenum target, GLenum pname, GLfloat *params)
{
  Internal("trace_glGetMinmaxParameterfvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetMinmaxParameterfvEXT(target, pname, params);
}

static void REGAL_CALL trace_glGetMinmaxParameterivEXT(GLenum target, GLenum pname, GLint *params)
{
  Internal("trace_glGetMinmaxParameterivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetMinmaxParameterivEXT(target, pname, params);
}

static void REGAL_CALL trace_glHistogramEXT(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink)
{
  Internal("trace_glHistogramEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glHistogramEXT(target, width, internalformat, sink);
}

static void REGAL_CALL trace_glMinmaxEXT(GLenum target, GLenum internalformat, GLboolean sink)
{
  Internal("trace_glMinmaxEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMinmaxEXT(target, internalformat, sink);
}

static void REGAL_CALL trace_glResetHistogramEXT(GLenum target)
{
  Internal("trace_glResetHistogramEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glResetHistogramEXT(target);
}

static void REGAL_CALL trace_glResetMinmaxEXT(GLenum target)
{
  Internal("trace_glResetMinmaxEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glResetMinmaxEXT(target);
}

// GL_EXT_index_func

static void REGAL_CALL trace_glIndexFuncEXT(GLenum func, GLfloat ref)
{
  Internal("trace_glIndexFuncEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glIndexFuncEXT(func, ref);
}

// GL_EXT_index_material

static void REGAL_CALL trace_glIndexMaterialEXT(GLenum face, GLenum mode)
{
  Internal("trace_glIndexMaterialEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glIndexMaterialEXT(face, mode);
}

// GL_EXT_light_texture

static void REGAL_CALL trace_glApplyTextureEXT(GLenum mode)
{
  Internal("trace_glApplyTextureEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glApplyTextureEXT(mode);
}

static void REGAL_CALL trace_glTextureLightEXT(GLenum pname)
{
  Internal("trace_glTextureLightEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTextureLightEXT(pname);
}

static void REGAL_CALL trace_glTextureMaterialEXT(GLenum face, GLenum mode)
{
  Internal("trace_glTextureMaterialEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTextureMaterialEXT(face, mode);
}

// GL_EXT_multi_draw_arrays

static void REGAL_CALL trace_glMultiDrawArraysEXT(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount)
{
  Internal("trace_glMultiDrawArraysEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiDrawArraysEXT(mode, first, count, primcount);
}

static void REGAL_CALL trace_glMultiDrawElementsEXT(GLenum mode, const GLsizei *count, GLenum type, const GLvoid **indices, GLsizei primcount)
{
  Internal("trace_glMultiDrawElementsEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiDrawElementsEXT(mode, count, type, indices, primcount);
}

// GL_EXT_multisample

static void REGAL_CALL trace_glSampleMaskEXT(GLclampf value, GLboolean invert)
{
  Internal("trace_glSampleMaskEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSampleMaskEXT(value, invert);
}

static void REGAL_CALL trace_glSamplePatternEXT(GLenum pattern)
{
  Internal("trace_glSamplePatternEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSamplePatternEXT(pattern);
}

// GL_EXT_occlusion_query_boolean

static void REGAL_CALL trace_glBeginQueryEXT(GLenum target, GLuint id)
{
  Internal("trace_glBeginQueryEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBeginQueryEXT(target, id);
}

static void REGAL_CALL trace_glDeleteQueriesEXT(GLsizei n, const GLuint *ids)
{
  Internal("trace_glDeleteQueriesEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDeleteQueriesEXT(n, ids);
}

static void REGAL_CALL trace_glEndQueryEXT(GLenum target)
{
  Internal("trace_glEndQueryEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glEndQueryEXT(target);
}

static void REGAL_CALL trace_glGenQueriesEXT(GLsizei n, GLuint *ids)
{
  Internal("trace_glGenQueriesEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGenQueriesEXT(n, ids);
}

static void REGAL_CALL trace_glGetQueryObjectuivEXT(GLuint id, GLenum pname, GLuint *params)
{
  Internal("trace_glGetQueryObjectuivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetQueryObjectuivEXT(id, pname, params);
}

static void REGAL_CALL trace_glGetQueryivEXT(GLenum target, GLenum pname, GLint *params)
{
  Internal("trace_glGetQueryivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetQueryivEXT(target, pname, params);
}

static GLboolean REGAL_CALL trace_glIsQueryEXT(GLuint id)
{
  Internal("trace_glIsQueryEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glIsQueryEXT(id);
  return ret;
}

// GL_EXT_paletted_texture

static void REGAL_CALL trace_glColorTableEXT(GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const GLvoid *table)
{
  Internal("trace_glColorTableEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColorTableEXT(target, internalFormat, width, format, type, table);
}

static void REGAL_CALL trace_glGetColorTableEXT(GLenum target, GLenum format, GLenum type, GLvoid *data)
{
  Internal("trace_glGetColorTableEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetColorTableEXT(target, format, type, data);
}

static void REGAL_CALL trace_glGetColorTableParameterfvEXT(GLenum target, GLenum pname, GLfloat *params)
{
  Internal("trace_glGetColorTableParameterfvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetColorTableParameterfvEXT(target, pname, params);
}

static void REGAL_CALL trace_glGetColorTableParameterivEXT(GLenum target, GLenum pname, GLint *params)
{
  Internal("trace_glGetColorTableParameterivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetColorTableParameterivEXT(target, pname, params);
}

// GL_EXT_pixel_transform

static void REGAL_CALL trace_glPixelTransformParameterfEXT(GLenum target, GLenum pname, const GLfloat param)
{
  Internal("trace_glPixelTransformParameterfEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPixelTransformParameterfEXT(target, pname, param);
}

static void REGAL_CALL trace_glPixelTransformParameterfvEXT(GLenum target, GLenum pname, const GLfloat *params)
{
  Internal("trace_glPixelTransformParameterfvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPixelTransformParameterfvEXT(target, pname, params);
}

static void REGAL_CALL trace_glPixelTransformParameteriEXT(GLenum target, GLenum pname, const GLint param)
{
  Internal("trace_glPixelTransformParameteriEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPixelTransformParameteriEXT(target, pname, param);
}

static void REGAL_CALL trace_glPixelTransformParameterivEXT(GLenum target, GLenum pname, const GLint *params)
{
  Internal("trace_glPixelTransformParameterivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPixelTransformParameterivEXT(target, pname, params);
}

// GL_EXT_point_parameters

static void REGAL_CALL trace_glPointParameterfEXT(GLenum pname, GLfloat param)
{
  Internal("trace_glPointParameterfEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPointParameterfEXT(pname, param);
}

static void REGAL_CALL trace_glPointParameterfvEXT(GLenum pname, const GLfloat *params)
{
  Internal("trace_glPointParameterfvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPointParameterfvEXT(pname, params);
}

// GL_EXT_polygon_offset

static void REGAL_CALL trace_glPolygonOffsetEXT(GLfloat factor, GLfloat bias)
{
  Internal("trace_glPolygonOffsetEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPolygonOffsetEXT(factor, bias);
}

// GL_EXT_provoking_vertex

static void REGAL_CALL trace_glProvokingVertexEXT(GLenum mode)
{
  Internal("trace_glProvokingVertexEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProvokingVertexEXT(mode);
}

// GL_EXT_secondary_color

static void REGAL_CALL trace_glSecondaryColor3bEXT(GLbyte red, GLbyte green, GLbyte blue)
{
  Internal("trace_glSecondaryColor3bEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSecondaryColor3bEXT(red, green, blue);
}

static void REGAL_CALL trace_glSecondaryColor3bvEXT(const GLbyte *v)
{
  Internal("trace_glSecondaryColor3bvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSecondaryColor3bvEXT(v);
}

static void REGAL_CALL trace_glSecondaryColor3dEXT(GLdouble red, GLdouble green, GLdouble blue)
{
  Internal("trace_glSecondaryColor3dEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSecondaryColor3dEXT(red, green, blue);
}

static void REGAL_CALL trace_glSecondaryColor3dvEXT(const GLdouble *v)
{
  Internal("trace_glSecondaryColor3dvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSecondaryColor3dvEXT(v);
}

static void REGAL_CALL trace_glSecondaryColor3fEXT(GLfloat red, GLfloat green, GLfloat blue)
{
  Internal("trace_glSecondaryColor3fEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSecondaryColor3fEXT(red, green, blue);
}

static void REGAL_CALL trace_glSecondaryColor3fvEXT(const GLfloat *v)
{
  Internal("trace_glSecondaryColor3fvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSecondaryColor3fvEXT(v);
}

static void REGAL_CALL trace_glSecondaryColor3iEXT(GLint red, GLint green, GLint blue)
{
  Internal("trace_glSecondaryColor3iEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSecondaryColor3iEXT(red, green, blue);
}

static void REGAL_CALL trace_glSecondaryColor3ivEXT(const GLint *v)
{
  Internal("trace_glSecondaryColor3ivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSecondaryColor3ivEXT(v);
}

static void REGAL_CALL trace_glSecondaryColor3sEXT(GLshort red, GLshort green, GLshort blue)
{
  Internal("trace_glSecondaryColor3sEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSecondaryColor3sEXT(red, green, blue);
}

static void REGAL_CALL trace_glSecondaryColor3svEXT(const GLshort *v)
{
  Internal("trace_glSecondaryColor3svEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSecondaryColor3svEXT(v);
}

static void REGAL_CALL trace_glSecondaryColor3ubEXT(GLubyte red, GLubyte green, GLubyte blue)
{
  Internal("trace_glSecondaryColor3ubEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSecondaryColor3ubEXT(red, green, blue);
}

static void REGAL_CALL trace_glSecondaryColor3ubvEXT(const GLubyte *v)
{
  Internal("trace_glSecondaryColor3ubvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSecondaryColor3ubvEXT(v);
}

static void REGAL_CALL trace_glSecondaryColor3uiEXT(GLuint red, GLuint green, GLuint blue)
{
  Internal("trace_glSecondaryColor3uiEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSecondaryColor3uiEXT(red, green, blue);
}

static void REGAL_CALL trace_glSecondaryColor3uivEXT(const GLuint *v)
{
  Internal("trace_glSecondaryColor3uivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSecondaryColor3uivEXT(v);
}

static void REGAL_CALL trace_glSecondaryColor3usEXT(GLushort red, GLushort green, GLushort blue)
{
  Internal("trace_glSecondaryColor3usEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSecondaryColor3usEXT(red, green, blue);
}

static void REGAL_CALL trace_glSecondaryColor3usvEXT(const GLushort *v)
{
  Internal("trace_glSecondaryColor3usvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSecondaryColor3usvEXT(v);
}

static void REGAL_CALL trace_glSecondaryColorPointerEXT(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
  Internal("trace_glSecondaryColorPointerEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSecondaryColorPointerEXT(size, type, stride, pointer);
}

// GL_EXT_separate_shader_objects

static void REGAL_CALL trace_glActiveProgramEXT(GLuint program)
{
  Internal("trace_glActiveProgramEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glActiveProgramEXT(program);
}

static GLuint REGAL_CALL trace_glCreateShaderProgramEXT(GLenum type, const GLchar *string)
{
  Internal("trace_glCreateShaderProgramEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLuint  ret = Trace::glCreateShaderProgramEXT(type, string);
  return ret;
}

static void REGAL_CALL trace_glUseShaderProgramEXT(GLenum type, GLuint program)
{
  Internal("trace_glUseShaderProgramEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUseShaderProgramEXT(type, program);
}

// GL_EXT_shader_image_load_store

static void REGAL_CALL trace_glBindImageTextureEXT(GLuint index, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLint format)
{
  Internal("trace_glBindImageTextureEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBindImageTextureEXT(index, texture, level, layered, layer, access, format);
}

static void REGAL_CALL trace_glMemoryBarrierEXT(GLbitfield barriers)
{
  Internal("trace_glMemoryBarrierEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMemoryBarrierEXT(barriers);
}

// GL_EXT_stencil_clear_tag

static void REGAL_CALL trace_glStencilClearTagEXT(GLsizei stencilTagBits, GLuint stencilClearTag)
{
  Internal("trace_glStencilClearTagEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glStencilClearTagEXT(stencilTagBits, stencilClearTag);
}

// GL_EXT_stencil_two_side

static void REGAL_CALL trace_glActiveStencilFaceEXT(GLenum face)
{
  Internal("trace_glActiveStencilFaceEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glActiveStencilFaceEXT(face);
}

// GL_EXT_subtexture

static void REGAL_CALL trace_glTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
{
  Internal("trace_glTexSubImage1DEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexSubImage1DEXT(target, level, xoffset, width, format, type, pixels);
}

static void REGAL_CALL trace_glTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
{
  Internal("trace_glTexSubImage2DEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexSubImage2DEXT(target, level, xoffset, yoffset, width, height, format, type, pixels);
}

static void REGAL_CALL trace_glTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
{
  Internal("trace_glTexSubImage3DEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexSubImage3DEXT(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
}

// GL_EXT_texture3D

static void REGAL_CALL trace_glTexImage3DEXT(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
  Internal("trace_glTexImage3DEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexImage3DEXT(target, level, internalformat, width, height, depth, border, format, type, pixels);
}

// GL_EXT_texture_array

static void REGAL_CALL trace_glFramebufferTextureLayerEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)
{
  Internal("trace_glFramebufferTextureLayerEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFramebufferTextureLayerEXT(target, attachment, texture, level, layer);
}

// GL_EXT_texture_buffer_object

static void REGAL_CALL trace_glTexBufferEXT(GLenum target, GLenum internalformat, GLuint buffer)
{
  Internal("trace_glTexBufferEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexBufferEXT(target, internalformat, buffer);
}

// GL_EXT_texture_integer

static void REGAL_CALL trace_glClearColorIiEXT(GLint red, GLint green, GLint blue, GLint alpha)
{
  Internal("trace_glClearColorIiEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glClearColorIiEXT(red, green, blue, alpha);
}

static void REGAL_CALL trace_glClearColorIuiEXT(GLuint red, GLuint green, GLuint blue, GLuint alpha)
{
  Internal("trace_glClearColorIuiEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glClearColorIuiEXT(red, green, blue, alpha);
}

static void REGAL_CALL trace_glGetTexParameterIivEXT(GLenum target, GLenum pname, GLint *params)
{
  Internal("trace_glGetTexParameterIivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetTexParameterIivEXT(target, pname, params);
}

static void REGAL_CALL trace_glGetTexParameterIuivEXT(GLenum target, GLenum pname, GLuint *params)
{
  Internal("trace_glGetTexParameterIuivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetTexParameterIuivEXT(target, pname, params);
}

static void REGAL_CALL trace_glTexParameterIivEXT(GLenum target, GLenum pname, const GLint *params)
{
  Internal("trace_glTexParameterIivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexParameterIivEXT(target, pname, params);
}

static void REGAL_CALL trace_glTexParameterIuivEXT(GLenum target, GLenum pname, const GLuint *params)
{
  Internal("trace_glTexParameterIuivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexParameterIuivEXT(target, pname, params);
}

// GL_EXT_texture_object

static GLboolean REGAL_CALL trace_glAreTexturesResidentEXT(GLsizei n, const GLuint *textures, GLboolean *residences)
{
  Internal("trace_glAreTexturesResidentEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glAreTexturesResidentEXT(n, textures, residences);
  return ret;
}

static void REGAL_CALL trace_glBindTextureEXT(GLenum target, GLuint texture)
{
  Internal("trace_glBindTextureEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBindTextureEXT(target, texture);
}

static void REGAL_CALL trace_glDeleteTexturesEXT(GLsizei n, const GLuint *textures)
{
  Internal("trace_glDeleteTexturesEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDeleteTexturesEXT(n, textures);
}

static void REGAL_CALL trace_glGenTexturesEXT(GLsizei n, GLuint *textures)
{
  Internal("trace_glGenTexturesEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGenTexturesEXT(n, textures);
}

static GLboolean REGAL_CALL trace_glIsTextureEXT(GLuint texture)
{
  Internal("trace_glIsTextureEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glIsTextureEXT(texture);
  return ret;
}

static void REGAL_CALL trace_glPrioritizeTexturesEXT(GLsizei n, const GLuint *textures, const GLclampf *priorities)
{
  Internal("trace_glPrioritizeTexturesEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPrioritizeTexturesEXT(n, textures, priorities);
}

// GL_EXT_texture_perturb_normal

static void REGAL_CALL trace_glTextureNormalEXT(GLenum mode)
{
  Internal("trace_glTextureNormalEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTextureNormalEXT(mode);
}

// GL_EXT_timer_query

static void REGAL_CALL trace_glGetQueryObjecti64vEXT(GLuint id, GLenum pname, GLint64EXT *params)
{
  Internal("trace_glGetQueryObjecti64vEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetQueryObjecti64vEXT(id, pname, params);
}

static void REGAL_CALL trace_glGetQueryObjectui64vEXT(GLuint id, GLenum pname, GLuint64EXT *params)
{
  Internal("trace_glGetQueryObjectui64vEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetQueryObjectui64vEXT(id, pname, params);
}

// GL_EXT_transform_feedback

static void REGAL_CALL trace_glBeginTransformFeedbackEXT(GLenum primitiveMode)
{
  Internal("trace_glBeginTransformFeedbackEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBeginTransformFeedbackEXT(primitiveMode);
}

static void REGAL_CALL trace_glBindBufferBaseEXT(GLenum target, GLuint index, GLuint buffer)
{
  Internal("trace_glBindBufferBaseEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBindBufferBaseEXT(target, index, buffer);
}

static void REGAL_CALL trace_glBindBufferOffsetEXT(GLenum target, GLuint index, GLuint buffer, GLintptr offset)
{
  Internal("trace_glBindBufferOffsetEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBindBufferOffsetEXT(target, index, buffer, offset);
}

static void REGAL_CALL trace_glBindBufferRangeEXT(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
  Internal("trace_glBindBufferRangeEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBindBufferRangeEXT(target, index, buffer, offset, size);
}

static void REGAL_CALL trace_glEndTransformFeedbackEXT(void)
{
  Internal("trace_glEndTransformFeedbackEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glEndTransformFeedbackEXT();
}

static void REGAL_CALL trace_glGetTransformFeedbackVaryingEXT(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name)
{
  Internal("trace_glGetTransformFeedbackVaryingEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetTransformFeedbackVaryingEXT(program, index, bufSize, length, size, type, name);
}

static void REGAL_CALL trace_glTransformFeedbackVaryingsEXT(GLuint program, GLsizei count, const GLchar ** const varyings, GLenum bufferMode)
{
  Internal("trace_glTransformFeedbackVaryingsEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTransformFeedbackVaryingsEXT(program, count, varyings, bufferMode);
}

// GL_EXT_vertex_array

static void REGAL_CALL trace_glArrayElementEXT(GLint i)
{
  Internal("trace_glArrayElementEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glArrayElementEXT(i);
}

static void REGAL_CALL trace_glColorPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer)
{
  Internal("trace_glColorPointerEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColorPointerEXT(size, type, stride, count, pointer);
}

static void REGAL_CALL trace_glDrawArraysEXT(GLenum mode, GLint first, GLsizei count)
{
  Internal("trace_glDrawArraysEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDrawArraysEXT(mode, first, count);
}

static void REGAL_CALL trace_glEdgeFlagPointerEXT(GLsizei stride, GLsizei count, const GLboolean *pointer)
{
  Internal("trace_glEdgeFlagPointerEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glEdgeFlagPointerEXT(stride, count, pointer);
}

static void REGAL_CALL trace_glGetPointervEXT(GLenum pname, GLvoid **params)
{
  Internal("trace_glGetPointervEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetPointervEXT(pname, params);
}

static void REGAL_CALL trace_glIndexPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer)
{
  Internal("trace_glIndexPointerEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glIndexPointerEXT(type, stride, count, pointer);
}

static void REGAL_CALL trace_glNormalPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer)
{
  Internal("trace_glNormalPointerEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNormalPointerEXT(type, stride, count, pointer);
}

static void REGAL_CALL trace_glTexCoordPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer)
{
  Internal("trace_glTexCoordPointerEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoordPointerEXT(size, type, stride, count, pointer);
}

static void REGAL_CALL trace_glVertexPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer)
{
  Internal("trace_glVertexPointerEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexPointerEXT(size, type, stride, count, pointer);
}

// GL_EXT_vertex_attrib_64bit

static void REGAL_CALL trace_glGetVertexAttribLdvEXT(GLuint index, GLenum pname, GLdouble *params)
{
  Internal("trace_glGetVertexAttribLdvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetVertexAttribLdvEXT(index, pname, params);
}

static void REGAL_CALL trace_glVertexArrayVertexAttribLOffsetEXT(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset)
{
  Internal("trace_glVertexArrayVertexAttribLOffsetEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexArrayVertexAttribLOffsetEXT(vaobj, buffer, index, size, type, stride, offset);
}

static void REGAL_CALL trace_glVertexAttribL1dEXT(GLuint index, GLdouble x)
{
  Internal("trace_glVertexAttribL1dEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribL1dEXT(index, x);
}

static void REGAL_CALL trace_glVertexAttribL1dvEXT(GLuint index, const GLdouble *v)
{
  Internal("trace_glVertexAttribL1dvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribL1dvEXT(index, v);
}

static void REGAL_CALL trace_glVertexAttribL2dEXT(GLuint index, GLdouble x, GLdouble y)
{
  Internal("trace_glVertexAttribL2dEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribL2dEXT(index, x, y);
}

static void REGAL_CALL trace_glVertexAttribL2dvEXT(GLuint index, const GLdouble *v)
{
  Internal("trace_glVertexAttribL2dvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribL2dvEXT(index, v);
}

static void REGAL_CALL trace_glVertexAttribL3dEXT(GLuint index, GLdouble x, GLdouble y, GLdouble z)
{
  Internal("trace_glVertexAttribL3dEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribL3dEXT(index, x, y, z);
}

static void REGAL_CALL trace_glVertexAttribL3dvEXT(GLuint index, const GLdouble *v)
{
  Internal("trace_glVertexAttribL3dvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribL3dvEXT(index, v);
}

static void REGAL_CALL trace_glVertexAttribL4dEXT(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  Internal("trace_glVertexAttribL4dEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribL4dEXT(index, x, y, z, w);
}

static void REGAL_CALL trace_glVertexAttribL4dvEXT(GLuint index, const GLdouble *v)
{
  Internal("trace_glVertexAttribL4dvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribL4dvEXT(index, v);
}

static void REGAL_CALL trace_glVertexAttribLPointerEXT(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
  Internal("trace_glVertexAttribLPointerEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribLPointerEXT(index, size, type, stride, pointer);
}

// GL_EXT_vertex_shader

static void REGAL_CALL trace_glBeginVertexShaderEXT(void)
{
  Internal("trace_glBeginVertexShaderEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBeginVertexShaderEXT();
}

static GLuint REGAL_CALL trace_glBindLightParameterEXT(GLenum light, GLenum value)
{
  Internal("trace_glBindLightParameterEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLuint  ret = Trace::glBindLightParameterEXT(light, value);
  return ret;
}

static GLuint REGAL_CALL trace_glBindMaterialParameterEXT(GLenum face, GLenum value)
{
  Internal("trace_glBindMaterialParameterEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLuint  ret = Trace::glBindMaterialParameterEXT(face, value);
  return ret;
}

static GLuint REGAL_CALL trace_glBindParameterEXT(GLenum value)
{
  Internal("trace_glBindParameterEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLuint  ret = Trace::glBindParameterEXT(value);
  return ret;
}

static GLuint REGAL_CALL trace_glBindTexGenParameterEXT(GLenum unit, GLenum coord, GLenum value)
{
  Internal("trace_glBindTexGenParameterEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLuint  ret = Trace::glBindTexGenParameterEXT(unit, coord, value);
  return ret;
}

static GLuint REGAL_CALL trace_glBindTextureUnitParameterEXT(GLenum unit, GLenum value)
{
  Internal("trace_glBindTextureUnitParameterEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLuint  ret = Trace::glBindTextureUnitParameterEXT(unit, value);
  return ret;
}

static void REGAL_CALL trace_glBindVertexShaderEXT(GLuint id)
{
  Internal("trace_glBindVertexShaderEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBindVertexShaderEXT(id);
}

static void REGAL_CALL trace_glDeleteVertexShaderEXT(GLuint id)
{
  Internal("trace_glDeleteVertexShaderEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDeleteVertexShaderEXT(id);
}

static void REGAL_CALL trace_glDisableVariantClientStateEXT(GLuint id)
{
  Internal("trace_glDisableVariantClientStateEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDisableVariantClientStateEXT(id);
}

static void REGAL_CALL trace_glEnableVariantClientStateEXT(GLuint id)
{
  Internal("trace_glEnableVariantClientStateEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glEnableVariantClientStateEXT(id);
}

static void REGAL_CALL trace_glEndVertexShaderEXT(void)
{
  Internal("trace_glEndVertexShaderEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glEndVertexShaderEXT();
}

static void REGAL_CALL trace_glExtractComponentEXT(GLuint res, GLuint src, GLuint num)
{
  Internal("trace_glExtractComponentEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glExtractComponentEXT(res, src, num);
}

static GLuint REGAL_CALL trace_glGenSymbolsEXT(GLenum datatype, GLenum storagetype, GLenum range, GLuint components)
{
  Internal("trace_glGenSymbolsEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLuint  ret = Trace::glGenSymbolsEXT(datatype, storagetype, range, components);
  return ret;
}

static GLuint REGAL_CALL trace_glGenVertexShadersEXT(GLuint range)
{
  Internal("trace_glGenVertexShadersEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLuint  ret = Trace::glGenVertexShadersEXT(range);
  return ret;
}

static void REGAL_CALL trace_glGetInvariantBooleanvEXT(GLuint id, GLenum value, GLboolean *data)
{
  Internal("trace_glGetInvariantBooleanvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetInvariantBooleanvEXT(id, value, data);
}

static void REGAL_CALL trace_glGetInvariantFloatvEXT(GLuint id, GLenum value, GLfloat *data)
{
  Internal("trace_glGetInvariantFloatvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetInvariantFloatvEXT(id, value, data);
}

static void REGAL_CALL trace_glGetInvariantIntegervEXT(GLuint id, GLenum value, GLint *data)
{
  Internal("trace_glGetInvariantIntegervEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetInvariantIntegervEXT(id, value, data);
}

static void REGAL_CALL trace_glGetLocalConstantBooleanvEXT(GLuint id, GLenum value, GLboolean *data)
{
  Internal("trace_glGetLocalConstantBooleanvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetLocalConstantBooleanvEXT(id, value, data);
}

static void REGAL_CALL trace_glGetLocalConstantFloatvEXT(GLuint id, GLenum value, GLfloat *data)
{
  Internal("trace_glGetLocalConstantFloatvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetLocalConstantFloatvEXT(id, value, data);
}

static void REGAL_CALL trace_glGetLocalConstantIntegervEXT(GLuint id, GLenum value, GLint *data)
{
  Internal("trace_glGetLocalConstantIntegervEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetLocalConstantIntegervEXT(id, value, data);
}

static void REGAL_CALL trace_glGetVariantBooleanvEXT(GLuint id, GLenum value, GLboolean *data)
{
  Internal("trace_glGetVariantBooleanvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetVariantBooleanvEXT(id, value, data);
}

static void REGAL_CALL trace_glGetVariantFloatvEXT(GLuint id, GLenum value, GLfloat *data)
{
  Internal("trace_glGetVariantFloatvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetVariantFloatvEXT(id, value, data);
}

static void REGAL_CALL trace_glGetVariantIntegervEXT(GLuint id, GLenum value, GLint *data)
{
  Internal("trace_glGetVariantIntegervEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetVariantIntegervEXT(id, value, data);
}

static void REGAL_CALL trace_glGetVariantPointervEXT(GLuint id, GLenum value, GLvoid **data)
{
  Internal("trace_glGetVariantPointervEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetVariantPointervEXT(id, value, data);
}

static void REGAL_CALL trace_glInsertComponentEXT(GLuint res, GLuint src, GLuint num)
{
  Internal("trace_glInsertComponentEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glInsertComponentEXT(res, src, num);
}

static GLboolean REGAL_CALL trace_glIsVariantEnabledEXT(GLuint id, GLenum cap)
{
  Internal("trace_glIsVariantEnabledEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glIsVariantEnabledEXT(id, cap);
  return ret;
}

static void REGAL_CALL trace_glSetInvariantEXT(GLuint id, GLenum type, const GLvoid *addr)
{
  Internal("trace_glSetInvariantEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSetInvariantEXT(id, type, addr);
}

static void REGAL_CALL trace_glSetLocalConstantEXT(GLuint id, GLenum type, const GLvoid *addr)
{
  Internal("trace_glSetLocalConstantEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSetLocalConstantEXT(id, type, addr);
}

static void REGAL_CALL trace_glShaderOp1EXT(GLenum op, GLuint res, GLuint arg1)
{
  Internal("trace_glShaderOp1EXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glShaderOp1EXT(op, res, arg1);
}

static void REGAL_CALL trace_glShaderOp2EXT(GLenum op, GLuint res, GLuint arg1, GLuint arg2)
{
  Internal("trace_glShaderOp2EXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glShaderOp2EXT(op, res, arg1, arg2);
}

static void REGAL_CALL trace_glShaderOp3EXT(GLenum op, GLuint res, GLuint arg1, GLuint arg2, GLuint arg3)
{
  Internal("trace_glShaderOp3EXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glShaderOp3EXT(op, res, arg1, arg2, arg3);
}

static void REGAL_CALL trace_glSwizzleEXT(GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW)
{
  Internal("trace_glSwizzleEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSwizzleEXT(res, in, outX, outY, outZ, outW);
}

static void REGAL_CALL trace_glVariantPointerEXT(GLuint id, GLenum type, GLuint stride, const GLvoid *addr)
{
  Internal("trace_glVariantPointerEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVariantPointerEXT(id, type, stride, addr);
}

static void REGAL_CALL trace_glVariantbvEXT(GLuint id, const GLbyte *addr)
{
  Internal("trace_glVariantbvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVariantbvEXT(id, addr);
}

static void REGAL_CALL trace_glVariantdvEXT(GLuint id, const GLdouble *addr)
{
  Internal("trace_glVariantdvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVariantdvEXT(id, addr);
}

static void REGAL_CALL trace_glVariantfvEXT(GLuint id, const GLfloat *addr)
{
  Internal("trace_glVariantfvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVariantfvEXT(id, addr);
}

static void REGAL_CALL trace_glVariantivEXT(GLuint id, const GLint *addr)
{
  Internal("trace_glVariantivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVariantivEXT(id, addr);
}

static void REGAL_CALL trace_glVariantsvEXT(GLuint id, const GLshort *addr)
{
  Internal("trace_glVariantsvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVariantsvEXT(id, addr);
}

static void REGAL_CALL trace_glVariantubvEXT(GLuint id, const GLubyte *addr)
{
  Internal("trace_glVariantubvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVariantubvEXT(id, addr);
}

static void REGAL_CALL trace_glVariantuivEXT(GLuint id, const GLuint *addr)
{
  Internal("trace_glVariantuivEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVariantuivEXT(id, addr);
}

static void REGAL_CALL trace_glVariantusvEXT(GLuint id, const GLushort *addr)
{
  Internal("trace_glVariantusvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVariantusvEXT(id, addr);
}

static void REGAL_CALL trace_glWriteMaskEXT(GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW)
{
  Internal("trace_glWriteMaskEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWriteMaskEXT(res, in, outX, outY, outZ, outW);
}

// GL_EXT_vertex_weighting

static void REGAL_CALL trace_glVertexWeightPointerEXT(GLsizei size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
  Internal("trace_glVertexWeightPointerEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexWeightPointerEXT(size, type, stride, pointer);
}

static void REGAL_CALL trace_glVertexWeightfEXT(GLfloat weight)
{
  Internal("trace_glVertexWeightfEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexWeightfEXT(weight);
}

static void REGAL_CALL trace_glVertexWeightfvEXT(const GLfloat *weight)
{
  Internal("trace_glVertexWeightfvEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexWeightfvEXT(weight);
}

// GL_EXT_x11_sync_object

static GLsync REGAL_CALL trace_glImportSyncEXT(GLenum external_sync_type, GLintptr external_sync, GLbitfield flags)
{
  Internal("trace_glImportSyncEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLsync  ret = Trace::glImportSyncEXT(external_sync_type, external_sync, flags);
  return ret;
}

// GL_GREMEDY_frame_terminator

static void REGAL_CALL trace_glFrameTerminatorGREMEDY(void)
{
  Internal("trace_glFrameTerminatorGREMEDY","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFrameTerminatorGREMEDY();
}

// GL_GREMEDY_string_marker

static void REGAL_CALL trace_glStringMarkerGREMEDY(GLsizei len, const GLvoid *string)
{
  Internal("trace_glStringMarkerGREMEDY","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glStringMarkerGREMEDY(len, string);
}

// GL_HP_image_transform

static void REGAL_CALL trace_glGetImageTransformParameterfvHP(GLenum target, GLenum pname, GLfloat *params)
{
  Internal("trace_glGetImageTransformParameterfvHP","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetImageTransformParameterfvHP(target, pname, params);
}

static void REGAL_CALL trace_glGetImageTransformParameterivHP(GLenum target, GLenum pname, GLint *params)
{
  Internal("trace_glGetImageTransformParameterivHP","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetImageTransformParameterivHP(target, pname, params);
}

static void REGAL_CALL trace_glImageTransformParameterfHP(GLenum target, GLenum pname, GLfloat param)
{
  Internal("trace_glImageTransformParameterfHP","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glImageTransformParameterfHP(target, pname, param);
}

static void REGAL_CALL trace_glImageTransformParameterfvHP(GLenum target, GLenum pname, const GLfloat *params)
{
  Internal("trace_glImageTransformParameterfvHP","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glImageTransformParameterfvHP(target, pname, params);
}

static void REGAL_CALL trace_glImageTransformParameteriHP(GLenum target, GLenum pname, GLint param)
{
  Internal("trace_glImageTransformParameteriHP","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glImageTransformParameteriHP(target, pname, param);
}

static void REGAL_CALL trace_glImageTransformParameterivHP(GLenum target, GLenum pname, const GLint *params)
{
  Internal("trace_glImageTransformParameterivHP","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glImageTransformParameterivHP(target, pname, params);
}

// GL_IBM_multimode_draw_arrays

static void REGAL_CALL trace_glMultiModeDrawArraysIBM(const GLenum *mode, const GLint *first, const GLsizei *count, GLsizei primcount, GLint modestride)
{
  Internal("trace_glMultiModeDrawArraysIBM","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiModeDrawArraysIBM(mode, first, count, primcount, modestride);
}

static void REGAL_CALL trace_glMultiModeDrawElementsIBM(const GLenum *mode, const GLsizei *count, GLenum type, const GLvoid * const *indices, GLsizei primcount, GLint modestride)
{
  Internal("trace_glMultiModeDrawElementsIBM","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiModeDrawElementsIBM(mode, count, type, indices, primcount, modestride);
}

// GL_IBM_vertex_array_lists

static void REGAL_CALL trace_glColorPointerListIBM(GLint size, GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
{
  Internal("trace_glColorPointerListIBM","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColorPointerListIBM(size, type, stride, pointer, ptrstride);
}

static void REGAL_CALL trace_glEdgeFlagPointerListIBM(GLint stride, const GLboolean **pointer, GLint ptrstride)
{
  Internal("trace_glEdgeFlagPointerListIBM","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glEdgeFlagPointerListIBM(stride, pointer, ptrstride);
}

static void REGAL_CALL trace_glFogCoordPointerListIBM(GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
{
  Internal("trace_glFogCoordPointerListIBM","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFogCoordPointerListIBM(type, stride, pointer, ptrstride);
}

static void REGAL_CALL trace_glIndexPointerListIBM(GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
{
  Internal("trace_glIndexPointerListIBM","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glIndexPointerListIBM(type, stride, pointer, ptrstride);
}

static void REGAL_CALL trace_glNormalPointerListIBM(GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
{
  Internal("trace_glNormalPointerListIBM","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNormalPointerListIBM(type, stride, pointer, ptrstride);
}

static void REGAL_CALL trace_glSecondaryColorPointerListIBM(GLint size, GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
{
  Internal("trace_glSecondaryColorPointerListIBM","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSecondaryColorPointerListIBM(size, type, stride, pointer, ptrstride);
}

static void REGAL_CALL trace_glTexCoordPointerListIBM(GLint size, GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
{
  Internal("trace_glTexCoordPointerListIBM","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoordPointerListIBM(size, type, stride, pointer, ptrstride);
}

static void REGAL_CALL trace_glVertexPointerListIBM(GLint size, GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
{
  Internal("trace_glVertexPointerListIBM","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexPointerListIBM(size, type, stride, pointer, ptrstride);
}

// GL_IMG_multisampled_render_to_texture

static void REGAL_CALL trace_glFramebufferTexture2DMultisampleIMG(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples)
{
  Internal("trace_glFramebufferTexture2DMultisampleIMG","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFramebufferTexture2DMultisampleIMG(target, attachment, textarget, texture, level, samples);
}

static void REGAL_CALL trace_glRenderbufferStorageMultisampleIMG(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
  Internal("trace_glRenderbufferStorageMultisampleIMG","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glRenderbufferStorageMultisampleIMG(target, samples, internalformat, width, height);
}

// GL_INGR_blend_func_separate

static void REGAL_CALL trace_glBlendFuncSeparateINGR(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)
{
  Internal("trace_glBlendFuncSeparateINGR","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBlendFuncSeparateINGR(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
}

// GL_INTEL_parallel_arrays

static void REGAL_CALL trace_glColorPointervINTEL(GLint size, GLenum type, const GLvoid **pointer)
{
  Internal("trace_glColorPointervINTEL","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColorPointervINTEL(size, type, pointer);
}

static void REGAL_CALL trace_glNormalPointervINTEL(GLenum type, const GLvoid **pointer)
{
  Internal("trace_glNormalPointervINTEL","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNormalPointervINTEL(type, pointer);
}

static void REGAL_CALL trace_glTexCoordPointervINTEL(GLint size, GLenum type, const GLvoid **pointer)
{
  Internal("trace_glTexCoordPointervINTEL","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoordPointervINTEL(size, type, pointer);
}

static void REGAL_CALL trace_glVertexPointervINTEL(GLint size, GLenum type, const GLvoid **pointer)
{
  Internal("trace_glVertexPointervINTEL","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexPointervINTEL(size, type, pointer);
}

// GL_KHR_debug

static void REGAL_CALL trace_glDebugMessageCallback(GLDEBUGPROC callback, const GLvoid *userParam)
{
  Internal("trace_glDebugMessageCallback","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDebugMessageCallback(callback, userParam);
}

static void REGAL_CALL trace_glDebugMessageControl(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled)
{
  Internal("trace_glDebugMessageControl","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDebugMessageControl(source, type, severity, count, ids, enabled);
}

static void REGAL_CALL trace_glDebugMessageInsert(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf)
{
  Internal("trace_glDebugMessageInsert","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDebugMessageInsert(source, type, id, severity, length, buf);
}

static GLuint REGAL_CALL trace_glGetDebugMessageLog(GLuint count, GLsizei bufsize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog)
{
  Internal("trace_glGetDebugMessageLog","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLuint  ret = Trace::glGetDebugMessageLog(count, bufsize, sources, types, ids, severities, lengths, messageLog);
  return ret;
}

static void REGAL_CALL trace_glGetObjectLabel(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei *length, GLchar *label)
{
  Internal("trace_glGetObjectLabel","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetObjectLabel(identifier, name, bufSize, length, label);
}

static void REGAL_CALL trace_glGetObjectPtrLabel(const GLvoid *ptr, GLsizei bufSize, GLsizei *length, GLchar *label)
{
  Internal("trace_glGetObjectPtrLabel","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetObjectPtrLabel(ptr, bufSize, length, label);
}

static void REGAL_CALL trace_glObjectLabel(GLenum identifier, GLuint name, GLsizei length, const GLchar *label)
{
  Internal("trace_glObjectLabel","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glObjectLabel(identifier, name, length, label);
}

static void REGAL_CALL trace_glObjectPtrLabel(const GLvoid *ptr, GLsizei length, const GLchar *label)
{
  Internal("trace_glObjectPtrLabel","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glObjectPtrLabel(ptr, length, label);
}

static void REGAL_CALL trace_glPopDebugGroup(void)
{
  Internal("trace_glPopDebugGroup","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPopDebugGroup();
}

static void REGAL_CALL trace_glPushDebugGroup(GLenum source, GLuint id, GLsizei length, const GLchar *message)
{
  Internal("trace_glPushDebugGroup","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPushDebugGroup(source, id, length, message);
}

// GL_KTX_buffer_region

static GLuint REGAL_CALL trace_glBufferRegionEnabled(void)
{
  Internal("trace_glBufferRegionEnabled","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLuint  ret = Trace::glBufferRegionEnabled();
  return ret;
}

static void REGAL_CALL trace_glDeleteBufferRegion(GLenum region)
{
  Internal("trace_glDeleteBufferRegion","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDeleteBufferRegion(region);
}

static void REGAL_CALL trace_glDrawBufferRegion(GLuint region, GLint x, GLint y, GLsizei width, GLsizei height, GLint xDest, GLint yDest)
{
  Internal("trace_glDrawBufferRegion","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDrawBufferRegion(region, x, y, width, height, xDest, yDest);
}

static GLuint REGAL_CALL trace_glNewBufferRegion(GLenum region)
{
  Internal("trace_glNewBufferRegion","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLuint  ret = Trace::glNewBufferRegion(region);
  return ret;
}

static void REGAL_CALL trace_glReadBufferRegion(GLuint region, GLint x, GLint y, GLsizei width, GLsizei height)
{
  Internal("trace_glReadBufferRegion","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glReadBufferRegion(region, x, y, width, height);
}

// GL_MESA_resize_buffers

static void REGAL_CALL trace_glResizeBuffersMESA(void)
{
  Internal("trace_glResizeBuffersMESA","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glResizeBuffersMESA();
}

// GL_MESA_window_pos

static void REGAL_CALL trace_glWindowPos2dMESA(GLdouble x, GLdouble y)
{
  Internal("trace_glWindowPos2dMESA","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos2dMESA(x, y);
}

static void REGAL_CALL trace_glWindowPos2dvMESA(const GLdouble *v)
{
  Internal("trace_glWindowPos2dvMESA","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos2dvMESA(v);
}

static void REGAL_CALL trace_glWindowPos2fMESA(GLfloat x, GLfloat y)
{
  Internal("trace_glWindowPos2fMESA","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos2fMESA(x, y);
}

static void REGAL_CALL trace_glWindowPos2fvMESA(const GLfloat *v)
{
  Internal("trace_glWindowPos2fvMESA","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos2fvMESA(v);
}

static void REGAL_CALL trace_glWindowPos2iMESA(GLint x, GLint y)
{
  Internal("trace_glWindowPos2iMESA","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos2iMESA(x, y);
}

static void REGAL_CALL trace_glWindowPos2ivMESA(const GLint *v)
{
  Internal("trace_glWindowPos2ivMESA","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos2ivMESA(v);
}

static void REGAL_CALL trace_glWindowPos2sMESA(GLshort x, GLshort y)
{
  Internal("trace_glWindowPos2sMESA","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos2sMESA(x, y);
}

static void REGAL_CALL trace_glWindowPos2svMESA(const GLshort *v)
{
  Internal("trace_glWindowPos2svMESA","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos2svMESA(v);
}

static void REGAL_CALL trace_glWindowPos3dMESA(GLdouble x, GLdouble y, GLdouble z)
{
  Internal("trace_glWindowPos3dMESA","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos3dMESA(x, y, z);
}

static void REGAL_CALL trace_glWindowPos3dvMESA(const GLdouble *v)
{
  Internal("trace_glWindowPos3dvMESA","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos3dvMESA(v);
}

static void REGAL_CALL trace_glWindowPos3fMESA(GLfloat x, GLfloat y, GLfloat z)
{
  Internal("trace_glWindowPos3fMESA","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos3fMESA(x, y, z);
}

static void REGAL_CALL trace_glWindowPos3fvMESA(const GLfloat *v)
{
  Internal("trace_glWindowPos3fvMESA","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos3fvMESA(v);
}

static void REGAL_CALL trace_glWindowPos3iMESA(GLint x, GLint y, GLint z)
{
  Internal("trace_glWindowPos3iMESA","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos3iMESA(x, y, z);
}

static void REGAL_CALL trace_glWindowPos3ivMESA(const GLint *v)
{
  Internal("trace_glWindowPos3ivMESA","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos3ivMESA(v);
}

static void REGAL_CALL trace_glWindowPos3sMESA(GLshort x, GLshort y, GLshort z)
{
  Internal("trace_glWindowPos3sMESA","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos3sMESA(x, y, z);
}

static void REGAL_CALL trace_glWindowPos3svMESA(const GLshort *v)
{
  Internal("trace_glWindowPos3svMESA","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos3svMESA(v);
}

static void REGAL_CALL trace_glWindowPos4dMESA(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  Internal("trace_glWindowPos4dMESA","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos4dMESA(x, y, z, w);
}

static void REGAL_CALL trace_glWindowPos4dvMESA(const GLdouble *v)
{
  Internal("trace_glWindowPos4dvMESA","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos4dvMESA(v);
}

static void REGAL_CALL trace_glWindowPos4fMESA(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  Internal("trace_glWindowPos4fMESA","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos4fMESA(x, y, z, w);
}

static void REGAL_CALL trace_glWindowPos4fvMESA(const GLfloat *v)
{
  Internal("trace_glWindowPos4fvMESA","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos4fvMESA(v);
}

static void REGAL_CALL trace_glWindowPos4iMESA(GLint x, GLint y, GLint z, GLint w)
{
  Internal("trace_glWindowPos4iMESA","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos4iMESA(x, y, z, w);
}

static void REGAL_CALL trace_glWindowPos4ivMESA(const GLint *v)
{
  Internal("trace_glWindowPos4ivMESA","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos4ivMESA(v);
}

static void REGAL_CALL trace_glWindowPos4sMESA(GLshort x, GLshort y, GLshort z, GLshort w)
{
  Internal("trace_glWindowPos4sMESA","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos4sMESA(x, y, z, w);
}

static void REGAL_CALL trace_glWindowPos4svMESA(const GLshort *v)
{
  Internal("trace_glWindowPos4svMESA","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWindowPos4svMESA(v);
}

// GL_NV_conditional_render

static void REGAL_CALL trace_glBeginConditionalRenderNV(GLuint id, GLenum mode)
{
  Internal("trace_glBeginConditionalRenderNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBeginConditionalRenderNV(id, mode);
}

static void REGAL_CALL trace_glEndConditionalRenderNV(void)
{
  Internal("trace_glEndConditionalRenderNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glEndConditionalRenderNV();
}

// GL_NV_copy_image

static void REGAL_CALL trace_glCopyImageSubDataNV(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth)
{
  Internal("trace_glCopyImageSubDataNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCopyImageSubDataNV(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
}

// GL_NV_coverage_sample

static void REGAL_CALL trace_glCoverageMaskNV(GLboolean mask)
{
  Internal("trace_glCoverageMaskNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCoverageMaskNV(mask);
}

static void REGAL_CALL trace_glCoverageOperationNV(GLenum operation)
{
  Internal("trace_glCoverageOperationNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCoverageOperationNV(operation);
}

// GL_NV_depth_buffer_float

static void REGAL_CALL trace_glClearDepthdNV(GLdouble depth)
{
  Internal("trace_glClearDepthdNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glClearDepthdNV(depth);
}

static void REGAL_CALL trace_glDepthBoundsdNV(GLdouble zmin, GLdouble zmax)
{
  Internal("trace_glDepthBoundsdNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDepthBoundsdNV(zmin, zmax);
}

static void REGAL_CALL trace_glDepthRangedNV(GLdouble zNear, GLdouble zFar)
{
  Internal("trace_glDepthRangedNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDepthRangedNV(zNear, zFar);
}

// GL_NV_draw_buffers

static void REGAL_CALL trace_glDrawBuffersNV(GLsizei n, const GLenum *bufs)
{
  Internal("trace_glDrawBuffersNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDrawBuffersNV(n, bufs);
}

// GL_NV_evaluators

static void REGAL_CALL trace_glEvalMapsNV(GLenum target, GLenum mode)
{
  Internal("trace_glEvalMapsNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glEvalMapsNV(target, mode);
}

static void REGAL_CALL trace_glGetMapAttribParameterfvNV(GLenum target, GLuint index, GLenum pname, GLfloat *params)
{
  Internal("trace_glGetMapAttribParameterfvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetMapAttribParameterfvNV(target, index, pname, params);
}

static void REGAL_CALL trace_glGetMapAttribParameterivNV(GLenum target, GLuint index, GLenum pname, GLint *params)
{
  Internal("trace_glGetMapAttribParameterivNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetMapAttribParameterivNV(target, index, pname, params);
}

static void REGAL_CALL trace_glGetMapControlPointsNV(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, GLvoid *points)
{
  Internal("trace_glGetMapControlPointsNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetMapControlPointsNV(target, index, type, ustride, vstride, packed, points);
}

static void REGAL_CALL trace_glGetMapParameterfvNV(GLenum target, GLenum pname, GLfloat *params)
{
  Internal("trace_glGetMapParameterfvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetMapParameterfvNV(target, pname, params);
}

static void REGAL_CALL trace_glGetMapParameterivNV(GLenum target, GLenum pname, GLint *params)
{
  Internal("trace_glGetMapParameterivNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetMapParameterivNV(target, pname, params);
}

static void REGAL_CALL trace_glMapControlPointsNV(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const GLvoid *points)
{
  Internal("trace_glMapControlPointsNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMapControlPointsNV(target, index, type, ustride, vstride, uorder, vorder, packed, points);
}

static void REGAL_CALL trace_glMapParameterfvNV(GLenum target, GLenum pname, const GLfloat *params)
{
  Internal("trace_glMapParameterfvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMapParameterfvNV(target, pname, params);
}

static void REGAL_CALL trace_glMapParameterivNV(GLenum target, GLenum pname, const GLint *params)
{
  Internal("trace_glMapParameterivNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMapParameterivNV(target, pname, params);
}

// GL_NV_explicit_multisample

static void REGAL_CALL trace_glGetMultisamplefvNV(GLenum pname, GLuint index, GLfloat *val)
{
  Internal("trace_glGetMultisamplefvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetMultisamplefvNV(pname, index, val);
}

static void REGAL_CALL trace_glSampleMaskIndexedNV(GLuint index, GLbitfield mask)
{
  Internal("trace_glSampleMaskIndexedNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSampleMaskIndexedNV(index, mask);
}

static void REGAL_CALL trace_glTexRenderbufferNV(GLenum target, GLuint renderbuffer)
{
  Internal("trace_glTexRenderbufferNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexRenderbufferNV(target, renderbuffer);
}

// GL_NV_fence

static void REGAL_CALL trace_glDeleteFencesNV(GLsizei n, const GLuint *fences)
{
  Internal("trace_glDeleteFencesNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDeleteFencesNV(n, fences);
}

static void REGAL_CALL trace_glFinishFenceNV(GLuint fence)
{
  Internal("trace_glFinishFenceNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFinishFenceNV(fence);
}

static void REGAL_CALL trace_glGenFencesNV(GLsizei n, GLuint *fences)
{
  Internal("trace_glGenFencesNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGenFencesNV(n, fences);
}

static void REGAL_CALL trace_glGetFenceivNV(GLuint fence, GLenum pname, GLint *params)
{
  Internal("trace_glGetFenceivNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetFenceivNV(fence, pname, params);
}

static GLboolean REGAL_CALL trace_glIsFenceNV(GLuint fence)
{
  Internal("trace_glIsFenceNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glIsFenceNV(fence);
  return ret;
}

static void REGAL_CALL trace_glSetFenceNV(GLuint fence, GLenum condition)
{
  Internal("trace_glSetFenceNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSetFenceNV(fence, condition);
}

static GLboolean REGAL_CALL trace_glTestFenceNV(GLuint fence)
{
  Internal("trace_glTestFenceNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glTestFenceNV(fence);
  return ret;
}

// GL_NV_fragment_program

static void REGAL_CALL trace_glGetProgramNamedParameterdvNV(GLuint id, GLsizei len, const GLubyte *name, GLdouble *params)
{
  Internal("trace_glGetProgramNamedParameterdvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetProgramNamedParameterdvNV(id, len, name, params);
}

static void REGAL_CALL trace_glGetProgramNamedParameterfvNV(GLuint id, GLsizei len, const GLubyte *name, GLfloat *params)
{
  Internal("trace_glGetProgramNamedParameterfvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetProgramNamedParameterfvNV(id, len, name, params);
}

static void REGAL_CALL trace_glProgramNamedParameter4dNV(GLuint id, GLsizei len, const GLubyte *name, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  Internal("trace_glProgramNamedParameter4dNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramNamedParameter4dNV(id, len, name, x, y, z, w);
}

static void REGAL_CALL trace_glProgramNamedParameter4dvNV(GLuint id, GLsizei len, const GLubyte *name, const GLdouble *v)
{
  Internal("trace_glProgramNamedParameter4dvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramNamedParameter4dvNV(id, len, name, v);
}

static void REGAL_CALL trace_glProgramNamedParameter4fNV(GLuint id, GLsizei len, const GLubyte *name, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  Internal("trace_glProgramNamedParameter4fNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramNamedParameter4fNV(id, len, name, x, y, z, w);
}

static void REGAL_CALL trace_glProgramNamedParameter4fvNV(GLuint id, GLsizei len, const GLubyte *name, const GLfloat *v)
{
  Internal("trace_glProgramNamedParameter4fvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramNamedParameter4fvNV(id, len, name, v);
}

// GL_NV_framebuffer_multisample_coverage

static void REGAL_CALL trace_glRenderbufferStorageMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height)
{
  Internal("trace_glRenderbufferStorageMultisampleCoverageNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glRenderbufferStorageMultisampleCoverageNV(target, coverageSamples, colorSamples, internalformat, width, height);
}

// GL_NV_geometry_program4

static void REGAL_CALL trace_glProgramVertexLimitNV(GLenum target, GLint limit)
{
  Internal("trace_glProgramVertexLimitNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramVertexLimitNV(target, limit);
}

// GL_NV_gpu_program4

static void REGAL_CALL trace_glGetProgramEnvParameterIivNV(GLenum target, GLuint index, GLint *params)
{
  Internal("trace_glGetProgramEnvParameterIivNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetProgramEnvParameterIivNV(target, index, params);
}

static void REGAL_CALL trace_glGetProgramEnvParameterIuivNV(GLenum target, GLuint index, GLuint *params)
{
  Internal("trace_glGetProgramEnvParameterIuivNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetProgramEnvParameterIuivNV(target, index, params);
}

static void REGAL_CALL trace_glGetProgramLocalParameterIivNV(GLenum target, GLuint index, GLint *params)
{
  Internal("trace_glGetProgramLocalParameterIivNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetProgramLocalParameterIivNV(target, index, params);
}

static void REGAL_CALL trace_glGetProgramLocalParameterIuivNV(GLenum target, GLuint index, GLuint *params)
{
  Internal("trace_glGetProgramLocalParameterIuivNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetProgramLocalParameterIuivNV(target, index, params);
}

static void REGAL_CALL trace_glProgramEnvParameterI4iNV(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w)
{
  Internal("trace_glProgramEnvParameterI4iNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramEnvParameterI4iNV(target, index, x, y, z, w);
}

static void REGAL_CALL trace_glProgramEnvParameterI4ivNV(GLenum target, GLuint index, const GLint *params)
{
  Internal("trace_glProgramEnvParameterI4ivNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramEnvParameterI4ivNV(target, index, params);
}

static void REGAL_CALL trace_glProgramEnvParameterI4uiNV(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
{
  Internal("trace_glProgramEnvParameterI4uiNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramEnvParameterI4uiNV(target, index, x, y, z, w);
}

static void REGAL_CALL trace_glProgramEnvParameterI4uivNV(GLenum target, GLuint index, const GLuint *params)
{
  Internal("trace_glProgramEnvParameterI4uivNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramEnvParameterI4uivNV(target, index, params);
}

static void REGAL_CALL trace_glProgramEnvParametersI4ivNV(GLenum target, GLuint index, GLsizei count, const GLint *params)
{
  Internal("trace_glProgramEnvParametersI4ivNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramEnvParametersI4ivNV(target, index, count, params);
}

static void REGAL_CALL trace_glProgramEnvParametersI4uivNV(GLenum target, GLuint index, GLsizei count, const GLuint *params)
{
  Internal("trace_glProgramEnvParametersI4uivNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramEnvParametersI4uivNV(target, index, count, params);
}

static void REGAL_CALL trace_glProgramLocalParameterI4iNV(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w)
{
  Internal("trace_glProgramLocalParameterI4iNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramLocalParameterI4iNV(target, index, x, y, z, w);
}

static void REGAL_CALL trace_glProgramLocalParameterI4ivNV(GLenum target, GLuint index, const GLint *params)
{
  Internal("trace_glProgramLocalParameterI4ivNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramLocalParameterI4ivNV(target, index, params);
}

static void REGAL_CALL trace_glProgramLocalParameterI4uiNV(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
{
  Internal("trace_glProgramLocalParameterI4uiNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramLocalParameterI4uiNV(target, index, x, y, z, w);
}

static void REGAL_CALL trace_glProgramLocalParameterI4uivNV(GLenum target, GLuint index, const GLuint *params)
{
  Internal("trace_glProgramLocalParameterI4uivNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramLocalParameterI4uivNV(target, index, params);
}

static void REGAL_CALL trace_glProgramLocalParametersI4ivNV(GLenum target, GLuint index, GLsizei count, const GLint *params)
{
  Internal("trace_glProgramLocalParametersI4ivNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramLocalParametersI4ivNV(target, index, count, params);
}

static void REGAL_CALL trace_glProgramLocalParametersI4uivNV(GLenum target, GLuint index, GLsizei count, const GLuint *params)
{
  Internal("trace_glProgramLocalParametersI4uivNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramLocalParametersI4uivNV(target, index, count, params);
}

// GL_NV_gpu_shader5

static void REGAL_CALL trace_glGetUniformi64vNV(GLuint program, GLint location, GLint64EXT *params)
{
  Internal("trace_glGetUniformi64vNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetUniformi64vNV(program, location, params);
}

static void REGAL_CALL trace_glProgramUniform1i64NV(GLuint program, GLint location, GLint64EXT x)
{
  Internal("trace_glProgramUniform1i64NV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform1i64NV(program, location, x);
}

static void REGAL_CALL trace_glProgramUniform1i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT *value)
{
  Internal("trace_glProgramUniform1i64vNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform1i64vNV(program, location, count, value);
}

static void REGAL_CALL trace_glProgramUniform1ui64NV(GLuint program, GLint location, GLuint64EXT x)
{
  Internal("trace_glProgramUniform1ui64NV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform1ui64NV(program, location, x);
}

static void REGAL_CALL trace_glProgramUniform1ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value)
{
  Internal("trace_glProgramUniform1ui64vNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform1ui64vNV(program, location, count, value);
}

static void REGAL_CALL trace_glProgramUniform2i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y)
{
  Internal("trace_glProgramUniform2i64NV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform2i64NV(program, location, x, y);
}

static void REGAL_CALL trace_glProgramUniform2i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT *value)
{
  Internal("trace_glProgramUniform2i64vNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform2i64vNV(program, location, count, value);
}

static void REGAL_CALL trace_glProgramUniform2ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y)
{
  Internal("trace_glProgramUniform2ui64NV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform2ui64NV(program, location, x, y);
}

static void REGAL_CALL trace_glProgramUniform2ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value)
{
  Internal("trace_glProgramUniform2ui64vNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform2ui64vNV(program, location, count, value);
}

static void REGAL_CALL trace_glProgramUniform3i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z)
{
  Internal("trace_glProgramUniform3i64NV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform3i64NV(program, location, x, y, z);
}

static void REGAL_CALL trace_glProgramUniform3i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT *value)
{
  Internal("trace_glProgramUniform3i64vNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform3i64vNV(program, location, count, value);
}

static void REGAL_CALL trace_glProgramUniform3ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z)
{
  Internal("trace_glProgramUniform3ui64NV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform3ui64NV(program, location, x, y, z);
}

static void REGAL_CALL trace_glProgramUniform3ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value)
{
  Internal("trace_glProgramUniform3ui64vNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform3ui64vNV(program, location, count, value);
}

static void REGAL_CALL trace_glProgramUniform4i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w)
{
  Internal("trace_glProgramUniform4i64NV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform4i64NV(program, location, x, y, z, w);
}

static void REGAL_CALL trace_glProgramUniform4i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT *value)
{
  Internal("trace_glProgramUniform4i64vNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform4i64vNV(program, location, count, value);
}

static void REGAL_CALL trace_glProgramUniform4ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w)
{
  Internal("trace_glProgramUniform4ui64NV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform4ui64NV(program, location, x, y, z, w);
}

static void REGAL_CALL trace_glProgramUniform4ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value)
{
  Internal("trace_glProgramUniform4ui64vNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniform4ui64vNV(program, location, count, value);
}

static void REGAL_CALL trace_glUniform1i64NV(GLint location, GLint64EXT x)
{
  Internal("trace_glUniform1i64NV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform1i64NV(location, x);
}

static void REGAL_CALL trace_glUniform1i64vNV(GLint location, GLsizei count, const GLint64EXT *value)
{
  Internal("trace_glUniform1i64vNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform1i64vNV(location, count, value);
}

static void REGAL_CALL trace_glUniform1ui64NV(GLint location, GLuint64EXT x)
{
  Internal("trace_glUniform1ui64NV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform1ui64NV(location, x);
}

static void REGAL_CALL trace_glUniform1ui64vNV(GLint location, GLsizei count, const GLuint64EXT *value)
{
  Internal("trace_glUniform1ui64vNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform1ui64vNV(location, count, value);
}

static void REGAL_CALL trace_glUniform2i64NV(GLint location, GLint64EXT x, GLint64EXT y)
{
  Internal("trace_glUniform2i64NV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform2i64NV(location, x, y);
}

static void REGAL_CALL trace_glUniform2i64vNV(GLint location, GLsizei count, const GLint64EXT *value)
{
  Internal("trace_glUniform2i64vNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform2i64vNV(location, count, value);
}

static void REGAL_CALL trace_glUniform2ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y)
{
  Internal("trace_glUniform2ui64NV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform2ui64NV(location, x, y);
}

static void REGAL_CALL trace_glUniform2ui64vNV(GLint location, GLsizei count, const GLuint64EXT *value)
{
  Internal("trace_glUniform2ui64vNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform2ui64vNV(location, count, value);
}

static void REGAL_CALL trace_glUniform3i64NV(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z)
{
  Internal("trace_glUniform3i64NV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform3i64NV(location, x, y, z);
}

static void REGAL_CALL trace_glUniform3i64vNV(GLint location, GLsizei count, const GLint64EXT *value)
{
  Internal("trace_glUniform3i64vNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform3i64vNV(location, count, value);
}

static void REGAL_CALL trace_glUniform3ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z)
{
  Internal("trace_glUniform3ui64NV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform3ui64NV(location, x, y, z);
}

static void REGAL_CALL trace_glUniform3ui64vNV(GLint location, GLsizei count, const GLuint64EXT *value)
{
  Internal("trace_glUniform3ui64vNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform3ui64vNV(location, count, value);
}

static void REGAL_CALL trace_glUniform4i64NV(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w)
{
  Internal("trace_glUniform4i64NV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform4i64NV(location, x, y, z, w);
}

static void REGAL_CALL trace_glUniform4i64vNV(GLint location, GLsizei count, const GLint64EXT *value)
{
  Internal("trace_glUniform4i64vNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform4i64vNV(location, count, value);
}

static void REGAL_CALL trace_glUniform4ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w)
{
  Internal("trace_glUniform4ui64NV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform4ui64NV(location, x, y, z, w);
}

static void REGAL_CALL trace_glUniform4ui64vNV(GLint location, GLsizei count, const GLuint64EXT *value)
{
  Internal("trace_glUniform4ui64vNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniform4ui64vNV(location, count, value);
}

// GL_NV_half_float

static void REGAL_CALL trace_glColor3hNV(GLhalfNV red, GLhalfNV green, GLhalfNV blue)
{
  Internal("trace_glColor3hNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColor3hNV(red, green, blue);
}

static void REGAL_CALL trace_glColor3hvNV(const GLhalfNV *v)
{
  Internal("trace_glColor3hvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColor3hvNV(v);
}

static void REGAL_CALL trace_glColor4hNV(GLhalfNV red, GLhalfNV green, GLhalfNV blue, GLhalfNV alpha)
{
  Internal("trace_glColor4hNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColor4hNV(red, green, blue, alpha);
}

static void REGAL_CALL trace_glColor4hvNV(const GLhalfNV *v)
{
  Internal("trace_glColor4hvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColor4hvNV(v);
}

static void REGAL_CALL trace_glFogCoordhNV(GLhalfNV coord)
{
  Internal("trace_glFogCoordhNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFogCoordhNV(coord);
}

static void REGAL_CALL trace_glFogCoordhvNV(const GLhalfNV *coord)
{
  Internal("trace_glFogCoordhvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFogCoordhvNV(coord);
}

static void REGAL_CALL trace_glMultiTexCoord1hNV(GLenum target, GLhalfNV s)
{
  Internal("trace_glMultiTexCoord1hNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord1hNV(target, s);
}

static void REGAL_CALL trace_glMultiTexCoord1hvNV(GLenum target, const GLhalfNV *v)
{
  Internal("trace_glMultiTexCoord1hvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord1hvNV(target, v);
}

static void REGAL_CALL trace_glMultiTexCoord2hNV(GLenum target, GLhalfNV s, GLhalfNV t)
{
  Internal("trace_glMultiTexCoord2hNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord2hNV(target, s, t);
}

static void REGAL_CALL trace_glMultiTexCoord2hvNV(GLenum target, const GLhalfNV *v)
{
  Internal("trace_glMultiTexCoord2hvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord2hvNV(target, v);
}

static void REGAL_CALL trace_glMultiTexCoord3hNV(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r)
{
  Internal("trace_glMultiTexCoord3hNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord3hNV(target, s, t, r);
}

static void REGAL_CALL trace_glMultiTexCoord3hvNV(GLenum target, const GLhalfNV *v)
{
  Internal("trace_glMultiTexCoord3hvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord3hvNV(target, v);
}

static void REGAL_CALL trace_glMultiTexCoord4hNV(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q)
{
  Internal("trace_glMultiTexCoord4hNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord4hNV(target, s, t, r, q);
}

static void REGAL_CALL trace_glMultiTexCoord4hvNV(GLenum target, const GLhalfNV *v)
{
  Internal("trace_glMultiTexCoord4hvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord4hvNV(target, v);
}

static void REGAL_CALL trace_glNormal3hNV(GLhalfNV nx, GLhalfNV ny, GLhalfNV nz)
{
  Internal("trace_glNormal3hNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNormal3hNV(nx, ny, nz);
}

static void REGAL_CALL trace_glNormal3hvNV(const GLhalfNV *v)
{
  Internal("trace_glNormal3hvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNormal3hvNV(v);
}

static void REGAL_CALL trace_glSecondaryColor3hNV(GLhalfNV red, GLhalfNV green, GLhalfNV blue)
{
  Internal("trace_glSecondaryColor3hNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSecondaryColor3hNV(red, green, blue);
}

static void REGAL_CALL trace_glSecondaryColor3hvNV(const GLhalfNV *v)
{
  Internal("trace_glSecondaryColor3hvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSecondaryColor3hvNV(v);
}

static void REGAL_CALL trace_glTexCoord1hNV(GLhalfNV s)
{
  Internal("trace_glTexCoord1hNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord1hNV(s);
}

static void REGAL_CALL trace_glTexCoord1hvNV(const GLhalfNV *v)
{
  Internal("trace_glTexCoord1hvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord1hvNV(v);
}

static void REGAL_CALL trace_glTexCoord2hNV(GLhalfNV s, GLhalfNV t)
{
  Internal("trace_glTexCoord2hNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord2hNV(s, t);
}

static void REGAL_CALL trace_glTexCoord2hvNV(const GLhalfNV *v)
{
  Internal("trace_glTexCoord2hvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord2hvNV(v);
}

static void REGAL_CALL trace_glTexCoord3hNV(GLhalfNV s, GLhalfNV t, GLhalfNV r)
{
  Internal("trace_glTexCoord3hNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord3hNV(s, t, r);
}

static void REGAL_CALL trace_glTexCoord3hvNV(const GLhalfNV *v)
{
  Internal("trace_glTexCoord3hvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord3hvNV(v);
}

static void REGAL_CALL trace_glTexCoord4hNV(GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q)
{
  Internal("trace_glTexCoord4hNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord4hNV(s, t, r, q);
}

static void REGAL_CALL trace_glTexCoord4hvNV(const GLhalfNV *v)
{
  Internal("trace_glTexCoord4hvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord4hvNV(v);
}

static void REGAL_CALL trace_glVertex2hNV(GLhalfNV x, GLhalfNV y)
{
  Internal("trace_glVertex2hNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertex2hNV(x, y);
}

static void REGAL_CALL trace_glVertex2hvNV(const GLhalfNV *v)
{
  Internal("trace_glVertex2hvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertex2hvNV(v);
}

static void REGAL_CALL trace_glVertex3hNV(GLhalfNV x, GLhalfNV y, GLhalfNV z)
{
  Internal("trace_glVertex3hNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertex3hNV(x, y, z);
}

static void REGAL_CALL trace_glVertex3hvNV(const GLhalfNV *v)
{
  Internal("trace_glVertex3hvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertex3hvNV(v);
}

static void REGAL_CALL trace_glVertex4hNV(GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w)
{
  Internal("trace_glVertex4hNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertex4hNV(x, y, z, w);
}

static void REGAL_CALL trace_glVertex4hvNV(const GLhalfNV *v)
{
  Internal("trace_glVertex4hvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertex4hvNV(v);
}

static void REGAL_CALL trace_glVertexAttrib1hNV(GLuint index, GLhalfNV x)
{
  Internal("trace_glVertexAttrib1hNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib1hNV(index, x);
}

static void REGAL_CALL trace_glVertexAttrib1hvNV(GLuint index, const GLhalfNV *v)
{
  Internal("trace_glVertexAttrib1hvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib1hvNV(index, v);
}

static void REGAL_CALL trace_glVertexAttrib2hNV(GLuint index, GLhalfNV x, GLhalfNV y)
{
  Internal("trace_glVertexAttrib2hNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib2hNV(index, x, y);
}

static void REGAL_CALL trace_glVertexAttrib2hvNV(GLuint index, const GLhalfNV *v)
{
  Internal("trace_glVertexAttrib2hvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib2hvNV(index, v);
}

static void REGAL_CALL trace_glVertexAttrib3hNV(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z)
{
  Internal("trace_glVertexAttrib3hNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib3hNV(index, x, y, z);
}

static void REGAL_CALL trace_glVertexAttrib3hvNV(GLuint index, const GLhalfNV *v)
{
  Internal("trace_glVertexAttrib3hvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib3hvNV(index, v);
}

static void REGAL_CALL trace_glVertexAttrib4hNV(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w)
{
  Internal("trace_glVertexAttrib4hNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib4hNV(index, x, y, z, w);
}

static void REGAL_CALL trace_glVertexAttrib4hvNV(GLuint index, const GLhalfNV *v)
{
  Internal("trace_glVertexAttrib4hvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib4hvNV(index, v);
}

static void REGAL_CALL trace_glVertexAttribs1hvNV(GLuint index, GLsizei count, const GLhalfNV *v)
{
  Internal("trace_glVertexAttribs1hvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribs1hvNV(index, count, v);
}

static void REGAL_CALL trace_glVertexAttribs2hvNV(GLuint index, GLsizei count, const GLhalfNV *v)
{
  Internal("trace_glVertexAttribs2hvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribs2hvNV(index, count, v);
}

static void REGAL_CALL trace_glVertexAttribs3hvNV(GLuint index, GLsizei count, const GLhalfNV *v)
{
  Internal("trace_glVertexAttribs3hvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribs3hvNV(index, count, v);
}

static void REGAL_CALL trace_glVertexAttribs4hvNV(GLuint index, GLsizei count, const GLhalfNV *v)
{
  Internal("trace_glVertexAttribs4hvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribs4hvNV(index, count, v);
}

static void REGAL_CALL trace_glVertexWeighthNV(GLhalfNV weight)
{
  Internal("trace_glVertexWeighthNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexWeighthNV(weight);
}

static void REGAL_CALL trace_glVertexWeighthvNV(const GLhalfNV *weight)
{
  Internal("trace_glVertexWeighthvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexWeighthvNV(weight);
}

// GL_NV_occlusion_query

static void REGAL_CALL trace_glBeginOcclusionQueryNV(GLuint id)
{
  Internal("trace_glBeginOcclusionQueryNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBeginOcclusionQueryNV(id);
}

static void REGAL_CALL trace_glDeleteOcclusionQueriesNV(GLsizei n, const GLuint *ids)
{
  Internal("trace_glDeleteOcclusionQueriesNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDeleteOcclusionQueriesNV(n, ids);
}

static void REGAL_CALL trace_glEndOcclusionQueryNV(void)
{
  Internal("trace_glEndOcclusionQueryNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glEndOcclusionQueryNV();
}

static void REGAL_CALL trace_glGenOcclusionQueriesNV(GLsizei n, GLuint *ids)
{
  Internal("trace_glGenOcclusionQueriesNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGenOcclusionQueriesNV(n, ids);
}

static void REGAL_CALL trace_glGetOcclusionQueryivNV(GLuint id, GLenum pname, GLint *params)
{
  Internal("trace_glGetOcclusionQueryivNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetOcclusionQueryivNV(id, pname, params);
}

static void REGAL_CALL trace_glGetOcclusionQueryuivNV(GLuint id, GLenum pname, GLuint *params)
{
  Internal("trace_glGetOcclusionQueryuivNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetOcclusionQueryuivNV(id, pname, params);
}

static GLboolean REGAL_CALL trace_glIsOcclusionQueryNV(GLuint id)
{
  Internal("trace_glIsOcclusionQueryNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glIsOcclusionQueryNV(id);
  return ret;
}

// GL_NV_parameter_buffer_object

static void REGAL_CALL trace_glProgramBufferParametersIivNV(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLint *params)
{
  Internal("trace_glProgramBufferParametersIivNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramBufferParametersIivNV(target, buffer, index, count, params);
}

static void REGAL_CALL trace_glProgramBufferParametersIuivNV(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLuint *params)
{
  Internal("trace_glProgramBufferParametersIuivNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramBufferParametersIuivNV(target, buffer, index, count, params);
}

static void REGAL_CALL trace_glProgramBufferParametersfvNV(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLfloat *params)
{
  Internal("trace_glProgramBufferParametersfvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramBufferParametersfvNV(target, buffer, index, count, params);
}

// GL_NV_path_rendering

static void REGAL_CALL trace_glCopyPathNV(GLuint resultPath, GLuint srcPath)
{
  Internal("trace_glCopyPathNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCopyPathNV(resultPath, srcPath);
}

static void REGAL_CALL trace_glCoverFillPathInstancedNV(GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues)
{
  Internal("trace_glCoverFillPathInstancedNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCoverFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
}

static void REGAL_CALL trace_glCoverFillPathNV(GLuint path, GLenum coverMode)
{
  Internal("trace_glCoverFillPathNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCoverFillPathNV(path, coverMode);
}

static void REGAL_CALL trace_glCoverStrokePathInstancedNV(GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues)
{
  Internal("trace_glCoverStrokePathInstancedNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCoverStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
}

static void REGAL_CALL trace_glCoverStrokePathNV(GLuint name, GLenum coverMode)
{
  Internal("trace_glCoverStrokePathNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCoverStrokePathNV(name, coverMode);
}

static void REGAL_CALL trace_glDeletePathsNV(GLuint path, GLsizei range)
{
  Internal("trace_glDeletePathsNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDeletePathsNV(path, range);
}

static GLuint REGAL_CALL trace_glGenPathsNV(GLsizei range)
{
  Internal("trace_glGenPathsNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLuint  ret = Trace::glGenPathsNV(range);
  return ret;
}

static void REGAL_CALL trace_glGetPathColorGenfvNV(GLenum color, GLenum pname, GLfloat *value)
{
  Internal("trace_glGetPathColorGenfvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetPathColorGenfvNV(color, pname, value);
}

static void REGAL_CALL trace_glGetPathColorGenivNV(GLenum color, GLenum pname, GLint *value)
{
  Internal("trace_glGetPathColorGenivNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetPathColorGenivNV(color, pname, value);
}

static void REGAL_CALL trace_glGetPathCommandsNV(GLuint name, GLubyte *commands)
{
  Internal("trace_glGetPathCommandsNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetPathCommandsNV(name, commands);
}

static void REGAL_CALL trace_glGetPathCoordsNV(GLuint name, GLfloat *coords)
{
  Internal("trace_glGetPathCoordsNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetPathCoordsNV(name, coords);
}

static void REGAL_CALL trace_glGetPathDashArrayNV(GLuint name, GLfloat *dashArray)
{
  Internal("trace_glGetPathDashArrayNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetPathDashArrayNV(name, dashArray);
}

static GLfloat REGAL_CALL trace_glGetPathLengthNV(GLuint path, GLsizei startSegment, GLsizei numSegments)
{
  Internal("trace_glGetPathLengthNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLfloat  ret = Trace::glGetPathLengthNV(path, startSegment, numSegments);
  return ret;
}

static void REGAL_CALL trace_glGetPathMetricRangeNV(GLbitfield metricQueryMask, GLuint fistPathName, GLsizei numPaths, GLsizei stride, GLfloat *metrics)
{
  Internal("trace_glGetPathMetricRangeNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetPathMetricRangeNV(metricQueryMask, fistPathName, numPaths, stride, metrics);
}

static void REGAL_CALL trace_glGetPathMetricsNV(GLbitfield metricQueryMask, GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLsizei stride, GLfloat *metrics)
{
  Internal("trace_glGetPathMetricsNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetPathMetricsNV(metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, metrics);
}

static void REGAL_CALL trace_glGetPathParameterfvNV(GLuint name, GLenum param, GLfloat *value)
{
  Internal("trace_glGetPathParameterfvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetPathParameterfvNV(name, param, value);
}

static void REGAL_CALL trace_glGetPathParameterivNV(GLuint name, GLenum param, GLint *value)
{
  Internal("trace_glGetPathParameterivNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetPathParameterivNV(name, param, value);
}

static void REGAL_CALL trace_glGetPathSpacingNV(GLenum pathListMode, GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLfloat advanceScale, GLfloat kerningScale, GLenum transformType, GLfloat *returnedSpacing)
{
  Internal("trace_glGetPathSpacingNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetPathSpacingNV(pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, returnedSpacing);
}

static void REGAL_CALL trace_glGetPathTexGenfvNV(GLenum texCoordSet, GLenum pname, GLfloat *value)
{
  Internal("trace_glGetPathTexGenfvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetPathTexGenfvNV(texCoordSet, pname, value);
}

static void REGAL_CALL trace_glGetPathTexGenivNV(GLenum texCoordSet, GLenum pname, GLint *value)
{
  Internal("trace_glGetPathTexGenivNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetPathTexGenivNV(texCoordSet, pname, value);
}

static void REGAL_CALL trace_glInterpolatePathsNV(GLuint resultPath, GLuint pathA, GLuint pathB, GLfloat weight)
{
  Internal("trace_glInterpolatePathsNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glInterpolatePathsNV(resultPath, pathA, pathB, weight);
}

static GLboolean REGAL_CALL trace_glIsPathNV(GLuint path)
{
  Internal("trace_glIsPathNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glIsPathNV(path);
  return ret;
}

static GLboolean REGAL_CALL trace_glIsPointInFillPathNV(GLuint path, GLuint mask, GLfloat x, GLfloat y)
{
  Internal("trace_glIsPointInFillPathNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glIsPointInFillPathNV(path, mask, x, y);
  return ret;
}

static GLboolean REGAL_CALL trace_glIsPointInStrokePathNV(GLuint path, GLfloat x, GLfloat y)
{
  Internal("trace_glIsPointInStrokePathNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glIsPointInStrokePathNV(path, x, y);
  return ret;
}

static void REGAL_CALL trace_glPathColorGenNV(GLenum color, GLenum genMode, GLenum colorFormat, const GLfloat *coeffs)
{
  Internal("trace_glPathColorGenNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPathColorGenNV(color, genMode, colorFormat, coeffs);
}

static void REGAL_CALL trace_glPathCommandsNV(GLuint path, GLsizei numCommands, const GLubyte *commands, GLsizei numCoords, GLenum coordType, const GLvoid *coords)
{
  Internal("trace_glPathCommandsNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPathCommandsNV(path, numCommands, commands, numCoords, coordType, coords);
}

static void REGAL_CALL trace_glPathCoordsNV(GLuint path, GLsizei numCoords, GLenum coordType, const GLvoid *coords)
{
  Internal("trace_glPathCoordsNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPathCoordsNV(path, numCoords, coordType, coords);
}

static void REGAL_CALL trace_glPathCoverDepthFuncNV(GLenum zfunc)
{
  Internal("trace_glPathCoverDepthFuncNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPathCoverDepthFuncNV(zfunc);
}

static void REGAL_CALL trace_glPathDashArrayNV(GLuint path, GLsizei dashCount, const GLfloat *dashArray)
{
  Internal("trace_glPathDashArrayNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPathDashArrayNV(path, dashCount, dashArray);
}

static void REGAL_CALL trace_glPathFogGenNV(GLenum genMode)
{
  Internal("trace_glPathFogGenNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPathFogGenNV(genMode);
}

static void REGAL_CALL trace_glPathGlyphRangeNV(GLuint firstPathName, GLenum fontTarget, const GLvoid *fontName, GLbitfield fontStyle, GLuint firstGlyph, GLsizei numGlyphs, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale)
{
  Internal("trace_glPathGlyphRangeNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPathGlyphRangeNV(firstPathName, fontTarget, fontName, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale);
}

static void REGAL_CALL trace_glPathGlyphsNV(GLuint firstPathName, GLenum fontTarget, const GLvoid *fontName, GLbitfield fontStyle, GLsizei numGlyphs, GLenum type, const GLvoid *charcodes, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale)
{
  Internal("trace_glPathGlyphsNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPathGlyphsNV(firstPathName, fontTarget, fontName, fontStyle, numGlyphs, type, charcodes, handleMissingGlyphs, pathParameterTemplate, emScale);
}

static void REGAL_CALL trace_glPathParameterfNV(GLuint path, GLenum pname, GLfloat value)
{
  Internal("trace_glPathParameterfNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPathParameterfNV(path, pname, value);
}

static void REGAL_CALL trace_glPathParameterfvNV(GLuint path, GLenum pname, const GLfloat *value)
{
  Internal("trace_glPathParameterfvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPathParameterfvNV(path, pname, value);
}

static void REGAL_CALL trace_glPathParameteriNV(GLuint path, GLenum pname, GLint value)
{
  Internal("trace_glPathParameteriNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPathParameteriNV(path, pname, value);
}

static void REGAL_CALL trace_glPathParameterivNV(GLuint path, GLenum pname, const GLint *value)
{
  Internal("trace_glPathParameterivNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPathParameterivNV(path, pname, value);
}

static void REGAL_CALL trace_glPathStencilDepthOffsetNV(GLfloat factor, GLfloat units)
{
  Internal("trace_glPathStencilDepthOffsetNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPathStencilDepthOffsetNV(factor, units);
}

static void REGAL_CALL trace_glPathStencilFuncNV(GLenum func, GLint ref, GLuint mask)
{
  Internal("trace_glPathStencilFuncNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPathStencilFuncNV(func, ref, mask);
}

static void REGAL_CALL trace_glPathStringNV(GLuint path, GLenum format, GLsizei length, const GLvoid *pathString)
{
  Internal("trace_glPathStringNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPathStringNV(path, format, length, pathString);
}

static void REGAL_CALL trace_glPathSubCommandsNV(GLuint path, GLsizei commandStart, GLsizei commandsToDelete, GLsizei numCommands, const GLubyte *commands, GLsizei numCoords, GLenum coordType, const GLvoid *coords)
{
  Internal("trace_glPathSubCommandsNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPathSubCommandsNV(path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, coords);
}

static void REGAL_CALL trace_glPathSubCoordsNV(GLuint path, GLsizei coordStart, GLsizei numCoords, GLenum coordType, const GLvoid *coords)
{
  Internal("trace_glPathSubCoordsNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPathSubCoordsNV(path, coordStart, numCoords, coordType, coords);
}

static void REGAL_CALL trace_glPathTexGenNV(GLenum texCoordSet, GLenum genMode, GLint components, const GLfloat *coeffs)
{
  Internal("trace_glPathTexGenNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPathTexGenNV(texCoordSet, genMode, components, coeffs);
}

static GLboolean REGAL_CALL trace_glPointAlongPathNV(GLuint path, GLsizei startSegment, GLsizei numSegments, GLfloat distance, GLfloat *x, GLfloat *y, GLfloat *tangentX, GLfloat *tangentY)
{
  Internal("trace_glPointAlongPathNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glPointAlongPathNV(path, startSegment, numSegments, distance, x, y, tangentX, tangentY);
  return ret;
}

static void REGAL_CALL trace_glStencilFillPathInstancedNV(GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum transformType, const GLfloat *transformValues)
{
  Internal("trace_glStencilFillPathInstancedNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glStencilFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues);
}

static void REGAL_CALL trace_glStencilFillPathNV(GLuint path, GLenum fillMode, GLuint mask)
{
  Internal("trace_glStencilFillPathNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glStencilFillPathNV(path, fillMode, mask);
}

static void REGAL_CALL trace_glStencilStrokePathInstancedNV(GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLint reference, GLuint mask, GLenum transformType, const GLfloat *transformValues)
{
  Internal("trace_glStencilStrokePathInstancedNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glStencilStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues);
}

static void REGAL_CALL trace_glStencilStrokePathNV(GLuint path, GLint reference, GLuint mask)
{
  Internal("trace_glStencilStrokePathNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glStencilStrokePathNV(path, reference, mask);
}

static void REGAL_CALL trace_glTransformPathNV(GLuint resultPath, GLuint srcPath, GLenum transformType, const GLfloat *transformValues)
{
  Internal("trace_glTransformPathNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTransformPathNV(resultPath, srcPath, transformType, transformValues);
}

static void REGAL_CALL trace_glWeightPathsNV(GLuint resultPath, GLsizei numPaths, const GLuint *paths, const GLfloat *weights)
{
  Internal("trace_glWeightPathsNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glWeightPathsNV(resultPath, numPaths, paths, weights);
}

// GL_NV_pixel_data_range

static void REGAL_CALL trace_glFlushPixelDataRangeNV(GLenum target)
{
  Internal("trace_glFlushPixelDataRangeNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFlushPixelDataRangeNV(target);
}

static void REGAL_CALL trace_glPixelDataRangeNV(GLenum target, GLsizei size, const GLvoid *pointer)
{
  Internal("trace_glPixelDataRangeNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPixelDataRangeNV(target, size, pointer);
}

// GL_NV_point_sprite

static void REGAL_CALL trace_glPointParameteriNV(GLenum pname, GLint param)
{
  Internal("trace_glPointParameteriNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPointParameteriNV(pname, param);
}

static void REGAL_CALL trace_glPointParameterivNV(GLenum pname, const GLint *params)
{
  Internal("trace_glPointParameterivNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPointParameterivNV(pname, params);
}

// GL_NV_present_video

static void REGAL_CALL trace_glGetVideoi64vNV(GLuint video_slot, GLenum pname, GLint64EXT *params)
{
  Internal("trace_glGetVideoi64vNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetVideoi64vNV(video_slot, pname, params);
}

static void REGAL_CALL trace_glGetVideoivNV(GLuint video_slot, GLenum pname, GLint *params)
{
  Internal("trace_glGetVideoivNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetVideoivNV(video_slot, pname, params);
}

static void REGAL_CALL trace_glGetVideoui64vNV(GLuint video_slot, GLenum pname, GLuint64EXT *params)
{
  Internal("trace_glGetVideoui64vNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetVideoui64vNV(video_slot, pname, params);
}

static void REGAL_CALL trace_glGetVideouivNV(GLuint video_slot, GLenum pname, GLuint *params)
{
  Internal("trace_glGetVideouivNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetVideouivNV(video_slot, pname, params);
}

static void REGAL_CALL trace_glPresentFrameDualFillNV(GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLenum target1, GLuint fill1, GLenum target2, GLuint fill2, GLenum target3, GLuint fill3)
{
  Internal("trace_glPresentFrameDualFillNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPresentFrameDualFillNV(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, target1, fill1, target2, fill2, target3, fill3);
}

static void REGAL_CALL trace_glPresentFrameKeyedNV(GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLuint key0, GLenum target1, GLuint fill1, GLuint key1)
{
  Internal("trace_glPresentFrameKeyedNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPresentFrameKeyedNV(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, key0, target1, fill1, key1);
}

// GL_NV_primitive_restart

static void REGAL_CALL trace_glPrimitiveRestartIndexNV(GLuint index)
{
  Internal("trace_glPrimitiveRestartIndexNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPrimitiveRestartIndexNV(index);
}

static void REGAL_CALL trace_glPrimitiveRestartNV(void)
{
  Internal("trace_glPrimitiveRestartNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPrimitiveRestartNV();
}

// GL_NV_read_buffer

static void REGAL_CALL trace_glReadBufferNV(GLenum mode)
{
  Internal("trace_glReadBufferNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glReadBufferNV(mode);
}

// GL_NV_register_combiners

static void REGAL_CALL trace_glCombinerInputNV(GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage)
{
  Internal("trace_glCombinerInputNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCombinerInputNV(stage, portion, variable, input, mapping, componentUsage);
}

static void REGAL_CALL trace_glCombinerOutputNV(GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum)
{
  Internal("trace_glCombinerOutputNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCombinerOutputNV(stage, portion, abOutput, cdOutput, sumOutput, scale, bias, abDotProduct, cdDotProduct, muxSum);
}

static void REGAL_CALL trace_glCombinerParameterfNV(GLenum pname, GLfloat param)
{
  Internal("trace_glCombinerParameterfNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCombinerParameterfNV(pname, param);
}

static void REGAL_CALL trace_glCombinerParameterfvNV(GLenum pname, const GLfloat *params)
{
  Internal("trace_glCombinerParameterfvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCombinerParameterfvNV(pname, params);
}

static void REGAL_CALL trace_glCombinerParameteriNV(GLenum pname, GLint param)
{
  Internal("trace_glCombinerParameteriNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCombinerParameteriNV(pname, param);
}

static void REGAL_CALL trace_glCombinerParameterivNV(GLenum pname, const GLint *params)
{
  Internal("trace_glCombinerParameterivNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCombinerParameterivNV(pname, params);
}

static void REGAL_CALL trace_glFinalCombinerInputNV(GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage)
{
  Internal("trace_glFinalCombinerInputNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFinalCombinerInputNV(variable, input, mapping, componentUsage);
}

static void REGAL_CALL trace_glGetCombinerInputParameterfvNV(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat *params)
{
  Internal("trace_glGetCombinerInputParameterfvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetCombinerInputParameterfvNV(stage, portion, variable, pname, params);
}

static void REGAL_CALL trace_glGetCombinerInputParameterivNV(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint *params)
{
  Internal("trace_glGetCombinerInputParameterivNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetCombinerInputParameterivNV(stage, portion, variable, pname, params);
}

static void REGAL_CALL trace_glGetCombinerOutputParameterfvNV(GLenum stage, GLenum portion, GLenum pname, GLfloat *params)
{
  Internal("trace_glGetCombinerOutputParameterfvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetCombinerOutputParameterfvNV(stage, portion, pname, params);
}

static void REGAL_CALL trace_glGetCombinerOutputParameterivNV(GLenum stage, GLenum portion, GLenum pname, GLint *params)
{
  Internal("trace_glGetCombinerOutputParameterivNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetCombinerOutputParameterivNV(stage, portion, pname, params);
}

static void REGAL_CALL trace_glGetFinalCombinerInputParameterfvNV(GLenum variable, GLenum pname, GLfloat *params)
{
  Internal("trace_glGetFinalCombinerInputParameterfvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetFinalCombinerInputParameterfvNV(variable, pname, params);
}

static void REGAL_CALL trace_glGetFinalCombinerInputParameterivNV(GLenum variable, GLenum pname, GLint *params)
{
  Internal("trace_glGetFinalCombinerInputParameterivNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetFinalCombinerInputParameterivNV(variable, pname, params);
}

// GL_NV_register_combiners2

static void REGAL_CALL trace_glCombinerStageParameterfvNV(GLenum stage, GLenum pname, const GLfloat *params)
{
  Internal("trace_glCombinerStageParameterfvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCombinerStageParameterfvNV(stage, pname, params);
}

static void REGAL_CALL trace_glGetCombinerStageParameterfvNV(GLenum stage, GLenum pname, GLfloat *params)
{
  Internal("trace_glGetCombinerStageParameterfvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetCombinerStageParameterfvNV(stage, pname, params);
}

// GL_NV_shader_buffer_load

static void REGAL_CALL trace_glGetBufferParameterui64vNV(GLenum target, GLenum pname, GLuint64EXT *params)
{
  Internal("trace_glGetBufferParameterui64vNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetBufferParameterui64vNV(target, pname, params);
}

static void REGAL_CALL trace_glGetIntegerui64vNV(GLenum target, GLuint64EXT *data)
{
  Internal("trace_glGetIntegerui64vNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetIntegerui64vNV(target, data);
}

static void REGAL_CALL trace_glGetNamedBufferParameterui64vNV(GLuint buffer, GLenum pname, GLuint64EXT *params)
{
  Internal("trace_glGetNamedBufferParameterui64vNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetNamedBufferParameterui64vNV(buffer, pname, params);
}

static void REGAL_CALL trace_glGetUniformui64vNV(GLuint program, GLint location, GLuint64EXT *params)
{
  Internal("trace_glGetUniformui64vNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetUniformui64vNV(program, location, params);
}

static GLboolean REGAL_CALL trace_glIsBufferResidentNV(GLenum target)
{
  Internal("trace_glIsBufferResidentNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glIsBufferResidentNV(target);
  return ret;
}

static GLboolean REGAL_CALL trace_glIsNamedBufferResidentNV(GLuint buffer)
{
  Internal("trace_glIsNamedBufferResidentNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glIsNamedBufferResidentNV(buffer);
  return ret;
}

static void REGAL_CALL trace_glMakeBufferNonResidentNV(GLenum target)
{
  Internal("trace_glMakeBufferNonResidentNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMakeBufferNonResidentNV(target);
}

static void REGAL_CALL trace_glMakeBufferResidentNV(GLenum target, GLenum access)
{
  Internal("trace_glMakeBufferResidentNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMakeBufferResidentNV(target, access);
}

static void REGAL_CALL trace_glMakeNamedBufferNonResidentNV(GLuint buffer)
{
  Internal("trace_glMakeNamedBufferNonResidentNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMakeNamedBufferNonResidentNV(buffer);
}

static void REGAL_CALL trace_glMakeNamedBufferResidentNV(GLuint buffer, GLenum access)
{
  Internal("trace_glMakeNamedBufferResidentNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMakeNamedBufferResidentNV(buffer, access);
}

static void REGAL_CALL trace_glProgramUniformui64NV(GLuint program, GLint location, GLuint64EXT v0)
{
  Internal("trace_glProgramUniformui64NV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniformui64NV(program, location, v0);
}

static void REGAL_CALL trace_glProgramUniformui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value)
{
  Internal("trace_glProgramUniformui64vNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramUniformui64vNV(program, location, count, value);
}

static void REGAL_CALL trace_glUniformui64NV(GLint location, GLuint64EXT v0)
{
  Internal("trace_glUniformui64NV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniformui64NV(location, v0);
}

static void REGAL_CALL trace_glUniformui64vNV(GLint location, GLsizei count, const GLuint64EXT *value)
{
  Internal("trace_glUniformui64vNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glUniformui64vNV(location, count, value);
}

// GL_NV_texture_barrier

static void REGAL_CALL trace_glTextureBarrierNV(void)
{
  Internal("trace_glTextureBarrierNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTextureBarrierNV();
}

// GL_NV_texture_multisample

static void REGAL_CALL trace_glTexImage2DMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations)
{
  Internal("trace_glTexImage2DMultisampleCoverageNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexImage2DMultisampleCoverageNV(target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
}

static void REGAL_CALL trace_glTexImage3DMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations)
{
  Internal("trace_glTexImage3DMultisampleCoverageNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexImage3DMultisampleCoverageNV(target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
}

static void REGAL_CALL trace_glTextureImage2DMultisampleCoverageNV(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations)
{
  Internal("trace_glTextureImage2DMultisampleCoverageNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTextureImage2DMultisampleCoverageNV(texture, target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
}

static void REGAL_CALL trace_glTextureImage2DMultisampleNV(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations)
{
  Internal("trace_glTextureImage2DMultisampleNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTextureImage2DMultisampleNV(texture, target, samples, internalFormat, width, height, fixedSampleLocations);
}

static void REGAL_CALL trace_glTextureImage3DMultisampleCoverageNV(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations)
{
  Internal("trace_glTextureImage3DMultisampleCoverageNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTextureImage3DMultisampleCoverageNV(texture, target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
}

static void REGAL_CALL trace_glTextureImage3DMultisampleNV(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations)
{
  Internal("trace_glTextureImage3DMultisampleNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTextureImage3DMultisampleNV(texture, target, samples, internalFormat, width, height, depth, fixedSampleLocations);
}

// GL_NV_transform_feedback

static void REGAL_CALL trace_glActiveVaryingNV(GLuint program, const GLchar *name)
{
  Internal("trace_glActiveVaryingNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glActiveVaryingNV(program, name);
}

static void REGAL_CALL trace_glBeginTransformFeedbackNV(GLenum primitiveMode)
{
  Internal("trace_glBeginTransformFeedbackNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBeginTransformFeedbackNV(primitiveMode);
}

static void REGAL_CALL trace_glBindBufferBaseNV(GLenum target, GLuint index, GLuint buffer)
{
  Internal("trace_glBindBufferBaseNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBindBufferBaseNV(target, index, buffer);
}

static void REGAL_CALL trace_glBindBufferOffsetNV(GLenum target, GLuint index, GLuint buffer, GLintptr offset)
{
  Internal("trace_glBindBufferOffsetNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBindBufferOffsetNV(target, index, buffer, offset);
}

static void REGAL_CALL trace_glBindBufferRangeNV(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
  Internal("trace_glBindBufferRangeNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBindBufferRangeNV(target, index, buffer, offset, size);
}

static void REGAL_CALL trace_glEndTransformFeedbackNV(void)
{
  Internal("trace_glEndTransformFeedbackNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glEndTransformFeedbackNV();
}

static void REGAL_CALL trace_glGetActiveVaryingNV(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name)
{
  Internal("trace_glGetActiveVaryingNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetActiveVaryingNV(program, index, bufSize, length, size, type, name);
}

static void REGAL_CALL trace_glGetTransformFeedbackVaryingNV(GLuint program, GLuint index, GLint *location)
{
  Internal("trace_glGetTransformFeedbackVaryingNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetTransformFeedbackVaryingNV(program, index, location);
}

static GLint REGAL_CALL trace_glGetVaryingLocationNV(GLuint program, const GLchar *name)
{
  Internal("trace_glGetVaryingLocationNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLint  ret = Trace::glGetVaryingLocationNV(program, name);
  return ret;
}

static void REGAL_CALL trace_glTransformFeedbackAttribsNV(GLuint count, const GLint *attribs, GLenum bufferMode)
{
  Internal("trace_glTransformFeedbackAttribsNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTransformFeedbackAttribsNV(count, attribs, bufferMode);
}

static void REGAL_CALL trace_glTransformFeedbackVaryingsNV(GLuint program, GLsizei count, const GLint *locations, GLenum bufferMode)
{
  Internal("trace_glTransformFeedbackVaryingsNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTransformFeedbackVaryingsNV(program, count, locations, bufferMode);
}

// GL_NV_transform_feedback2

static void REGAL_CALL trace_glBindTransformFeedbackNV(GLenum target, GLuint id)
{
  Internal("trace_glBindTransformFeedbackNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBindTransformFeedbackNV(target, id);
}

static void REGAL_CALL trace_glDeleteTransformFeedbacksNV(GLsizei n, const GLuint *ids)
{
  Internal("trace_glDeleteTransformFeedbacksNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDeleteTransformFeedbacksNV(n, ids);
}

static void REGAL_CALL trace_glDrawTransformFeedbackNV(GLenum mode, GLuint name)
{
  Internal("trace_glDrawTransformFeedbackNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDrawTransformFeedbackNV(mode, name);
}

static void REGAL_CALL trace_glGenTransformFeedbacksNV(GLsizei n, GLuint *ids)
{
  Internal("trace_glGenTransformFeedbacksNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGenTransformFeedbacksNV(n, ids);
}

static GLboolean REGAL_CALL trace_glIsTransformFeedbackNV(GLuint id)
{
  Internal("trace_glIsTransformFeedbackNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glIsTransformFeedbackNV(id);
  return ret;
}

static void REGAL_CALL trace_glPauseTransformFeedbackNV(void)
{
  Internal("trace_glPauseTransformFeedbackNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPauseTransformFeedbackNV();
}

static void REGAL_CALL trace_glResumeTransformFeedbackNV(void)
{
  Internal("trace_glResumeTransformFeedbackNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glResumeTransformFeedbackNV();
}

// GL_NV_vertex_array_range

static void REGAL_CALL trace_glFlushVertexArrayRangeNV(void)
{
  Internal("trace_glFlushVertexArrayRangeNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFlushVertexArrayRangeNV();
}

static void REGAL_CALL trace_glVertexArrayRangeNV(GLsizei size, const GLvoid *pointer)
{
  Internal("trace_glVertexArrayRangeNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexArrayRangeNV(size, pointer);
}

// GL_NV_vertex_attrib_integer_64bit

static void REGAL_CALL trace_glGetVertexAttribLi64vNV(GLuint index, GLenum pname, GLint64EXT *params)
{
  Internal("trace_glGetVertexAttribLi64vNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetVertexAttribLi64vNV(index, pname, params);
}

static void REGAL_CALL trace_glGetVertexAttribLui64vNV(GLuint index, GLenum pname, GLuint64EXT *params)
{
  Internal("trace_glGetVertexAttribLui64vNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetVertexAttribLui64vNV(index, pname, params);
}

static void REGAL_CALL trace_glVertexAttribL1i64NV(GLuint index, GLint64EXT x)
{
  Internal("trace_glVertexAttribL1i64NV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribL1i64NV(index, x);
}

static void REGAL_CALL trace_glVertexAttribL1i64vNV(GLuint index, const GLint64EXT *v)
{
  Internal("trace_glVertexAttribL1i64vNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribL1i64vNV(index, v);
}

static void REGAL_CALL trace_glVertexAttribL1ui64NV(GLuint index, GLuint64EXT x)
{
  Internal("trace_glVertexAttribL1ui64NV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribL1ui64NV(index, x);
}

static void REGAL_CALL trace_glVertexAttribL1ui64vNV(GLuint index, const GLuint64EXT *v)
{
  Internal("trace_glVertexAttribL1ui64vNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribL1ui64vNV(index, v);
}

static void REGAL_CALL trace_glVertexAttribL2i64NV(GLuint index, GLint64EXT x, GLint64EXT y)
{
  Internal("trace_glVertexAttribL2i64NV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribL2i64NV(index, x, y);
}

static void REGAL_CALL trace_glVertexAttribL2i64vNV(GLuint index, const GLint64EXT *v)
{
  Internal("trace_glVertexAttribL2i64vNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribL2i64vNV(index, v);
}

static void REGAL_CALL trace_glVertexAttribL2ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y)
{
  Internal("trace_glVertexAttribL2ui64NV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribL2ui64NV(index, x, y);
}

static void REGAL_CALL trace_glVertexAttribL2ui64vNV(GLuint index, const GLuint64EXT *v)
{
  Internal("trace_glVertexAttribL2ui64vNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribL2ui64vNV(index, v);
}

static void REGAL_CALL trace_glVertexAttribL3i64NV(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z)
{
  Internal("trace_glVertexAttribL3i64NV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribL3i64NV(index, x, y, z);
}

static void REGAL_CALL trace_glVertexAttribL3i64vNV(GLuint index, const GLint64EXT *v)
{
  Internal("trace_glVertexAttribL3i64vNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribL3i64vNV(index, v);
}

static void REGAL_CALL trace_glVertexAttribL3ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z)
{
  Internal("trace_glVertexAttribL3ui64NV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribL3ui64NV(index, x, y, z);
}

static void REGAL_CALL trace_glVertexAttribL3ui64vNV(GLuint index, const GLuint64EXT *v)
{
  Internal("trace_glVertexAttribL3ui64vNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribL3ui64vNV(index, v);
}

static void REGAL_CALL trace_glVertexAttribL4i64NV(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w)
{
  Internal("trace_glVertexAttribL4i64NV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribL4i64NV(index, x, y, z, w);
}

static void REGAL_CALL trace_glVertexAttribL4i64vNV(GLuint index, const GLint64EXT *v)
{
  Internal("trace_glVertexAttribL4i64vNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribL4i64vNV(index, v);
}

static void REGAL_CALL trace_glVertexAttribL4ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w)
{
  Internal("trace_glVertexAttribL4ui64NV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribL4ui64NV(index, x, y, z, w);
}

static void REGAL_CALL trace_glVertexAttribL4ui64vNV(GLuint index, const GLuint64EXT *v)
{
  Internal("trace_glVertexAttribL4ui64vNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribL4ui64vNV(index, v);
}

static void REGAL_CALL trace_glVertexAttribLFormatNV(GLuint index, GLint size, GLenum type, GLsizei stride)
{
  Internal("trace_glVertexAttribLFormatNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribLFormatNV(index, size, type, stride);
}

// GL_NV_vertex_buffer_unified_memory

static void REGAL_CALL trace_glBufferAddressRangeNV(GLenum pname, GLuint index, GLuint64EXT address, GLsizeiptr length)
{
  Internal("trace_glBufferAddressRangeNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBufferAddressRangeNV(pname, index, address, length);
}

static void REGAL_CALL trace_glColorFormatNV(GLint size, GLenum type, GLsizei stride)
{
  Internal("trace_glColorFormatNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColorFormatNV(size, type, stride);
}

static void REGAL_CALL trace_glEdgeFlagFormatNV(GLsizei stride)
{
  Internal("trace_glEdgeFlagFormatNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glEdgeFlagFormatNV(stride);
}

static void REGAL_CALL trace_glFogCoordFormatNV(GLenum type, GLsizei stride)
{
  Internal("trace_glFogCoordFormatNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFogCoordFormatNV(type, stride);
}

static void REGAL_CALL trace_glGetIntegerui64i_vNV(GLenum target, GLuint index, GLuint64EXT *data)
{
  Internal("trace_glGetIntegerui64i_vNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetIntegerui64i_vNV(target, index, data);
}

static void REGAL_CALL trace_glIndexFormatNV(GLenum type, GLsizei stride)
{
  Internal("trace_glIndexFormatNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glIndexFormatNV(type, stride);
}

static void REGAL_CALL trace_glNormalFormatNV(GLenum type, GLsizei stride)
{
  Internal("trace_glNormalFormatNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNormalFormatNV(type, stride);
}

static void REGAL_CALL trace_glSecondaryColorFormatNV(GLint size, GLenum type, GLsizei stride)
{
  Internal("trace_glSecondaryColorFormatNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSecondaryColorFormatNV(size, type, stride);
}

static void REGAL_CALL trace_glTexCoordFormatNV(GLint size, GLenum type, GLsizei stride)
{
  Internal("trace_glTexCoordFormatNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoordFormatNV(size, type, stride);
}

static void REGAL_CALL trace_glVertexAttribFormatNV(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride)
{
  Internal("trace_glVertexAttribFormatNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribFormatNV(index, size, type, normalized, stride);
}

static void REGAL_CALL trace_glVertexAttribIFormatNV(GLuint index, GLint size, GLenum type, GLsizei stride)
{
  Internal("trace_glVertexAttribIFormatNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribIFormatNV(index, size, type, stride);
}

static void REGAL_CALL trace_glVertexFormatNV(GLint size, GLenum type, GLsizei stride)
{
  Internal("trace_glVertexFormatNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexFormatNV(size, type, stride);
}

// GL_NV_vertex_program

static GLboolean REGAL_CALL trace_glAreProgramsResidentNV(GLsizei n, const GLuint *programs, GLboolean *residences)
{
  Internal("trace_glAreProgramsResidentNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glAreProgramsResidentNV(n, programs, residences);
  return ret;
}

static void REGAL_CALL trace_glBindProgramNV(GLenum target, GLuint id)
{
  Internal("trace_glBindProgramNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBindProgramNV(target, id);
}

static void REGAL_CALL trace_glDeleteProgramsNV(GLsizei n, const GLuint *programs)
{
  Internal("trace_glDeleteProgramsNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDeleteProgramsNV(n, programs);
}

static void REGAL_CALL trace_glExecuteProgramNV(GLenum target, GLuint id, const GLfloat *params)
{
  Internal("trace_glExecuteProgramNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glExecuteProgramNV(target, id, params);
}

static void REGAL_CALL trace_glGenProgramsNV(GLsizei n, GLuint *programs)
{
  Internal("trace_glGenProgramsNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGenProgramsNV(n, programs);
}

static void REGAL_CALL trace_glGetProgramParameterdvNV(GLenum target, GLuint index, GLenum pname, GLdouble *params)
{
  Internal("trace_glGetProgramParameterdvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetProgramParameterdvNV(target, index, pname, params);
}

static void REGAL_CALL trace_glGetProgramParameterfvNV(GLenum target, GLuint index, GLenum pname, GLfloat *params)
{
  Internal("trace_glGetProgramParameterfvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetProgramParameterfvNV(target, index, pname, params);
}

static void REGAL_CALL trace_glGetProgramStringNV(GLuint id, GLenum pname, GLubyte *program)
{
  Internal("trace_glGetProgramStringNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetProgramStringNV(id, pname, program);
}

static void REGAL_CALL trace_glGetProgramivNV(GLuint id, GLenum pname, GLint *params)
{
  Internal("trace_glGetProgramivNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetProgramivNV(id, pname, params);
}

static void REGAL_CALL trace_glGetTrackMatrixivNV(GLenum target, GLuint address, GLenum pname, GLint *params)
{
  Internal("trace_glGetTrackMatrixivNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetTrackMatrixivNV(target, address, pname, params);
}

static void REGAL_CALL trace_glGetVertexAttribPointervNV(GLuint index, GLenum pname, GLvoid **pointer)
{
  Internal("trace_glGetVertexAttribPointervNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetVertexAttribPointervNV(index, pname, pointer);
}

static void REGAL_CALL trace_glGetVertexAttribdvNV(GLuint index, GLenum pname, GLdouble *params)
{
  Internal("trace_glGetVertexAttribdvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetVertexAttribdvNV(index, pname, params);
}

static void REGAL_CALL trace_glGetVertexAttribfvNV(GLuint index, GLenum pname, GLfloat *params)
{
  Internal("trace_glGetVertexAttribfvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetVertexAttribfvNV(index, pname, params);
}

static void REGAL_CALL trace_glGetVertexAttribivNV(GLuint index, GLenum pname, GLint *params)
{
  Internal("trace_glGetVertexAttribivNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetVertexAttribivNV(index, pname, params);
}

static GLboolean REGAL_CALL trace_glIsProgramNV(GLuint id)
{
  Internal("trace_glIsProgramNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glIsProgramNV(id);
  return ret;
}

static void REGAL_CALL trace_glLoadProgramNV(GLenum target, GLuint id, GLsizei len, const GLubyte *program)
{
  Internal("trace_glLoadProgramNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glLoadProgramNV(target, id, len, program);
}

static void REGAL_CALL trace_glProgramParameter4dNV(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  Internal("trace_glProgramParameter4dNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramParameter4dNV(target, index, x, y, z, w);
}

static void REGAL_CALL trace_glProgramParameter4dvNV(GLenum target, GLuint index, const GLdouble *v)
{
  Internal("trace_glProgramParameter4dvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramParameter4dvNV(target, index, v);
}

static void REGAL_CALL trace_glProgramParameter4fNV(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  Internal("trace_glProgramParameter4fNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramParameter4fNV(target, index, x, y, z, w);
}

static void REGAL_CALL trace_glProgramParameter4fvNV(GLenum target, GLuint index, const GLfloat *v)
{
  Internal("trace_glProgramParameter4fvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramParameter4fvNV(target, index, v);
}

static void REGAL_CALL trace_glProgramParameters4dvNV(GLenum target, GLuint index, GLsizei count, const GLdouble *v)
{
  Internal("trace_glProgramParameters4dvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramParameters4dvNV(target, index, count, v);
}

static void REGAL_CALL trace_glProgramParameters4fvNV(GLenum target, GLuint index, GLsizei count, const GLfloat *v)
{
  Internal("trace_glProgramParameters4fvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramParameters4fvNV(target, index, count, v);
}

static void REGAL_CALL trace_glRequestResidentProgramsNV(GLsizei n, const GLuint *programs)
{
  Internal("trace_glRequestResidentProgramsNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glRequestResidentProgramsNV(n, programs);
}

static void REGAL_CALL trace_glTrackMatrixNV(GLenum target, GLuint address, GLenum matrix, GLenum transform)
{
  Internal("trace_glTrackMatrixNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTrackMatrixNV(target, address, matrix, transform);
}

static void REGAL_CALL trace_glVertexAttrib1dNV(GLuint index, GLdouble x)
{
  Internal("trace_glVertexAttrib1dNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib1dNV(index, x);
}

static void REGAL_CALL trace_glVertexAttrib1dvNV(GLuint index, const GLdouble *v)
{
  Internal("trace_glVertexAttrib1dvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib1dvNV(index, v);
}

static void REGAL_CALL trace_glVertexAttrib1fNV(GLuint index, GLfloat x)
{
  Internal("trace_glVertexAttrib1fNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib1fNV(index, x);
}

static void REGAL_CALL trace_glVertexAttrib1fvNV(GLuint index, const GLfloat *v)
{
  Internal("trace_glVertexAttrib1fvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib1fvNV(index, v);
}

static void REGAL_CALL trace_glVertexAttrib1sNV(GLuint index, GLshort x)
{
  Internal("trace_glVertexAttrib1sNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib1sNV(index, x);
}

static void REGAL_CALL trace_glVertexAttrib1svNV(GLuint index, const GLshort *v)
{
  Internal("trace_glVertexAttrib1svNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib1svNV(index, v);
}

static void REGAL_CALL trace_glVertexAttrib2dNV(GLuint index, GLdouble x, GLdouble y)
{
  Internal("trace_glVertexAttrib2dNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib2dNV(index, x, y);
}

static void REGAL_CALL trace_glVertexAttrib2dvNV(GLuint index, const GLdouble *v)
{
  Internal("trace_glVertexAttrib2dvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib2dvNV(index, v);
}

static void REGAL_CALL trace_glVertexAttrib2fNV(GLuint index, GLfloat x, GLfloat y)
{
  Internal("trace_glVertexAttrib2fNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib2fNV(index, x, y);
}

static void REGAL_CALL trace_glVertexAttrib2fvNV(GLuint index, const GLfloat *v)
{
  Internal("trace_glVertexAttrib2fvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib2fvNV(index, v);
}

static void REGAL_CALL trace_glVertexAttrib2sNV(GLuint index, GLshort x, GLshort y)
{
  Internal("trace_glVertexAttrib2sNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib2sNV(index, x, y);
}

static void REGAL_CALL trace_glVertexAttrib2svNV(GLuint index, const GLshort *v)
{
  Internal("trace_glVertexAttrib2svNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib2svNV(index, v);
}

static void REGAL_CALL trace_glVertexAttrib3dNV(GLuint index, GLdouble x, GLdouble y, GLdouble z)
{
  Internal("trace_glVertexAttrib3dNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib3dNV(index, x, y, z);
}

static void REGAL_CALL trace_glVertexAttrib3dvNV(GLuint index, const GLdouble *v)
{
  Internal("trace_glVertexAttrib3dvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib3dvNV(index, v);
}

static void REGAL_CALL trace_glVertexAttrib3fNV(GLuint index, GLfloat x, GLfloat y, GLfloat z)
{
  Internal("trace_glVertexAttrib3fNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib3fNV(index, x, y, z);
}

static void REGAL_CALL trace_glVertexAttrib3fvNV(GLuint index, const GLfloat *v)
{
  Internal("trace_glVertexAttrib3fvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib3fvNV(index, v);
}

static void REGAL_CALL trace_glVertexAttrib3sNV(GLuint index, GLshort x, GLshort y, GLshort z)
{
  Internal("trace_glVertexAttrib3sNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib3sNV(index, x, y, z);
}

static void REGAL_CALL trace_glVertexAttrib3svNV(GLuint index, const GLshort *v)
{
  Internal("trace_glVertexAttrib3svNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib3svNV(index, v);
}

static void REGAL_CALL trace_glVertexAttrib4dNV(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  Internal("trace_glVertexAttrib4dNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib4dNV(index, x, y, z, w);
}

static void REGAL_CALL trace_glVertexAttrib4dvNV(GLuint index, const GLdouble *v)
{
  Internal("trace_glVertexAttrib4dvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib4dvNV(index, v);
}

static void REGAL_CALL trace_glVertexAttrib4fNV(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  Internal("trace_glVertexAttrib4fNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib4fNV(index, x, y, z, w);
}

static void REGAL_CALL trace_glVertexAttrib4fvNV(GLuint index, const GLfloat *v)
{
  Internal("trace_glVertexAttrib4fvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib4fvNV(index, v);
}

static void REGAL_CALL trace_glVertexAttrib4sNV(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
{
  Internal("trace_glVertexAttrib4sNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib4sNV(index, x, y, z, w);
}

static void REGAL_CALL trace_glVertexAttrib4svNV(GLuint index, const GLshort *v)
{
  Internal("trace_glVertexAttrib4svNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib4svNV(index, v);
}

static void REGAL_CALL trace_glVertexAttrib4ubNV(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
{
  Internal("trace_glVertexAttrib4ubNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib4ubNV(index, x, y, z, w);
}

static void REGAL_CALL trace_glVertexAttrib4ubvNV(GLuint index, const GLubyte *v)
{
  Internal("trace_glVertexAttrib4ubvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttrib4ubvNV(index, v);
}

static void REGAL_CALL trace_glVertexAttribPointerNV(GLuint index, GLint fsize, GLenum type, GLsizei stride, const GLvoid *pointer)
{
  Internal("trace_glVertexAttribPointerNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribPointerNV(index, fsize, type, stride, pointer);
}

static void REGAL_CALL trace_glVertexAttribs1dvNV(GLuint index, GLsizei n, const GLdouble *v)
{
  Internal("trace_glVertexAttribs1dvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribs1dvNV(index, n, v);
}

static void REGAL_CALL trace_glVertexAttribs1fvNV(GLuint index, GLsizei n, const GLfloat *v)
{
  Internal("trace_glVertexAttribs1fvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribs1fvNV(index, n, v);
}

static void REGAL_CALL trace_glVertexAttribs1svNV(GLuint index, GLsizei n, const GLshort *v)
{
  Internal("trace_glVertexAttribs1svNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribs1svNV(index, n, v);
}

static void REGAL_CALL trace_glVertexAttribs2dvNV(GLuint index, GLsizei n, const GLdouble *v)
{
  Internal("trace_glVertexAttribs2dvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribs2dvNV(index, n, v);
}

static void REGAL_CALL trace_glVertexAttribs2fvNV(GLuint index, GLsizei n, const GLfloat *v)
{
  Internal("trace_glVertexAttribs2fvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribs2fvNV(index, n, v);
}

static void REGAL_CALL trace_glVertexAttribs2svNV(GLuint index, GLsizei n, const GLshort *v)
{
  Internal("trace_glVertexAttribs2svNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribs2svNV(index, n, v);
}

static void REGAL_CALL trace_glVertexAttribs3dvNV(GLuint index, GLsizei n, const GLdouble *v)
{
  Internal("trace_glVertexAttribs3dvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribs3dvNV(index, n, v);
}

static void REGAL_CALL trace_glVertexAttribs3fvNV(GLuint index, GLsizei n, const GLfloat *v)
{
  Internal("trace_glVertexAttribs3fvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribs3fvNV(index, n, v);
}

static void REGAL_CALL trace_glVertexAttribs3svNV(GLuint index, GLsizei n, const GLshort *v)
{
  Internal("trace_glVertexAttribs3svNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribs3svNV(index, n, v);
}

static void REGAL_CALL trace_glVertexAttribs4dvNV(GLuint index, GLsizei n, const GLdouble *v)
{
  Internal("trace_glVertexAttribs4dvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribs4dvNV(index, n, v);
}

static void REGAL_CALL trace_glVertexAttribs4fvNV(GLuint index, GLsizei n, const GLfloat *v)
{
  Internal("trace_glVertexAttribs4fvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribs4fvNV(index, n, v);
}

static void REGAL_CALL trace_glVertexAttribs4svNV(GLuint index, GLsizei n, const GLshort *v)
{
  Internal("trace_glVertexAttribs4svNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribs4svNV(index, n, v);
}

static void REGAL_CALL trace_glVertexAttribs4ubvNV(GLuint index, GLsizei n, const GLubyte *v)
{
  Internal("trace_glVertexAttribs4ubvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVertexAttribs4ubvNV(index, n, v);
}

// GL_NV_video_capture

static void REGAL_CALL trace_glBeginVideoCaptureNV(GLuint video_capture_slot)
{
  Internal("trace_glBeginVideoCaptureNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBeginVideoCaptureNV(video_capture_slot);
}

static void REGAL_CALL trace_glBindVideoCaptureStreamBufferNV(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLintptr offset)
{
  Internal("trace_glBindVideoCaptureStreamBufferNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBindVideoCaptureStreamBufferNV(video_capture_slot, stream, frame_region, offset);
}

static void REGAL_CALL trace_glBindVideoCaptureStreamTextureNV(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLenum target, GLuint texture)
{
  Internal("trace_glBindVideoCaptureStreamTextureNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBindVideoCaptureStreamTextureNV(video_capture_slot, stream, frame_region, target, texture);
}

static void REGAL_CALL trace_glEndVideoCaptureNV(GLuint video_capture_slot)
{
  Internal("trace_glEndVideoCaptureNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glEndVideoCaptureNV(video_capture_slot);
}

static void REGAL_CALL trace_glGetVideoCaptureStreamdvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, GLdouble *params)
{
  Internal("trace_glGetVideoCaptureStreamdvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetVideoCaptureStreamdvNV(video_capture_slot, stream, pname, params);
}

static void REGAL_CALL trace_glGetVideoCaptureStreamfvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, GLfloat *params)
{
  Internal("trace_glGetVideoCaptureStreamfvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetVideoCaptureStreamfvNV(video_capture_slot, stream, pname, params);
}

static void REGAL_CALL trace_glGetVideoCaptureStreamivNV(GLuint video_capture_slot, GLuint stream, GLenum pname, GLint *params)
{
  Internal("trace_glGetVideoCaptureStreamivNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetVideoCaptureStreamivNV(video_capture_slot, stream, pname, params);
}

static void REGAL_CALL trace_glGetVideoCaptureivNV(GLuint video_capture_slot, GLenum pname, GLint *params)
{
  Internal("trace_glGetVideoCaptureivNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetVideoCaptureivNV(video_capture_slot, pname, params);
}

static GLenum REGAL_CALL trace_glVideoCaptureNV(GLuint video_capture_slot, GLuint *sequence_num, GLuint64EXT *capture_time)
{
  Internal("trace_glVideoCaptureNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLenum  ret = Trace::glVideoCaptureNV(video_capture_slot, sequence_num, capture_time);
  return ret;
}

static void REGAL_CALL trace_glVideoCaptureStreamParameterdvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLdouble *params)
{
  Internal("trace_glVideoCaptureStreamParameterdvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVideoCaptureStreamParameterdvNV(video_capture_slot, stream, pname, params);
}

static void REGAL_CALL trace_glVideoCaptureStreamParameterfvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLfloat *params)
{
  Internal("trace_glVideoCaptureStreamParameterfvNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVideoCaptureStreamParameterfvNV(video_capture_slot, stream, pname, params);
}

static void REGAL_CALL trace_glVideoCaptureStreamParameterivNV(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLint *params)
{
  Internal("trace_glVideoCaptureStreamParameterivNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glVideoCaptureStreamParameterivNV(video_capture_slot, stream, pname, params);
}

// GL_OES_blend_equation_separate

static void REGAL_CALL trace_glBlendEquationSeparateOES(GLenum modeRGB, GLenum modeAlpha)
{
  Internal("trace_glBlendEquationSeparateOES","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBlendEquationSeparateOES(modeRGB, modeAlpha);
}

// GL_OES_blend_func_separate

static void REGAL_CALL trace_glBlendFuncSeparateOES(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)
{
  Internal("trace_glBlendFuncSeparateOES","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBlendFuncSeparateOES(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
}

// GL_OES_blend_subtract

static void REGAL_CALL trace_glBlendEquationOES(GLenum mode)
{
  Internal("trace_glBlendEquationOES","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBlendEquationOES(mode);
}

// GL_OES_framebuffer_object

static void REGAL_CALL trace_glBindFramebufferOES(GLenum target, GLuint framebuffer)
{
  Internal("trace_glBindFramebufferOES","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBindFramebufferOES(target, framebuffer);
}

static void REGAL_CALL trace_glBindRenderbufferOES(GLenum target, GLuint renderbuffer)
{
  Internal("trace_glBindRenderbufferOES","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBindRenderbufferOES(target, renderbuffer);
}

static GLenum REGAL_CALL trace_glCheckFramebufferStatusOES(GLenum target)
{
  Internal("trace_glCheckFramebufferStatusOES","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLenum  ret = Trace::glCheckFramebufferStatusOES(target);
  return ret;
}

static void REGAL_CALL trace_glDeleteFramebuffersOES(GLsizei n, const GLuint *framebuffers)
{
  Internal("trace_glDeleteFramebuffersOES","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDeleteFramebuffersOES(n, framebuffers);
}

static void REGAL_CALL trace_glDeleteRenderbuffersOES(GLsizei n, const GLuint *renderbuffers)
{
  Internal("trace_glDeleteRenderbuffersOES","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDeleteRenderbuffersOES(n, renderbuffers);
}

static void REGAL_CALL trace_glFramebufferRenderbufferOES(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{
  Internal("trace_glFramebufferRenderbufferOES","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFramebufferRenderbufferOES(target, attachment, renderbuffertarget, renderbuffer);
}

static void REGAL_CALL trace_glFramebufferTexture2DOES(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
  Internal("trace_glFramebufferTexture2DOES","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFramebufferTexture2DOES(target, attachment, textarget, texture, level);
}

static void REGAL_CALL trace_glGenFramebuffersOES(GLsizei n, GLuint *framebuffers)
{
  Internal("trace_glGenFramebuffersOES","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGenFramebuffersOES(n, framebuffers);
}

static void REGAL_CALL trace_glGenRenderbuffersOES(GLsizei n, GLuint *renderbuffers)
{
  Internal("trace_glGenRenderbuffersOES","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGenRenderbuffersOES(n, renderbuffers);
}

static void REGAL_CALL trace_glGenerateMipmapOES(GLenum target)
{
  Internal("trace_glGenerateMipmapOES","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGenerateMipmapOES(target);
}

static void REGAL_CALL trace_glGetFramebufferAttachmentParameterivOES(GLenum target, GLenum attachment, GLenum pname, GLint *params)
{
  Internal("trace_glGetFramebufferAttachmentParameterivOES","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetFramebufferAttachmentParameterivOES(target, attachment, pname, params);
}

static void REGAL_CALL trace_glGetRenderbufferParameterivOES(GLenum target, GLenum pname, GLint *params)
{
  Internal("trace_glGetRenderbufferParameterivOES","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetRenderbufferParameterivOES(target, pname, params);
}

static GLboolean REGAL_CALL trace_glIsFramebufferOES(GLuint framebuffer)
{
  Internal("trace_glIsFramebufferOES","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glIsFramebufferOES(framebuffer);
  return ret;
}

static GLboolean REGAL_CALL trace_glIsRenderbufferOES(GLuint renderbuffer)
{
  Internal("trace_glIsRenderbufferOES","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glIsRenderbufferOES(renderbuffer);
  return ret;
}

static void REGAL_CALL trace_glRenderbufferStorageOES(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
{
  Internal("trace_glRenderbufferStorageOES","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glRenderbufferStorageOES(target, internalformat, width, height);
}

// GL_OES_get_program_binary

static void REGAL_CALL trace_glGetProgramBinaryOES(GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, GLvoid *binary)
{
  Internal("trace_glGetProgramBinaryOES","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetProgramBinaryOES(program, bufSize, length, binaryFormat, binary);
}

static void REGAL_CALL trace_glProgramBinaryOES(GLuint program, GLenum binaryFormat, const GLvoid *binary, GLint length)
{
  Internal("trace_glProgramBinaryOES","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glProgramBinaryOES(program, binaryFormat, binary, length);
}

// GL_OES_mapbuffer

static void REGAL_CALL trace_glGetBufferPointervOES(GLenum target, GLenum pname, GLvoid **params)
{
  Internal("trace_glGetBufferPointervOES","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetBufferPointervOES(target, pname, params);
}

static GLvoid *REGAL_CALL trace_glMapBufferOES(GLenum target, GLenum access)
{
  Internal("trace_glMapBufferOES","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLvoid * ret = Trace::glMapBufferOES(target, access);
  return ret;
}

static GLboolean REGAL_CALL trace_glUnmapBufferOES(GLenum target)
{
  Internal("trace_glUnmapBufferOES","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glUnmapBufferOES(target);
  return ret;
}

// GL_OES_matrix_palette

static void REGAL_CALL trace_glCurrentPaletteMatrixOES(GLuint index)
{
  Internal("trace_glCurrentPaletteMatrixOES","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCurrentPaletteMatrixOES(index);
}

// GL_OES_texture_3D

static void REGAL_CALL trace_glCompressedTexImage3DOES(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data)
{
  Internal("trace_glCompressedTexImage3DOES","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCompressedTexImage3DOES(target, level, internalformat, width, height, depth, border, imageSize, data);
}

static void REGAL_CALL trace_glCompressedTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data)
{
  Internal("trace_glCompressedTexSubImage3DOES","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCompressedTexSubImage3DOES(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
}

static void REGAL_CALL trace_glCopyTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
  Internal("trace_glCopyTexSubImage3DOES","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCopyTexSubImage3DOES(target, level, xoffset, yoffset, zoffset, x, y, width, height);
}

static void REGAL_CALL trace_glFramebufferTexture3DOES(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)
{
  Internal("trace_glFramebufferTexture3DOES","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFramebufferTexture3DOES(target, attachment, textarget, texture, level, zoffset);
}

static void REGAL_CALL trace_glTexImage3DOES(GLenum target, GLint level, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
  Internal("trace_glTexImage3DOES","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexImage3DOES(target, level, internalFormat, width, height, depth, border, format, type, pixels);
}

static void REGAL_CALL trace_glTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
{
  Internal("trace_glTexSubImage3DOES","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexSubImage3DOES(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
}

// GL_OES_texture_cube_map

static void REGAL_CALL trace_glGetTexGenfvOES(GLenum coord, GLenum pname, GLfloat *params)
{
  Internal("trace_glGetTexGenfvOES","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetTexGenfvOES(coord, pname, params);
}

static void REGAL_CALL trace_glGetTexGenivOES(GLenum coord, GLenum pname, GLint *params)
{
  Internal("trace_glGetTexGenivOES","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetTexGenivOES(coord, pname, params);
}

static void REGAL_CALL trace_glGetTexGenxvOES(GLenum coord, GLenum pname, GLfixed *params)
{
  Internal("trace_glGetTexGenxvOES","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetTexGenxvOES(coord, pname, params);
}

static void REGAL_CALL trace_glTexGenfOES(GLenum coord, GLenum pname, GLfloat param)
{
  Internal("trace_glTexGenfOES","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexGenfOES(coord, pname, param);
}

static void REGAL_CALL trace_glTexGenfvOES(GLenum coord, GLenum pname, const GLfloat *params)
{
  Internal("trace_glTexGenfvOES","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexGenfvOES(coord, pname, params);
}

static void REGAL_CALL trace_glTexGeniOES(GLenum coord, GLenum pname, GLint param)
{
  Internal("trace_glTexGeniOES","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexGeniOES(coord, pname, param);
}

static void REGAL_CALL trace_glTexGenivOES(GLenum coord, GLenum pname, const GLint *params)
{
  Internal("trace_glTexGenivOES","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexGenivOES(coord, pname, params);
}

static void REGAL_CALL trace_glTexGenxOES(GLenum coord, GLenum pname, GLfixed param)
{
  Internal("trace_glTexGenxOES","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexGenxOES(coord, pname, param);
}

static void REGAL_CALL trace_glTexGenxvOES(GLenum coord, GLenum pname, const GLfixed *params)
{
  Internal("trace_glTexGenxvOES","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexGenxvOES(coord, pname, params);
}

// GL_OES_vertex_array_object

static void REGAL_CALL trace_glBindVertexArrayOES(GLuint array)
{
  Internal("trace_glBindVertexArrayOES","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glBindVertexArrayOES(array);
}

static void REGAL_CALL trace_glDeleteVertexArraysOES(GLsizei n, const GLuint *arrays)
{
  Internal("trace_glDeleteVertexArraysOES","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDeleteVertexArraysOES(n, arrays);
}

static void REGAL_CALL trace_glGenVertexArraysOES(GLsizei n, GLuint *arrays)
{
  Internal("trace_glGenVertexArraysOES","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGenVertexArraysOES(n, arrays);
}

static GLboolean REGAL_CALL trace_glIsVertexArrayOES(GLuint array)
{
  Internal("trace_glIsVertexArrayOES","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glIsVertexArrayOES(array);
  return ret;
}

// GL_PGI_misc_hints

static void REGAL_CALL trace_glHintPGI(GLenum target, GLint mode)
{
  Internal("trace_glHintPGI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glHintPGI(target, mode);
}

// GL_REGAL_ES1_0_compatibility

static void REGAL_CALL trace_glAlphaFuncx(GLenum func, GLclampx ref)
{
  Internal("trace_glAlphaFuncx","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glAlphaFuncx(func, ref);
}

static void REGAL_CALL trace_glClearColorx(GLclampx red, GLclampx green, GLclampx blue, GLclampx alpha)
{
  Internal("trace_glClearColorx","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glClearColorx(red, green, blue, alpha);
}

static void REGAL_CALL trace_glClearDepthx(GLclampx depth)
{
  Internal("trace_glClearDepthx","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glClearDepthx(depth);
}

static void REGAL_CALL trace_glColor4x(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha)
{
  Internal("trace_glColor4x","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColor4x(red, green, blue, alpha);
}

static void REGAL_CALL trace_glDepthRangex(GLclampx zNear, GLclampx zFar)
{
  Internal("trace_glDepthRangex","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDepthRangex(zNear, zFar);
}

static void REGAL_CALL trace_glFogx(GLenum pname, GLfixed param)
{
  Internal("trace_glFogx","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFogx(pname, param);
}

static void REGAL_CALL trace_glFogxv(GLenum pname, const GLfixed *params)
{
  Internal("trace_glFogxv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFogxv(pname, params);
}

static void REGAL_CALL trace_glFrustumf(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar)
{
  Internal("trace_glFrustumf","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFrustumf(left, right, bottom, top, zNear, zFar);
}

static void REGAL_CALL trace_glFrustumx(GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar)
{
  Internal("trace_glFrustumx","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFrustumx(left, right, bottom, top, zNear, zFar);
}

static void REGAL_CALL trace_glLightModelx(GLenum pname, GLfixed param)
{
  Internal("trace_glLightModelx","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glLightModelx(pname, param);
}

static void REGAL_CALL trace_glLightModelxv(GLenum pname, const GLfixed *params)
{
  Internal("trace_glLightModelxv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glLightModelxv(pname, params);
}

static void REGAL_CALL trace_glLightx(GLenum light, GLenum pname, GLfixed param)
{
  Internal("trace_glLightx","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glLightx(light, pname, param);
}

static void REGAL_CALL trace_glLightxv(GLenum light, GLenum pname, const GLfixed *params)
{
  Internal("trace_glLightxv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glLightxv(light, pname, params);
}

static void REGAL_CALL trace_glLineWidthx(GLfixed width)
{
  Internal("trace_glLineWidthx","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glLineWidthx(width);
}

static void REGAL_CALL trace_glLoadMatrixx(const GLfixed *m)
{
  Internal("trace_glLoadMatrixx","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glLoadMatrixx(m);
}

static void REGAL_CALL trace_glMaterialx(GLenum face, GLenum pname, GLfixed param)
{
  Internal("trace_glMaterialx","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMaterialx(face, pname, param);
}

static void REGAL_CALL trace_glMaterialxv(GLenum face, GLenum pname, const GLfixed *params)
{
  Internal("trace_glMaterialxv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMaterialxv(face, pname, params);
}

static void REGAL_CALL trace_glMultMatrixx(const GLfixed *m)
{
  Internal("trace_glMultMatrixx","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultMatrixx(m);
}

static void REGAL_CALL trace_glMultiTexCoord4x(GLenum target, GLfixed s, GLfixed t, GLfixed r, GLfixed q)
{
  Internal("trace_glMultiTexCoord4x","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glMultiTexCoord4x(target, s, t, r, q);
}

static void REGAL_CALL trace_glNormal3x(GLfixed nx, GLfixed ny, GLfixed nz)
{
  Internal("trace_glNormal3x","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNormal3x(nx, ny, nz);
}

static void REGAL_CALL trace_glOrthof(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar)
{
  Internal("trace_glOrthof","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glOrthof(left, right, bottom, top, zNear, zFar);
}

static void REGAL_CALL trace_glOrthox(GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar)
{
  Internal("trace_glOrthox","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glOrthox(left, right, bottom, top, zNear, zFar);
}

static void REGAL_CALL trace_glPointSizex(GLfixed size)
{
  Internal("trace_glPointSizex","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPointSizex(size);
}

static void REGAL_CALL trace_glPolygonOffsetx(GLfixed factor, GLfixed units)
{
  Internal("trace_glPolygonOffsetx","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPolygonOffsetx(factor, units);
}

static void REGAL_CALL trace_glRotatex(GLfixed angle, GLfixed x, GLfixed y, GLfixed z)
{
  Internal("trace_glRotatex","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glRotatex(angle, x, y, z);
}

static void REGAL_CALL trace_glSampleCoveragex(GLclampx value, GLboolean invert)
{
  Internal("trace_glSampleCoveragex","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSampleCoveragex(value, invert);
}

static void REGAL_CALL trace_glScalex(GLfixed x, GLfixed y, GLfixed z)
{
  Internal("trace_glScalex","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glScalex(x, y, z);
}

static void REGAL_CALL trace_glTexEnvx(GLenum target, GLenum pname, GLfixed param)
{
  Internal("trace_glTexEnvx","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexEnvx(target, pname, param);
}

static void REGAL_CALL trace_glTexEnvxv(GLenum target, GLenum pname, const GLfixed *params)
{
  Internal("trace_glTexEnvxv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexEnvxv(target, pname, params);
}

static void REGAL_CALL trace_glTexParameterx(GLenum target, GLenum pname, GLfixed param)
{
  Internal("trace_glTexParameterx","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexParameterx(target, pname, param);
}

static void REGAL_CALL trace_glTranslatex(GLfixed x, GLfixed y, GLfixed z)
{
  Internal("trace_glTranslatex","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTranslatex(x, y, z);
}

// GL_REGAL_ES1_1_compatibility

static void REGAL_CALL trace_glClipPlanef(GLenum plane, const GLfloat *equation)
{
  Internal("trace_glClipPlanef","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glClipPlanef(plane, equation);
}

static void REGAL_CALL trace_glClipPlanex(GLenum plane, const GLfixed *equation)
{
  Internal("trace_glClipPlanex","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glClipPlanex(plane, equation);
}

static void REGAL_CALL trace_glGetClipPlanef(GLenum pname, GLfloat *eqn)
{
  Internal("trace_glGetClipPlanef","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetClipPlanef(pname, eqn);
}

static void REGAL_CALL trace_glGetClipPlanex(GLenum pname, GLfixed *eqn)
{
  Internal("trace_glGetClipPlanex","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetClipPlanex(pname, eqn);
}

static void REGAL_CALL trace_glGetFixedv(GLenum pname, GLfixed *params)
{
  Internal("trace_glGetFixedv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetFixedv(pname, params);
}

static void REGAL_CALL trace_glGetLightxv(GLenum light, GLenum pname, GLfixed *params)
{
  Internal("trace_glGetLightxv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetLightxv(light, pname, params);
}

static void REGAL_CALL trace_glGetMaterialxv(GLenum face, GLenum pname, GLfixed *params)
{
  Internal("trace_glGetMaterialxv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetMaterialxv(face, pname, params);
}

static void REGAL_CALL trace_glGetTexEnvxv(GLenum env, GLenum pname, GLfixed *params)
{
  Internal("trace_glGetTexEnvxv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetTexEnvxv(env, pname, params);
}

static void REGAL_CALL trace_glGetTexParameterxv(GLenum target, GLenum pname, GLfixed *params)
{
  Internal("trace_glGetTexParameterxv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetTexParameterxv(target, pname, params);
}

static void REGAL_CALL trace_glPointParameterx(GLenum pname, GLfixed param)
{
  Internal("trace_glPointParameterx","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPointParameterx(pname, param);
}

static void REGAL_CALL trace_glPointParameterxv(GLenum pname, const GLfixed *params)
{
  Internal("trace_glPointParameterxv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPointParameterxv(pname, params);
}

static void REGAL_CALL trace_glPointSizePointerOES(GLenum type, GLsizei stride, const GLvoid *pointer)
{
  Internal("trace_glPointSizePointerOES","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPointSizePointerOES(type, stride, pointer);
}

static void REGAL_CALL trace_glTexParameterxv(GLenum target, GLenum pname, const GLfixed *params)
{
  Internal("trace_glTexParameterxv","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexParameterxv(target, pname, params);
}

// GL_SGIS_detail_texture

static void REGAL_CALL trace_glDetailTexFuncSGIS(GLenum target, GLsizei n, const GLfloat *points)
{
  Internal("trace_glDetailTexFuncSGIS","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDetailTexFuncSGIS(target, n, points);
}

static void REGAL_CALL trace_glGetDetailTexFuncSGIS(GLenum target, GLfloat *points)
{
  Internal("trace_glGetDetailTexFuncSGIS","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetDetailTexFuncSGIS(target, points);
}

// GL_SGIS_fog_function

static void REGAL_CALL trace_glFogFuncSGIS(GLsizei n, const GLfloat *points)
{
  Internal("trace_glFogFuncSGIS","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFogFuncSGIS(n, points);
}

static void REGAL_CALL trace_glGetFogFuncSGIS(GLfloat *points)
{
  Internal("trace_glGetFogFuncSGIS","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetFogFuncSGIS(points);
}

// GL_SGIS_multisample

static void REGAL_CALL trace_glSampleMaskSGIS(GLclampf value, GLboolean invert)
{
  Internal("trace_glSampleMaskSGIS","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSampleMaskSGIS(value, invert);
}

static void REGAL_CALL trace_glSamplePatternSGIS(GLenum pattern)
{
  Internal("trace_glSamplePatternSGIS","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSamplePatternSGIS(pattern);
}

// GL_SGIS_pixel_texture

static void REGAL_CALL trace_glGetPixelTexGenParameterfvSGIS(GLenum pname, GLfloat *params)
{
  Internal("trace_glGetPixelTexGenParameterfvSGIS","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetPixelTexGenParameterfvSGIS(pname, params);
}

static void REGAL_CALL trace_glGetPixelTexGenParameterivSGIS(GLenum pname, GLint *params)
{
  Internal("trace_glGetPixelTexGenParameterivSGIS","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetPixelTexGenParameterivSGIS(pname, params);
}

static void REGAL_CALL trace_glPixelTexGenParameterfSGIS(GLenum pname, GLfloat param)
{
  Internal("trace_glPixelTexGenParameterfSGIS","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPixelTexGenParameterfSGIS(pname, param);
}

static void REGAL_CALL trace_glPixelTexGenParameterfvSGIS(GLenum pname, const GLfloat *params)
{
  Internal("trace_glPixelTexGenParameterfvSGIS","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPixelTexGenParameterfvSGIS(pname, params);
}

static void REGAL_CALL trace_glPixelTexGenParameteriSGIS(GLenum pname, GLint param)
{
  Internal("trace_glPixelTexGenParameteriSGIS","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPixelTexGenParameteriSGIS(pname, param);
}

static void REGAL_CALL trace_glPixelTexGenParameterivSGIS(GLenum pname, const GLint *params)
{
  Internal("trace_glPixelTexGenParameterivSGIS","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPixelTexGenParameterivSGIS(pname, params);
}

// GL_SGIS_point_parameters

static void REGAL_CALL trace_glPointParameterfSGIS(GLenum pname, GLfloat param)
{
  Internal("trace_glPointParameterfSGIS","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPointParameterfSGIS(pname, param);
}

static void REGAL_CALL trace_glPointParameterfvSGIS(GLenum pname, const GLfloat *params)
{
  Internal("trace_glPointParameterfvSGIS","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPointParameterfvSGIS(pname, params);
}

// GL_SGIS_sharpen_texture

static void REGAL_CALL trace_glGetSharpenTexFuncSGIS(GLenum target, GLfloat *points)
{
  Internal("trace_glGetSharpenTexFuncSGIS","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetSharpenTexFuncSGIS(target, points);
}

static void REGAL_CALL trace_glSharpenTexFuncSGIS(GLenum target, GLsizei n, const GLfloat *points)
{
  Internal("trace_glSharpenTexFuncSGIS","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSharpenTexFuncSGIS(target, n, points);
}

// GL_SGIS_texture4D

static void REGAL_CALL trace_glTexImage4DSGIS(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
  Internal("trace_glTexImage4DSGIS","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexImage4DSGIS(target, level, internalformat, width, height, depth, size4d, border, format, type, pixels);
}

static void REGAL_CALL trace_glTexSubImage4DSGIS(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLenum format, GLenum type, const GLvoid *pixels)
{
  Internal("trace_glTexSubImage4DSGIS","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexSubImage4DSGIS(target, level, xoffset, yoffset, zoffset, woffset, width, height, depth, size4d, format, type, pixels);
}

// GL_SGIS_texture_color_mask

static void REGAL_CALL trace_glTextureColorMaskSGIS(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
{
  Internal("trace_glTextureColorMaskSGIS","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTextureColorMaskSGIS(red, green, blue, alpha);
}

// GL_SGIS_texture_filter4

static void REGAL_CALL trace_glGetTexFilterFuncSGIS(GLenum target, GLenum filter, GLfloat *weights)
{
  Internal("trace_glGetTexFilterFuncSGIS","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetTexFilterFuncSGIS(target, filter, weights);
}

static void REGAL_CALL trace_glTexFilterFuncSGIS(GLenum target, GLenum filter, GLsizei n, const GLfloat *weights)
{
  Internal("trace_glTexFilterFuncSGIS","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexFilterFuncSGIS(target, filter, n, weights);
}

// GL_SGIX_async

static void REGAL_CALL trace_glAsyncMarkerSGIX(GLuint marker)
{
  Internal("trace_glAsyncMarkerSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glAsyncMarkerSGIX(marker);
}

static void REGAL_CALL trace_glDeleteAsyncMarkersSGIX(GLuint marker, GLsizei range)
{
  Internal("trace_glDeleteAsyncMarkersSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDeleteAsyncMarkersSGIX(marker, range);
}

static GLint REGAL_CALL trace_glFinishAsyncSGIX(GLuint *markerp)
{
  Internal("trace_glFinishAsyncSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLint  ret = Trace::glFinishAsyncSGIX(markerp);
  return ret;
}

static GLuint REGAL_CALL trace_glGenAsyncMarkersSGIX(GLsizei range)
{
  Internal("trace_glGenAsyncMarkersSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLuint  ret = Trace::glGenAsyncMarkersSGIX(range);
  return ret;
}

static GLboolean REGAL_CALL trace_glIsAsyncMarkerSGIX(GLuint marker)
{
  Internal("trace_glIsAsyncMarkerSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLboolean  ret = Trace::glIsAsyncMarkerSGIX(marker);
  return ret;
}

static GLint REGAL_CALL trace_glPollAsyncSGIX(GLuint *markerp)
{
  Internal("trace_glPollAsyncSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLint  ret = Trace::glPollAsyncSGIX(markerp);
  return ret;
}

// GL_SGIX_flush_raster

static void REGAL_CALL trace_glFlushRasterSGIX(void)
{
  Internal("trace_glFlushRasterSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFlushRasterSGIX();
}

// GL_SGIX_fragment_lighting

static void REGAL_CALL trace_glFragmentColorMaterialSGIX(GLenum face, GLenum mode)
{
  Internal("trace_glFragmentColorMaterialSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFragmentColorMaterialSGIX(face, mode);
}

static void REGAL_CALL trace_glFragmentLightModelfSGIX(GLenum pname, GLfloat param)
{
  Internal("trace_glFragmentLightModelfSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFragmentLightModelfSGIX(pname, param);
}

static void REGAL_CALL trace_glFragmentLightModelfvSGIX(GLenum pname, const GLfloat *params)
{
  Internal("trace_glFragmentLightModelfvSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFragmentLightModelfvSGIX(pname, params);
}

static void REGAL_CALL trace_glFragmentLightModeliSGIX(GLenum pname, GLint param)
{
  Internal("trace_glFragmentLightModeliSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFragmentLightModeliSGIX(pname, param);
}

static void REGAL_CALL trace_glFragmentLightModelivSGIX(GLenum pname, const GLint *params)
{
  Internal("trace_glFragmentLightModelivSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFragmentLightModelivSGIX(pname, params);
}

static void REGAL_CALL trace_glFragmentLightfSGIX(GLenum light, GLenum pname, GLfloat param)
{
  Internal("trace_glFragmentLightfSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFragmentLightfSGIX(light, pname, param);
}

static void REGAL_CALL trace_glFragmentLightfvSGIX(GLenum light, GLenum pname, const GLfloat *params)
{
  Internal("trace_glFragmentLightfvSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFragmentLightfvSGIX(light, pname, params);
}

static void REGAL_CALL trace_glFragmentLightiSGIX(GLenum light, GLenum pname, GLint param)
{
  Internal("trace_glFragmentLightiSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFragmentLightiSGIX(light, pname, param);
}

static void REGAL_CALL trace_glFragmentLightivSGIX(GLenum light, GLenum pname, const GLint *params)
{
  Internal("trace_glFragmentLightivSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFragmentLightivSGIX(light, pname, params);
}

static void REGAL_CALL trace_glFragmentMaterialfSGIX(GLenum face, GLenum pname, GLfloat param)
{
  Internal("trace_glFragmentMaterialfSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFragmentMaterialfSGIX(face, pname, param);
}

static void REGAL_CALL trace_glFragmentMaterialfvSGIX(GLenum face, GLenum pname, const GLfloat *params)
{
  Internal("trace_glFragmentMaterialfvSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFragmentMaterialfvSGIX(face, pname, params);
}

static void REGAL_CALL trace_glFragmentMaterialiSGIX(GLenum face, GLenum pname, GLint param)
{
  Internal("trace_glFragmentMaterialiSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFragmentMaterialiSGIX(face, pname, param);
}

static void REGAL_CALL trace_glFragmentMaterialivSGIX(GLenum face, GLenum pname, const GLint *params)
{
  Internal("trace_glFragmentMaterialivSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFragmentMaterialivSGIX(face, pname, params);
}

static void REGAL_CALL trace_glGetFragmentLightfvSGIX(GLenum light, GLenum pname, GLfloat *params)
{
  Internal("trace_glGetFragmentLightfvSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetFragmentLightfvSGIX(light, pname, params);
}

static void REGAL_CALL trace_glGetFragmentLightivSGIX(GLenum light, GLenum pname, GLint *params)
{
  Internal("trace_glGetFragmentLightivSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetFragmentLightivSGIX(light, pname, params);
}

static void REGAL_CALL trace_glGetFragmentMaterialfvSGIX(GLenum face, GLenum pname, GLfloat *params)
{
  Internal("trace_glGetFragmentMaterialfvSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetFragmentMaterialfvSGIX(face, pname, params);
}

static void REGAL_CALL trace_glGetFragmentMaterialivSGIX(GLenum face, GLenum pname, GLint *params)
{
  Internal("trace_glGetFragmentMaterialivSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetFragmentMaterialivSGIX(face, pname, params);
}

static void REGAL_CALL trace_glLightEnviSGIX(GLenum pname, GLint param)
{
  Internal("trace_glLightEnviSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glLightEnviSGIX(pname, param);
}

// GL_SGIX_framezoom

static void REGAL_CALL trace_glFrameZoomSGIX(GLint factor)
{
  Internal("trace_glFrameZoomSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFrameZoomSGIX(factor);
}

// GL_SGIX_igloo_interface

static void REGAL_CALL trace_glIglooInterfaceSGIX(GLenum pname, const GLvoid *params)
{
  Internal("trace_glIglooInterfaceSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glIglooInterfaceSGIX(pname, params);
}

// GL_SGIX_instruments

static GLint REGAL_CALL trace_glGetInstrumentsSGIX(void)
{
  Internal("trace_glGetInstrumentsSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLint  ret = Trace::glGetInstrumentsSGIX();
  return ret;
}

static void REGAL_CALL trace_glInstrumentsBufferSGIX(GLsizei size, GLint *buffer)
{
  Internal("trace_glInstrumentsBufferSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glInstrumentsBufferSGIX(size, buffer);
}

static GLint REGAL_CALL trace_glPollInstrumentsSGIX(GLint *marker_p)
{
  Internal("trace_glPollInstrumentsSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  GLint  ret = Trace::glPollInstrumentsSGIX(marker_p);
  return ret;
}

static void REGAL_CALL trace_glReadInstrumentsSGIX(GLint marker)
{
  Internal("trace_glReadInstrumentsSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glReadInstrumentsSGIX(marker);
}

static void REGAL_CALL trace_glStartInstrumentsSGIX(void)
{
  Internal("trace_glStartInstrumentsSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glStartInstrumentsSGIX();
}

static void REGAL_CALL trace_glStopInstrumentsSGIX(GLint marker)
{
  Internal("trace_glStopInstrumentsSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glStopInstrumentsSGIX(marker);
}

// GL_SGIX_list_priority

static void REGAL_CALL trace_glGetListParameterfvSGIX(GLuint list, GLenum pname, GLfloat *params)
{
  Internal("trace_glGetListParameterfvSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetListParameterfvSGIX(list, pname, params);
}

static void REGAL_CALL trace_glGetListParameterivSGIX(GLuint list, GLenum pname, GLint *params)
{
  Internal("trace_glGetListParameterivSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetListParameterivSGIX(list, pname, params);
}

static void REGAL_CALL trace_glListParameterfSGIX(GLuint list, GLenum pname, GLfloat param)
{
  Internal("trace_glListParameterfSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glListParameterfSGIX(list, pname, param);
}

static void REGAL_CALL trace_glListParameterfvSGIX(GLuint list, GLenum pname, const GLfloat *params)
{
  Internal("trace_glListParameterfvSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glListParameterfvSGIX(list, pname, params);
}

static void REGAL_CALL trace_glListParameteriSGIX(GLuint list, GLenum pname, GLint param)
{
  Internal("trace_glListParameteriSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glListParameteriSGIX(list, pname, param);
}

static void REGAL_CALL trace_glListParameterivSGIX(GLuint list, GLenum pname, const GLint *params)
{
  Internal("trace_glListParameterivSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glListParameterivSGIX(list, pname, params);
}

// GL_SGIX_pixel_texture

static void REGAL_CALL trace_glPixelTexGenSGIX(GLenum mode)
{
  Internal("trace_glPixelTexGenSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glPixelTexGenSGIX(mode);
}

// GL_SGIX_polynomial_ffd

static void REGAL_CALL trace_glDeformSGIX(GLbitfield mask)
{
  Internal("trace_glDeformSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDeformSGIX(mask);
}

static void REGAL_CALL trace_glDeformationMap3dSGIX(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, GLdouble w1, GLdouble w2, GLint wstride, GLint worder, const GLdouble *points)
{
  Internal("trace_glDeformationMap3dSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDeformationMap3dSGIX(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
}

static void REGAL_CALL trace_glDeformationMap3fSGIX(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, GLfloat w1, GLfloat w2, GLint wstride, GLint worder, const GLfloat *points)
{
  Internal("trace_glDeformationMap3fSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDeformationMap3fSGIX(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
}

static void REGAL_CALL trace_glLoadIdentityDeformationMapSGIX(GLbitfield mask)
{
  Internal("trace_glLoadIdentityDeformationMapSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glLoadIdentityDeformationMapSGIX(mask);
}

// GL_SGIX_reference_plane

static void REGAL_CALL trace_glReferencePlaneSGIX(const GLdouble *equation)
{
  Internal("trace_glReferencePlaneSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glReferencePlaneSGIX(equation);
}

// GL_SGIX_sprite

static void REGAL_CALL trace_glSpriteParameterfSGIX(GLenum pname, GLfloat param)
{
  Internal("trace_glSpriteParameterfSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSpriteParameterfSGIX(pname, param);
}

static void REGAL_CALL trace_glSpriteParameterfvSGIX(GLenum pname, const GLfloat *params)
{
  Internal("trace_glSpriteParameterfvSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSpriteParameterfvSGIX(pname, params);
}

static void REGAL_CALL trace_glSpriteParameteriSGIX(GLenum pname, GLint param)
{
  Internal("trace_glSpriteParameteriSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSpriteParameteriSGIX(pname, param);
}

static void REGAL_CALL trace_glSpriteParameterivSGIX(GLenum pname, const GLint *params)
{
  Internal("trace_glSpriteParameterivSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glSpriteParameterivSGIX(pname, params);
}

// GL_SGIX_tag_sample_buffer

static void REGAL_CALL trace_glTagSampleBufferSGIX(void)
{
  Internal("trace_glTagSampleBufferSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTagSampleBufferSGIX();
}

// GL_SGI_color_table

static void REGAL_CALL trace_glColorTableParameterfvSGI(GLenum target, GLenum pname, const GLfloat *params)
{
  Internal("trace_glColorTableParameterfvSGI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColorTableParameterfvSGI(target, pname, params);
}

static void REGAL_CALL trace_glColorTableParameterivSGI(GLenum target, GLenum pname, const GLint *params)
{
  Internal("trace_glColorTableParameterivSGI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColorTableParameterivSGI(target, pname, params);
}

static void REGAL_CALL trace_glColorTableSGI(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table)
{
  Internal("trace_glColorTableSGI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColorTableSGI(target, internalformat, width, format, type, table);
}

static void REGAL_CALL trace_glCopyColorTableSGI(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
{
  Internal("trace_glCopyColorTableSGI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glCopyColorTableSGI(target, internalformat, x, y, width);
}

static void REGAL_CALL trace_glGetColorTableParameterfvSGI(GLenum target, GLenum pname, GLfloat *params)
{
  Internal("trace_glGetColorTableParameterfvSGI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetColorTableParameterfvSGI(target, pname, params);
}

static void REGAL_CALL trace_glGetColorTableParameterivSGI(GLenum target, GLenum pname, GLint *params)
{
  Internal("trace_glGetColorTableParameterivSGI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetColorTableParameterivSGI(target, pname, params);
}

static void REGAL_CALL trace_glGetColorTableSGI(GLenum target, GLenum format, GLenum type, GLvoid *table)
{
  Internal("trace_glGetColorTableSGI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGetColorTableSGI(target, format, type, table);
}

// GL_SUNX_constant_data

static void REGAL_CALL trace_glFinishTextureSUNX(void)
{
  Internal("trace_glFinishTextureSUNX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glFinishTextureSUNX();
}

// GL_SUN_global_alpha

static void REGAL_CALL trace_glGlobalAlphaFactorbSUN(GLbyte factor)
{
  Internal("trace_glGlobalAlphaFactorbSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGlobalAlphaFactorbSUN(factor);
}

static void REGAL_CALL trace_glGlobalAlphaFactordSUN(GLdouble factor)
{
  Internal("trace_glGlobalAlphaFactordSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGlobalAlphaFactordSUN(factor);
}

static void REGAL_CALL trace_glGlobalAlphaFactorfSUN(GLfloat factor)
{
  Internal("trace_glGlobalAlphaFactorfSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGlobalAlphaFactorfSUN(factor);
}

static void REGAL_CALL trace_glGlobalAlphaFactoriSUN(GLint factor)
{
  Internal("trace_glGlobalAlphaFactoriSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGlobalAlphaFactoriSUN(factor);
}

static void REGAL_CALL trace_glGlobalAlphaFactorsSUN(GLshort factor)
{
  Internal("trace_glGlobalAlphaFactorsSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGlobalAlphaFactorsSUN(factor);
}

static void REGAL_CALL trace_glGlobalAlphaFactorubSUN(GLubyte factor)
{
  Internal("trace_glGlobalAlphaFactorubSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGlobalAlphaFactorubSUN(factor);
}

static void REGAL_CALL trace_glGlobalAlphaFactoruiSUN(GLuint factor)
{
  Internal("trace_glGlobalAlphaFactoruiSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGlobalAlphaFactoruiSUN(factor);
}

static void REGAL_CALL trace_glGlobalAlphaFactorusSUN(GLushort factor)
{
  Internal("trace_glGlobalAlphaFactorusSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glGlobalAlphaFactorusSUN(factor);
}

// GL_SUN_mesh_array

static void REGAL_CALL trace_glDrawMeshArraysSUN(GLenum mode, GLint first, GLsizei count, GLsizei width)
{
  Internal("trace_glDrawMeshArraysSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glDrawMeshArraysSUN(mode, first, count, width);
}

// GL_SUN_triangle_list

static void REGAL_CALL trace_glReplacementCodePointerSUN(GLenum type, GLsizei stride, const GLvoid **pointer)
{
  Internal("trace_glReplacementCodePointerSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glReplacementCodePointerSUN(type, stride, pointer);
}

static void REGAL_CALL trace_glReplacementCodeubSUN(GLubyte code)
{
  Internal("trace_glReplacementCodeubSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glReplacementCodeubSUN(code);
}

static void REGAL_CALL trace_glReplacementCodeubvSUN(const GLubyte *code)
{
  Internal("trace_glReplacementCodeubvSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glReplacementCodeubvSUN(code);
}

static void REGAL_CALL trace_glReplacementCodeuiSUN(GLuint code)
{
  Internal("trace_glReplacementCodeuiSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glReplacementCodeuiSUN(code);
}

static void REGAL_CALL trace_glReplacementCodeuivSUN(const GLuint *code)
{
  Internal("trace_glReplacementCodeuivSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glReplacementCodeuivSUN(code);
}

static void REGAL_CALL trace_glReplacementCodeusSUN(GLushort code)
{
  Internal("trace_glReplacementCodeusSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glReplacementCodeusSUN(code);
}

static void REGAL_CALL trace_glReplacementCodeusvSUN(const GLushort *code)
{
  Internal("trace_glReplacementCodeusvSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glReplacementCodeusvSUN(code);
}

// GL_SUN_vertex

static void REGAL_CALL trace_glColor3fVertex3fSUN(GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z)
{
  Internal("trace_glColor3fVertex3fSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColor3fVertex3fSUN(r, g, b, x, y, z);
}

static void REGAL_CALL trace_glColor3fVertex3fvSUN(const GLfloat *c, const GLfloat *v)
{
  Internal("trace_glColor3fVertex3fvSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColor3fVertex3fvSUN(c, v);
}

static void REGAL_CALL trace_glColor4fNormal3fVertex3fSUN(GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
  Internal("trace_glColor4fNormal3fVertex3fSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColor4fNormal3fVertex3fSUN(r, g, b, a, nx, ny, nz, x, y, z);
}

static void REGAL_CALL trace_glColor4fNormal3fVertex3fvSUN(const GLfloat *c, const GLfloat *n, const GLfloat *v)
{
  Internal("trace_glColor4fNormal3fVertex3fvSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColor4fNormal3fVertex3fvSUN(c, n, v);
}

static void REGAL_CALL trace_glColor4ubVertex2fSUN(GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y)
{
  Internal("trace_glColor4ubVertex2fSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColor4ubVertex2fSUN(r, g, b, a, x, y);
}

static void REGAL_CALL trace_glColor4ubVertex2fvSUN(const GLubyte *c, const GLfloat *v)
{
  Internal("trace_glColor4ubVertex2fvSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColor4ubVertex2fvSUN(c, v);
}

static void REGAL_CALL trace_glColor4ubVertex3fSUN(GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z)
{
  Internal("trace_glColor4ubVertex3fSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColor4ubVertex3fSUN(r, g, b, a, x, y, z);
}

static void REGAL_CALL trace_glColor4ubVertex3fvSUN(const GLubyte *c, const GLfloat *v)
{
  Internal("trace_glColor4ubVertex3fvSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glColor4ubVertex3fvSUN(c, v);
}

static void REGAL_CALL trace_glNormal3fVertex3fSUN(GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
  Internal("trace_glNormal3fVertex3fSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNormal3fVertex3fSUN(nx, ny, nz, x, y, z);
}

static void REGAL_CALL trace_glNormal3fVertex3fvSUN(const GLfloat *n, const GLfloat *v)
{
  Internal("trace_glNormal3fVertex3fvSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glNormal3fVertex3fvSUN(n, v);
}

static void REGAL_CALL trace_glReplacementCodeuiColor3fVertex3fSUN(GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z)
{
  Internal("trace_glReplacementCodeuiColor3fVertex3fSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glReplacementCodeuiColor3fVertex3fSUN(rc, r, g, b, x, y, z);
}

static void REGAL_CALL trace_glReplacementCodeuiColor3fVertex3fvSUN(const GLuint *rc, const GLfloat *c, const GLfloat *v)
{
  Internal("trace_glReplacementCodeuiColor3fVertex3fvSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glReplacementCodeuiColor3fVertex3fvSUN(rc, c, v);
}

static void REGAL_CALL trace_glReplacementCodeuiColor4fNormal3fVertex3fSUN(GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
  Internal("trace_glReplacementCodeuiColor4fNormal3fVertex3fSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glReplacementCodeuiColor4fNormal3fVertex3fSUN(rc, r, g, b, a, nx, ny, nz, x, y, z);
}

static void REGAL_CALL trace_glReplacementCodeuiColor4fNormal3fVertex3fvSUN(const GLuint *rc, const GLfloat *c, const GLfloat *n, const GLfloat *v)
{
  Internal("trace_glReplacementCodeuiColor4fNormal3fVertex3fvSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc, c, n, v);
}

static void REGAL_CALL trace_glReplacementCodeuiColor4ubVertex3fSUN(GLuint rc, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z)
{
  Internal("trace_glReplacementCodeuiColor4ubVertex3fSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glReplacementCodeuiColor4ubVertex3fSUN(rc, r, g, b, a, x, y, z);
}

static void REGAL_CALL trace_glReplacementCodeuiColor4ubVertex3fvSUN(const GLuint *rc, const GLubyte *c, const GLfloat *v)
{
  Internal("trace_glReplacementCodeuiColor4ubVertex3fvSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glReplacementCodeuiColor4ubVertex3fvSUN(rc, c, v);
}

static void REGAL_CALL trace_glReplacementCodeuiNormal3fVertex3fSUN(GLuint rc, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
  Internal("trace_glReplacementCodeuiNormal3fVertex3fSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glReplacementCodeuiNormal3fVertex3fSUN(rc, nx, ny, nz, x, y, z);
}

static void REGAL_CALL trace_glReplacementCodeuiNormal3fVertex3fvSUN(const GLuint *rc, const GLfloat *n, const GLfloat *v)
{
  Internal("trace_glReplacementCodeuiNormal3fVertex3fvSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glReplacementCodeuiNormal3fVertex3fvSUN(rc, n, v);
}

static void REGAL_CALL trace_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(GLuint rc, GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
  Internal("trace_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(rc, s, t, r, g, b, a, nx, ny, nz, x, y, z);
}

static void REGAL_CALL trace_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(const GLuint *rc, const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v)
{
  Internal("trace_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc, c, n, v);
}

static void REGAL_CALL trace_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(GLuint rc, GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
  Internal("trace_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(rc, s, t, nx, ny, nz, x, y, z);
}

static void REGAL_CALL trace_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(const GLuint *rc, const GLfloat *tc, const GLfloat *n, const GLfloat *v)
{
  Internal("trace_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc, tc, n, v);
}

static void REGAL_CALL trace_glReplacementCodeuiTexCoord2fVertex3fSUN(GLuint rc, GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z)
{
  Internal("trace_glReplacementCodeuiTexCoord2fVertex3fSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glReplacementCodeuiTexCoord2fVertex3fSUN(rc, s, t, x, y, z);
}

static void REGAL_CALL trace_glReplacementCodeuiTexCoord2fVertex3fvSUN(const GLuint *rc, const GLfloat *tc, const GLfloat *v)
{
  Internal("trace_glReplacementCodeuiTexCoord2fVertex3fvSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glReplacementCodeuiTexCoord2fVertex3fvSUN(rc, tc, v);
}

static void REGAL_CALL trace_glReplacementCodeuiVertex3fSUN(GLuint rc, GLfloat x, GLfloat y, GLfloat z)
{
  Internal("trace_glReplacementCodeuiVertex3fSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glReplacementCodeuiVertex3fSUN(rc, x, y, z);
}

static void REGAL_CALL trace_glReplacementCodeuiVertex3fvSUN(const GLuint *rc, const GLfloat *v)
{
  Internal("trace_glReplacementCodeuiVertex3fvSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glReplacementCodeuiVertex3fvSUN(rc, v);
}

static void REGAL_CALL trace_glTexCoord2fColor3fVertex3fSUN(GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z)
{
  Internal("trace_glTexCoord2fColor3fVertex3fSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord2fColor3fVertex3fSUN(s, t, r, g, b, x, y, z);
}

static void REGAL_CALL trace_glTexCoord2fColor3fVertex3fvSUN(const GLfloat *tc, const GLfloat *c, const GLfloat *v)
{
  Internal("trace_glTexCoord2fColor3fVertex3fvSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord2fColor3fVertex3fvSUN(tc, c, v);
}

static void REGAL_CALL trace_glTexCoord2fColor4fNormal3fVertex3fSUN(GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
  Internal("trace_glTexCoord2fColor4fNormal3fVertex3fSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord2fColor4fNormal3fVertex3fSUN(s, t, r, g, b, a, nx, ny, nz, x, y, z);
}

static void REGAL_CALL trace_glTexCoord2fColor4fNormal3fVertex3fvSUN(const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v)
{
  Internal("trace_glTexCoord2fColor4fNormal3fVertex3fvSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord2fColor4fNormal3fVertex3fvSUN(tc, c, n, v);
}

static void REGAL_CALL trace_glTexCoord2fColor4ubVertex3fSUN(GLfloat s, GLfloat t, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z)
{
  Internal("trace_glTexCoord2fColor4ubVertex3fSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord2fColor4ubVertex3fSUN(s, t, r, g, b, a, x, y, z);
}

static void REGAL_CALL trace_glTexCoord2fColor4ubVertex3fvSUN(const GLfloat *tc, const GLubyte *c, const GLfloat *v)
{
  Internal("trace_glTexCoord2fColor4ubVertex3fvSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord2fColor4ubVertex3fvSUN(tc, c, v);
}

static void REGAL_CALL trace_glTexCoord2fNormal3fVertex3fSUN(GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
  Internal("trace_glTexCoord2fNormal3fVertex3fSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord2fNormal3fVertex3fSUN(s, t, nx, ny, nz, x, y, z);
}

static void REGAL_CALL trace_glTexCoord2fNormal3fVertex3fvSUN(const GLfloat *tc, const GLfloat *n, const GLfloat *v)
{
  Internal("trace_glTexCoord2fNormal3fVertex3fvSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord2fNormal3fVertex3fvSUN(tc, n, v);
}

static void REGAL_CALL trace_glTexCoord2fVertex3fSUN(GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z)
{
  Internal("trace_glTexCoord2fVertex3fSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord2fVertex3fSUN(s, t, x, y, z);
}

static void REGAL_CALL trace_glTexCoord2fVertex3fvSUN(const GLfloat *tc, const GLfloat *v)
{
  Internal("trace_glTexCoord2fVertex3fvSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord2fVertex3fvSUN(tc, v);
}

static void REGAL_CALL trace_glTexCoord4fColor4fNormal3fVertex4fSUN(GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  Internal("trace_glTexCoord4fColor4fNormal3fVertex4fSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord4fColor4fNormal3fVertex4fSUN(s, t, p, q, r, g, b, a, nx, ny, nz, x, y, z, w);
}

static void REGAL_CALL trace_glTexCoord4fColor4fNormal3fVertex4fvSUN(const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v)
{
  Internal("trace_glTexCoord4fColor4fNormal3fVertex4fvSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord4fColor4fNormal3fVertex4fvSUN(tc, c, n, v);
}

static void REGAL_CALL trace_glTexCoord4fVertex4fSUN(GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  Internal("trace_glTexCoord4fVertex4fSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord4fVertex4fSUN(s, t, p, q, x, y, z, w);
}

static void REGAL_CALL trace_glTexCoord4fVertex4fvSUN(const GLfloat *tc, const GLfloat *v)
{
  Internal("trace_glTexCoord4fVertex4fvSUN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glTexCoord4fVertex4fvSUN(tc, v);
}

// GL_WIN_swap_hint

static void REGAL_CALL trace_glAddSwapHintRectWIN(GLint x, GLint y, GLsizei width, GLsizei height)
{
  Internal("trace_glAddSwapHintRectWIN","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  RegalAssert(_instance.currentContext);
  Push<DispatchTableGL *> _push(_instance.nextDispatchTable);
  _instance.nextDispatchTable = _instance.currentContext->dispatcher.trace.next();
  Trace::glAddSwapHintRectWIN(x, y, width, height);
}

#if REGAL_SYS_WGL

// WGL_3DL_stereo_control

static BOOL REGAL_CALL trace_wglSetStereoEmitterState3DL(HDC hDC, UINT uState)
{
  Internal("trace_wglSetStereoEmitterState3DL","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglSetStereoEmitterState3DL(hDC, uState);
  return ret;
}

// WGL_AMD_gpu_association

static VOID REGAL_CALL trace_wglBlitContextFramebufferAMD(HGLRC dstCtx, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
{
  Internal("trace_wglBlitContextFramebufferAMD","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Trace::wglBlitContextFramebufferAMD(dstCtx, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
}

static HGLRC REGAL_CALL trace_wglCreateAssociatedContextAMD(UINT id)
{
  Internal("trace_wglCreateAssociatedContextAMD","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  HGLRC  ret = Trace::wglCreateAssociatedContextAMD(id);
  return ret;
}

static HGLRC REGAL_CALL trace_wglCreateAssociatedContextAttribsAMD(UINT id, HGLRC hShareContext, const int *attribList)
{
  Internal("trace_wglCreateAssociatedContextAttribsAMD","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  HGLRC  ret = Trace::wglCreateAssociatedContextAttribsAMD(id, hShareContext, attribList);
  return ret;
}

static BOOL REGAL_CALL trace_wglDeleteAssociatedContextAMD(HGLRC hglrc)
{
  Internal("trace_wglDeleteAssociatedContextAMD","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglDeleteAssociatedContextAMD(hglrc);
  return ret;
}

static UINT REGAL_CALL trace_wglGetContextGPUIDAMD(HGLRC hglrc)
{
  Internal("trace_wglGetContextGPUIDAMD","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  UINT  ret = Trace::wglGetContextGPUIDAMD(hglrc);
  return ret;
}

static HGLRC REGAL_CALL trace_wglGetCurrentAssociatedContextAMD(void)
{
  Internal("trace_wglGetCurrentAssociatedContextAMD","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  HGLRC  ret = Trace::wglGetCurrentAssociatedContextAMD();
  return ret;
}

static UINT REGAL_CALL trace_wglGetGPUIDsAMD(UINT maxCount, UINT *ids)
{
  Internal("trace_wglGetGPUIDsAMD","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  UINT  ret = Trace::wglGetGPUIDsAMD(maxCount, ids);
  return ret;
}

static INT REGAL_CALL trace_wglGetGPUInfoAMD(UINT id, int property, GLenum dataType, UINT size, void *data)
{
  Internal("trace_wglGetGPUInfoAMD","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  INT  ret = Trace::wglGetGPUInfoAMD(id, property, dataType, size, data);
  return ret;
}

static BOOL REGAL_CALL trace_wglMakeAssociatedContextCurrentAMD(HGLRC hglrc)
{
  Internal("trace_wglMakeAssociatedContextCurrentAMD","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglMakeAssociatedContextCurrentAMD(hglrc);
  return ret;
}

// WGL_ARB_buffer_region

static HANDLE REGAL_CALL trace_wglCreateBufferRegionARB(HDC hDC, int iLayerPlane, UINT uType)
{
  Internal("trace_wglCreateBufferRegionARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  HANDLE  ret = Trace::wglCreateBufferRegionARB(hDC, iLayerPlane, uType);
  return ret;
}

static VOID REGAL_CALL trace_wglDeleteBufferRegionARB(HANDLE hRegion)
{
  Internal("trace_wglDeleteBufferRegionARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Trace::wglDeleteBufferRegionARB(hRegion);
}

static BOOL REGAL_CALL trace_wglRestoreBufferRegionARB(HANDLE hRegion, int x, int y, int width, int height, int xSrc, int ySrc)
{
  Internal("trace_wglRestoreBufferRegionARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglRestoreBufferRegionARB(hRegion, x, y, width, height, xSrc, ySrc);
  return ret;
}

static BOOL REGAL_CALL trace_wglSaveBufferRegionARB(HANDLE hRegion, int x, int y, int width, int height)
{
  Internal("trace_wglSaveBufferRegionARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglSaveBufferRegionARB(hRegion, x, y, width, height);
  return ret;
}

// WGL_ARB_create_context

static HGLRC REGAL_CALL trace_wglCreateContextAttribsARB(HDC hDC, HGLRC hShareContext, const int *piAttribList)
{
  Internal("trace_wglCreateContextAttribsARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  HGLRC  ret = Trace::wglCreateContextAttribsARB(hDC, hShareContext, piAttribList);
  return ret;
}

// WGL_ARB_extensions_string

static const char *REGAL_CALL trace_wglGetExtensionsStringARB(HDC hDC)
{
  Internal("trace_wglGetExtensionsStringARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  const char * ret = Trace::wglGetExtensionsStringARB(hDC);
  return ret;
}

// WGL_ARB_make_current_read

static HDC REGAL_CALL trace_wglGetCurrentReadDCARB(void)
{
  Internal("trace_wglGetCurrentReadDCARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  HDC  ret = Trace::wglGetCurrentReadDCARB();
  return ret;
}

static BOOL REGAL_CALL trace_wglMakeContextCurrentARB(HDC hDrawDC, HDC hReadDC, HGLRC hglrc)
{
  Internal("trace_wglMakeContextCurrentARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglMakeContextCurrentARB(hDrawDC, hReadDC, hglrc);
  return ret;
}

// WGL_ARB_pbuffer

static HPBUFFERARB REGAL_CALL trace_wglCreatePbufferARB(HDC hDC, int iPixelFormat, int iWidth, int iHeight, const int *piAttribList)
{
  Internal("trace_wglCreatePbufferARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  HPBUFFERARB  ret = Trace::wglCreatePbufferARB(hDC, iPixelFormat, iWidth, iHeight, piAttribList);
  return ret;
}

static BOOL REGAL_CALL trace_wglDestroyPbufferARB(HPBUFFERARB hPbuffer)
{
  Internal("trace_wglDestroyPbufferARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglDestroyPbufferARB(hPbuffer);
  return ret;
}

static HDC REGAL_CALL trace_wglGetPbufferDCARB(HPBUFFERARB hPbuffer)
{
  Internal("trace_wglGetPbufferDCARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  HDC  ret = Trace::wglGetPbufferDCARB(hPbuffer);
  return ret;
}

static BOOL REGAL_CALL trace_wglQueryPbufferARB(HPBUFFERARB hPbuffer, int iAttribute, int *piValue)
{
  Internal("trace_wglQueryPbufferARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglQueryPbufferARB(hPbuffer, iAttribute, piValue);
  return ret;
}

static int REGAL_CALL trace_wglReleasePbufferDCARB(HPBUFFERARB hPbuffer, HDC hDC)
{
  Internal("trace_wglReleasePbufferDCARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  int  ret = Trace::wglReleasePbufferDCARB(hPbuffer, hDC);
  return ret;
}

// WGL_ARB_render_texture

static BOOL REGAL_CALL trace_wglBindTexImageARB(HPBUFFERARB hPbuffer, int iBuffer)
{
  Internal("trace_wglBindTexImageARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglBindTexImageARB(hPbuffer, iBuffer);
  return ret;
}

static BOOL REGAL_CALL trace_wglReleaseTexImageARB(HPBUFFERARB hPbuffer, int iBuffer)
{
  Internal("trace_wglReleaseTexImageARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglReleaseTexImageARB(hPbuffer, iBuffer);
  return ret;
}

static BOOL REGAL_CALL trace_wglSetPbufferAttribARB(HPBUFFERARB hPbuffer, const int *piAttribList)
{
  Internal("trace_wglSetPbufferAttribARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglSetPbufferAttribARB(hPbuffer, piAttribList);
  return ret;
}

// WGL_EXT_display_color_table

static GLboolean REGAL_CALL trace_wglBindDisplayColorTableEXT(GLushort id)
{
  Internal("trace_wglBindDisplayColorTableEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  GLboolean  ret = Trace::wglBindDisplayColorTableEXT(id);
  return ret;
}

static GLboolean REGAL_CALL trace_wglCreateDisplayColorTableEXT(GLushort id)
{
  Internal("trace_wglCreateDisplayColorTableEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  GLboolean  ret = Trace::wglCreateDisplayColorTableEXT(id);
  return ret;
}

static VOID REGAL_CALL trace_wglDestroyDisplayColorTableEXT(GLushort id)
{
  Internal("trace_wglDestroyDisplayColorTableEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Trace::wglDestroyDisplayColorTableEXT(id);
}

static GLboolean REGAL_CALL trace_wglLoadDisplayColorTableEXT(const GLushort *table, GLuint length)
{
  Internal("trace_wglLoadDisplayColorTableEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  GLboolean  ret = Trace::wglLoadDisplayColorTableEXT(table, length);
  return ret;
}

// WGL_EXT_extensions_string

static const char *REGAL_CALL trace_wglGetExtensionsStringEXT(void)
{
  Internal("trace_wglGetExtensionsStringEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  const char * ret = Trace::wglGetExtensionsStringEXT();
  return ret;
}

// WGL_EXT_make_current_read

static HDC REGAL_CALL trace_wglGetCurrentReadDCEXT(void)
{
  Internal("trace_wglGetCurrentReadDCEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  HDC  ret = Trace::wglGetCurrentReadDCEXT();
  return ret;
}

static BOOL REGAL_CALL trace_wglMakeContextCurrentEXT(HDC hDrawDC, HDC hReadDC, HGLRC hglrc)
{
  Internal("trace_wglMakeContextCurrentEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglMakeContextCurrentEXT(hDrawDC, hReadDC, hglrc);
  return ret;
}

// WGL_EXT_pbuffer

static HPBUFFEREXT REGAL_CALL trace_wglCreatePbufferEXT(HDC hDC, int iPixelFormat, int iWidth, int iHeight, const int *piAttribList)
{
  Internal("trace_wglCreatePbufferEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  HPBUFFEREXT  ret = Trace::wglCreatePbufferEXT(hDC, iPixelFormat, iWidth, iHeight, piAttribList);
  return ret;
}

static BOOL REGAL_CALL trace_wglDestroyPbufferEXT(HPBUFFEREXT hPbuffer)
{
  Internal("trace_wglDestroyPbufferEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglDestroyPbufferEXT(hPbuffer);
  return ret;
}

static HDC REGAL_CALL trace_wglGetPbufferDCEXT(HPBUFFEREXT hPbuffer)
{
  Internal("trace_wglGetPbufferDCEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  HDC  ret = Trace::wglGetPbufferDCEXT(hPbuffer);
  return ret;
}

static BOOL REGAL_CALL trace_wglQueryPbufferEXT(HPBUFFEREXT hPbuffer, int iAttribute, int *piValue)
{
  Internal("trace_wglQueryPbufferEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglQueryPbufferEXT(hPbuffer, iAttribute, piValue);
  return ret;
}

static int REGAL_CALL trace_wglReleasePbufferDCEXT(HPBUFFEREXT hPbuffer, HDC hDC)
{
  Internal("trace_wglReleasePbufferDCEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  int  ret = Trace::wglReleasePbufferDCEXT(hPbuffer, hDC);
  return ret;
}

// WGL_EXT_pixel_format

static BOOL REGAL_CALL trace_wglChoosePixelFormatEXT(HDC hDC, const int *piAttribIList, const FLOAT *pfAttribFList, UINT nMaxFormats, int *piFormats, UINT *nNumFormats)
{
  Internal("trace_wglChoosePixelFormatEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglChoosePixelFormatEXT(hDC, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
  return ret;
}

// WGL_EXT_swap_control

static int REGAL_CALL trace_wglGetSwapIntervalEXT(void)
{
  Internal("trace_wglGetSwapIntervalEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  int  ret = Trace::wglGetSwapIntervalEXT();
  return ret;
}

static BOOL REGAL_CALL trace_wglSwapIntervalEXT(int interval)
{
  Internal("trace_wglSwapIntervalEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglSwapIntervalEXT(interval);
  return ret;
}

// WGL_GDI

static int REGAL_CALL trace_wglChoosePixelFormat(HDC hDC, const PIXELFORMATDESCRIPTOR *ppfd)
{
  Internal("trace_wglChoosePixelFormat","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  int  ret = Trace::wglChoosePixelFormat(hDC, ppfd);
  return ret;
}

static int REGAL_CALL trace_wglDescribePixelFormat(HDC hDC, int iPixelFormat, UINT nBytes, LPPIXELFORMATDESCRIPTOR ppfd)
{
  Internal("trace_wglDescribePixelFormat","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  int  ret = Trace::wglDescribePixelFormat(hDC, iPixelFormat, nBytes, ppfd);
  return ret;
}

static int REGAL_CALL trace_wglGetPixelFormat(HDC hDC)
{
  Internal("trace_wglGetPixelFormat","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  int  ret = Trace::wglGetPixelFormat(hDC);
  return ret;
}

static BOOL REGAL_CALL trace_wglSetPixelFormat(HDC hDC, int iPixelFormat, const PIXELFORMATDESCRIPTOR *ppfd)
{
  Internal("trace_wglSetPixelFormat","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglSetPixelFormat(hDC, iPixelFormat, ppfd);
  return ret;
}

static BOOL REGAL_CALL trace_wglSwapBuffers(HDC hDC)
{
  Internal("trace_wglSwapBuffers","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglSwapBuffers(hDC);
  return ret;
}

// WGL_I3D_digital_video_control

static BOOL REGAL_CALL trace_wglGetDigitalVideoParametersI3D(HDC hDC, int iAttribute, int *piValue)
{
  Internal("trace_wglGetDigitalVideoParametersI3D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglGetDigitalVideoParametersI3D(hDC, iAttribute, piValue);
  return ret;
}

static BOOL REGAL_CALL trace_wglSetDigitalVideoParametersI3D(HDC hDC, int iAttribute, const int *piValue)
{
  Internal("trace_wglSetDigitalVideoParametersI3D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglSetDigitalVideoParametersI3D(hDC, iAttribute, piValue);
  return ret;
}

// WGL_I3D_gamma

static BOOL REGAL_CALL trace_wglGetGammaTableI3D(HDC hDC, int iEntries, USHORT *puRed, USHORT *puGreen, USHORT *puBlue)
{
  Internal("trace_wglGetGammaTableI3D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglGetGammaTableI3D(hDC, iEntries, puRed, puGreen, puBlue);
  return ret;
}

static BOOL REGAL_CALL trace_wglGetGammaTableParametersI3D(HDC hDC, int iAttribute, int *piValue)
{
  Internal("trace_wglGetGammaTableParametersI3D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglGetGammaTableParametersI3D(hDC, iAttribute, piValue);
  return ret;
}

static BOOL REGAL_CALL trace_wglSetGammaTableI3D(HDC hDC, int iEntries, const USHORT *puRed, const USHORT *puGreen, const USHORT *puBlue)
{
  Internal("trace_wglSetGammaTableI3D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglSetGammaTableI3D(hDC, iEntries, puRed, puGreen, puBlue);
  return ret;
}

static BOOL REGAL_CALL trace_wglSetGammaTableParametersI3D(HDC hDC, int iAttribute, const int *piValue)
{
  Internal("trace_wglSetGammaTableParametersI3D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglSetGammaTableParametersI3D(hDC, iAttribute, piValue);
  return ret;
}

// WGL_I3D_genlock

static BOOL REGAL_CALL trace_wglDisableGenlockI3D(HDC hDC)
{
  Internal("trace_wglDisableGenlockI3D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglDisableGenlockI3D(hDC);
  return ret;
}

static BOOL REGAL_CALL trace_wglEnableGenlockI3D(HDC hDC)
{
  Internal("trace_wglEnableGenlockI3D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglEnableGenlockI3D(hDC);
  return ret;
}

static BOOL REGAL_CALL trace_wglGenlockSampleRateI3D(HDC hDC, UINT uRate)
{
  Internal("trace_wglGenlockSampleRateI3D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglGenlockSampleRateI3D(hDC, uRate);
  return ret;
}

static BOOL REGAL_CALL trace_wglGenlockSourceDelayI3D(HDC hDC, UINT uDelay)
{
  Internal("trace_wglGenlockSourceDelayI3D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglGenlockSourceDelayI3D(hDC, uDelay);
  return ret;
}

static BOOL REGAL_CALL trace_wglGenlockSourceEdgeI3D(HDC hDC, UINT uEdge)
{
  Internal("trace_wglGenlockSourceEdgeI3D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglGenlockSourceEdgeI3D(hDC, uEdge);
  return ret;
}

static BOOL REGAL_CALL trace_wglGenlockSourceI3D(HDC hDC, UINT uSource)
{
  Internal("trace_wglGenlockSourceI3D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglGenlockSourceI3D(hDC, uSource);
  return ret;
}

static BOOL REGAL_CALL trace_wglGetGenlockSampleRateI3D(HDC hDC, UINT *uRate)
{
  Internal("trace_wglGetGenlockSampleRateI3D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglGetGenlockSampleRateI3D(hDC, uRate);
  return ret;
}

static BOOL REGAL_CALL trace_wglGetGenlockSourceDelayI3D(HDC hDC, UINT *uDelay)
{
  Internal("trace_wglGetGenlockSourceDelayI3D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglGetGenlockSourceDelayI3D(hDC, uDelay);
  return ret;
}

static BOOL REGAL_CALL trace_wglGetGenlockSourceEdgeI3D(HDC hDC, UINT *uEdge)
{
  Internal("trace_wglGetGenlockSourceEdgeI3D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglGetGenlockSourceEdgeI3D(hDC, uEdge);
  return ret;
}

static BOOL REGAL_CALL trace_wglGetGenlockSourceI3D(HDC hDC, UINT *uSource)
{
  Internal("trace_wglGetGenlockSourceI3D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglGetGenlockSourceI3D(hDC, uSource);
  return ret;
}

static BOOL REGAL_CALL trace_wglIsEnabledGenlockI3D(HDC hDC, BOOL *pFlag)
{
  Internal("trace_wglIsEnabledGenlockI3D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglIsEnabledGenlockI3D(hDC, pFlag);
  return ret;
}

static BOOL REGAL_CALL trace_wglQueryGenlockMaxSourceDelayI3D(HDC hDC, UINT *uMaxLineDelay, UINT *uMaxPixelDelay)
{
  Internal("trace_wglQueryGenlockMaxSourceDelayI3D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglQueryGenlockMaxSourceDelayI3D(hDC, uMaxLineDelay, uMaxPixelDelay);
  return ret;
}

// WGL_I3D_image_buffer

static BOOL REGAL_CALL trace_wglAssociateImageBufferEventsI3D(HDC hDC, const HANDLE *pEvent, const LPVOID *pAddress, const DWORD *pSize, UINT count)
{
  Internal("trace_wglAssociateImageBufferEventsI3D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglAssociateImageBufferEventsI3D(hDC, pEvent, pAddress, pSize, count);
  return ret;
}

static LPVOID REGAL_CALL trace_wglCreateImageBufferI3D(HDC hDC, DWORD dwSize, UINT uFlags)
{
  Internal("trace_wglCreateImageBufferI3D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  LPVOID  ret = Trace::wglCreateImageBufferI3D(hDC, dwSize, uFlags);
  return ret;
}

static BOOL REGAL_CALL trace_wglDestroyImageBufferI3D(HDC hDC, LPVOID pAddress)
{
  Internal("trace_wglDestroyImageBufferI3D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglDestroyImageBufferI3D(hDC, pAddress);
  return ret;
}

static BOOL REGAL_CALL trace_wglReleaseImageBufferEventsI3D(HDC hDC, const LPVOID *pAddress, UINT count)
{
  Internal("trace_wglReleaseImageBufferEventsI3D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglReleaseImageBufferEventsI3D(hDC, pAddress, count);
  return ret;
}

// WGL_I3D_swap_frame_lock

static BOOL REGAL_CALL trace_wglDisableFrameLockI3D(void)
{
  Internal("trace_wglDisableFrameLockI3D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglDisableFrameLockI3D();
  return ret;
}

static BOOL REGAL_CALL trace_wglEnableFrameLockI3D(void)
{
  Internal("trace_wglEnableFrameLockI3D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglEnableFrameLockI3D();
  return ret;
}

static BOOL REGAL_CALL trace_wglIsEnabledFrameLockI3D(BOOL *pFlag)
{
  Internal("trace_wglIsEnabledFrameLockI3D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglIsEnabledFrameLockI3D(pFlag);
  return ret;
}

static BOOL REGAL_CALL trace_wglQueryFrameLockMasterI3D(BOOL *pFlag)
{
  Internal("trace_wglQueryFrameLockMasterI3D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglQueryFrameLockMasterI3D(pFlag);
  return ret;
}

// WGL_I3D_swap_frame_usage

static BOOL REGAL_CALL trace_wglBeginFrameTrackingI3D(void)
{
  Internal("trace_wglBeginFrameTrackingI3D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglBeginFrameTrackingI3D();
  return ret;
}

static BOOL REGAL_CALL trace_wglEndFrameTrackingI3D(void)
{
  Internal("trace_wglEndFrameTrackingI3D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglEndFrameTrackingI3D();
  return ret;
}

static BOOL REGAL_CALL trace_wglGetFrameUsageI3D(float *pUsage)
{
  Internal("trace_wglGetFrameUsageI3D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglGetFrameUsageI3D(pUsage);
  return ret;
}

static BOOL REGAL_CALL trace_wglQueryFrameTrackingI3D(DWORD *pFrameCount, DWORD *pMissedFrames, float *pLastMissedUsage)
{
  Internal("trace_wglQueryFrameTrackingI3D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglQueryFrameTrackingI3D(pFrameCount, pMissedFrames, pLastMissedUsage);
  return ret;
}

// WGL_NV_DX_interop

static BOOL REGAL_CALL trace_wglDXCloseDeviceNV(HANDLE hDevice)
{
  Internal("trace_wglDXCloseDeviceNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglDXCloseDeviceNV(hDevice);
  return ret;
}

static BOOL REGAL_CALL trace_wglDXLockObjectsNV(HANDLE hDevice, GLint count, HANDLE *hObjects)
{
  Internal("trace_wglDXLockObjectsNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglDXLockObjectsNV(hDevice, count, hObjects);
  return ret;
}

static BOOL REGAL_CALL trace_wglDXObjectAccessNV(HANDLE hObject, GLenum access)
{
  Internal("trace_wglDXObjectAccessNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglDXObjectAccessNV(hObject, access);
  return ret;
}

static HANDLE REGAL_CALL trace_wglDXOpenDeviceNV(GLvoid *dxDevice)
{
  Internal("trace_wglDXOpenDeviceNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  HANDLE  ret = Trace::wglDXOpenDeviceNV(dxDevice);
  return ret;
}

static HANDLE REGAL_CALL trace_wglDXRegisterObjectNV(HANDLE hDevice, GLvoid *dxObject, GLuint name, GLenum type, GLenum access)
{
  Internal("trace_wglDXRegisterObjectNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  HANDLE  ret = Trace::wglDXRegisterObjectNV(hDevice, dxObject, name, type, access);
  return ret;
}

static BOOL REGAL_CALL trace_wglDXSetResourceShareHandleNV(GLvoid *dxObject, HANDLE shareHandle)
{
  Internal("trace_wglDXSetResourceShareHandleNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglDXSetResourceShareHandleNV(dxObject, shareHandle);
  return ret;
}

static BOOL REGAL_CALL trace_wglDXUnlockObjectsNV(HANDLE hDevice, GLint count, HANDLE *hObjects)
{
  Internal("trace_wglDXUnlockObjectsNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglDXUnlockObjectsNV(hDevice, count, hObjects);
  return ret;
}

static BOOL REGAL_CALL trace_wglDXUnregisterObjectNV(HANDLE hDevice, HANDLE hObject)
{
  Internal("trace_wglDXUnregisterObjectNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglDXUnregisterObjectNV(hDevice, hObject);
  return ret;
}

// WGL_NV_copy_image

static BOOL REGAL_CALL trace_wglCopyImageSubDataNV(HGLRC hSrcRC, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, HGLRC hDstRC, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth)
{
  Internal("trace_wglCopyImageSubDataNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglCopyImageSubDataNV(hSrcRC, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, hDstRC, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
  return ret;
}

// WGL_NV_gpu_affinity

static HDC REGAL_CALL trace_wglCreateAffinityDCNV(const HGPUNV *phGpuList)
{
  Internal("trace_wglCreateAffinityDCNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  HDC  ret = Trace::wglCreateAffinityDCNV(phGpuList);
  return ret;
}

static BOOL REGAL_CALL trace_wglDeleteDCNV(HDC hAffinityDC)
{
  Internal("trace_wglDeleteDCNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglDeleteDCNV(hAffinityDC);
  return ret;
}

static BOOL REGAL_CALL trace_wglEnumGpusFromAffinityDCNV(HDC hAffinityDC, UINT iGpuIndex, HGPUNV *hGpu)
{
  Internal("trace_wglEnumGpusFromAffinityDCNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglEnumGpusFromAffinityDCNV(hAffinityDC, iGpuIndex, hGpu);
  return ret;
}

static BOOL REGAL_CALL trace_wglEnumGpusNV(UINT iGpuIndex, HGPUNV *phGpu)
{
  Internal("trace_wglEnumGpusNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglEnumGpusNV(iGpuIndex, phGpu);
  return ret;
}

// WGL_NV_present_video

static BOOL REGAL_CALL trace_wglBindVideoDeviceNV(HDC hDC, unsigned int uVideoSlot, HVIDEOOUTPUTDEVICENV hVideoDevice, const int *piAttribList)
{
  Internal("trace_wglBindVideoDeviceNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglBindVideoDeviceNV(hDC, uVideoSlot, hVideoDevice, piAttribList);
  return ret;
}

static int REGAL_CALL trace_wglEnumerateVideoDevicesNV(HDC hDC, HVIDEOOUTPUTDEVICENV *phDeviceList)
{
  Internal("trace_wglEnumerateVideoDevicesNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  int  ret = Trace::wglEnumerateVideoDevicesNV(hDC, phDeviceList);
  return ret;
}

static BOOL REGAL_CALL trace_wglQueryCurrentContextNV(int iAttribute, int *piValue)
{
  Internal("trace_wglQueryCurrentContextNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglQueryCurrentContextNV(iAttribute, piValue);
  return ret;
}

// WGL_NV_swap_group

static BOOL REGAL_CALL trace_wglBindSwapBarrierNV(GLuint group, GLuint barrier)
{
  Internal("trace_wglBindSwapBarrierNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglBindSwapBarrierNV(group, barrier);
  return ret;
}

static BOOL REGAL_CALL trace_wglJoinSwapGroupNV(HDC hDC, GLuint group)
{
  Internal("trace_wglJoinSwapGroupNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglJoinSwapGroupNV(hDC, group);
  return ret;
}

static BOOL REGAL_CALL trace_wglQueryFrameCountNV(HDC hDC, GLuint *count)
{
  Internal("trace_wglQueryFrameCountNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglQueryFrameCountNV(hDC, count);
  return ret;
}

static BOOL REGAL_CALL trace_wglQueryMaxSwapGroupsNV(HDC hDC, GLuint *maxGroups, GLuint *maxBarriers)
{
  Internal("trace_wglQueryMaxSwapGroupsNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglQueryMaxSwapGroupsNV(hDC, maxGroups, maxBarriers);
  return ret;
}

static BOOL REGAL_CALL trace_wglQuerySwapGroupNV(HDC hDC, GLuint *group, GLuint *barrier)
{
  Internal("trace_wglQuerySwapGroupNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglQuerySwapGroupNV(hDC, group, barrier);
  return ret;
}

static BOOL REGAL_CALL trace_wglResetFrameCountNV(HDC hDC)
{
  Internal("trace_wglResetFrameCountNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglResetFrameCountNV(hDC);
  return ret;
}

// WGL_NV_vertex_array_range

static void *REGAL_CALL trace_wglAllocateMemoryNV(GLsizei size, GLfloat readfreq, GLfloat writefreq, GLfloat priority)
{
  Internal("trace_wglAllocateMemoryNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  void * ret = Trace::wglAllocateMemoryNV(size, readfreq, writefreq, priority);
  return ret;
}

static void REGAL_CALL trace_wglFreeMemoryNV(void *pointer)
{
  Internal("trace_wglFreeMemoryNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Trace::wglFreeMemoryNV(pointer);
}

// WGL_NV_video_capture

static BOOL REGAL_CALL trace_wglBindVideoCaptureDeviceNV(UINT uVideoSlot, HVIDEOINPUTDEVICENV hDevice)
{
  Internal("trace_wglBindVideoCaptureDeviceNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglBindVideoCaptureDeviceNV(uVideoSlot, hDevice);
  return ret;
}

static UINT REGAL_CALL trace_wglEnumerateVideoCaptureDevicesNV(HDC hDC, HVIDEOINPUTDEVICENV *phDeviceList)
{
  Internal("trace_wglEnumerateVideoCaptureDevicesNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  UINT  ret = Trace::wglEnumerateVideoCaptureDevicesNV(hDC, phDeviceList);
  return ret;
}

static BOOL REGAL_CALL trace_wglLockVideoCaptureDeviceNV(HDC hDC, HVIDEOINPUTDEVICENV hDevice)
{
  Internal("trace_wglLockVideoCaptureDeviceNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglLockVideoCaptureDeviceNV(hDC, hDevice);
  return ret;
}

static BOOL REGAL_CALL trace_wglQueryVideoCaptureDeviceNV(HDC hDC, HVIDEOINPUTDEVICENV hDevice, int iAttribute, int *piValue)
{
  Internal("trace_wglQueryVideoCaptureDeviceNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglQueryVideoCaptureDeviceNV(hDC, hDevice, iAttribute, piValue);
  return ret;
}

static BOOL REGAL_CALL trace_wglReleaseVideoCaptureDeviceNV(HDC hDC, HVIDEOINPUTDEVICENV hDevice)
{
  Internal("trace_wglReleaseVideoCaptureDeviceNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglReleaseVideoCaptureDeviceNV(hDC, hDevice);
  return ret;
}

// WGL_NV_video_output

static BOOL REGAL_CALL trace_wglBindVideoImageNV(HPVIDEODEV hVideoDevice, HPBUFFERARB hPbuffer, int iVideoBuffer)
{
  Internal("trace_wglBindVideoImageNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglBindVideoImageNV(hVideoDevice, hPbuffer, iVideoBuffer);
  return ret;
}

static BOOL REGAL_CALL trace_wglGetVideoDeviceNV(HDC hDC, int numDevices, HPVIDEODEV *hVideoDevice)
{
  Internal("trace_wglGetVideoDeviceNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglGetVideoDeviceNV(hDC, numDevices, hVideoDevice);
  return ret;
}

static BOOL REGAL_CALL trace_wglGetVideoInfoNV(HPVIDEODEV hpVideoDevice, unsigned long *pulCounterOutputPbuffer, unsigned long *pulCounterOutputVideo)
{
  Internal("trace_wglGetVideoInfoNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglGetVideoInfoNV(hpVideoDevice, pulCounterOutputPbuffer, pulCounterOutputVideo);
  return ret;
}

static BOOL REGAL_CALL trace_wglReleaseVideoDeviceNV(HPVIDEODEV hVideoDevice)
{
  Internal("trace_wglReleaseVideoDeviceNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglReleaseVideoDeviceNV(hVideoDevice);
  return ret;
}

static BOOL REGAL_CALL trace_wglReleaseVideoImageNV(HPBUFFERARB hPbuffer, int iVideoBuffer)
{
  Internal("trace_wglReleaseVideoImageNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglReleaseVideoImageNV(hPbuffer, iVideoBuffer);
  return ret;
}

static BOOL REGAL_CALL trace_wglSendPbufferToVideoNV(HPBUFFERARB hPbuffer, int iBufferType, unsigned long *pulCounterPbuffer, BOOL bBlock)
{
  Internal("trace_wglSendPbufferToVideoNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglSendPbufferToVideoNV(hPbuffer, iBufferType, pulCounterPbuffer, bBlock);
  return ret;
}

// WGL_OML_sync_control

static BOOL REGAL_CALL trace_wglGetMscRateOML(HDC hDC, INT32 *numerator, INT32 *denominator)
{
  Internal("trace_wglGetMscRateOML","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglGetMscRateOML(hDC, numerator, denominator);
  return ret;
}

static BOOL REGAL_CALL trace_wglGetSyncValuesOML(HDC hDC, INT64 *ust, INT64 *msc, INT64 *sbc)
{
  Internal("trace_wglGetSyncValuesOML","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglGetSyncValuesOML(hDC, ust, msc, sbc);
  return ret;
}

static INT64 REGAL_CALL trace_wglSwapBuffersMscOML(HDC hDC, INT64 target_msc, INT64 divisor, INT64 remainder)
{
  Internal("trace_wglSwapBuffersMscOML","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  INT64  ret = Trace::wglSwapBuffersMscOML(hDC, target_msc, divisor, remainder);
  return ret;
}

static INT64 REGAL_CALL trace_wglSwapLayerBuffersMscOML(HDC hDC, int fuPlanes, INT64 target_msc, INT64 divisor, INT64 remainder)
{
  Internal("trace_wglSwapLayerBuffersMscOML","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  INT64  ret = Trace::wglSwapLayerBuffersMscOML(hDC, fuPlanes, target_msc, divisor, remainder);
  return ret;
}

static BOOL REGAL_CALL trace_wglWaitForMscOML(HDC hDC, INT64 target_msc, INT64 divisor, INT64 remainder, INT64 *ust, INT64 *msc, INT64 *sbc)
{
  Internal("trace_wglWaitForMscOML","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglWaitForMscOML(hDC, target_msc, divisor, remainder, ust, msc, sbc);
  return ret;
}

static BOOL REGAL_CALL trace_wglWaitForSbcOML(HDC hDC, INT64 target_sbc, INT64 *ust, INT64 *msc, INT64 *sbc)
{
  Internal("trace_wglWaitForSbcOML","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglWaitForSbcOML(hDC, target_sbc, ust, msc, sbc);
  return ret;
}

// WGL_core

static BOOL REGAL_CALL trace_wglCopyContext(HGLRC hglrcSrc, HGLRC hglrcDst, UINT mask)
{
  Internal("trace_wglCopyContext","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglCopyContext(hglrcSrc, hglrcDst, mask);
  return ret;
}

static HGLRC REGAL_CALL trace_wglCreateContext(HDC hDC)
{
  Internal("trace_wglCreateContext","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  HGLRC  ret = Trace::wglCreateContext(hDC);
  return ret;
}

static HGLRC REGAL_CALL trace_wglCreateLayerContext(HDC hDC, int iLayerPlane)
{
  Internal("trace_wglCreateLayerContext","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  HGLRC  ret = Trace::wglCreateLayerContext(hDC, iLayerPlane);
  return ret;
}

static BOOL REGAL_CALL trace_wglDeleteContext(HGLRC hglrc)
{
  Internal("trace_wglDeleteContext","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglDeleteContext(hglrc);
  return ret;
}

static BOOL REGAL_CALL trace_wglDescribeLayerPlane(HDC hDC, int iPixelFormat, int iLayerPlane, UINT nBytes, LPLAYERPLANEDESCRIPTOR plpd)
{
  Internal("trace_wglDescribeLayerPlane","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglDescribeLayerPlane(hDC, iPixelFormat, iLayerPlane, nBytes, plpd);
  return ret;
}

static HGLRC REGAL_CALL trace_wglGetCurrentContext(void)
{
  Internal("trace_wglGetCurrentContext","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  HGLRC  ret = Trace::wglGetCurrentContext();
  return ret;
}

static HDC REGAL_CALL trace_wglGetCurrentDC(void)
{
  Internal("trace_wglGetCurrentDC","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  HDC  ret = Trace::wglGetCurrentDC();
  return ret;
}

static int REGAL_CALL trace_wglGetLayerPaletteEntries(HDC hDC, int iLayerPlane, int iStart, int nEntries, COLORREF *pcr)
{
  Internal("trace_wglGetLayerPaletteEntries","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  int  ret = Trace::wglGetLayerPaletteEntries(hDC, iLayerPlane, iStart, nEntries, pcr);
  return ret;
}

static BOOL REGAL_CALL trace_wglMakeCurrent(HDC hDC, HGLRC hglrc)
{
  Internal("trace_wglMakeCurrent","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglMakeCurrent(hDC, hglrc);
  return ret;
}

static BOOL REGAL_CALL trace_wglRealizeLayerPalette(HDC hDC, int iLayerPlane, BOOL bRealize)
{
  Internal("trace_wglRealizeLayerPalette","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglRealizeLayerPalette(hDC, iLayerPlane, bRealize);
  return ret;
}

static int REGAL_CALL trace_wglSetLayerPaletteEntries(HDC hDC, int iLayerPlane, int iStart, int nEntries, const COLORREF *pcr)
{
  Internal("trace_wglSetLayerPaletteEntries","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  int  ret = Trace::wglSetLayerPaletteEntries(hDC, iLayerPlane, iStart, nEntries, pcr);
  return ret;
}

static BOOL REGAL_CALL trace_wglShareLists(HGLRC hglrcShare, HGLRC hglrcSrc)
{
  Internal("trace_wglShareLists","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglShareLists(hglrcShare, hglrcSrc);
  return ret;
}

static BOOL REGAL_CALL trace_wglSwapLayerBuffers(HDC hDC, UINT fuPlanes)
{
  Internal("trace_wglSwapLayerBuffers","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglSwapLayerBuffers(hDC, fuPlanes);
  return ret;
}

static DWORD REGAL_CALL trace_wglSwapMultipleBuffers(UINT n, const WGLSWAP *ps)
{
  Internal("trace_wglSwapMultipleBuffers","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  DWORD  ret = Trace::wglSwapMultipleBuffers(n, ps);
  return ret;
}

static BOOL REGAL_CALL trace_wglUseFontBitmapsA(HDC hDC, DWORD first, DWORD count, DWORD listBase)
{
  Internal("trace_wglUseFontBitmapsA","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglUseFontBitmapsA(hDC, first, count, listBase);
  return ret;
}

static BOOL REGAL_CALL trace_wglUseFontBitmapsW(HDC hDC, DWORD first, DWORD count, DWORD listBase)
{
  Internal("trace_wglUseFontBitmapsW","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglUseFontBitmapsW(hDC, first, count, listBase);
  return ret;
}

static BOOL REGAL_CALL trace_wglUseFontOutlinesA(HDC hDC, DWORD first, DWORD count, DWORD listBase, FLOAT deviation, FLOAT extrusion, int format, LPGLYPHMETRICSFLOAT lpgmf)
{
  Internal("trace_wglUseFontOutlinesA","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglUseFontOutlinesA(hDC, first, count, listBase, deviation, extrusion, format, lpgmf);
  return ret;
}

static BOOL REGAL_CALL trace_wglUseFontOutlinesW(HDC hDC, DWORD first, DWORD count, DWORD listBase, FLOAT deviation, FLOAT extrusion, int format, LPGLYPHMETRICSFLOAT lpgmf)
{
  Internal("trace_wglUseFontOutlinesW","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  BOOL  ret = Trace::wglUseFontOutlinesW(hDC, first, count, listBase, deviation, extrusion, format, lpgmf);
  return ret;
}

#endif // REGAL_SYS_WGL

#if REGAL_SYS_GLX

// GLX_VERSION_1_0

static XVisualInfo *REGAL_CALL trace_glXChooseVisual(Display *dpy, int screen, int *attribList)
{
  Internal("trace_glXChooseVisual","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  XVisualInfo * ret = Trace::glXChooseVisual(dpy, screen, attribList);
  return ret;
}

static void REGAL_CALL trace_glXCopyContext(Display *dpy, GLXContext src, GLXContext dst, unsigned long mask)
{
  Internal("trace_glXCopyContext","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Trace::glXCopyContext(dpy, src, dst, mask);
}

static GLXContext REGAL_CALL trace_glXCreateContext(Display *dpy, XVisualInfo *vis, GLXContext shareList, Bool direct)
{
  Internal("trace_glXCreateContext","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  GLXContext  ret = Trace::glXCreateContext(dpy, vis, shareList, direct);
  return ret;
}

static GLXPixmap REGAL_CALL trace_glXCreateGLXPixmap(Display *dpy, XVisualInfo *vis, Pixmap pixmap)
{
  Internal("trace_glXCreateGLXPixmap","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  GLXPixmap  ret = Trace::glXCreateGLXPixmap(dpy, vis, pixmap);
  return ret;
}

static void REGAL_CALL trace_glXDestroyContext(Display *dpy, GLXContext ctx)
{
  Internal("trace_glXDestroyContext","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Trace::glXDestroyContext(dpy, ctx);
}

static void REGAL_CALL trace_glXDestroyGLXPixmap(Display *dpy, GLXPixmap pix)
{
  Internal("trace_glXDestroyGLXPixmap","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Trace::glXDestroyGLXPixmap(dpy, pix);
}

static int REGAL_CALL trace_glXGetConfig(Display *dpy, XVisualInfo *vis, int attrib, int *value)
{
  Internal("trace_glXGetConfig","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  int  ret = Trace::glXGetConfig(dpy, vis, attrib, value);
  return ret;
}

static GLXContext REGAL_CALL trace_glXGetCurrentContext(void)
{
  Internal("trace_glXGetCurrentContext","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  GLXContext  ret = Trace::glXGetCurrentContext();
  return ret;
}

static GLXDrawable REGAL_CALL trace_glXGetCurrentDrawable(void)
{
  Internal("trace_glXGetCurrentDrawable","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  GLXDrawable  ret = Trace::glXGetCurrentDrawable();
  return ret;
}

static Bool REGAL_CALL trace_glXIsDirect(Display *dpy, GLXContext ctx)
{
  Internal("trace_glXIsDirect","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Bool  ret = Trace::glXIsDirect(dpy, ctx);
  return ret;
}

static Bool REGAL_CALL trace_glXMakeCurrent(Display *dpy, GLXDrawable drawable, GLXContext ctx)
{
  Internal("trace_glXMakeCurrent","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Bool  ret = Trace::glXMakeCurrent(dpy, drawable, ctx);
  return ret;
}

static Bool REGAL_CALL trace_glXQueryExtension(Display *dpy, int *errorBase, int *eventBase)
{
  Internal("trace_glXQueryExtension","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Bool  ret = Trace::glXQueryExtension(dpy, errorBase, eventBase);
  return ret;
}

static Bool REGAL_CALL trace_glXQueryVersion(Display *dpy, int *major, int *minor)
{
  Internal("trace_glXQueryVersion","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Bool  ret = Trace::glXQueryVersion(dpy, major, minor);
  return ret;
}

static void REGAL_CALL trace_glXSwapBuffers(Display *dpy, GLXDrawable drawable)
{
  Internal("trace_glXSwapBuffers","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Trace::glXSwapBuffers(dpy, drawable);
}

static void REGAL_CALL trace_glXUseXFont(Font font, int first, int count, int listBase)
{
  Internal("trace_glXUseXFont","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Trace::glXUseXFont(font, first, count, listBase);
}

static void REGAL_CALL trace_glXWaitGL(void)
{
  Internal("trace_glXWaitGL","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Trace::glXWaitGL();
}

static void REGAL_CALL trace_glXWaitX(void)
{
  Internal("trace_glXWaitX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Trace::glXWaitX();
}

// GLX_VERSION_1_1

static const char *REGAL_CALL trace_glXGetClientString(Display *dpy, int name)
{
  Internal("trace_glXGetClientString","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  const char * ret = Trace::glXGetClientString(dpy, name);
  return ret;
}

static const char *REGAL_CALL trace_glXQueryExtensionsString(Display *dpy, int screen)
{
  Internal("trace_glXQueryExtensionsString","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  const char * ret = Trace::glXQueryExtensionsString(dpy, screen);
  return ret;
}

static const char *REGAL_CALL trace_glXQueryServerString(Display *dpy, int screen, int name)
{
  Internal("trace_glXQueryServerString","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  const char * ret = Trace::glXQueryServerString(dpy, screen, name);
  return ret;
}

// GLX_VERSION_1_2

static Display *REGAL_CALL trace_glXGetCurrentDisplay(void)
{
  Internal("trace_glXGetCurrentDisplay","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Display * ret = Trace::glXGetCurrentDisplay();
  return ret;
}

// GLX_VERSION_1_3

static GLXFBConfig *REGAL_CALL trace_glXChooseFBConfig(Display *dpy, int screen, const int *attrib_list, int *nelements)
{
  Internal("trace_glXChooseFBConfig","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  GLXFBConfig * ret = Trace::glXChooseFBConfig(dpy, screen, attrib_list, nelements);
  return ret;
}

static GLXContext REGAL_CALL trace_glXCreateNewContext(Display *dpy, GLXFBConfig config, int render_type, GLXContext share_list, Bool direct)
{
  Internal("trace_glXCreateNewContext","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  GLXContext  ret = Trace::glXCreateNewContext(dpy, config, render_type, share_list, direct);
  return ret;
}

static GLXPbuffer REGAL_CALL trace_glXCreatePbuffer(Display *dpy, GLXFBConfig config, const int *attrib_list)
{
  Internal("trace_glXCreatePbuffer","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  GLXPbuffer  ret = Trace::glXCreatePbuffer(dpy, config, attrib_list);
  return ret;
}

static GLXPixmap REGAL_CALL trace_glXCreatePixmap(Display *dpy, GLXFBConfig config, Pixmap pixmap, const int *attrib_list)
{
  Internal("trace_glXCreatePixmap","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  GLXPixmap  ret = Trace::glXCreatePixmap(dpy, config, pixmap, attrib_list);
  return ret;
}

static GLXWindow REGAL_CALL trace_glXCreateWindow(Display *dpy, GLXFBConfig config, Window win, const int *attrib_list)
{
  Internal("trace_glXCreateWindow","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  GLXWindow  ret = Trace::glXCreateWindow(dpy, config, win, attrib_list);
  return ret;
}

static void REGAL_CALL trace_glXDestroyPbuffer(Display *dpy, GLXPbuffer pbuf)
{
  Internal("trace_glXDestroyPbuffer","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Trace::glXDestroyPbuffer(dpy, pbuf);
}

static void REGAL_CALL trace_glXDestroyPixmap(Display *dpy, GLXPixmap pixmap)
{
  Internal("trace_glXDestroyPixmap","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Trace::glXDestroyPixmap(dpy, pixmap);
}

static void REGAL_CALL trace_glXDestroyWindow(Display *dpy, GLXWindow win)
{
  Internal("trace_glXDestroyWindow","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Trace::glXDestroyWindow(dpy, win);
}

static GLXDrawable REGAL_CALL trace_glXGetCurrentReadDrawable(void)
{
  Internal("trace_glXGetCurrentReadDrawable","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  GLXDrawable  ret = Trace::glXGetCurrentReadDrawable();
  return ret;
}

static int REGAL_CALL trace_glXGetFBConfigAttrib(Display *dpy, GLXFBConfig config, int attribute, int *value)
{
  Internal("trace_glXGetFBConfigAttrib","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  int  ret = Trace::glXGetFBConfigAttrib(dpy, config, attribute, value);
  return ret;
}

static GLXFBConfig *REGAL_CALL trace_glXGetFBConfigs(Display *dpy, int screen, int *nelements)
{
  Internal("trace_glXGetFBConfigs","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  GLXFBConfig * ret = Trace::glXGetFBConfigs(dpy, screen, nelements);
  return ret;
}

static void REGAL_CALL trace_glXGetSelectedEvent(Display *dpy, GLXDrawable draw, unsigned long *event_mask)
{
  Internal("trace_glXGetSelectedEvent","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Trace::glXGetSelectedEvent(dpy, draw, event_mask);
}

static XVisualInfo *REGAL_CALL trace_glXGetVisualFromFBConfig(Display *dpy, GLXFBConfig config)
{
  Internal("trace_glXGetVisualFromFBConfig","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  XVisualInfo * ret = Trace::glXGetVisualFromFBConfig(dpy, config);
  return ret;
}

static Bool REGAL_CALL trace_glXMakeContextCurrent(Display *display, GLXDrawable draw, GLXDrawable read, GLXContext ctx)
{
  Internal("trace_glXMakeContextCurrent","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Bool  ret = Trace::glXMakeContextCurrent(display, draw, read, ctx);
  return ret;
}

static int REGAL_CALL trace_glXQueryContext(Display *dpy, GLXContext ctx, int attribute, int *value)
{
  Internal("trace_glXQueryContext","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  int  ret = Trace::glXQueryContext(dpy, ctx, attribute, value);
  return ret;
}

static void REGAL_CALL trace_glXQueryDrawable(Display *dpy, GLXDrawable draw, int attribute, unsigned int *value)
{
  Internal("trace_glXQueryDrawable","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Trace::glXQueryDrawable(dpy, draw, attribute, value);
}

static void REGAL_CALL trace_glXSelectEvent(Display *dpy, GLXDrawable draw, unsigned long event_mask)
{
  Internal("trace_glXSelectEvent","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Trace::glXSelectEvent(dpy, draw, event_mask);
}

// GLX_VERSION_1_4

static __GLXextFuncPtr REGAL_CALL trace_glXGetProcAddress(const GLubyte *procName)
{
  Internal("trace_glXGetProcAddress","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  __GLXextFuncPtr  ret = Trace::glXGetProcAddress(procName);
  return ret;
}

// GLX_ARB_create_context

static GLXContext REGAL_CALL trace_glXCreateContextAttribsARB(Display *dpy, GLXFBConfig config, GLXContext share_context, Bool direct, const int *attrib_list)
{
  Internal("trace_glXCreateContextAttribsARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  GLXContext  ret = Trace::glXCreateContextAttribsARB(dpy, config, share_context, direct, attrib_list);
  return ret;
}

// GLX_ARB_get_proc_address

static __GLXextFuncPtr REGAL_CALL trace_glXGetProcAddressARB(const GLubyte *procName)
{
  Internal("trace_glXGetProcAddressARB","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  __GLXextFuncPtr  ret = Trace::glXGetProcAddressARB(procName);
  return ret;
}

// GLX_EXT_import_context

static void REGAL_CALL trace_glXFreeContextEXT(Display *dpy, GLXContext context)
{
  Internal("trace_glXFreeContextEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Trace::glXFreeContextEXT(dpy, context);
}

static GLXContextID REGAL_CALL trace_glXGetContextIDEXT(const GLXContext context)
{
  Internal("trace_glXGetContextIDEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  GLXContextID  ret = Trace::glXGetContextIDEXT(context);
  return ret;
}

static GLXContext REGAL_CALL trace_glXImportContextEXT(Display *dpy, GLXContextID contextID)
{
  Internal("trace_glXImportContextEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  GLXContext  ret = Trace::glXImportContextEXT(dpy, contextID);
  return ret;
}

static int REGAL_CALL trace_glXQueryContextInfoEXT(Display *dpy, GLXContext context, int attribute, int *value)
{
  Internal("trace_glXQueryContextInfoEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  int  ret = Trace::glXQueryContextInfoEXT(dpy, context, attribute, value);
  return ret;
}

// GLX_EXT_swap_control

static void REGAL_CALL trace_glXSwapIntervalEXT(Display *dpy, GLXDrawable drawable, int interval)
{
  Internal("trace_glXSwapIntervalEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Trace::glXSwapIntervalEXT(dpy, drawable, interval);
}

// GLX_EXT_texture_from_pixmap

static void REGAL_CALL trace_glXBindTexImageEXT(Display *display, GLXDrawable drawable, int buffer, const int *attrib_list)
{
  Internal("trace_glXBindTexImageEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Trace::glXBindTexImageEXT(display, drawable, buffer, attrib_list);
}

static void REGAL_CALL trace_glXReleaseTexImageEXT(Display *display, GLXDrawable drawable, int buffer)
{
  Internal("trace_glXReleaseTexImageEXT","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Trace::glXReleaseTexImageEXT(display, drawable, buffer);
}

// GLX_MESA_agp_offset

static unsigned int REGAL_CALL trace_glXGetAGPOffsetMESA(const void *pointer)
{
  Internal("trace_glXGetAGPOffsetMESA","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  unsigned int  ret = Trace::glXGetAGPOffsetMESA(pointer);
  return ret;
}

// GLX_MESA_copy_sub_buffer

static void REGAL_CALL trace_glXCopySubBufferMESA(Display *dpy, GLXDrawable drawable, int x, int y, int width, int height)
{
  Internal("trace_glXCopySubBufferMESA","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Trace::glXCopySubBufferMESA(dpy, drawable, x, y, width, height);
}

// GLX_MESA_pixmap_colormap

static GLXPixmap REGAL_CALL trace_glXCreateGLXPixmapMESA(Display *dpy, XVisualInfo *visual, Pixmap pixmap, Colormap cmap)
{
  Internal("trace_glXCreateGLXPixmapMESA","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  GLXPixmap  ret = Trace::glXCreateGLXPixmapMESA(dpy, visual, pixmap, cmap);
  return ret;
}

// GLX_MESA_release_buffers

static Bool REGAL_CALL trace_glXReleaseBuffersMESA(Display *dpy, GLXDrawable d)
{
  Internal("trace_glXReleaseBuffersMESA","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Bool  ret = Trace::glXReleaseBuffersMESA(dpy, d);
  return ret;
}

// GLX_MESA_set_3dfx_mode

static GLboolean REGAL_CALL trace_glXSet3DfxModeMESA(GLint mode)
{
  Internal("trace_glXSet3DfxModeMESA","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  GLboolean  ret = Trace::glXSet3DfxModeMESA(mode);
  return ret;
}

// GLX_MESA_swap_control

static int REGAL_CALL trace_glXGetSwapIntervalMESA(void)
{
  Internal("trace_glXGetSwapIntervalMESA","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  int  ret = Trace::glXGetSwapIntervalMESA();
  return ret;
}

static int REGAL_CALL trace_glXSwapIntervalMESA(unsigned int interval)
{
  Internal("trace_glXSwapIntervalMESA","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  int  ret = Trace::glXSwapIntervalMESA(interval);
  return ret;
}

// GLX_NV_copy_image

static void REGAL_CALL trace_glXCopyImageSubDataNV(Display *dpy, GLXContext srcCtx, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLXContext dstCtx, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth)
{
  Internal("trace_glXCopyImageSubDataNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Trace::glXCopyImageSubDataNV(dpy, srcCtx, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstCtx, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
}

// GLX_NV_present_video

static int REGAL_CALL trace_glXBindVideoDeviceNV(Display *dpy, unsigned int video_slot, unsigned int video_device, const int *attrib_list)
{
  Internal("trace_glXBindVideoDeviceNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  int  ret = Trace::glXBindVideoDeviceNV(dpy, video_slot, video_device, attrib_list);
  return ret;
}

static unsigned int *REGAL_CALL trace_glXEnumerateVideoDevicesNV(Display *dpy, int screen, int *nelements)
{
  Internal("trace_glXEnumerateVideoDevicesNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  unsigned int * ret = Trace::glXEnumerateVideoDevicesNV(dpy, screen, nelements);
  return ret;
}

// GLX_NV_swap_group

static Bool REGAL_CALL trace_glXBindSwapBarrierNV(Display *dpy, GLuint group, GLuint barrier)
{
  Internal("trace_glXBindSwapBarrierNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Bool  ret = Trace::glXBindSwapBarrierNV(dpy, group, barrier);
  return ret;
}

static Bool REGAL_CALL trace_glXJoinSwapGroupNV(Display *dpy, GLXDrawable drawable, GLuint group)
{
  Internal("trace_glXJoinSwapGroupNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Bool  ret = Trace::glXJoinSwapGroupNV(dpy, drawable, group);
  return ret;
}

static Bool REGAL_CALL trace_glXQueryFrameCountNV(Display *dpy, int screen, GLuint *count)
{
  Internal("trace_glXQueryFrameCountNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Bool  ret = Trace::glXQueryFrameCountNV(dpy, screen, count);
  return ret;
}

static Bool REGAL_CALL trace_glXQueryMaxSwapGroupsNV(Display *dpy, int screen, GLuint *maxGroups, GLuint *maxBarriers)
{
  Internal("trace_glXQueryMaxSwapGroupsNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Bool  ret = Trace::glXQueryMaxSwapGroupsNV(dpy, screen, maxGroups, maxBarriers);
  return ret;
}

static Bool REGAL_CALL trace_glXQuerySwapGroupNV(Display *dpy, GLXDrawable drawable, GLuint *group, GLuint *barrier)
{
  Internal("trace_glXQuerySwapGroupNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Bool  ret = Trace::glXQuerySwapGroupNV(dpy, drawable, group, barrier);
  return ret;
}

static Bool REGAL_CALL trace_glXResetFrameCountNV(Display *dpy, int screen)
{
  Internal("trace_glXResetFrameCountNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Bool  ret = Trace::glXResetFrameCountNV(dpy, screen);
  return ret;
}

// GLX_NV_vertex_array_range

static void *REGAL_CALL trace_glXAllocateMemoryNV(GLsizei size, GLfloat readFrequency, GLfloat writeFrequency, GLfloat priority)
{
  Internal("trace_glXAllocateMemoryNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  void * ret = Trace::glXAllocateMemoryNV(size, readFrequency, writeFrequency, priority);
  return ret;
}

static void REGAL_CALL trace_glXFreeMemoryNV(void *pointer)
{
  Internal("trace_glXFreeMemoryNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Trace::glXFreeMemoryNV(pointer);
}

// GLX_NV_video_capture

static int REGAL_CALL trace_glXBindVideoCaptureDeviceNV(Display *dpy, unsigned int video_capture_slot, GLXVideoCaptureDeviceNV device)
{
  Internal("trace_glXBindVideoCaptureDeviceNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  int  ret = Trace::glXBindVideoCaptureDeviceNV(dpy, video_capture_slot, device);
  return ret;
}

static GLXVideoCaptureDeviceNV *REGAL_CALL trace_glXEnumerateVideoCaptureDevicesNV(Display *dpy, int screen, int *nelements)
{
  Internal("trace_glXEnumerateVideoCaptureDevicesNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  GLXVideoCaptureDeviceNV * ret = Trace::glXEnumerateVideoCaptureDevicesNV(dpy, screen, nelements);
  return ret;
}

static void REGAL_CALL trace_glXLockVideoCaptureDeviceNV(Display *dpy, GLXVideoCaptureDeviceNV device)
{
  Internal("trace_glXLockVideoCaptureDeviceNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Trace::glXLockVideoCaptureDeviceNV(dpy, device);
}

static int REGAL_CALL trace_glXQueryVideoCaptureDeviceNV(Display *dpy, GLXVideoCaptureDeviceNV device, int attribute, int *value)
{
  Internal("trace_glXQueryVideoCaptureDeviceNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  int  ret = Trace::glXQueryVideoCaptureDeviceNV(dpy, device, attribute, value);
  return ret;
}

static void REGAL_CALL trace_glXReleaseVideoCaptureDeviceNV(Display *dpy, GLXVideoCaptureDeviceNV device)
{
  Internal("trace_glXReleaseVideoCaptureDeviceNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Trace::glXReleaseVideoCaptureDeviceNV(dpy, device);
}

// GLX_NV_video_output

static int REGAL_CALL trace_glXBindVideoImageNV(Display *dpy, GLXVideoDeviceNV VideoDevice, GLXPbuffer pbuf, int iVideoBuffer)
{
  Internal("trace_glXBindVideoImageNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  int  ret = Trace::glXBindVideoImageNV(dpy, VideoDevice, pbuf, iVideoBuffer);
  return ret;
}

static int REGAL_CALL trace_glXGetVideoDeviceNV(Display *dpy, int screen, int numVideoDevices, GLXVideoDeviceNV *pVideoDevice)
{
  Internal("trace_glXGetVideoDeviceNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  int  ret = Trace::glXGetVideoDeviceNV(dpy, screen, numVideoDevices, pVideoDevice);
  return ret;
}

static int REGAL_CALL trace_glXGetVideoInfoNV(Display *dpy, int screen, GLXVideoDeviceNV VideoDevice, unsigned long *pulCounterOutputPbuffer, unsigned long *pulCounterOutputVideo)
{
  Internal("trace_glXGetVideoInfoNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  int  ret = Trace::glXGetVideoInfoNV(dpy, screen, VideoDevice, pulCounterOutputPbuffer, pulCounterOutputVideo);
  return ret;
}

static int REGAL_CALL trace_glXReleaseVideoDeviceNV(Display *dpy, int screen, GLXVideoDeviceNV VideoDevice)
{
  Internal("trace_glXReleaseVideoDeviceNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  int  ret = Trace::glXReleaseVideoDeviceNV(dpy, screen, VideoDevice);
  return ret;
}

static int REGAL_CALL trace_glXReleaseVideoImageNV(Display *dpy, GLXPbuffer pbuf)
{
  Internal("trace_glXReleaseVideoImageNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  int  ret = Trace::glXReleaseVideoImageNV(dpy, pbuf);
  return ret;
}

static int REGAL_CALL trace_glXSendPbufferToVideoNV(Display *dpy, GLXPbuffer pbuf, int iBufferType, unsigned long *pulCounterPbuffer, GLboolean bBlock)
{
  Internal("trace_glXSendPbufferToVideoNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  int  ret = Trace::glXSendPbufferToVideoNV(dpy, pbuf, iBufferType, pulCounterPbuffer, bBlock);
  return ret;
}

// GLX_OML_sync_control

static Bool REGAL_CALL trace_glXGetMscRateOML(Display *dpy, GLXDrawable drawable, int32_t *numerator, int32_t *denominator)
{
  Internal("trace_glXGetMscRateOML","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Bool  ret = Trace::glXGetMscRateOML(dpy, drawable, numerator, denominator);
  return ret;
}

static Bool REGAL_CALL trace_glXGetSyncValuesOML(Display *dpy, GLXDrawable drawable, int64_t *ust, int64_t *msc, int64_t *sbc)
{
  Internal("trace_glXGetSyncValuesOML","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Bool  ret = Trace::glXGetSyncValuesOML(dpy, drawable, ust, msc, sbc);
  return ret;
}

static int64_t REGAL_CALL trace_glXSwapBuffersMscOML(Display *dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder)
{
  Internal("trace_glXSwapBuffersMscOML","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  int64_t  ret = Trace::glXSwapBuffersMscOML(dpy, drawable, target_msc, divisor, remainder);
  return ret;
}

static Bool REGAL_CALL trace_glXWaitForMscOML(Display *dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder, int64_t *ust, int64_t *msc, int64_t *sbc)
{
  Internal("trace_glXWaitForMscOML","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Bool  ret = Trace::glXWaitForMscOML(dpy, drawable, target_msc, divisor, remainder, ust, msc, sbc);
  return ret;
}

static Bool REGAL_CALL trace_glXWaitForSbcOML(Display *dpy, GLXDrawable drawable, int64_t target_sbc, int64_t *ust, int64_t *msc, int64_t *sbc)
{
  Internal("trace_glXWaitForSbcOML","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Bool  ret = Trace::glXWaitForSbcOML(dpy, drawable, target_sbc, ust, msc, sbc);
  return ret;
}

// GLX_SGIX_fbconfig

static GLXContext REGAL_CALL trace_glXCreateContextWithConfigSGIX(Display *dpy, GLXFBConfig config, int render_type, GLXContext share_list, Bool direct)
{
  Internal("trace_glXCreateContextWithConfigSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  GLXContext  ret = Trace::glXCreateContextWithConfigSGIX(dpy, config, render_type, share_list, direct);
  return ret;
}

static GLXPixmap REGAL_CALL trace_glXCreateGLXPixmapWithConfigSGIX(Display *dpy, GLXFBConfig config, Pixmap pixmap)
{
  Internal("trace_glXCreateGLXPixmapWithConfigSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  GLXPixmap  ret = Trace::glXCreateGLXPixmapWithConfigSGIX(dpy, config, pixmap);
  return ret;
}

static int REGAL_CALL trace_glXGetFBConfigAttribSGIX(Display *dpy, GLXFBConfigSGIX config, int attribute, int *value)
{
  Internal("trace_glXGetFBConfigAttribSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  int  ret = Trace::glXGetFBConfigAttribSGIX(dpy, config, attribute, value);
  return ret;
}

static GLXFBConfigSGIX REGAL_CALL trace_glXGetFBConfigFromVisualSGIX(Display *dpy, XVisualInfo *vis)
{
  Internal("trace_glXGetFBConfigFromVisualSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  GLXFBConfigSGIX  ret = Trace::glXGetFBConfigFromVisualSGIX(dpy, vis);
  return ret;
}

static XVisualInfo *REGAL_CALL trace_glXGetVisualFromFBConfigSGIX(Display *dpy, GLXFBConfig config)
{
  Internal("trace_glXGetVisualFromFBConfigSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  XVisualInfo * ret = Trace::glXGetVisualFromFBConfigSGIX(dpy, config);
  return ret;
}

// GLX_SGIX_pbuffer

static GLXPbuffer REGAL_CALL trace_glXCreateGLXPbufferSGIX(Display *dpy, GLXFBConfig config, unsigned int width, unsigned int height, int *attrib_list)
{
  Internal("trace_glXCreateGLXPbufferSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  GLXPbuffer  ret = Trace::glXCreateGLXPbufferSGIX(dpy, config, width, height, attrib_list);
  return ret;
}

static void REGAL_CALL trace_glXDestroyGLXPbufferSGIX(Display *dpy, GLXPbuffer pbuf)
{
  Internal("trace_glXDestroyGLXPbufferSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Trace::glXDestroyGLXPbufferSGIX(dpy, pbuf);
}

static void REGAL_CALL trace_glXGetSelectedEventSGIX(Display *dpy, GLXDrawable drawable, unsigned long *mask)
{
  Internal("trace_glXGetSelectedEventSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Trace::glXGetSelectedEventSGIX(dpy, drawable, mask);
}

static void REGAL_CALL trace_glXQueryGLXPbufferSGIX(Display *dpy, GLXPbuffer pbuf, int attribute, unsigned int *value)
{
  Internal("trace_glXQueryGLXPbufferSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Trace::glXQueryGLXPbufferSGIX(dpy, pbuf, attribute, value);
}

static void REGAL_CALL trace_glXSelectEventSGIX(Display *dpy, GLXDrawable drawable, unsigned long mask)
{
  Internal("trace_glXSelectEventSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Trace::glXSelectEventSGIX(dpy, drawable, mask);
}

// GLX_SGIX_swap_barrier

static void REGAL_CALL trace_glXBindSwapBarrierSGIX(Display *dpy, GLXDrawable drawable, int barrier)
{
  Internal("trace_glXBindSwapBarrierSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Trace::glXBindSwapBarrierSGIX(dpy, drawable, barrier);
}

static Bool REGAL_CALL trace_glXQueryMaxSwapBarriersSGIX(Display *dpy, int screen, int *max)
{
  Internal("trace_glXQueryMaxSwapBarriersSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Bool  ret = Trace::glXQueryMaxSwapBarriersSGIX(dpy, screen, max);
  return ret;
}

// GLX_SGIX_swap_group

static void REGAL_CALL trace_glXJoinSwapGroupSGIX(Display *dpy, GLXDrawable drawable, GLXDrawable member)
{
  Internal("trace_glXJoinSwapGroupSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Trace::glXJoinSwapGroupSGIX(dpy, drawable, member);
}

// GLX_SGIX_video_resize

static int REGAL_CALL trace_glXBindChannelToWindowSGIX(Display *display, int screen, int channel, Window window)
{
  Internal("trace_glXBindChannelToWindowSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  int  ret = Trace::glXBindChannelToWindowSGIX(display, screen, channel, window);
  return ret;
}

static int REGAL_CALL trace_glXChannelRectSGIX(Display *display, int screen, int channel, int x, int y, int w, int h)
{
  Internal("trace_glXChannelRectSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  int  ret = Trace::glXChannelRectSGIX(display, screen, channel, x, y, w, h);
  return ret;
}

static int REGAL_CALL trace_glXChannelRectSyncSGIX(Display *display, int screen, int channel, GLenum synctype)
{
  Internal("trace_glXChannelRectSyncSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  int  ret = Trace::glXChannelRectSyncSGIX(display, screen, channel, synctype);
  return ret;
}

static int REGAL_CALL trace_glXQueryChannelDeltasSGIX(Display *display, int screen, int channel, int *x, int *y, int *w, int *h)
{
  Internal("trace_glXQueryChannelDeltasSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  int  ret = Trace::glXQueryChannelDeltasSGIX(display, screen, channel, x, y, w, h);
  return ret;
}

static int REGAL_CALL trace_glXQueryChannelRectSGIX(Display *display, int screen, int channel, int *dx, int *dy, int *dw, int *dh)
{
  Internal("trace_glXQueryChannelRectSGIX","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  int  ret = Trace::glXQueryChannelRectSGIX(display, screen, channel, dx, dy, dw, dh);
  return ret;
}

// GLX_SGI_cushion

static void REGAL_CALL trace_glXCushionSGI(Display *dpy, Window window, float cushion)
{
  Internal("trace_glXCushionSGI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Trace::glXCushionSGI(dpy, window, cushion);
}

// GLX_SGI_make_current_read

static GLXDrawable REGAL_CALL trace_glXGetCurrentReadDrawableSGI(void)
{
  Internal("trace_glXGetCurrentReadDrawableSGI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  GLXDrawable  ret = Trace::glXGetCurrentReadDrawableSGI();
  return ret;
}

static Bool REGAL_CALL trace_glXMakeCurrentReadSGI(Display *dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx)
{
  Internal("trace_glXMakeCurrentReadSGI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Bool  ret = Trace::glXMakeCurrentReadSGI(dpy, draw, read, ctx);
  return ret;
}

// GLX_SGI_swap_control

static int REGAL_CALL trace_glXSwapIntervalSGI(int interval)
{
  Internal("trace_glXSwapIntervalSGI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  int  ret = Trace::glXSwapIntervalSGI(interval);
  return ret;
}

// GLX_SGI_video_sync

static int REGAL_CALL trace_glXGetVideoSyncSGI(unsigned int *count)
{
  Internal("trace_glXGetVideoSyncSGI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  int  ret = Trace::glXGetVideoSyncSGI(count);
  return ret;
}

static int REGAL_CALL trace_glXWaitVideoSyncSGI(int divisor, int remainder, unsigned int *count)
{
  Internal("trace_glXWaitVideoSyncSGI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  int  ret = Trace::glXWaitVideoSyncSGI(divisor, remainder, count);
  return ret;
}

#endif // REGAL_SYS_GLX

#if REGAL_SYS_OSX

// CGL_VERSION_1_0

static CGLError REGAL_CALL trace_CGLChoosePixelFormat(const CGLPixelFormatAttribute *attribs, CGLPixelFormatObj *pix, GLint *npix)
{
  Internal("trace_CGLChoosePixelFormat","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  CGLError  ret = Trace::CGLChoosePixelFormat(attribs, pix, npix);
  return ret;
}

static CGLError REGAL_CALL trace_CGLClearDrawable(CGLContextObj ctx)
{
  Internal("trace_CGLClearDrawable","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  CGLError  ret = Trace::CGLClearDrawable(ctx);
  return ret;
}

static CGLError REGAL_CALL trace_CGLCopyContext(CGLContextObj src, CGLContextObj dst, GLbitfield mask)
{
  Internal("trace_CGLCopyContext","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  CGLError  ret = Trace::CGLCopyContext(src, dst, mask);
  return ret;
}

static CGLError REGAL_CALL trace_CGLCreateContext(CGLPixelFormatObj pix, CGLContextObj share, CGLContextObj *ctx)
{
  Internal("trace_CGLCreateContext","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  CGLError  ret = Trace::CGLCreateContext(pix, share, ctx);
  return ret;
}

static CGLError REGAL_CALL trace_CGLDescribePixelFormat(CGLPixelFormatObj pix, GLint pix_num, CGLPixelFormatAttribute attrib, GLint *value)
{
  Internal("trace_CGLDescribePixelFormat","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  CGLError  ret = Trace::CGLDescribePixelFormat(pix, pix_num, attrib, value);
  return ret;
}

static CGLError REGAL_CALL trace_CGLDescribeRenderer(CGLRendererInfoObj rend, GLint rend_num, CGLRendererProperty prop, GLint *value)
{
  Internal("trace_CGLDescribeRenderer","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  CGLError  ret = Trace::CGLDescribeRenderer(rend, rend_num, prop, value);
  return ret;
}

static CGLError REGAL_CALL trace_CGLDestroyContext(CGLContextObj ctx)
{
  Internal("trace_CGLDestroyContext","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  CGLError  ret = Trace::CGLDestroyContext(ctx);
  return ret;
}

static CGLError REGAL_CALL trace_CGLDestroyPixelFormat(CGLPixelFormatObj pix)
{
  Internal("trace_CGLDestroyPixelFormat","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  CGLError  ret = Trace::CGLDestroyPixelFormat(pix);
  return ret;
}

static CGLError REGAL_CALL trace_CGLDestroyRendererInfo(CGLRendererInfoObj rend)
{
  Internal("trace_CGLDestroyRendererInfo","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  CGLError  ret = Trace::CGLDestroyRendererInfo(rend);
  return ret;
}

static CGLError REGAL_CALL trace_CGLDisable(CGLContextObj ctx, CGLContextEnable pname)
{
  Internal("trace_CGLDisable","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  CGLError  ret = Trace::CGLDisable(ctx, pname);
  return ret;
}

static CGLError REGAL_CALL trace_CGLEnable(CGLContextObj ctx, CGLContextEnable pname)
{
  Internal("trace_CGLEnable","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  CGLError  ret = Trace::CGLEnable(ctx, pname);
  return ret;
}

static const char *REGAL_CALL trace_CGLErrorString(CGLError error)
{
  Internal("trace_CGLErrorString","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  const char * ret = Trace::CGLErrorString(error);
  return ret;
}

static CGLError REGAL_CALL trace_CGLFlushDrawable(CGLContextObj ctx)
{
  Internal("trace_CGLFlushDrawable","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  CGLError  ret = Trace::CGLFlushDrawable(ctx);
  return ret;
}

static CGLError REGAL_CALL trace_CGLGetOffScreen(CGLContextObj ctx, GLsizei *width, GLsizei *height, GLsizei *rowbytes, void **baseaddr)
{
  Internal("trace_CGLGetOffScreen","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  CGLError  ret = Trace::CGLGetOffScreen(ctx, width, height, rowbytes, baseaddr);
  return ret;
}

static CGLError REGAL_CALL trace_CGLGetOption(CGLGlobalOption pname, GLint *param)
{
  Internal("trace_CGLGetOption","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  CGLError  ret = Trace::CGLGetOption(pname, param);
  return ret;
}

static CGLError REGAL_CALL trace_CGLGetParameter(CGLContextObj ctx, CGLContextParameter pname, GLint *params)
{
  Internal("trace_CGLGetParameter","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  CGLError  ret = Trace::CGLGetParameter(ctx, pname, params);
  return ret;
}

static void REGAL_CALL trace_CGLGetVersion(GLint *majorvers, GLint *minorvers)
{
  Internal("trace_CGLGetVersion","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Trace::CGLGetVersion(majorvers, minorvers);
}

static CGLError REGAL_CALL trace_CGLGetVirtualScreen(CGLContextObj ctx, GLint *screen)
{
  Internal("trace_CGLGetVirtualScreen","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  CGLError  ret = Trace::CGLGetVirtualScreen(ctx, screen);
  return ret;
}

static CGLError REGAL_CALL trace_CGLIsEnabled(CGLContextObj ctx, CGLContextEnable pname, GLint *enable)
{
  Internal("trace_CGLIsEnabled","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  CGLError  ret = Trace::CGLIsEnabled(ctx, pname, enable);
  return ret;
}

static CGLError REGAL_CALL trace_CGLQueryRendererInfo(GLuint display_mask, CGLRendererInfoObj *rend, GLint *nrend)
{
  Internal("trace_CGLQueryRendererInfo","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  CGLError  ret = Trace::CGLQueryRendererInfo(display_mask, rend, nrend);
  return ret;
}

static CGLError REGAL_CALL trace_CGLSetFullScreen(CGLContextObj ctx)
{
  Internal("trace_CGLSetFullScreen","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  CGLError  ret = Trace::CGLSetFullScreen(ctx);
  return ret;
}

static CGLError REGAL_CALL trace_CGLSetOffScreen(CGLContextObj ctx, GLsizei width, GLsizei height, GLsizei rowbytes, void *baseaddr)
{
  Internal("trace_CGLSetOffScreen","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  CGLError  ret = Trace::CGLSetOffScreen(ctx, width, height, rowbytes, baseaddr);
  return ret;
}

static CGLError REGAL_CALL trace_CGLSetOption(CGLGlobalOption pname, GLint param)
{
  Internal("trace_CGLSetOption","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  CGLError  ret = Trace::CGLSetOption(pname, param);
  return ret;
}

static CGLError REGAL_CALL trace_CGLSetParameter(CGLContextObj ctx, CGLContextParameter pname, const GLint *params)
{
  Internal("trace_CGLSetParameter","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  CGLError  ret = Trace::CGLSetParameter(ctx, pname, params);
  return ret;
}

static CGLError REGAL_CALL trace_CGLSetVirtualScreen(CGLContextObj ctx, GLint screen)
{
  Internal("trace_CGLSetVirtualScreen","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  CGLError  ret = Trace::CGLSetVirtualScreen(ctx, screen);
  return ret;
}

// CGL_VERSION_1_1

static CGLError REGAL_CALL trace_CGLCreatePBuffer(GLsizei width, GLsizei height, GLenum target, GLenum internalFormat, GLint max_level, CGLPBufferObj *pbuffer)
{
  Internal("trace_CGLCreatePBuffer","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  CGLError  ret = Trace::CGLCreatePBuffer(width, height, target, internalFormat, max_level, pbuffer);
  return ret;
}

static CGLError REGAL_CALL trace_CGLDescribePBuffer(CGLPBufferObj pbuffer, GLsizei *width, GLsizei *height, GLenum *target, GLenum *internalFormat, GLint *mipmap)
{
  Internal("trace_CGLDescribePBuffer","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  CGLError  ret = Trace::CGLDescribePBuffer(pbuffer, width, height, target, internalFormat, mipmap);
  return ret;
}

static CGLError REGAL_CALL trace_CGLDestroyPBuffer(CGLPBufferObj pbuffer)
{
  Internal("trace_CGLDestroyPBuffer","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  CGLError  ret = Trace::CGLDestroyPBuffer(pbuffer);
  return ret;
}

static CGLError REGAL_CALL trace_CGLGetPBuffer(CGLContextObj ctx, CGLPBufferObj *pbuffer, GLenum *face, GLint *level, GLint *screen)
{
  Internal("trace_CGLGetPBuffer","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  CGLError  ret = Trace::CGLGetPBuffer(ctx, pbuffer, face, level, screen);
  return ret;
}

static CGLError REGAL_CALL trace_CGLSetPBuffer(CGLContextObj ctx, CGLPBufferObj pbuffer, GLenum face, GLint level, GLint screen)
{
  Internal("trace_CGLSetPBuffer","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  CGLError  ret = Trace::CGLSetPBuffer(ctx, pbuffer, face, level, screen);
  return ret;
}

static CGLError REGAL_CALL trace_CGLTexImagePBuffer(CGLContextObj ctx, CGLPBufferObj pbuffer, GLenum source)
{
  Internal("trace_CGLTexImagePBuffer","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  CGLError  ret = Trace::CGLTexImagePBuffer(ctx, pbuffer, source);
  return ret;
}

// CGL_VERSION_1_2

static GLuint REGAL_CALL trace_CGLGetContextRetainCount(CGLContextObj ctx)
{
  Internal("trace_CGLGetContextRetainCount","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  GLuint  ret = Trace::CGLGetContextRetainCount(ctx);
  return ret;
}

static CGLError REGAL_CALL trace_CGLGetGlobalOption(CGLGlobalOption pname, GLint *params)
{
  Internal("trace_CGLGetGlobalOption","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  CGLError  ret = Trace::CGLGetGlobalOption(pname, params);
  return ret;
}

static GLuint REGAL_CALL trace_CGLGetPBufferRetainCount(CGLPBufferObj pbuffer)
{
  Internal("trace_CGLGetPBufferRetainCount","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  GLuint  ret = Trace::CGLGetPBufferRetainCount(pbuffer);
  return ret;
}

static CGLPixelFormatObj REGAL_CALL trace_CGLGetPixelFormat(CGLContextObj ctx)
{
  Internal("trace_CGLGetPixelFormat","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  CGLPixelFormatObj  ret = Trace::CGLGetPixelFormat(ctx);
  return ret;
}

static GLuint REGAL_CALL trace_CGLGetPixelFormatRetainCount(CGLPixelFormatObj pix)
{
  Internal("trace_CGLGetPixelFormatRetainCount","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  GLuint  ret = Trace::CGLGetPixelFormatRetainCount(pix);
  return ret;
}

static CGLError REGAL_CALL trace_CGLLockContext(CGLContextObj ctx)
{
  Internal("trace_CGLLockContext","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  CGLError  ret = Trace::CGLLockContext(ctx);
  return ret;
}

static void REGAL_CALL trace_CGLReleaseContext(CGLContextObj ctx)
{
  Internal("trace_CGLReleaseContext","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Trace::CGLReleaseContext(ctx);
}

static void REGAL_CALL trace_CGLReleasePBuffer(CGLPBufferObj pbuffer)
{
  Internal("trace_CGLReleasePBuffer","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Trace::CGLReleasePBuffer(pbuffer);
}

static void REGAL_CALL trace_CGLReleasePixelFormat(CGLPixelFormatObj pix)
{
  Internal("trace_CGLReleasePixelFormat","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  Trace::CGLReleasePixelFormat(pix);
}

static CGLContextObj REGAL_CALL trace_CGLRetainContext(CGLContextObj ctx)
{
  Internal("trace_CGLRetainContext","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  CGLContextObj  ret = Trace::CGLRetainContext(ctx);
  return ret;
}

static CGLPBufferObj REGAL_CALL trace_CGLRetainPBuffer(CGLPBufferObj pbuffer)
{
  Internal("trace_CGLRetainPBuffer","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  CGLPBufferObj  ret = Trace::CGLRetainPBuffer(pbuffer);
  return ret;
}

static CGLPixelFormatObj REGAL_CALL trace_CGLRetainPixelFormat(CGLPixelFormatObj pix)
{
  Internal("trace_CGLRetainPixelFormat","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  CGLPixelFormatObj  ret = Trace::CGLRetainPixelFormat(pix);
  return ret;
}

static CGLError REGAL_CALL trace_CGLSetGlobalOption(CGLGlobalOption pname, const GLint *params)
{
  Internal("trace_CGLSetGlobalOption","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  CGLError  ret = Trace::CGLSetGlobalOption(pname, params);
  return ret;
}

static CGLError REGAL_CALL trace_CGLUnlockContext(CGLContextObj ctx)
{
  Internal("trace_CGLUnlockContext","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  CGLError  ret = Trace::CGLUnlockContext(ctx);
  return ret;
}

// CGL_VERSION_1_3

static CGLContextObj REGAL_CALL trace_CGLGetCurrentContext(void)
{
  Internal("trace_CGLGetCurrentContext","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  CGLContextObj  ret = Trace::CGLGetCurrentContext();
  return ret;
}

static CGLShareGroupObj REGAL_CALL trace_CGLGetShareGroup(CGLContextObj ctx)
{
  Internal("trace_CGLGetShareGroup","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  CGLShareGroupObj  ret = Trace::CGLGetShareGroup(ctx);
  return ret;
}

static CGLError REGAL_CALL trace_CGLGetSurface(CGLContextObj ctx, CGSConnectionID *conn, CGSWindowID *win, CGSSurfaceID *srf)
{
  Internal("trace_CGLGetSurface","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  CGLError  ret = Trace::CGLGetSurface(ctx, conn, win, srf);
  return ret;
}

static CGLError REGAL_CALL trace_CGLSetCurrentContext(CGLContextObj ctx)
{
  Internal("trace_CGLSetCurrentContext","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  CGLError  ret = Trace::CGLSetCurrentContext(ctx);
  return ret;
}

static CGLError REGAL_CALL trace_CGLSetSurface(CGLContextObj ctx, CGSConnectionID conn, CGSWindowID win, CGSSurfaceID srf)
{
  Internal("trace_CGLSetSurface","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  CGLError  ret = Trace::CGLSetSurface(ctx, conn, win, srf);
  return ret;
}

static CGLError REGAL_CALL trace_CGLTexImageIOSurface2D(CGLContextObj ctx, GLenum target, GLenum internal_format, GLsizei width, GLsizei height, GLenum format, GLenum type, IOSurfaceRef ioSurface, GLuint plane)
{
  Internal("trace_CGLTexImageIOSurface2D","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  CGLError  ret = Trace::CGLTexImageIOSurface2D(ctx, target, internal_format, width, height, format, type, ioSurface, plane);
  return ret;
}

static CGLError REGAL_CALL trace_CGLUpdateContext(CGLContextObj ctx)
{
  Internal("trace_CGLUpdateContext","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  CGLError  ret = Trace::CGLUpdateContext(ctx);
  return ret;
}

#endif // REGAL_SYS_OSX

#if REGAL_SYS_EGL

// EGL_ANGLE_query_surface_pointer

static EGLBoolean REGAL_CALL trace_eglQuerySurfacePointerANGLE(EGLDisplay dpy, EGLSurface surface, EGLint attribute, GLvoid **value)
{
  Internal("trace_eglQuerySurfacePointerANGLE","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  EGLBoolean  ret = Trace::eglQuerySurfacePointerANGLE(dpy, surface, attribute, value);
  return ret;
}

// EGL_KHR_fence_sync

static EGLint REGAL_CALL trace_eglClientWaitSyncKHR(EGLDisplay dpy, EGLSyncKHR GLsync, EGLint flags, EGLTimeKHR timeout)
{
  Internal("trace_eglClientWaitSyncKHR","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  EGLint  ret = Trace::eglClientWaitSyncKHR(dpy, GLsync, flags, timeout);
  return ret;
}

static EGLSyncKHR REGAL_CALL trace_eglCreateSyncKHR(EGLDisplay dpy, EGLenum type, const EGLint *attrib_list)
{
  Internal("trace_eglCreateSyncKHR","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  EGLSyncKHR  ret = Trace::eglCreateSyncKHR(dpy, type, attrib_list);
  return ret;
}

static EGLBoolean REGAL_CALL trace_eglDestroySyncKHR(EGLDisplay dpy, EGLSyncKHR GLsync)
{
  Internal("trace_eglDestroySyncKHR","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  EGLBoolean  ret = Trace::eglDestroySyncKHR(dpy, GLsync);
  return ret;
}

static EGLBoolean REGAL_CALL trace_eglGetSyncAttribKHR(EGLDisplay dpy, EGLSyncKHR GLsync, EGLint attribute, EGLint *value)
{
  Internal("trace_eglGetSyncAttribKHR","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  EGLBoolean  ret = Trace::eglGetSyncAttribKHR(dpy, GLsync, attribute, value);
  return ret;
}

// EGL_KHR_image_base

static EGLImageKHR REGAL_CALL trace_eglCreateImageKHR(EGLDisplay dpy, EGLContext ctx, EGLenum target, EGLClientBuffer buffer, const EGLint *attrib_list)
{
  Internal("trace_eglCreateImageKHR","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  EGLImageKHR  ret = Trace::eglCreateImageKHR(dpy, ctx, target, buffer, attrib_list);
  return ret;
}

static EGLBoolean REGAL_CALL trace_eglDestroyImageKHR(EGLDisplay dpy, EGLImageKHR image)
{
  Internal("trace_eglDestroyImageKHR","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  EGLBoolean  ret = Trace::eglDestroyImageKHR(dpy, image);
  return ret;
}

// EGL_KHR_lock_surface

static EGLBoolean REGAL_CALL trace_eglLockSurfaceKHR(EGLDisplay display, EGLSurface surface, const EGLint *attrib_list)
{
  Internal("trace_eglLockSurfaceKHR","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  EGLBoolean  ret = Trace::eglLockSurfaceKHR(display, surface, attrib_list);
  return ret;
}

static EGLBoolean REGAL_CALL trace_eglUnlockSurfaceKHR(EGLDisplay display, EGLSurface surface)
{
  Internal("trace_eglUnlockSurfaceKHR","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  EGLBoolean  ret = Trace::eglUnlockSurfaceKHR(display, surface);
  return ret;
}

// EGL_MESA_drm_image

static EGLImageKHR REGAL_CALL trace_eglCreateDRMImageMESA(EGLDisplay dpy, const EGLint *attrib_list)
{
  Internal("trace_eglCreateDRMImageMESA","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  EGLImageKHR  ret = Trace::eglCreateDRMImageMESA(dpy, attrib_list);
  return ret;
}

static EGLBoolean REGAL_CALL trace_eglExportDRMImageMESA(EGLDisplay dpy, EGLImageKHR image, EGLint *name, EGLint *handle, EGLint *stride)
{
  Internal("trace_eglExportDRMImageMESA","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  EGLBoolean  ret = Trace::eglExportDRMImageMESA(dpy, image, name, handle, stride);
  return ret;
}

// EGL_NV_post_sub_buffer

static EGLBoolean REGAL_CALL trace_eglPostSubBufferNV(EGLDisplay dpy, EGLSurface surface, EGLint x, EGLint y, EGLint width, EGLint height)
{
  Internal("trace_eglPostSubBufferNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  EGLBoolean  ret = Trace::eglPostSubBufferNV(dpy, surface, x, y, width, height);
  return ret;
}

// EGL_NV_sync

static EGLint REGAL_CALL trace_eglClientWaitSyncNV(EGLSyncNV GLsync, EGLint flags, EGLTimeNV timeout)
{
  Internal("trace_eglClientWaitSyncNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  EGLint  ret = Trace::eglClientWaitSyncNV(GLsync, flags, timeout);
  return ret;
}

static EGLSyncNV REGAL_CALL trace_eglCreateFenceSyncNV(EGLDisplay dpy, EGLenum condition, const EGLint *attrib_list)
{
  Internal("trace_eglCreateFenceSyncNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  EGLSyncNV  ret = Trace::eglCreateFenceSyncNV(dpy, condition, attrib_list);
  return ret;
}

static EGLBoolean REGAL_CALL trace_eglDestroySyncNV(EGLSyncNV GLsync)
{
  Internal("trace_eglDestroySyncNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  EGLBoolean  ret = Trace::eglDestroySyncNV(GLsync);
  return ret;
}

static EGLBoolean REGAL_CALL trace_eglFenceNV(EGLSyncNV GLsync)
{
  Internal("trace_eglFenceNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  EGLBoolean  ret = Trace::eglFenceNV(GLsync);
  return ret;
}

static EGLBoolean REGAL_CALL trace_eglGetSyncAttribNV(EGLSyncNV GLsync, EGLint attribute, EGLint *value)
{
  Internal("trace_eglGetSyncAttribNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  EGLBoolean  ret = Trace::eglGetSyncAttribNV(GLsync, attribute, value);
  return ret;
}

static EGLBoolean REGAL_CALL trace_eglSignalSyncNV(EGLSyncNV GLsync, EGLenum mode)
{
  Internal("trace_eglSignalSyncNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  EGLBoolean  ret = Trace::eglSignalSyncNV(GLsync, mode);
  return ret;
}

// EGL_NV_system_time

static EGLuint64NV REGAL_CALL trace_eglGetSystemTimeFrequencyNV(void)
{
  Internal("trace_eglGetSystemTimeFrequencyNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  EGLuint64NV  ret = Trace::eglGetSystemTimeFrequencyNV();
  return ret;
}

static EGLuint64NV REGAL_CALL trace_eglGetSystemTimeNV(void)
{
  Internal("trace_eglGetSystemTimeNV","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  EGLuint64NV  ret = Trace::eglGetSystemTimeNV();
  return ret;
}

// EGL_VERSION_1_0

static EGLBoolean REGAL_CALL trace_eglChooseConfig(EGLDisplay dpy, const EGLint *attrib_list, EGLConfig *configs, EGLint config_size, EGLint *num_config)
{
  Internal("trace_eglChooseConfig","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  EGLBoolean  ret = Trace::eglChooseConfig(dpy, attrib_list, configs, config_size, num_config);
  return ret;
}

static EGLBoolean REGAL_CALL trace_eglCopyBuffers(EGLDisplay dpy, EGLSurface surface, EGLNativePixmapType target)
{
  Internal("trace_eglCopyBuffers","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  EGLBoolean  ret = Trace::eglCopyBuffers(dpy, surface, target);
  return ret;
}

static EGLContext REGAL_CALL trace_eglCreateContext(EGLDisplay dpy, EGLConfig config, EGLContext share_context, const EGLint *attrib_list)
{
  Internal("trace_eglCreateContext","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  EGLContext  ret = Trace::eglCreateContext(dpy, config, share_context, attrib_list);
  return ret;
}

static EGLSurface REGAL_CALL trace_eglCreatePbufferSurface(EGLDisplay dpy, EGLConfig config, const EGLint *attrib_list)
{
  Internal("trace_eglCreatePbufferSurface","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  EGLSurface  ret = Trace::eglCreatePbufferSurface(dpy, config, attrib_list);
  return ret;
}

static EGLSurface REGAL_CALL trace_eglCreatePixmapSurface(EGLDisplay dpy, EGLConfig config, EGLNativePixmapType pixmap, const EGLint *attrib_list)
{
  Internal("trace_eglCreatePixmapSurface","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  EGLSurface  ret = Trace::eglCreatePixmapSurface(dpy, config, pixmap, attrib_list);
  return ret;
}

static EGLSurface REGAL_CALL trace_eglCreateWindowSurface(EGLDisplay dpy, EGLConfig config, EGLNativeWindowType win, const EGLint *attrib_list)
{
  Internal("trace_eglCreateWindowSurface","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  EGLSurface  ret = Trace::eglCreateWindowSurface(dpy, config, win, attrib_list);
  return ret;
}

static EGLBoolean REGAL_CALL trace_eglDestroyContext(EGLDisplay dpy, EGLContext ctx)
{
  Internal("trace_eglDestroyContext","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  EGLBoolean  ret = Trace::eglDestroyContext(dpy, ctx);
  return ret;
}

static EGLBoolean REGAL_CALL trace_eglDestroySurface(EGLDisplay dpy, EGLSurface surface)
{
  Internal("trace_eglDestroySurface","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  EGLBoolean  ret = Trace::eglDestroySurface(dpy, surface);
  return ret;
}

static EGLBoolean REGAL_CALL trace_eglGetConfigAttrib(EGLDisplay dpy, EGLConfig config, EGLint attribute, EGLint *value)
{
  Internal("trace_eglGetConfigAttrib","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  EGLBoolean  ret = Trace::eglGetConfigAttrib(dpy, config, attribute, value);
  return ret;
}

static EGLBoolean REGAL_CALL trace_eglGetConfigs(EGLDisplay dpy, EGLConfig *configs, EGLint config_size, EGLint *num_config)
{
  Internal("trace_eglGetConfigs","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  EGLBoolean  ret = Trace::eglGetConfigs(dpy, configs, config_size, num_config);
  return ret;
}

static EGLContext REGAL_CALL trace_eglGetCurrentContext(void)
{
  Internal("trace_eglGetCurrentContext","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  EGLContext  ret = Trace::eglGetCurrentContext();
  return ret;
}

static EGLDisplay REGAL_CALL trace_eglGetCurrentDisplay(void)
{
  Internal("trace_eglGetCurrentDisplay","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  EGLDisplay  ret = Trace::eglGetCurrentDisplay();
  return ret;
}

static EGLSurface REGAL_CALL trace_eglGetCurrentSurface(EGLint readdraw)
{
  Internal("trace_eglGetCurrentSurface","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  EGLSurface  ret = Trace::eglGetCurrentSurface(readdraw);
  return ret;
}

static EGLDisplay REGAL_CALL trace_eglGetDisplay(EGLNativeDisplayType display_id)
{
  Internal("trace_eglGetDisplay","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  EGLDisplay  ret = Trace::eglGetDisplay(display_id);
  return ret;
}

static EGLint REGAL_CALL trace_eglGetError(void)
{
  Internal("trace_eglGetError","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  EGLint  ret = Trace::eglGetError();
  return ret;
}

static __eglMustCastToProperFunctionPointerType REGAL_CALL trace_eglGetProcAddress(const char *procname)
{
  Internal("trace_eglGetProcAddress","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  __eglMustCastToProperFunctionPointerType  ret = Trace::eglGetProcAddress(procname);
  return ret;
}

static EGLBoolean REGAL_CALL trace_eglInitialize(EGLDisplay dpy, EGLint *major, EGLint *minor)
{
  Internal("trace_eglInitialize","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  EGLBoolean  ret = Trace::eglInitialize(dpy, major, minor);
  return ret;
}

static EGLBoolean REGAL_CALL trace_eglMakeCurrent(EGLDisplay dpy, EGLSurface draw, EGLSurface read, EGLContext ctx)
{
  Internal("trace_eglMakeCurrent","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  EGLBoolean  ret = Trace::eglMakeCurrent(dpy, draw, read, ctx);
  return ret;
}

static EGLBoolean REGAL_CALL trace_eglQueryContext(EGLDisplay dpy, EGLContext ctx, EGLint attribute, EGLint *value)
{
  Internal("trace_eglQueryContext","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  EGLBoolean  ret = Trace::eglQueryContext(dpy, ctx, attribute, value);
  return ret;
}

static const char *REGAL_CALL trace_eglQueryString(EGLDisplay dpy, EGLint name)
{
  Internal("trace_eglQueryString","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  const char * ret = Trace::eglQueryString(dpy, name);
  return ret;
}

static EGLBoolean REGAL_CALL trace_eglQuerySurface(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint *value)
{
  Internal("trace_eglQuerySurface","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  EGLBoolean  ret = Trace::eglQuerySurface(dpy, surface, attribute, value);
  return ret;
}

static EGLBoolean REGAL_CALL trace_eglSwapBuffers(EGLDisplay dpy, EGLSurface surface)
{
  Internal("trace_eglSwapBuffers","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  EGLBoolean  ret = Trace::eglSwapBuffers(dpy, surface);
  return ret;
}

static EGLBoolean REGAL_CALL trace_eglTerminate(EGLDisplay dpy)
{
  Internal("trace_eglTerminate","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  EGLBoolean  ret = Trace::eglTerminate(dpy);
  return ret;
}

static EGLBoolean REGAL_CALL trace_eglWaitGL(void)
{
  Internal("trace_eglWaitGL","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  EGLBoolean  ret = Trace::eglWaitGL();
  return ret;
}

static EGLBoolean REGAL_CALL trace_eglWaitNative(EGLint engine)
{
  Internal("trace_eglWaitNative","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  EGLBoolean  ret = Trace::eglWaitNative(engine);
  return ret;
}

// EGL_VERSION_1_1

static EGLBoolean REGAL_CALL trace_eglBindTexImage(EGLDisplay dpy, EGLSurface surface, EGLint buffer)
{
  Internal("trace_eglBindTexImage","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  EGLBoolean  ret = Trace::eglBindTexImage(dpy, surface, buffer);
  return ret;
}

static EGLBoolean REGAL_CALL trace_eglReleaseTexImage(EGLDisplay dpy, EGLSurface surface, EGLint buffer)
{
  Internal("trace_eglReleaseTexImage","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  EGLBoolean  ret = Trace::eglReleaseTexImage(dpy, surface, buffer);
  return ret;
}

// EGL_VERSION_1_2

static EGLBoolean REGAL_CALL trace_eglBindAPI(EGLenum api)
{
  Internal("trace_eglBindAPI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  EGLBoolean  ret = Trace::eglBindAPI(api);
  return ret;
}

static EGLSurface REGAL_CALL trace_eglCreatePbufferFromClientBuffer(EGLDisplay dpy, EGLenum buftype, EGLClientBuffer buffer, EGLConfig config, const EGLint *attrib_list)
{
  Internal("trace_eglCreatePbufferFromClientBuffer","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  EGLSurface  ret = Trace::eglCreatePbufferFromClientBuffer(dpy, buftype, buffer, config, attrib_list);
  return ret;
}

static EGLenum REGAL_CALL trace_eglQueryAPI(void)
{
  Internal("trace_eglQueryAPI","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  EGLenum  ret = Trace::eglQueryAPI();
  return ret;
}

static EGLBoolean REGAL_CALL trace_eglReleaseThread(void)
{
  Internal("trace_eglReleaseThread","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  EGLBoolean  ret = Trace::eglReleaseThread();
  return ret;
}

static EGLBoolean REGAL_CALL trace_eglSurfaceAttrib(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint value)
{
  Internal("trace_eglSurfaceAttrib","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  EGLBoolean  ret = Trace::eglSurfaceAttrib(dpy, surface, attribute, value);
  return ret;
}

static EGLBoolean REGAL_CALL trace_eglSwapInterval(EGLDisplay dpy, EGLint interval)
{
  Internal("trace_eglSwapInterval","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  EGLBoolean  ret = Trace::eglSwapInterval(dpy, interval);
  return ret;
}

static EGLBoolean REGAL_CALL trace_eglWaitClient(void)
{
  Internal("trace_eglWaitClient","()");
  Thread::ThreadLocal &_instance = Thread::ThreadLocal::instance();
  Push<DispatchTableGlobal *> _push(_instance.nextDispatchTableGlobal);
  _instance.nextDispatchTableGlobal = dispatcherGlobal.trace.next();
  EGLBoolean  ret = Trace::eglWaitClient();
  return ret;
}

#endif // REGAL_SYS_EGL

void InitDispatchTableTrace(DispatchTableGL &tbl)
{

  // GL_VERSION_1_0

  tbl.glAccum = trace_glAccum;
  tbl.glAlphaFunc = trace_glAlphaFunc;
  tbl.glBegin = trace_glBegin;
  tbl.glBitmap = trace_glBitmap;
  tbl.glBlendFunc = trace_glBlendFunc;
  tbl.glCallList = trace_glCallList;
  tbl.glCallLists = trace_glCallLists;
  tbl.glClear = trace_glClear;
  tbl.glClearAccum = trace_glClearAccum;
  tbl.glClearColor = trace_glClearColor;
  tbl.glClearDepth = trace_glClearDepth;
  tbl.glClearIndex = trace_glClearIndex;
  tbl.glClearStencil = trace_glClearStencil;
  tbl.glClipPlane = trace_glClipPlane;
  tbl.glColor3b = trace_glColor3b;
  tbl.glColor3bv = trace_glColor3bv;
  tbl.glColor3d = trace_glColor3d;
  tbl.glColor3dv = trace_glColor3dv;
  tbl.glColor3f = trace_glColor3f;
  tbl.glColor3fv = trace_glColor3fv;
  tbl.glColor3i = trace_glColor3i;
  tbl.glColor3iv = trace_glColor3iv;
  tbl.glColor3s = trace_glColor3s;
  tbl.glColor3sv = trace_glColor3sv;
  tbl.glColor3ub = trace_glColor3ub;
  tbl.glColor3ubv = trace_glColor3ubv;
  tbl.glColor3ui = trace_glColor3ui;
  tbl.glColor3uiv = trace_glColor3uiv;
  tbl.glColor3us = trace_glColor3us;
  tbl.glColor3usv = trace_glColor3usv;
  tbl.glColor4b = trace_glColor4b;
  tbl.glColor4bv = trace_glColor4bv;
  tbl.glColor4d = trace_glColor4d;
  tbl.glColor4dv = trace_glColor4dv;
  tbl.glColor4f = trace_glColor4f;
  tbl.glColor4fv = trace_glColor4fv;
  tbl.glColor4i = trace_glColor4i;
  tbl.glColor4iv = trace_glColor4iv;
  tbl.glColor4s = trace_glColor4s;
  tbl.glColor4sv = trace_glColor4sv;
  tbl.glColor4ub = trace_glColor4ub;
  tbl.glColor4ubv = trace_glColor4ubv;
  tbl.glColor4ui = trace_glColor4ui;
  tbl.glColor4uiv = trace_glColor4uiv;
  tbl.glColor4us = trace_glColor4us;
  tbl.glColor4usv = trace_glColor4usv;
  tbl.glColorMask = trace_glColorMask;
  tbl.glColorMaterial = trace_glColorMaterial;
  tbl.glCopyPixels = trace_glCopyPixels;
  tbl.glCullFace = trace_glCullFace;
  tbl.glDeleteLists = trace_glDeleteLists;
  tbl.glDepthFunc = trace_glDepthFunc;
  tbl.glDepthMask = trace_glDepthMask;
  tbl.glDepthRange = trace_glDepthRange;
  tbl.glDisable = trace_glDisable;
  tbl.glDrawBuffer = trace_glDrawBuffer;
  tbl.glDrawPixels = trace_glDrawPixels;
  tbl.glEdgeFlag = trace_glEdgeFlag;
  tbl.glEdgeFlagv = trace_glEdgeFlagv;
  tbl.glEnable = trace_glEnable;
  tbl.glEnd = trace_glEnd;
  tbl.glEndList = trace_glEndList;
  tbl.glEvalCoord1d = trace_glEvalCoord1d;
  tbl.glEvalCoord1dv = trace_glEvalCoord1dv;
  tbl.glEvalCoord1f = trace_glEvalCoord1f;
  tbl.glEvalCoord1fv = trace_glEvalCoord1fv;
  tbl.glEvalCoord2d = trace_glEvalCoord2d;
  tbl.glEvalCoord2dv = trace_glEvalCoord2dv;
  tbl.glEvalCoord2f = trace_glEvalCoord2f;
  tbl.glEvalCoord2fv = trace_glEvalCoord2fv;
  tbl.glEvalMesh1 = trace_glEvalMesh1;
  tbl.glEvalMesh2 = trace_glEvalMesh2;
  tbl.glEvalPoint1 = trace_glEvalPoint1;
  tbl.glEvalPoint2 = trace_glEvalPoint2;
  tbl.glFeedbackBuffer = trace_glFeedbackBuffer;
  tbl.glFinish = trace_glFinish;
  tbl.glFlush = trace_glFlush;
  tbl.glFogf = trace_glFogf;
  tbl.glFogfv = trace_glFogfv;
  tbl.glFogi = trace_glFogi;
  tbl.glFogiv = trace_glFogiv;
  tbl.glFrontFace = trace_glFrontFace;
  tbl.glFrustum = trace_glFrustum;
  tbl.glGenLists = trace_glGenLists;
  tbl.glGetBooleanv = trace_glGetBooleanv;
  tbl.glGetClipPlane = trace_glGetClipPlane;
  tbl.glGetDoublev = trace_glGetDoublev;
  tbl.glGetError = trace_glGetError;
  tbl.glGetFloatv = trace_glGetFloatv;
  tbl.glGetIntegerv = trace_glGetIntegerv;
  tbl.glGetLightfv = trace_glGetLightfv;
  tbl.glGetLightiv = trace_glGetLightiv;
  tbl.glGetMapdv = trace_glGetMapdv;
  tbl.glGetMapfv = trace_glGetMapfv;
  tbl.glGetMapiv = trace_glGetMapiv;
  tbl.glGetMaterialfv = trace_glGetMaterialfv;
  tbl.glGetMaterialiv = trace_glGetMaterialiv;
  tbl.glGetPixelMapfv = trace_glGetPixelMapfv;
  tbl.glGetPixelMapuiv = trace_glGetPixelMapuiv;
  tbl.glGetPixelMapusv = trace_glGetPixelMapusv;
  tbl.glGetPolygonStipple = trace_glGetPolygonStipple;
  tbl.glGetString = trace_glGetString;
  tbl.glGetTexEnvfv = trace_glGetTexEnvfv;
  tbl.glGetTexEnviv = trace_glGetTexEnviv;
  tbl.glGetTexGendv = trace_glGetTexGendv;
  tbl.glGetTexGenfv = trace_glGetTexGenfv;
  tbl.glGetTexGeniv = trace_glGetTexGeniv;
  tbl.glGetTexImage = trace_glGetTexImage;
  tbl.glGetTexLevelParameterfv = trace_glGetTexLevelParameterfv;
  tbl.glGetTexLevelParameteriv = trace_glGetTexLevelParameteriv;
  tbl.glGetTexParameterfv = trace_glGetTexParameterfv;
  tbl.glGetTexParameteriv = trace_glGetTexParameteriv;
  tbl.glHint = trace_glHint;
  tbl.glIndexMask = trace_glIndexMask;
  tbl.glIndexd = trace_glIndexd;
  tbl.glIndexdv = trace_glIndexdv;
  tbl.glIndexf = trace_glIndexf;
  tbl.glIndexfv = trace_glIndexfv;
  tbl.glIndexi = trace_glIndexi;
  tbl.glIndexiv = trace_glIndexiv;
  tbl.glIndexs = trace_glIndexs;
  tbl.glIndexsv = trace_glIndexsv;
  tbl.glInitNames = trace_glInitNames;
  tbl.glIsEnabled = trace_glIsEnabled;
  tbl.glIsList = trace_glIsList;
  tbl.glLightModelf = trace_glLightModelf;
  tbl.glLightModelfv = trace_glLightModelfv;
  tbl.glLightModeli = trace_glLightModeli;
  tbl.glLightModeliv = trace_glLightModeliv;
  tbl.glLightf = trace_glLightf;
  tbl.glLightfv = trace_glLightfv;
  tbl.glLighti = trace_glLighti;
  tbl.glLightiv = trace_glLightiv;
  tbl.glLineStipple = trace_glLineStipple;
  tbl.glLineWidth = trace_glLineWidth;
  tbl.glListBase = trace_glListBase;
  tbl.glLoadIdentity = trace_glLoadIdentity;
  tbl.glLoadMatrixd = trace_glLoadMatrixd;
  tbl.glLoadMatrixf = trace_glLoadMatrixf;
  tbl.glLoadName = trace_glLoadName;
  tbl.glLogicOp = trace_glLogicOp;
  tbl.glMap1d = trace_glMap1d;
  tbl.glMap1f = trace_glMap1f;
  tbl.glMap2d = trace_glMap2d;
  tbl.glMap2f = trace_glMap2f;
  tbl.glMapGrid1d = trace_glMapGrid1d;
  tbl.glMapGrid1f = trace_glMapGrid1f;
  tbl.glMapGrid2d = trace_glMapGrid2d;
  tbl.glMapGrid2f = trace_glMapGrid2f;
  tbl.glMaterialf = trace_glMaterialf;
  tbl.glMaterialfv = trace_glMaterialfv;
  tbl.glMateriali = trace_glMateriali;
  tbl.glMaterialiv = trace_glMaterialiv;
  tbl.glMatrixMode = trace_glMatrixMode;
  tbl.glMultMatrixd = trace_glMultMatrixd;
  tbl.glMultMatrixf = trace_glMultMatrixf;
  tbl.glNewList = trace_glNewList;
  tbl.glNormal3b = trace_glNormal3b;
  tbl.glNormal3bv = trace_glNormal3bv;
  tbl.glNormal3d = trace_glNormal3d;
  tbl.glNormal3dv = trace_glNormal3dv;
  tbl.glNormal3f = trace_glNormal3f;
  tbl.glNormal3fv = trace_glNormal3fv;
  tbl.glNormal3i = trace_glNormal3i;
  tbl.glNormal3iv = trace_glNormal3iv;
  tbl.glNormal3s = trace_glNormal3s;
  tbl.glNormal3sv = trace_glNormal3sv;
  tbl.glOrtho = trace_glOrtho;
  tbl.glPassThrough = trace_glPassThrough;
  tbl.glPixelMapfv = trace_glPixelMapfv;
  tbl.glPixelMapuiv = trace_glPixelMapuiv;
  tbl.glPixelMapusv = trace_glPixelMapusv;
  tbl.glPixelStoref = trace_glPixelStoref;
  tbl.glPixelStorei = trace_glPixelStorei;
  tbl.glPixelTransferf = trace_glPixelTransferf;
  tbl.glPixelTransferi = trace_glPixelTransferi;
  tbl.glPixelZoom = trace_glPixelZoom;
  tbl.glPointSize = trace_glPointSize;
  tbl.glPolygonMode = trace_glPolygonMode;
  tbl.glPolygonStipple = trace_glPolygonStipple;
  tbl.glPopAttrib = trace_glPopAttrib;
  tbl.glPopMatrix = trace_glPopMatrix;
  tbl.glPopName = trace_glPopName;
  tbl.glPushAttrib = trace_glPushAttrib;
  tbl.glPushMatrix = trace_glPushMatrix;
  tbl.glPushName = trace_glPushName;
  tbl.glRasterPos2d = trace_glRasterPos2d;
  tbl.glRasterPos2dv = trace_glRasterPos2dv;
  tbl.glRasterPos2f = trace_glRasterPos2f;
  tbl.glRasterPos2fv = trace_glRasterPos2fv;
  tbl.glRasterPos2i = trace_glRasterPos2i;
  tbl.glRasterPos2iv = trace_glRasterPos2iv;
  tbl.glRasterPos2s = trace_glRasterPos2s;
  tbl.glRasterPos2sv = trace_glRasterPos2sv;
  tbl.glRasterPos3d = trace_glRasterPos3d;
  tbl.glRasterPos3dv = trace_glRasterPos3dv;
  tbl.glRasterPos3f = trace_glRasterPos3f;
  tbl.glRasterPos3fv = trace_glRasterPos3fv;
  tbl.glRasterPos3i = trace_glRasterPos3i;
  tbl.glRasterPos3iv = trace_glRasterPos3iv;
  tbl.glRasterPos3s = trace_glRasterPos3s;
  tbl.glRasterPos3sv = trace_glRasterPos3sv;
  tbl.glRasterPos4d = trace_glRasterPos4d;
  tbl.glRasterPos4dv = trace_glRasterPos4dv;
  tbl.glRasterPos4f = trace_glRasterPos4f;
  tbl.glRasterPos4fv = trace_glRasterPos4fv;
  tbl.glRasterPos4i = trace_glRasterPos4i;
  tbl.glRasterPos4iv = trace_glRasterPos4iv;
  tbl.glRasterPos4s = trace_glRasterPos4s;
  tbl.glRasterPos4sv = trace_glRasterPos4sv;
  tbl.glReadBuffer = trace_glReadBuffer;
  tbl.glReadPixels = trace_glReadPixels;
  tbl.glRectd = trace_glRectd;
  tbl.glRectdv = trace_glRectdv;
  tbl.glRectf = trace_glRectf;
  tbl.glRectfv = trace_glRectfv;
  tbl.glRecti = trace_glRecti;
  tbl.glRectiv = trace_glRectiv;
  tbl.glRects = trace_glRects;
  tbl.glRectsv = trace_glRectsv;
  tbl.glRenderMode = trace_glRenderMode;
  tbl.glRotated = trace_glRotated;
  tbl.glRotatef = trace_glRotatef;
  tbl.glScaled = trace_glScaled;
  tbl.glScalef = trace_glScalef;
  tbl.glScissor = trace_glScissor;
  tbl.glSelectBuffer = trace_glSelectBuffer;
  tbl.glShadeModel = trace_glShadeModel;
  tbl.glStencilFunc = trace_glStencilFunc;
  tbl.glStencilMask = trace_glStencilMask;
  tbl.glStencilOp = trace_glStencilOp;
  tbl.glTexCoord1d = trace_glTexCoord1d;
  tbl.glTexCoord1dv = trace_glTexCoord1dv;
  tbl.glTexCoord1f = trace_glTexCoord1f;
  tbl.glTexCoord1fv = trace_glTexCoord1fv;
  tbl.glTexCoord1i = trace_glTexCoord1i;
  tbl.glTexCoord1iv = trace_glTexCoord1iv;
  tbl.glTexCoord1s = trace_glTexCoord1s;
  tbl.glTexCoord1sv = trace_glTexCoord1sv;
  tbl.glTexCoord2d = trace_glTexCoord2d;
  tbl.glTexCoord2dv = trace_glTexCoord2dv;
  tbl.glTexCoord2f = trace_glTexCoord2f;
  tbl.glTexCoord2fv = trace_glTexCoord2fv;
  tbl.glTexCoord2i = trace_glTexCoord2i;
  tbl.glTexCoord2iv = trace_glTexCoord2iv;
  tbl.glTexCoord2s = trace_glTexCoord2s;
  tbl.glTexCoord2sv = trace_glTexCoord2sv;
  tbl.glTexCoord3d = trace_glTexCoord3d;
  tbl.glTexCoord3dv = trace_glTexCoord3dv;
  tbl.glTexCoord3f = trace_glTexCoord3f;
  tbl.glTexCoord3fv = trace_glTexCoord3fv;
  tbl.glTexCoord3i = trace_glTexCoord3i;
  tbl.glTexCoord3iv = trace_glTexCoord3iv;
  tbl.glTexCoord3s = trace_glTexCoord3s;
  tbl.glTexCoord3sv = trace_glTexCoord3sv;
  tbl.glTexCoord4d = trace_glTexCoord4d;
  tbl.glTexCoord4dv = trace_glTexCoord4dv;
  tbl.glTexCoord4f = trace_glTexCoord4f;
  tbl.glTexCoord4fv = trace_glTexCoord4fv;
  tbl.glTexCoord4i = trace_glTexCoord4i;
  tbl.glTexCoord4iv = trace_glTexCoord4iv;
  tbl.glTexCoord4s = trace_glTexCoord4s;
  tbl.glTexCoord4sv = trace_glTexCoord4sv;
  tbl.glTexEnvf = trace_glTexEnvf;
  tbl.glTexEnvfv = trace_glTexEnvfv;
  tbl.glTexEnvi = trace_glTexEnvi;
  tbl.glTexEnviv = trace_glTexEnviv;
  tbl.glTexGend = trace_glTexGend;
  tbl.glTexGendv = trace_glTexGendv;
  tbl.glTexGenf = trace_glTexGenf;
  tbl.glTexGenfv = trace_glTexGenfv;
  tbl.glTexGeni = trace_glTexGeni;
  tbl.glTexGeniv = trace_glTexGeniv;
  tbl.glTexImage1D = trace_glTexImage1D;
  tbl.glTexImage2D = trace_glTexImage2D;
  tbl.glTexParameterf = trace_glTexParameterf;
  tbl.glTexParameterfv = trace_glTexParameterfv;
  tbl.glTexParameteri = trace_glTexParameteri;
  tbl.glTexParameteriv = trace_glTexParameteriv;
  tbl.glTranslated = trace_glTranslated;
  tbl.glTranslatef = trace_glTranslatef;
  tbl.glVertex2d = trace_glVertex2d;
  tbl.glVertex2dv = trace_glVertex2dv;
  tbl.glVertex2f = trace_glVertex2f;
  tbl.glVertex2fv = trace_glVertex2fv;
  tbl.glVertex2i = trace_glVertex2i;
  tbl.glVertex2iv = trace_glVertex2iv;
  tbl.glVertex2s = trace_glVertex2s;
  tbl.glVertex2sv = trace_glVertex2sv;
  tbl.glVertex3d = trace_glVertex3d;
  tbl.glVertex3dv = trace_glVertex3dv;
  tbl.glVertex3f = trace_glVertex3f;
  tbl.glVertex3fv = trace_glVertex3fv;
  tbl.glVertex3i = trace_glVertex3i;
  tbl.glVertex3iv = trace_glVertex3iv;
  tbl.glVertex3s = trace_glVertex3s;
  tbl.glVertex3sv = trace_glVertex3sv;
  tbl.glVertex4d = trace_glVertex4d;
  tbl.glVertex4dv = trace_glVertex4dv;
  tbl.glVertex4f = trace_glVertex4f;
  tbl.glVertex4fv = trace_glVertex4fv;
  tbl.glVertex4i = trace_glVertex4i;
  tbl.glVertex4iv = trace_glVertex4iv;
  tbl.glVertex4s = trace_glVertex4s;
  tbl.glVertex4sv = trace_glVertex4sv;
  tbl.glViewport = trace_glViewport;

  // GL_VERSION_1_1

  tbl.glAreTexturesResident = trace_glAreTexturesResident;
  tbl.glArrayElement = trace_glArrayElement;
  tbl.glBindTexture = trace_glBindTexture;
  tbl.glColorPointer = trace_glColorPointer;
  tbl.glCopyTexImage1D = trace_glCopyTexImage1D;
  tbl.glCopyTexImage2D = trace_glCopyTexImage2D;
  tbl.glCopyTexSubImage1D = trace_glCopyTexSubImage1D;
  tbl.glCopyTexSubImage2D = trace_glCopyTexSubImage2D;
  tbl.glDeleteTextures = trace_glDeleteTextures;
  tbl.glDisableClientState = trace_glDisableClientState;
  tbl.glDrawArrays = trace_glDrawArrays;
  tbl.glDrawElements = trace_glDrawElements;
  tbl.glEdgeFlagPointer = trace_glEdgeFlagPointer;
  tbl.glEnableClientState = trace_glEnableClientState;
  tbl.glGenTextures = trace_glGenTextures;
  tbl.glGetPointerv = trace_glGetPointerv;
  tbl.glIndexPointer = trace_glIndexPointer;
  tbl.glIndexub = trace_glIndexub;
  tbl.glIndexubv = trace_glIndexubv;
  tbl.glInterleavedArrays = trace_glInterleavedArrays;
  tbl.glIsTexture = trace_glIsTexture;
  tbl.glNormalPointer = trace_glNormalPointer;
  tbl.glPolygonOffset = trace_glPolygonOffset;
  tbl.glPopClientAttrib = trace_glPopClientAttrib;
  tbl.glPrioritizeTextures = trace_glPrioritizeTextures;
  tbl.glPushClientAttrib = trace_glPushClientAttrib;
  tbl.glTexCoordPointer = trace_glTexCoordPointer;
  tbl.glTexSubImage1D = trace_glTexSubImage1D;
  tbl.glTexSubImage2D = trace_glTexSubImage2D;
  tbl.glVertexPointer = trace_glVertexPointer;

  // GL_VERSION_1_2

  tbl.glBlendColor = trace_glBlendColor;
  tbl.glBlendEquation = trace_glBlendEquation;
  tbl.glCopyTexSubImage3D = trace_glCopyTexSubImage3D;
  tbl.glDrawRangeElements = trace_glDrawRangeElements;
  tbl.glTexImage3D = trace_glTexImage3D;
  tbl.glTexSubImage3D = trace_glTexSubImage3D;

  // GL_VERSION_1_3

  tbl.glActiveTexture = trace_glActiveTexture;
  tbl.glClientActiveTexture = trace_glClientActiveTexture;
  tbl.glCompressedTexImage1D = trace_glCompressedTexImage1D;
  tbl.glCompressedTexImage2D = trace_glCompressedTexImage2D;
  tbl.glCompressedTexImage3D = trace_glCompressedTexImage3D;
  tbl.glCompressedTexSubImage1D = trace_glCompressedTexSubImage1D;
  tbl.glCompressedTexSubImage2D = trace_glCompressedTexSubImage2D;
  tbl.glCompressedTexSubImage3D = trace_glCompressedTexSubImage3D;
  tbl.glGetCompressedTexImage = trace_glGetCompressedTexImage;
  tbl.glLoadTransposeMatrixd = trace_glLoadTransposeMatrixd;
  tbl.glLoadTransposeMatrixf = trace_glLoadTransposeMatrixf;
  tbl.glMultTransposeMatrixd = trace_glMultTransposeMatrixd;
  tbl.glMultTransposeMatrixf = trace_glMultTransposeMatrixf;
  tbl.glMultiTexCoord1d = trace_glMultiTexCoord1d;
  tbl.glMultiTexCoord1dv = trace_glMultiTexCoord1dv;
  tbl.glMultiTexCoord1f = trace_glMultiTexCoord1f;
  tbl.glMultiTexCoord1fv = trace_glMultiTexCoord1fv;
  tbl.glMultiTexCoord1i = trace_glMultiTexCoord1i;
  tbl.glMultiTexCoord1iv = trace_glMultiTexCoord1iv;
  tbl.glMultiTexCoord1s = trace_glMultiTexCoord1s;
  tbl.glMultiTexCoord1sv = trace_glMultiTexCoord1sv;
  tbl.glMultiTexCoord2d = trace_glMultiTexCoord2d;
  tbl.glMultiTexCoord2dv = trace_glMultiTexCoord2dv;
  tbl.glMultiTexCoord2f = trace_glMultiTexCoord2f;
  tbl.glMultiTexCoord2fv = trace_glMultiTexCoord2fv;
  tbl.glMultiTexCoord2i = trace_glMultiTexCoord2i;
  tbl.glMultiTexCoord2iv = trace_glMultiTexCoord2iv;
  tbl.glMultiTexCoord2s = trace_glMultiTexCoord2s;
  tbl.glMultiTexCoord2sv = trace_glMultiTexCoord2sv;
  tbl.glMultiTexCoord3d = trace_glMultiTexCoord3d;
  tbl.glMultiTexCoord3dv = trace_glMultiTexCoord3dv;
  tbl.glMultiTexCoord3f = trace_glMultiTexCoord3f;
  tbl.glMultiTexCoord3fv = trace_glMultiTexCoord3fv;
  tbl.glMultiTexCoord3i = trace_glMultiTexCoord3i;
  tbl.glMultiTexCoord3iv = trace_glMultiTexCoord3iv;
  tbl.glMultiTexCoord3s = trace_glMultiTexCoord3s;
  tbl.glMultiTexCoord3sv = trace_glMultiTexCoord3sv;
  tbl.glMultiTexCoord4d = trace_glMultiTexCoord4d;
  tbl.glMultiTexCoord4dv = trace_glMultiTexCoord4dv;
  tbl.glMultiTexCoord4f = trace_glMultiTexCoord4f;
  tbl.glMultiTexCoord4fv = trace_glMultiTexCoord4fv;
  tbl.glMultiTexCoord4i = trace_glMultiTexCoord4i;
  tbl.glMultiTexCoord4iv = trace_glMultiTexCoord4iv;
  tbl.glMultiTexCoord4s = trace_glMultiTexCoord4s;
  tbl.glMultiTexCoord4sv = trace_glMultiTexCoord4sv;
  tbl.glSampleCoverage = trace_glSampleCoverage;

  // GL_VERSION_1_4

  tbl.glBlendFuncSeparate = trace_glBlendFuncSeparate;
  tbl.glFogCoordPointer = trace_glFogCoordPointer;
  tbl.glFogCoordd = trace_glFogCoordd;
  tbl.glFogCoorddv = trace_glFogCoorddv;
  tbl.glFogCoordf = trace_glFogCoordf;
  tbl.glFogCoordfv = trace_glFogCoordfv;
  tbl.glMultiDrawArrays = trace_glMultiDrawArrays;
  tbl.glMultiDrawElements = trace_glMultiDrawElements;
  tbl.glPointParameterf = trace_glPointParameterf;
  tbl.glPointParameterfv = trace_glPointParameterfv;
  tbl.glPointParameteri = trace_glPointParameteri;
  tbl.glPointParameteriv = trace_glPointParameteriv;
  tbl.glSecondaryColor3b = trace_glSecondaryColor3b;
  tbl.glSecondaryColor3bv = trace_glSecondaryColor3bv;
  tbl.glSecondaryColor3d = trace_glSecondaryColor3d;
  tbl.glSecondaryColor3dv = trace_glSecondaryColor3dv;
  tbl.glSecondaryColor3f = trace_glSecondaryColor3f;
  tbl.glSecondaryColor3fv = trace_glSecondaryColor3fv;
  tbl.glSecondaryColor3i = trace_glSecondaryColor3i;
  tbl.glSecondaryColor3iv = trace_glSecondaryColor3iv;
  tbl.glSecondaryColor3s = trace_glSecondaryColor3s;
  tbl.glSecondaryColor3sv = trace_glSecondaryColor3sv;
  tbl.glSecondaryColor3ub = trace_glSecondaryColor3ub;
  tbl.glSecondaryColor3ubv = trace_glSecondaryColor3ubv;
  tbl.glSecondaryColor3ui = trace_glSecondaryColor3ui;
  tbl.glSecondaryColor3uiv = trace_glSecondaryColor3uiv;
  tbl.glSecondaryColor3us = trace_glSecondaryColor3us;
  tbl.glSecondaryColor3usv = trace_glSecondaryColor3usv;
  tbl.glSecondaryColorPointer = trace_glSecondaryColorPointer;
  tbl.glWindowPos2d = trace_glWindowPos2d;
  tbl.glWindowPos2dv = trace_glWindowPos2dv;
  tbl.glWindowPos2f = trace_glWindowPos2f;
  tbl.glWindowPos2fv = trace_glWindowPos2fv;
  tbl.glWindowPos2i = trace_glWindowPos2i;
  tbl.glWindowPos2iv = trace_glWindowPos2iv;
  tbl.glWindowPos2s = trace_glWindowPos2s;
  tbl.glWindowPos2sv = trace_glWindowPos2sv;
  tbl.glWindowPos3d = trace_glWindowPos3d;
  tbl.glWindowPos3dv = trace_glWindowPos3dv;
  tbl.glWindowPos3f = trace_glWindowPos3f;
  tbl.glWindowPos3fv = trace_glWindowPos3fv;
  tbl.glWindowPos3i = trace_glWindowPos3i;
  tbl.glWindowPos3iv = trace_glWindowPos3iv;
  tbl.glWindowPos3s = trace_glWindowPos3s;
  tbl.glWindowPos3sv = trace_glWindowPos3sv;

  // GL_VERSION_1_5

  tbl.glBeginQuery = trace_glBeginQuery;
  tbl.glBindBuffer = trace_glBindBuffer;
  tbl.glBufferData = trace_glBufferData;
  tbl.glBufferSubData = trace_glBufferSubData;
  tbl.glDeleteBuffers = trace_glDeleteBuffers;
  tbl.glDeleteQueries = trace_glDeleteQueries;
  tbl.glEndQuery = trace_glEndQuery;
  tbl.glGenBuffers = trace_glGenBuffers;
  tbl.glGenQueries = trace_glGenQueries;
  tbl.glGetBufferParameteriv = trace_glGetBufferParameteriv;
  tbl.glGetBufferPointerv = trace_glGetBufferPointerv;
  tbl.glGetBufferSubData = trace_glGetBufferSubData;
  tbl.glGetQueryObjectiv = trace_glGetQueryObjectiv;
  tbl.glGetQueryObjectuiv = trace_glGetQueryObjectuiv;
  tbl.glGetQueryiv = trace_glGetQueryiv;
  tbl.glIsBuffer = trace_glIsBuffer;
  tbl.glIsQuery = trace_glIsQuery;
  tbl.glMapBuffer = trace_glMapBuffer;
  tbl.glUnmapBuffer = trace_glUnmapBuffer;

  // GL_VERSION_2_0

  tbl.glAttachShader = trace_glAttachShader;
  tbl.glBindAttribLocation = trace_glBindAttribLocation;
  tbl.glBlendEquationSeparate = trace_glBlendEquationSeparate;
  tbl.glCompileShader = trace_glCompileShader;
  tbl.glCreateProgram = trace_glCreateProgram;
  tbl.glCreateShader = trace_glCreateShader;
  tbl.glDeleteProgram = trace_glDeleteProgram;
  tbl.glDeleteShader = trace_glDeleteShader;
  tbl.glDetachShader = trace_glDetachShader;
  tbl.glDisableVertexAttribArray = trace_glDisableVertexAttribArray;
  tbl.glDrawBuffers = trace_glDrawBuffers;
  tbl.glEnableVertexAttribArray = trace_glEnableVertexAttribArray;
  tbl.glGetActiveAttrib = trace_glGetActiveAttrib;
  tbl.glGetActiveUniform = trace_glGetActiveUniform;
  tbl.glGetAttachedShaders = trace_glGetAttachedShaders;
  tbl.glGetAttribLocation = trace_glGetAttribLocation;
  tbl.glGetProgramInfoLog = trace_glGetProgramInfoLog;
  tbl.glGetProgramiv = trace_glGetProgramiv;
  tbl.glGetShaderInfoLog = trace_glGetShaderInfoLog;
  tbl.glGetShaderSource = trace_glGetShaderSource;
  tbl.glGetShaderiv = trace_glGetShaderiv;
  tbl.glGetUniformLocation = trace_glGetUniformLocation;
  tbl.glGetUniformfv = trace_glGetUniformfv;
  tbl.glGetUniformiv = trace_glGetUniformiv;
  tbl.glGetVertexAttribPointerv = trace_glGetVertexAttribPointerv;
  tbl.glGetVertexAttribdv = trace_glGetVertexAttribdv;
  tbl.glGetVertexAttribfv = trace_glGetVertexAttribfv;
  tbl.glGetVertexAttribiv = trace_glGetVertexAttribiv;
  tbl.glIsProgram = trace_glIsProgram;
  tbl.glIsShader = trace_glIsShader;
  tbl.glLinkProgram = trace_glLinkProgram;
  tbl.glShaderSource = trace_glShaderSource;
  tbl.glStencilFuncSeparate = trace_glStencilFuncSeparate;
  tbl.glStencilMaskSeparate = trace_glStencilMaskSeparate;
  tbl.glStencilOpSeparate = trace_glStencilOpSeparate;
  tbl.glUniform1f = trace_glUniform1f;
  tbl.glUniform1fv = trace_glUniform1fv;
  tbl.glUniform1i = trace_glUniform1i;
  tbl.glUniform1iv = trace_glUniform1iv;
  tbl.glUniform2f = trace_glUniform2f;
  tbl.glUniform2fv = trace_glUniform2fv;
  tbl.glUniform2i = trace_glUniform2i;
  tbl.glUniform2iv = trace_glUniform2iv;
  tbl.glUniform3f = trace_glUniform3f;
  tbl.glUniform3fv = trace_glUniform3fv;
  tbl.glUniform3i = trace_glUniform3i;
  tbl.glUniform3iv = trace_glUniform3iv;
  tbl.glUniform4f = trace_glUniform4f;
  tbl.glUniform4fv = trace_glUniform4fv;
  tbl.glUniform4i = trace_glUniform4i;
  tbl.glUniform4iv = trace_glUniform4iv;
  tbl.glUniformMatrix2fv = trace_glUniformMatrix2fv;
  tbl.glUniformMatrix3fv = trace_glUniformMatrix3fv;
  tbl.glUniformMatrix4fv = trace_glUniformMatrix4fv;
  tbl.glUseProgram = trace_glUseProgram;
  tbl.glValidateProgram = trace_glValidateProgram;
  tbl.glVertexAttrib1d = trace_glVertexAttrib1d;
  tbl.glVertexAttrib1dv = trace_glVertexAttrib1dv;
  tbl.glVertexAttrib1f = trace_glVertexAttrib1f;
  tbl.glVertexAttrib1fv = trace_glVertexAttrib1fv;
  tbl.glVertexAttrib1s = trace_glVertexAttrib1s;
  tbl.glVertexAttrib1sv = trace_glVertexAttrib1sv;
  tbl.glVertexAttrib2d = trace_glVertexAttrib2d;
  tbl.glVertexAttrib2dv = trace_glVertexAttrib2dv;
  tbl.glVertexAttrib2f = trace_glVertexAttrib2f;
  tbl.glVertexAttrib2fv = trace_glVertexAttrib2fv;
  tbl.glVertexAttrib2s = trace_glVertexAttrib2s;
  tbl.glVertexAttrib2sv = trace_glVertexAttrib2sv;
  tbl.glVertexAttrib3d = trace_glVertexAttrib3d;
  tbl.glVertexAttrib3dv = trace_glVertexAttrib3dv;
  tbl.glVertexAttrib3f = trace_glVertexAttrib3f;
  tbl.glVertexAttrib3fv = trace_glVertexAttrib3fv;
  tbl.glVertexAttrib3s = trace_glVertexAttrib3s;
  tbl.glVertexAttrib3sv = trace_glVertexAttrib3sv;
  tbl.glVertexAttrib4Nbv = trace_glVertexAttrib4Nbv;
  tbl.glVertexAttrib4Niv = trace_glVertexAttrib4Niv;
  tbl.glVertexAttrib4Nsv = trace_glVertexAttrib4Nsv;
  tbl.glVertexAttrib4Nub = trace_glVertexAttrib4Nub;
  tbl.glVertexAttrib4Nubv = trace_glVertexAttrib4Nubv;
  tbl.glVertexAttrib4Nuiv = trace_glVertexAttrib4Nuiv;
  tbl.glVertexAttrib4Nusv = trace_glVertexAttrib4Nusv;
  tbl.glVertexAttrib4bv = trace_glVertexAttrib4bv;
  tbl.glVertexAttrib4d = trace_glVertexAttrib4d;
  tbl.glVertexAttrib4dv = trace_glVertexAttrib4dv;
  tbl.glVertexAttrib4f = trace_glVertexAttrib4f;
  tbl.glVertexAttrib4fv = trace_glVertexAttrib4fv;
  tbl.glVertexAttrib4iv = trace_glVertexAttrib4iv;
  tbl.glVertexAttrib4s = trace_glVertexAttrib4s;
  tbl.glVertexAttrib4sv = trace_glVertexAttrib4sv;
  tbl.glVertexAttrib4ubv = trace_glVertexAttrib4ubv;
  tbl.glVertexAttrib4uiv = trace_glVertexAttrib4uiv;
  tbl.glVertexAttrib4usv = trace_glVertexAttrib4usv;
  tbl.glVertexAttribPointer = trace_glVertexAttribPointer;

  // GL_VERSION_2_1

  tbl.glUniformMatrix2x3fv = trace_glUniformMatrix2x3fv;
  tbl.glUniformMatrix2x4fv = trace_glUniformMatrix2x4fv;
  tbl.glUniformMatrix3x2fv = trace_glUniformMatrix3x2fv;
  tbl.glUniformMatrix3x4fv = trace_glUniformMatrix3x4fv;
  tbl.glUniformMatrix4x2fv = trace_glUniformMatrix4x2fv;
  tbl.glUniformMatrix4x3fv = trace_glUniformMatrix4x3fv;

  // GL_VERSION_3_0

  tbl.glBeginConditionalRender = trace_glBeginConditionalRender;
  tbl.glBeginTransformFeedback = trace_glBeginTransformFeedback;
  tbl.glBindFragDataLocation = trace_glBindFragDataLocation;
  tbl.glClampColor = trace_glClampColor;
  tbl.glClearBufferfi = trace_glClearBufferfi;
  tbl.glClearBufferfv = trace_glClearBufferfv;
  tbl.glClearBufferiv = trace_glClearBufferiv;
  tbl.glClearBufferuiv = trace_glClearBufferuiv;
  tbl.glColorMaski = trace_glColorMaski;
  tbl.glDisablei = trace_glDisablei;
  tbl.glEnablei = trace_glEnablei;
  tbl.glEndConditionalRender = trace_glEndConditionalRender;
  tbl.glEndTransformFeedback = trace_glEndTransformFeedback;
  tbl.glGetBooleani_v = trace_glGetBooleani_v;
  tbl.glGetFragDataLocation = trace_glGetFragDataLocation;
  tbl.glGetStringi = trace_glGetStringi;
  tbl.glGetTexParameterIiv = trace_glGetTexParameterIiv;
  tbl.glGetTexParameterIuiv = trace_glGetTexParameterIuiv;
  tbl.glGetTransformFeedbackVarying = trace_glGetTransformFeedbackVarying;
  tbl.glGetUniformuiv = trace_glGetUniformuiv;
  tbl.glGetVertexAttribIiv = trace_glGetVertexAttribIiv;
  tbl.glGetVertexAttribIuiv = trace_glGetVertexAttribIuiv;
  tbl.glIsEnabledi = trace_glIsEnabledi;
  tbl.glTexParameterIiv = trace_glTexParameterIiv;
  tbl.glTexParameterIuiv = trace_glTexParameterIuiv;
  tbl.glTransformFeedbackVaryings = trace_glTransformFeedbackVaryings;
  tbl.glUniform1ui = trace_glUniform1ui;
  tbl.glUniform1uiv = trace_glUniform1uiv;
  tbl.glUniform2ui = trace_glUniform2ui;
  tbl.glUniform2uiv = trace_glUniform2uiv;
  tbl.glUniform3ui = trace_glUniform3ui;
  tbl.glUniform3uiv = trace_glUniform3uiv;
  tbl.glUniform4ui = trace_glUniform4ui;
  tbl.glUniform4uiv = trace_glUniform4uiv;
  tbl.glVertexAttribI1i = trace_glVertexAttribI1i;
  tbl.glVertexAttribI1iv = trace_glVertexAttribI1iv;
  tbl.glVertexAttribI1ui = trace_glVertexAttribI1ui;
  tbl.glVertexAttribI1uiv = trace_glVertexAttribI1uiv;
  tbl.glVertexAttribI2i = trace_glVertexAttribI2i;
  tbl.glVertexAttribI2iv = trace_glVertexAttribI2iv;
  tbl.glVertexAttribI2ui = trace_glVertexAttribI2ui;
  tbl.glVertexAttribI2uiv = trace_glVertexAttribI2uiv;
  tbl.glVertexAttribI3i = trace_glVertexAttribI3i;
  tbl.glVertexAttribI3iv = trace_glVertexAttribI3iv;
  tbl.glVertexAttribI3ui = trace_glVertexAttribI3ui;
  tbl.glVertexAttribI3uiv = trace_glVertexAttribI3uiv;
  tbl.glVertexAttribI4bv = trace_glVertexAttribI4bv;
  tbl.glVertexAttribI4i = trace_glVertexAttribI4i;
  tbl.glVertexAttribI4iv = trace_glVertexAttribI4iv;
  tbl.glVertexAttribI4sv = trace_glVertexAttribI4sv;
  tbl.glVertexAttribI4ubv = trace_glVertexAttribI4ubv;
  tbl.glVertexAttribI4ui = trace_glVertexAttribI4ui;
  tbl.glVertexAttribI4uiv = trace_glVertexAttribI4uiv;
  tbl.glVertexAttribI4usv = trace_glVertexAttribI4usv;
  tbl.glVertexAttribIPointer = trace_glVertexAttribIPointer;

  // GL_VERSION_3_1

  tbl.glDrawArraysInstanced = trace_glDrawArraysInstanced;
  tbl.glDrawElementsInstanced = trace_glDrawElementsInstanced;
  tbl.glPrimitiveRestartIndex = trace_glPrimitiveRestartIndex;
  tbl.glTexBuffer = trace_glTexBuffer;

  // GL_VERSION_3_2

  tbl.glFramebufferTexture = trace_glFramebufferTexture;
  tbl.glGetBufferParameteri64v = trace_glGetBufferParameteri64v;
  tbl.glGetInteger64i_v = trace_glGetInteger64i_v;

  // GL_VERSION_3_3

  tbl.glVertexAttribDivisor = trace_glVertexAttribDivisor;

  // GL_VERSION_4_0

  tbl.glBlendEquationSeparatei = trace_glBlendEquationSeparatei;
  tbl.glBlendEquationi = trace_glBlendEquationi;
  tbl.glBlendFuncSeparatei = trace_glBlendFuncSeparatei;
  tbl.glBlendFunci = trace_glBlendFunci;

  // GL_3DFX_tbuffer

  tbl.glTbufferMask3DFX = trace_glTbufferMask3DFX;

  // GL_AMD_debug_output

  tbl.glDebugMessageCallbackAMD = trace_glDebugMessageCallbackAMD;
  tbl.glDebugMessageEnableAMD = trace_glDebugMessageEnableAMD;
  tbl.glDebugMessageInsertAMD = trace_glDebugMessageInsertAMD;
  tbl.glGetDebugMessageLogAMD = trace_glGetDebugMessageLogAMD;

  // GL_AMD_draw_buffers_blend

  tbl.glBlendEquationIndexedAMD = trace_glBlendEquationIndexedAMD;
  tbl.glBlendEquationSeparateIndexedAMD = trace_glBlendEquationSeparateIndexedAMD;
  tbl.glBlendFuncIndexedAMD = trace_glBlendFuncIndexedAMD;
  tbl.glBlendFuncSeparateIndexedAMD = trace_glBlendFuncSeparateIndexedAMD;

  // GL_AMD_multi_draw_indirect

  tbl.glMultiDrawArraysIndirectAMD = trace_glMultiDrawArraysIndirectAMD;
  tbl.glMultiDrawElementsIndirectAMD = trace_glMultiDrawElementsIndirectAMD;

  // GL_AMD_name_gen_delete

  tbl.glDeleteNamesAMD = trace_glDeleteNamesAMD;
  tbl.glGenNamesAMD = trace_glGenNamesAMD;
  tbl.glIsNameAMD = trace_glIsNameAMD;

  // GL_AMD_performance_monitor

  tbl.glBeginPerfMonitorAMD = trace_glBeginPerfMonitorAMD;
  tbl.glDeletePerfMonitorsAMD = trace_glDeletePerfMonitorsAMD;
  tbl.glEndPerfMonitorAMD = trace_glEndPerfMonitorAMD;
  tbl.glGenPerfMonitorsAMD = trace_glGenPerfMonitorsAMD;
  tbl.glGetPerfMonitorCounterDataAMD = trace_glGetPerfMonitorCounterDataAMD;
  tbl.glGetPerfMonitorCounterInfoAMD = trace_glGetPerfMonitorCounterInfoAMD;
  tbl.glGetPerfMonitorCounterStringAMD = trace_glGetPerfMonitorCounterStringAMD;
  tbl.glGetPerfMonitorCountersAMD = trace_glGetPerfMonitorCountersAMD;
  tbl.glGetPerfMonitorGroupStringAMD = trace_glGetPerfMonitorGroupStringAMD;
  tbl.glGetPerfMonitorGroupsAMD = trace_glGetPerfMonitorGroupsAMD;
  tbl.glSelectPerfMonitorCountersAMD = trace_glSelectPerfMonitorCountersAMD;

  // GL_AMD_sample_positions

  tbl.glSetMultisamplefvAMD = trace_glSetMultisamplefvAMD;

  // GL_AMD_vertex_shader_tessellator

  tbl.glTessellationFactorAMD = trace_glTessellationFactorAMD;
  tbl.glTessellationModeAMD = trace_glTessellationModeAMD;

  // GL_ANGLE_framebuffer_blit

  tbl.glBlitFramebufferANGLE = trace_glBlitFramebufferANGLE;

  // GL_ANGLE_framebuffer_multisample

  tbl.glRenderbufferStorageMultisampleANGLE = trace_glRenderbufferStorageMultisampleANGLE;

  // GL_APPLE_element_array

  tbl.glDrawElementArrayAPPLE = trace_glDrawElementArrayAPPLE;
  tbl.glDrawRangeElementArrayAPPLE = trace_glDrawRangeElementArrayAPPLE;
  tbl.glElementPointerAPPLE = trace_glElementPointerAPPLE;
  tbl.glMultiDrawElementArrayAPPLE = trace_glMultiDrawElementArrayAPPLE;
  tbl.glMultiDrawRangeElementArrayAPPLE = trace_glMultiDrawRangeElementArrayAPPLE;

  // GL_APPLE_fence

  tbl.glDeleteFencesAPPLE = trace_glDeleteFencesAPPLE;
  tbl.glFinishFenceAPPLE = trace_glFinishFenceAPPLE;
  tbl.glFinishObjectAPPLE = trace_glFinishObjectAPPLE;
  tbl.glGenFencesAPPLE = trace_glGenFencesAPPLE;
  tbl.glIsFenceAPPLE = trace_glIsFenceAPPLE;
  tbl.glSetFenceAPPLE = trace_glSetFenceAPPLE;
  tbl.glTestFenceAPPLE = trace_glTestFenceAPPLE;
  tbl.glTestObjectAPPLE = trace_glTestObjectAPPLE;

  // GL_APPLE_flush_buffer_range

  tbl.glBufferParameteriAPPLE = trace_glBufferParameteriAPPLE;
  tbl.glFlushMappedBufferRangeAPPLE = trace_glFlushMappedBufferRangeAPPLE;

  // GL_APPLE_flush_render

  tbl.glFinishRenderAPPLE = trace_glFinishRenderAPPLE;
  tbl.glFlushRenderAPPLE = trace_glFlushRenderAPPLE;
  tbl.glSwapAPPLE = trace_glSwapAPPLE;

  // GL_APPLE_framebuffer_multisample

  tbl.glRenderbufferStorageMultisampleAPPLE = trace_glRenderbufferStorageMultisampleAPPLE;
  tbl.glResolveMultisampleFramebufferAPPLE = trace_glResolveMultisampleFramebufferAPPLE;

  // GL_APPLE_object_purgeable

  tbl.glGetObjectParameterivAPPLE = trace_glGetObjectParameterivAPPLE;
  tbl.glObjectPurgeableAPPLE = trace_glObjectPurgeableAPPLE;
  tbl.glObjectUnpurgeableAPPLE = trace_glObjectUnpurgeableAPPLE;

  // GL_APPLE_texture_range

  tbl.glGetTexParameterPointervAPPLE = trace_glGetTexParameterPointervAPPLE;
  tbl.glTextureRangeAPPLE = trace_glTextureRangeAPPLE;

  // GL_APPLE_vertex_array_object

  tbl.glBindVertexArrayAPPLE = trace_glBindVertexArrayAPPLE;
  tbl.glDeleteVertexArraysAPPLE = trace_glDeleteVertexArraysAPPLE;
  tbl.glGenVertexArraysAPPLE = trace_glGenVertexArraysAPPLE;
  tbl.glIsVertexArrayAPPLE = trace_glIsVertexArrayAPPLE;

  // GL_APPLE_vertex_array_range

  tbl.glFlushVertexArrayRangeAPPLE = trace_glFlushVertexArrayRangeAPPLE;
  tbl.glVertexArrayParameteriAPPLE = trace_glVertexArrayParameteriAPPLE;
  tbl.glVertexArrayRangeAPPLE = trace_glVertexArrayRangeAPPLE;

  // GL_APPLE_vertex_program_evaluators

  tbl.glDisableVertexAttribAPPLE = trace_glDisableVertexAttribAPPLE;
  tbl.glEnableVertexAttribAPPLE = trace_glEnableVertexAttribAPPLE;
  tbl.glIsVertexAttribEnabledAPPLE = trace_glIsVertexAttribEnabledAPPLE;
  tbl.glMapVertexAttrib1dAPPLE = trace_glMapVertexAttrib1dAPPLE;
  tbl.glMapVertexAttrib1fAPPLE = trace_glMapVertexAttrib1fAPPLE;
  tbl.glMapVertexAttrib2dAPPLE = trace_glMapVertexAttrib2dAPPLE;
  tbl.glMapVertexAttrib2fAPPLE = trace_glMapVertexAttrib2fAPPLE;

  // GL_ARB_ES2_compatibility

  tbl.glClearDepthf = trace_glClearDepthf;
  tbl.glDepthRangef = trace_glDepthRangef;
  tbl.glGetShaderPrecisionFormat = trace_glGetShaderPrecisionFormat;
  tbl.glReleaseShaderCompiler = trace_glReleaseShaderCompiler;
  tbl.glShaderBinary = trace_glShaderBinary;

  // GL_ARB_base_instance

  tbl.glDrawArraysInstancedBaseInstance = trace_glDrawArraysInstancedBaseInstance;
  tbl.glDrawElementsInstancedBaseInstance = trace_glDrawElementsInstancedBaseInstance;
  tbl.glDrawElementsInstancedBaseVertexBaseInstance = trace_glDrawElementsInstancedBaseVertexBaseInstance;

  // GL_ARB_blend_func_extended

  tbl.glBindFragDataLocationIndexed = trace_glBindFragDataLocationIndexed;
  tbl.glGetFragDataIndex = trace_glGetFragDataIndex;

  // GL_ARB_clear_buffer_object

  tbl.glClearBufferData = trace_glClearBufferData;
  tbl.glClearBufferSubData = trace_glClearBufferSubData;
  tbl.glClearNamedBufferDataEXT = trace_glClearNamedBufferDataEXT;

  // GL_ARB_color_buffer_float

  tbl.glClampColorARB = trace_glClampColorARB;

  // GL_ARB_compute_shader

  tbl.glDispatchCompute = trace_glDispatchCompute;
  tbl.glDispatchComputeIndirect = trace_glDispatchComputeIndirect;

  // GL_ARB_copy_buffer

  tbl.glCopyBufferSubData = trace_glCopyBufferSubData;

  // GL_ARB_copy_image

  tbl.glCopyImageSubData = trace_glCopyImageSubData;

  // GL_ARB_debug_output

  tbl.glDebugMessageCallbackARB = trace_glDebugMessageCallbackARB;
  tbl.glDebugMessageControlARB = trace_glDebugMessageControlARB;
  tbl.glDebugMessageInsertARB = trace_glDebugMessageInsertARB;
  tbl.glGetDebugMessageLogARB = trace_glGetDebugMessageLogARB;

  // GL_ARB_draw_buffers

  tbl.glDrawBuffersARB = trace_glDrawBuffersARB;

  // GL_ARB_draw_buffers_blend

  tbl.glBlendEquationSeparateiARB = trace_glBlendEquationSeparateiARB;
  tbl.glBlendEquationiARB = trace_glBlendEquationiARB;
  tbl.glBlendFuncSeparateiARB = trace_glBlendFuncSeparateiARB;
  tbl.glBlendFunciARB = trace_glBlendFunciARB;

  // GL_ARB_draw_elements_base_vertex

  tbl.glDrawElementsBaseVertex = trace_glDrawElementsBaseVertex;
  tbl.glDrawElementsInstancedBaseVertex = trace_glDrawElementsInstancedBaseVertex;
  tbl.glDrawRangeElementsBaseVertex = trace_glDrawRangeElementsBaseVertex;
  tbl.glMultiDrawElementsBaseVertex = trace_glMultiDrawElementsBaseVertex;

  // GL_ARB_draw_indirect

  tbl.glDrawArraysIndirect = trace_glDrawArraysIndirect;
  tbl.glDrawElementsIndirect = trace_glDrawElementsIndirect;

  // GL_ARB_draw_instanced

  tbl.glDrawArraysInstancedARB = trace_glDrawArraysInstancedARB;
  tbl.glDrawElementsInstancedARB = trace_glDrawElementsInstancedARB;

  // GL_ARB_framebuffer_no_attachments

  tbl.glFramebufferParameteri = trace_glFramebufferParameteri;
  tbl.glGetFramebufferParameteriv = trace_glGetFramebufferParameteriv;
  tbl.glGetNamedFramebufferParameterivEXT = trace_glGetNamedFramebufferParameterivEXT;
  tbl.glNamedFramebufferParameteriEXT = trace_glNamedFramebufferParameteriEXT;

  // GL_ARB_framebuffer_object

  tbl.glBindFramebuffer = trace_glBindFramebuffer;
  tbl.glBindRenderbuffer = trace_glBindRenderbuffer;
  tbl.glBlitFramebuffer = trace_glBlitFramebuffer;
  tbl.glCheckFramebufferStatus = trace_glCheckFramebufferStatus;
  tbl.glDeleteFramebuffers = trace_glDeleteFramebuffers;
  tbl.glDeleteRenderbuffers = trace_glDeleteRenderbuffers;
  tbl.glFramebufferRenderbuffer = trace_glFramebufferRenderbuffer;
  tbl.glFramebufferTexture1D = trace_glFramebufferTexture1D;
  tbl.glFramebufferTexture2D = trace_glFramebufferTexture2D;
  tbl.glFramebufferTexture3D = trace_glFramebufferTexture3D;
  tbl.glFramebufferTextureLayer = trace_glFramebufferTextureLayer;
  tbl.glGenFramebuffers = trace_glGenFramebuffers;
  tbl.glGenRenderbuffers = trace_glGenRenderbuffers;
  tbl.glGenerateMipmap = trace_glGenerateMipmap;
  tbl.glGetFramebufferAttachmentParameteriv = trace_glGetFramebufferAttachmentParameteriv;
  tbl.glGetRenderbufferParameteriv = trace_glGetRenderbufferParameteriv;
  tbl.glIsFramebuffer = trace_glIsFramebuffer;
  tbl.glIsRenderbuffer = trace_glIsRenderbuffer;
  tbl.glRenderbufferStorage = trace_glRenderbufferStorage;
  tbl.glRenderbufferStorageMultisample = trace_glRenderbufferStorageMultisample;

  // GL_ARB_geometry_shader4

  tbl.glFramebufferTextureARB = trace_glFramebufferTextureARB;
  tbl.glFramebufferTextureFaceARB = trace_glFramebufferTextureFaceARB;
  tbl.glFramebufferTextureLayerARB = trace_glFramebufferTextureLayerARB;
  tbl.glProgramParameteriARB = trace_glProgramParameteriARB;

  // GL_ARB_get_program_binary

  tbl.glGetProgramBinary = trace_glGetProgramBinary;
  tbl.glProgramBinary = trace_glProgramBinary;
  tbl.glProgramParameteri = trace_glProgramParameteri;

  // GL_ARB_gpu_shader_fp64

  tbl.glGetUniformdv = trace_glGetUniformdv;
  tbl.glUniform1d = trace_glUniform1d;
  tbl.glUniform1dv = trace_glUniform1dv;
  tbl.glUniform2d = trace_glUniform2d;
  tbl.glUniform2dv = trace_glUniform2dv;
  tbl.glUniform3d = trace_glUniform3d;
  tbl.glUniform3dv = trace_glUniform3dv;
  tbl.glUniform4d = trace_glUniform4d;
  tbl.glUniform4dv = trace_glUniform4dv;
  tbl.glUniformMatrix2dv = trace_glUniformMatrix2dv;
  tbl.glUniformMatrix2x3dv = trace_glUniformMatrix2x3dv;
  tbl.glUniformMatrix2x4dv = trace_glUniformMatrix2x4dv;
  tbl.glUniformMatrix3dv = trace_glUniformMatrix3dv;
  tbl.glUniformMatrix3x2dv = trace_glUniformMatrix3x2dv;
  tbl.glUniformMatrix3x4dv = trace_glUniformMatrix3x4dv;
  tbl.glUniformMatrix4dv = trace_glUniformMatrix4dv;
  tbl.glUniformMatrix4x2dv = trace_glUniformMatrix4x2dv;
  tbl.glUniformMatrix4x3dv = trace_glUniformMatrix4x3dv;

  // GL_ARB_imaging

  tbl.glColorSubTable = trace_glColorSubTable;
  tbl.glColorTable = trace_glColorTable;
  tbl.glColorTableParameterfv = trace_glColorTableParameterfv;
  tbl.glColorTableParameteriv = trace_glColorTableParameteriv;
  tbl.glConvolutionFilter1D = trace_glConvolutionFilter1D;
  tbl.glConvolutionFilter2D = trace_glConvolutionFilter2D;
  tbl.glConvolutionParameterf = trace_glConvolutionParameterf;
  tbl.glConvolutionParameterfv = trace_glConvolutionParameterfv;
  tbl.glConvolutionParameteri = trace_glConvolutionParameteri;
  tbl.glConvolutionParameteriv = trace_glConvolutionParameteriv;
  tbl.glCopyColorSubTable = trace_glCopyColorSubTable;
  tbl.glCopyColorTable = trace_glCopyColorTable;
  tbl.glCopyConvolutionFilter1D = trace_glCopyConvolutionFilter1D;
  tbl.glCopyConvolutionFilter2D = trace_glCopyConvolutionFilter2D;
  tbl.glGetColorTable = trace_glGetColorTable;
  tbl.glGetColorTableParameterfv = trace_glGetColorTableParameterfv;
  tbl.glGetColorTableParameteriv = trace_glGetColorTableParameteriv;
  tbl.glGetConvolutionFilter = trace_glGetConvolutionFilter;
  tbl.glGetConvolutionParameterfv = trace_glGetConvolutionParameterfv;
  tbl.glGetConvolutionParameteriv = trace_glGetConvolutionParameteriv;
  tbl.glGetHistogram = trace_glGetHistogram;
  tbl.glGetHistogramParameterfv = trace_glGetHistogramParameterfv;
  tbl.glGetHistogramParameteriv = trace_glGetHistogramParameteriv;
  tbl.glGetMinmax = trace_glGetMinmax;
  tbl.glGetMinmaxParameterfv = trace_glGetMinmaxParameterfv;
  tbl.glGetMinmaxParameteriv = trace_glGetMinmaxParameteriv;
  tbl.glGetSeparableFilter = trace_glGetSeparableFilter;
  tbl.glHistogram = trace_glHistogram;
  tbl.glMinmax = trace_glMinmax;
  tbl.glResetHistogram = trace_glResetHistogram;
  tbl.glResetMinmax = trace_glResetMinmax;
  tbl.glSeparableFilter2D = trace_glSeparableFilter2D;

  // GL_ARB_instanced_arrays

  tbl.glVertexAttribDivisorARB = trace_glVertexAttribDivisorARB;

  // GL_ARB_internalformat_query

  tbl.glGetInternalformativ = trace_glGetInternalformativ;

  // GL_ARB_internalformat_query2

  tbl.glGetInternalformati64v = trace_glGetInternalformati64v;

  // GL_ARB_invalidate_subdata

  tbl.glInvalidateBufferData = trace_glInvalidateBufferData;
  tbl.glInvalidateBufferSubData = trace_glInvalidateBufferSubData;
  tbl.glInvalidateFramebuffer = trace_glInvalidateFramebuffer;
  tbl.glInvalidateSubFramebuffer = trace_glInvalidateSubFramebuffer;
  tbl.glInvalidateTexImage = trace_glInvalidateTexImage;
  tbl.glInvalidateTexSubImage = trace_glInvalidateTexSubImage;

  // GL_ARB_map_buffer_range

  tbl.glFlushMappedBufferRange = trace_glFlushMappedBufferRange;
  tbl.glMapBufferRange = trace_glMapBufferRange;

  // GL_ARB_matrix_palette

  tbl.glCurrentPaletteMatrixARB = trace_glCurrentPaletteMatrixARB;
  tbl.glMatrixIndexPointerARB = trace_glMatrixIndexPointerARB;
  tbl.glMatrixIndexubvARB = trace_glMatrixIndexubvARB;
  tbl.glMatrixIndexuivARB = trace_glMatrixIndexuivARB;
  tbl.glMatrixIndexusvARB = trace_glMatrixIndexusvARB;

  // GL_ARB_multi_draw_indirect

  tbl.glMultiDrawArraysIndirect = trace_glMultiDrawArraysIndirect;
  tbl.glMultiDrawElementsIndirect = trace_glMultiDrawElementsIndirect;

  // GL_ARB_multisample

  tbl.glSampleCoverageARB = trace_glSampleCoverageARB;

  // GL_ARB_multitexture

  tbl.glActiveTextureARB = trace_glActiveTextureARB;
  tbl.glClientActiveTextureARB = trace_glClientActiveTextureARB;
  tbl.glMultiTexCoord1dARB = trace_glMultiTexCoord1dARB;
  tbl.glMultiTexCoord1dvARB = trace_glMultiTexCoord1dvARB;
  tbl.glMultiTexCoord1fARB = trace_glMultiTexCoord1fARB;
  tbl.glMultiTexCoord1fvARB = trace_glMultiTexCoord1fvARB;
  tbl.glMultiTexCoord1iARB = trace_glMultiTexCoord1iARB;
  tbl.glMultiTexCoord1ivARB = trace_glMultiTexCoord1ivARB;
  tbl.glMultiTexCoord1sARB = trace_glMultiTexCoord1sARB;
  tbl.glMultiTexCoord1svARB = trace_glMultiTexCoord1svARB;
  tbl.glMultiTexCoord2dARB = trace_glMultiTexCoord2dARB;
  tbl.glMultiTexCoord2dvARB = trace_glMultiTexCoord2dvARB;
  tbl.glMultiTexCoord2fARB = trace_glMultiTexCoord2fARB;
  tbl.glMultiTexCoord2fvARB = trace_glMultiTexCoord2fvARB;
  tbl.glMultiTexCoord2iARB = trace_glMultiTexCoord2iARB;
  tbl.glMultiTexCoord2ivARB = trace_glMultiTexCoord2ivARB;
  tbl.glMultiTexCoord2sARB = trace_glMultiTexCoord2sARB;
  tbl.glMultiTexCoord2svARB = trace_glMultiTexCoord2svARB;
  tbl.glMultiTexCoord3dARB = trace_glMultiTexCoord3dARB;
  tbl.glMultiTexCoord3dvARB = trace_glMultiTexCoord3dvARB;
  tbl.glMultiTexCoord3fARB = trace_glMultiTexCoord3fARB;
  tbl.glMultiTexCoord3fvARB = trace_glMultiTexCoord3fvARB;
  tbl.glMultiTexCoord3iARB = trace_glMultiTexCoord3iARB;
  tbl.glMultiTexCoord3ivARB = trace_glMultiTexCoord3ivARB;
  tbl.glMultiTexCoord3sARB = trace_glMultiTexCoord3sARB;
  tbl.glMultiTexCoord3svARB = trace_glMultiTexCoord3svARB;
  tbl.glMultiTexCoord4dARB = trace_glMultiTexCoord4dARB;
  tbl.glMultiTexCoord4dvARB = trace_glMultiTexCoord4dvARB;
  tbl.glMultiTexCoord4fARB = trace_glMultiTexCoord4fARB;
  tbl.glMultiTexCoord4fvARB = trace_glMultiTexCoord4fvARB;
  tbl.glMultiTexCoord4iARB = trace_glMultiTexCoord4iARB;
  tbl.glMultiTexCoord4ivARB = trace_glMultiTexCoord4ivARB;
  tbl.glMultiTexCoord4sARB = trace_glMultiTexCoord4sARB;
  tbl.glMultiTexCoord4svARB = trace_glMultiTexCoord4svARB;

  // GL_ARB_occlusion_query

  tbl.glBeginQueryARB = trace_glBeginQueryARB;
  tbl.glDeleteQueriesARB = trace_glDeleteQueriesARB;
  tbl.glEndQueryARB = trace_glEndQueryARB;
  tbl.glGenQueriesARB = trace_glGenQueriesARB;
  tbl.glGetQueryObjectivARB = trace_glGetQueryObjectivARB;
  tbl.glGetQueryObjectuivARB = trace_glGetQueryObjectuivARB;
  tbl.glGetQueryivARB = trace_glGetQueryivARB;
  tbl.glIsQueryARB = trace_glIsQueryARB;

  // GL_ARB_point_parameters

  tbl.glPointParameterfARB = trace_glPointParameterfARB;
  tbl.glPointParameterfvARB = trace_glPointParameterfvARB;

  // GL_ARB_program_interface_query

  tbl.glGetProgramInterfaceiv = trace_glGetProgramInterfaceiv;
  tbl.glGetProgramResourceIndex = trace_glGetProgramResourceIndex;
  tbl.glGetProgramResourceLocation = trace_glGetProgramResourceLocation;
  tbl.glGetProgramResourceLocationIndex = trace_glGetProgramResourceLocationIndex;
  tbl.glGetProgramResourceName = trace_glGetProgramResourceName;
  tbl.glGetProgramResourceiv = trace_glGetProgramResourceiv;

  // GL_ARB_provoking_vertex

  tbl.glProvokingVertex = trace_glProvokingVertex;

  // GL_ARB_robustness

  tbl.glGetGraphicsResetStatusARB = trace_glGetGraphicsResetStatusARB;
  tbl.glGetnColorTableARB = trace_glGetnColorTableARB;
  tbl.glGetnCompressedTexImageARB = trace_glGetnCompressedTexImageARB;
  tbl.glGetnConvolutionFilterARB = trace_glGetnConvolutionFilterARB;
  tbl.glGetnHistogramARB = trace_glGetnHistogramARB;
  tbl.glGetnMapdvARB = trace_glGetnMapdvARB;
  tbl.glGetnMapfvARB = trace_glGetnMapfvARB;
  tbl.glGetnMapivARB = trace_glGetnMapivARB;
  tbl.glGetnMinmaxARB = trace_glGetnMinmaxARB;
  tbl.glGetnPixelMapfvARB = trace_glGetnPixelMapfvARB;
  tbl.glGetnPixelMapuivARB = trace_glGetnPixelMapuivARB;
  tbl.glGetnPixelMapusvARB = trace_glGetnPixelMapusvARB;
  tbl.glGetnPolygonStippleARB = trace_glGetnPolygonStippleARB;
  tbl.glGetnSeparableFilterARB = trace_glGetnSeparableFilterARB;
  tbl.glGetnTexImageARB = trace_glGetnTexImageARB;
  tbl.glGetnUniformdvARB = trace_glGetnUniformdvARB;
  tbl.glGetnUniformfvARB = trace_glGetnUniformfvARB;
  tbl.glGetnUniformivARB = trace_glGetnUniformivARB;
  tbl.glGetnUniformuivARB = trace_glGetnUniformuivARB;
  tbl.glReadnPixelsARB = trace_glReadnPixelsARB;

  // GL_ARB_sample_shading

  tbl.glMinSampleShading = trace_glMinSampleShading;
  tbl.glMinSampleShadingARB = trace_glMinSampleShadingARB;

  // GL_ARB_sampler_objects

  tbl.glBindSampler = trace_glBindSampler;
  tbl.glDeleteSamplers = trace_glDeleteSamplers;
  tbl.glGenSamplers = trace_glGenSamplers;
  tbl.glGetSamplerParameterIiv = trace_glGetSamplerParameterIiv;
  tbl.glGetSamplerParameterIuiv = trace_glGetSamplerParameterIuiv;
  tbl.glGetSamplerParameterfv = trace_glGetSamplerParameterfv;
  tbl.glGetSamplerParameteriv = trace_glGetSamplerParameteriv;
  tbl.glIsSampler = trace_glIsSampler;
  tbl.glSamplerParameterIiv = trace_glSamplerParameterIiv;
  tbl.glSamplerParameterIuiv = trace_glSamplerParameterIuiv;
  tbl.glSamplerParameterf = trace_glSamplerParameterf;
  tbl.glSamplerParameterfv = trace_glSamplerParameterfv;
  tbl.glSamplerParameteri = trace_glSamplerParameteri;
  tbl.glSamplerParameteriv = trace_glSamplerParameteriv;

  // GL_ARB_separate_shader_objects

  tbl.glActiveShaderProgram = trace_glActiveShaderProgram;
  tbl.glBindProgramPipeline = trace_glBindProgramPipeline;
  tbl.glCreateShaderProgramv = trace_glCreateShaderProgramv;
  tbl.glDeleteProgramPipelines = trace_glDeleteProgramPipelines;
  tbl.glGenProgramPipelines = trace_glGenProgramPipelines;
  tbl.glGetProgramPipelineInfoLog = trace_glGetProgramPipelineInfoLog;
  tbl.glGetProgramPipelineiv = trace_glGetProgramPipelineiv;
  tbl.glIsProgramPipeline = trace_glIsProgramPipeline;
  tbl.glProgramUniform1d = trace_glProgramUniform1d;
  tbl.glProgramUniform1dv = trace_glProgramUniform1dv;
  tbl.glProgramUniform1f = trace_glProgramUniform1f;
  tbl.glProgramUniform1fv = trace_glProgramUniform1fv;
  tbl.glProgramUniform1i = trace_glProgramUniform1i;
  tbl.glProgramUniform1iv = trace_glProgramUniform1iv;
  tbl.glProgramUniform1ui = trace_glProgramUniform1ui;
  tbl.glProgramUniform1uiv = trace_glProgramUniform1uiv;
  tbl.glProgramUniform2d = trace_glProgramUniform2d;
  tbl.glProgramUniform2dv = trace_glProgramUniform2dv;
  tbl.glProgramUniform2f = trace_glProgramUniform2f;
  tbl.glProgramUniform2fv = trace_glProgramUniform2fv;
  tbl.glProgramUniform2i = trace_glProgramUniform2i;
  tbl.glProgramUniform2iv = trace_glProgramUniform2iv;
  tbl.glProgramUniform2ui = trace_glProgramUniform2ui;
  tbl.glProgramUniform2uiv = trace_glProgramUniform2uiv;
  tbl.glProgramUniform3d = trace_glProgramUniform3d;
  tbl.glProgramUniform3dv = trace_glProgramUniform3dv;
  tbl.glProgramUniform3f = trace_glProgramUniform3f;
  tbl.glProgramUniform3fv = trace_glProgramUniform3fv;
  tbl.glProgramUniform3i = trace_glProgramUniform3i;
  tbl.glProgramUniform3iv = trace_glProgramUniform3iv;
  tbl.glProgramUniform3ui = trace_glProgramUniform3ui;
  tbl.glProgramUniform3uiv = trace_glProgramUniform3uiv;
  tbl.glProgramUniform4d = trace_glProgramUniform4d;
  tbl.glProgramUniform4dv = trace_glProgramUniform4dv;
  tbl.glProgramUniform4f = trace_glProgramUniform4f;
  tbl.glProgramUniform4fv = trace_glProgramUniform4fv;
  tbl.glProgramUniform4i = trace_glProgramUniform4i;
  tbl.glProgramUniform4iv = trace_glProgramUniform4iv;
  tbl.glProgramUniform4ui = trace_glProgramUniform4ui;
  tbl.glProgramUniform4uiv = trace_glProgramUniform4uiv;
  tbl.glProgramUniformMatrix2dv = trace_glProgramUniformMatrix2dv;
  tbl.glProgramUniformMatrix2fv = trace_glProgramUniformMatrix2fv;
  tbl.glProgramUniformMatrix2x3dv = trace_glProgramUniformMatrix2x3dv;
  tbl.glProgramUniformMatrix2x3fv = trace_glProgramUniformMatrix2x3fv;
  tbl.glProgramUniformMatrix2x4dv = trace_glProgramUniformMatrix2x4dv;
  tbl.glProgramUniformMatrix2x4fv = trace_glProgramUniformMatrix2x4fv;
  tbl.glProgramUniformMatrix3dv = trace_glProgramUniformMatrix3dv;
  tbl.glProgramUniformMatrix3fv = trace_glProgramUniformMatrix3fv;
  tbl.glProgramUniformMatrix3x2dv = trace_glProgramUniformMatrix3x2dv;
  tbl.glProgramUniformMatrix3x2fv = trace_glProgramUniformMatrix3x2fv;
  tbl.glProgramUniformMatrix3x4dv = trace_glProgramUniformMatrix3x4dv;
  tbl.glProgramUniformMatrix3x4fv = trace_glProgramUniformMatrix3x4fv;
  tbl.glProgramUniformMatrix4dv = trace_glProgramUniformMatrix4dv;
  tbl.glProgramUniformMatrix4fv = trace_glProgramUniformMatrix4fv;
  tbl.glProgramUniformMatrix4x2dv = trace_glProgramUniformMatrix4x2dv;
  tbl.glProgramUniformMatrix4x2fv = trace_glProgramUniformMatrix4x2fv;
  tbl.glProgramUniformMatrix4x3dv = trace_glProgramUniformMatrix4x3dv;
  tbl.glProgramUniformMatrix4x3fv = trace_glProgramUniformMatrix4x3fv;
  tbl.glUseProgramStages = trace_glUseProgramStages;
  tbl.glValidateProgramPipeline = trace_glValidateProgramPipeline;

  // GL_ARB_shader_atomic_counters

  tbl.glGetActiveAtomicCounterBufferiv = trace_glGetActiveAtomicCounterBufferiv;

  // GL_ARB_shader_image_load_store

  tbl.glBindImageTexture = trace_glBindImageTexture;
  tbl.glMemoryBarrier = trace_glMemoryBarrier;

  // GL_ARB_shader_objects

  tbl.glAttachObjectARB = trace_glAttachObjectARB;
  tbl.glCompileShaderARB = trace_glCompileShaderARB;
  tbl.glCreateProgramObjectARB = trace_glCreateProgramObjectARB;
  tbl.glCreateShaderObjectARB = trace_glCreateShaderObjectARB;
  tbl.glDeleteObjectARB = trace_glDeleteObjectARB;
  tbl.glDetachObjectARB = trace_glDetachObjectARB;
  tbl.glGetActiveUniformARB = trace_glGetActiveUniformARB;
  tbl.glGetAttachedObjectsARB = trace_glGetAttachedObjectsARB;
  tbl.glGetHandleARB = trace_glGetHandleARB;
  tbl.glGetInfoLogARB = trace_glGetInfoLogARB;
  tbl.glGetObjectParameterfvARB = trace_glGetObjectParameterfvARB;
  tbl.glGetObjectParameterivARB = trace_glGetObjectParameterivARB;
  tbl.glGetShaderSourceARB = trace_glGetShaderSourceARB;
  tbl.glGetUniformLocationARB = trace_glGetUniformLocationARB;
  tbl.glGetUniformfvARB = trace_glGetUniformfvARB;
  tbl.glGetUniformivARB = trace_glGetUniformivARB;
  tbl.glLinkProgramARB = trace_glLinkProgramARB;
  tbl.glShaderSourceARB = trace_glShaderSourceARB;
  tbl.glUniform1fARB = trace_glUniform1fARB;
  tbl.glUniform1fvARB = trace_glUniform1fvARB;
  tbl.glUniform1iARB = trace_glUniform1iARB;
  tbl.glUniform1ivARB = trace_glUniform1ivARB;
  tbl.glUniform2fARB = trace_glUniform2fARB;
  tbl.glUniform2fvARB = trace_glUniform2fvARB;
  tbl.glUniform2iARB = trace_glUniform2iARB;
  tbl.glUniform2ivARB = trace_glUniform2ivARB;
  tbl.glUniform3fARB = trace_glUniform3fARB;
  tbl.glUniform3fvARB = trace_glUniform3fvARB;
  tbl.glUniform3iARB = trace_glUniform3iARB;
  tbl.glUniform3ivARB = trace_glUniform3ivARB;
  tbl.glUniform4fARB = trace_glUniform4fARB;
  tbl.glUniform4fvARB = trace_glUniform4fvARB;
  tbl.glUniform4iARB = trace_glUniform4iARB;
  tbl.glUniform4ivARB = trace_glUniform4ivARB;
  tbl.glUniformMatrix2fvARB = trace_glUniformMatrix2fvARB;
  tbl.glUniformMatrix3fvARB = trace_glUniformMatrix3fvARB;
  tbl.glUniformMatrix4fvARB = trace_glUniformMatrix4fvARB;
  tbl.glUseProgramObjectARB = trace_glUseProgramObjectARB;
  tbl.glValidateProgramARB = trace_glValidateProgramARB;

  // GL_ARB_shader_storage_buffer_object

  tbl.glShaderStorageBlockBinding = trace_glShaderStorageBlockBinding;

  // GL_ARB_shader_subroutine

  tbl.glGetActiveSubroutineName = trace_glGetActiveSubroutineName;
  tbl.glGetActiveSubroutineUniformName = trace_glGetActiveSubroutineUniformName;
  tbl.glGetActiveSubroutineUniformiv = trace_glGetActiveSubroutineUniformiv;
  tbl.glGetProgramStageiv = trace_glGetProgramStageiv;
  tbl.glGetProgramSubroutineParameteruivNV = trace_glGetProgramSubroutineParameteruivNV;
  tbl.glGetSubroutineIndex = trace_glGetSubroutineIndex;
  tbl.glGetSubroutineUniformLocation = trace_glGetSubroutineUniformLocation;
  tbl.glGetUniformSubroutineuiv = trace_glGetUniformSubroutineuiv;
  tbl.glProgramSubroutineParametersuivNV = trace_glProgramSubroutineParametersuivNV;
  tbl.glUniformSubroutinesuiv = trace_glUniformSubroutinesuiv;

  // GL_ARB_shading_language_include

  tbl.glCompileShaderIncludeARB = trace_glCompileShaderIncludeARB;
  tbl.glDeleteNamedStringARB = trace_glDeleteNamedStringARB;
  tbl.glGetNamedStringARB = trace_glGetNamedStringARB;
  tbl.glGetNamedStringivARB = trace_glGetNamedStringivARB;
  tbl.glIsNamedStringARB = trace_glIsNamedStringARB;
  tbl.glNamedStringARB = trace_glNamedStringARB;

  // GL_ARB_sync

  tbl.glClientWaitSync = trace_glClientWaitSync;
  tbl.glDeleteSync = trace_glDeleteSync;
  tbl.glFenceSync = trace_glFenceSync;
  tbl.glGetInteger64v = trace_glGetInteger64v;
  tbl.glGetSynciv = trace_glGetSynciv;
  tbl.glIsSync = trace_glIsSync;
  tbl.glWaitSync = trace_glWaitSync;

  // GL_ARB_tessellation_shader

  tbl.glPatchParameterfv = trace_glPatchParameterfv;
  tbl.glPatchParameteri = trace_glPatchParameteri;

  // GL_ARB_texture_buffer_object

  tbl.glTexBufferARB = trace_glTexBufferARB;

  // GL_ARB_texture_buffer_range

  tbl.glTexBufferRange = trace_glTexBufferRange;
  tbl.glTextureBufferRangeEXT = trace_glTextureBufferRangeEXT;

  // GL_ARB_texture_compression

  tbl.glCompressedTexImage1DARB = trace_glCompressedTexImage1DARB;
  tbl.glCompressedTexImage2DARB = trace_glCompressedTexImage2DARB;
  tbl.glCompressedTexImage3DARB = trace_glCompressedTexImage3DARB;
  tbl.glCompressedTexSubImage1DARB = trace_glCompressedTexSubImage1DARB;
  tbl.glCompressedTexSubImage2DARB = trace_glCompressedTexSubImage2DARB;
  tbl.glCompressedTexSubImage3DARB = trace_glCompressedTexSubImage3DARB;
  tbl.glGetCompressedTexImageARB = trace_glGetCompressedTexImageARB;

  // GL_ARB_texture_multisample

  tbl.glGetMultisamplefv = trace_glGetMultisamplefv;
  tbl.glSampleMaski = trace_glSampleMaski;
  tbl.glTexImage2DMultisample = trace_glTexImage2DMultisample;
  tbl.glTexImage3DMultisample = trace_glTexImage3DMultisample;

  // GL_ARB_texture_storage

  tbl.glTexStorage1D = trace_glTexStorage1D;
  tbl.glTexStorage2D = trace_glTexStorage2D;
  tbl.glTexStorage3D = trace_glTexStorage3D;
  tbl.glTextureStorage1DEXT = trace_glTextureStorage1DEXT;
  tbl.glTextureStorage2DEXT = trace_glTextureStorage2DEXT;
  tbl.glTextureStorage3DEXT = trace_glTextureStorage3DEXT;

  // GL_ARB_texture_storage_multisample

  tbl.glTexStorage2DMultisample = trace_glTexStorage2DMultisample;
  tbl.glTexStorage3DMultisample = trace_glTexStorage3DMultisample;
  tbl.glTextureStorage2DMultisampleEXT = trace_glTextureStorage2DMultisampleEXT;
  tbl.glTextureStorage3DMultisampleEXT = trace_glTextureStorage3DMultisampleEXT;

  // GL_ARB_texture_view

  tbl.glTextureView = trace_glTextureView;

  // GL_ARB_timer_query

  tbl.glGetQueryObjecti64v = trace_glGetQueryObjecti64v;
  tbl.glGetQueryObjectui64v = trace_glGetQueryObjectui64v;
  tbl.glQueryCounter = trace_glQueryCounter;

  // GL_ARB_transform_feedback2

  tbl.glBindTransformFeedback = trace_glBindTransformFeedback;
  tbl.glDeleteTransformFeedbacks = trace_glDeleteTransformFeedbacks;
  tbl.glDrawTransformFeedback = trace_glDrawTransformFeedback;
  tbl.glGenTransformFeedbacks = trace_glGenTransformFeedbacks;
  tbl.glIsTransformFeedback = trace_glIsTransformFeedback;
  tbl.glPauseTransformFeedback = trace_glPauseTransformFeedback;
  tbl.glResumeTransformFeedback = trace_glResumeTransformFeedback;

  // GL_ARB_transform_feedback3

  tbl.glBeginQueryIndexed = trace_glBeginQueryIndexed;
  tbl.glDrawTransformFeedbackStream = trace_glDrawTransformFeedbackStream;
  tbl.glEndQueryIndexed = trace_glEndQueryIndexed;
  tbl.glGetQueryIndexediv = trace_glGetQueryIndexediv;

  // GL_ARB_transform_feedback_instanced

  tbl.glDrawTransformFeedbackInstanced = trace_glDrawTransformFeedbackInstanced;
  tbl.glDrawTransformFeedbackStreamInstanced = trace_glDrawTransformFeedbackStreamInstanced;

  // GL_ARB_transpose_matrix

  tbl.glLoadTransposeMatrixdARB = trace_glLoadTransposeMatrixdARB;
  tbl.glLoadTransposeMatrixfARB = trace_glLoadTransposeMatrixfARB;
  tbl.glMultTransposeMatrixdARB = trace_glMultTransposeMatrixdARB;
  tbl.glMultTransposeMatrixfARB = trace_glMultTransposeMatrixfARB;

  // GL_ARB_uniform_buffer_object

  tbl.glBindBufferBase = trace_glBindBufferBase;
  tbl.glBindBufferRange = trace_glBindBufferRange;
  tbl.glGetActiveUniformBlockName = trace_glGetActiveUniformBlockName;
  tbl.glGetActiveUniformBlockiv = trace_glGetActiveUniformBlockiv;
  tbl.glGetActiveUniformName = trace_glGetActiveUniformName;
  tbl.glGetActiveUniformsiv = trace_glGetActiveUniformsiv;
  tbl.glGetIntegeri_v = trace_glGetIntegeri_v;
  tbl.glGetUniformBlockIndex = trace_glGetUniformBlockIndex;
  tbl.glGetUniformIndices = trace_glGetUniformIndices;
  tbl.glUniformBlockBinding = trace_glUniformBlockBinding;

  // GL_ARB_vertex_array_object

  tbl.glBindVertexArray = trace_glBindVertexArray;
  tbl.glDeleteVertexArrays = trace_glDeleteVertexArrays;
  tbl.glGenVertexArrays = trace_glGenVertexArrays;
  tbl.glIsVertexArray = trace_glIsVertexArray;

  // GL_ARB_vertex_attrib_64bit

  tbl.glGetVertexAttribLdv = trace_glGetVertexAttribLdv;
  tbl.glVertexAttribL1d = trace_glVertexAttribL1d;
  tbl.glVertexAttribL1dv = trace_glVertexAttribL1dv;
  tbl.glVertexAttribL2d = trace_glVertexAttribL2d;
  tbl.glVertexAttribL2dv = trace_glVertexAttribL2dv;
  tbl.glVertexAttribL3d = trace_glVertexAttribL3d;
  tbl.glVertexAttribL3dv = trace_glVertexAttribL3dv;
  tbl.glVertexAttribL4d = trace_glVertexAttribL4d;
  tbl.glVertexAttribL4dv = trace_glVertexAttribL4dv;
  tbl.glVertexAttribLPointer = trace_glVertexAttribLPointer;

  // GL_ARB_vertex_attrib_binding

  tbl.glBindVertexBuffer = trace_glBindVertexBuffer;
  tbl.glVertexAttribBinding = trace_glVertexAttribBinding;
  tbl.glVertexAttribFormat = trace_glVertexAttribFormat;
  tbl.glVertexAttribIFormat = trace_glVertexAttribIFormat;
  tbl.glVertexAttribLFormat = trace_glVertexAttribLFormat;
  tbl.glVertexBindingDivisor = trace_glVertexBindingDivisor;

  // GL_ARB_vertex_blend

  tbl.glVertexBlendARB = trace_glVertexBlendARB;
  tbl.glWeightPointerARB = trace_glWeightPointerARB;
  tbl.glWeightbvARB = trace_glWeightbvARB;
  tbl.glWeightdvARB = trace_glWeightdvARB;
  tbl.glWeightfvARB = trace_glWeightfvARB;
  tbl.glWeightivARB = trace_glWeightivARB;
  tbl.glWeightsvARB = trace_glWeightsvARB;
  tbl.glWeightubvARB = trace_glWeightubvARB;
  tbl.glWeightuivARB = trace_glWeightuivARB;
  tbl.glWeightusvARB = trace_glWeightusvARB;

  // GL_ARB_vertex_buffer_object

  tbl.glBindBufferARB = trace_glBindBufferARB;
  tbl.glBufferDataARB = trace_glBufferDataARB;
  tbl.glBufferSubDataARB = trace_glBufferSubDataARB;
  tbl.glDeleteBuffersARB = trace_glDeleteBuffersARB;
  tbl.glGenBuffersARB = trace_glGenBuffersARB;
  tbl.glGetBufferParameterivARB = trace_glGetBufferParameterivARB;
  tbl.glGetBufferPointervARB = trace_glGetBufferPointervARB;
  tbl.glGetBufferSubDataARB = trace_glGetBufferSubDataARB;
  tbl.glIsBufferARB = trace_glIsBufferARB;
  tbl.glMapBufferARB = trace_glMapBufferARB;
  tbl.glUnmapBufferARB = trace_glUnmapBufferARB;

  // GL_ARB_vertex_program

  tbl.glBindProgramARB = trace_glBindProgramARB;
  tbl.glDeleteProgramsARB = trace_glDeleteProgramsARB;
  tbl.glDisableVertexAttribArrayARB = trace_glDisableVertexAttribArrayARB;
  tbl.glEnableVertexAttribArrayARB = trace_glEnableVertexAttribArrayARB;
  tbl.glGenProgramsARB = trace_glGenProgramsARB;
  tbl.glGetProgramEnvParameterdvARB = trace_glGetProgramEnvParameterdvARB;
  tbl.glGetProgramEnvParameterfvARB = trace_glGetProgramEnvParameterfvARB;
  tbl.glGetProgramLocalParameterdvARB = trace_glGetProgramLocalParameterdvARB;
  tbl.glGetProgramLocalParameterfvARB = trace_glGetProgramLocalParameterfvARB;
  tbl.glGetProgramStringARB = trace_glGetProgramStringARB;
  tbl.glGetProgramivARB = trace_glGetProgramivARB;
  tbl.glGetVertexAttribPointervARB = trace_glGetVertexAttribPointervARB;
  tbl.glGetVertexAttribdvARB = trace_glGetVertexAttribdvARB;
  tbl.glGetVertexAttribfvARB = trace_glGetVertexAttribfvARB;
  tbl.glGetVertexAttribivARB = trace_glGetVertexAttribivARB;
  tbl.glIsProgramARB = trace_glIsProgramARB;
  tbl.glProgramEnvParameter4dARB = trace_glProgramEnvParameter4dARB;
  tbl.glProgramEnvParameter4dvARB = trace_glProgramEnvParameter4dvARB;
  tbl.glProgramEnvParameter4fARB = trace_glProgramEnvParameter4fARB;
  tbl.glProgramEnvParameter4fvARB = trace_glProgramEnvParameter4fvARB;
  tbl.glProgramLocalParameter4dARB = trace_glProgramLocalParameter4dARB;
  tbl.glProgramLocalParameter4dvARB = trace_glProgramLocalParameter4dvARB;
  tbl.glProgramLocalParameter4fARB = trace_glProgramLocalParameter4fARB;
  tbl.glProgramLocalParameter4fvARB = trace_glProgramLocalParameter4fvARB;
  tbl.glProgramStringARB = trace_glProgramStringARB;
  tbl.glVertexAttrib1dARB = trace_glVertexAttrib1dARB;
  tbl.glVertexAttrib1dvARB = trace_glVertexAttrib1dvARB;
  tbl.glVertexAttrib1fARB = trace_glVertexAttrib1fARB;
  tbl.glVertexAttrib1fvARB = trace_glVertexAttrib1fvARB;
  tbl.glVertexAttrib1sARB = trace_glVertexAttrib1sARB;
  tbl.glVertexAttrib1svARB = trace_glVertexAttrib1svARB;
  tbl.glVertexAttrib2dARB = trace_glVertexAttrib2dARB;
  tbl.glVertexAttrib2dvARB = trace_glVertexAttrib2dvARB;
  tbl.glVertexAttrib2fARB = trace_glVertexAttrib2fARB;
  tbl.glVertexAttrib2fvARB = trace_glVertexAttrib2fvARB;
  tbl.glVertexAttrib2sARB = trace_glVertexAttrib2sARB;
  tbl.glVertexAttrib2svARB = trace_glVertexAttrib2svARB;
  tbl.glVertexAttrib3dARB = trace_glVertexAttrib3dARB;
  tbl.glVertexAttrib3dvARB = trace_glVertexAttrib3dvARB;
  tbl.glVertexAttrib3fARB = trace_glVertexAttrib3fARB;
  tbl.glVertexAttrib3fvARB = trace_glVertexAttrib3fvARB;
  tbl.glVertexAttrib3sARB = trace_glVertexAttrib3sARB;
  tbl.glVertexAttrib3svARB = trace_glVertexAttrib3svARB;
  tbl.glVertexAttrib4NbvARB = trace_glVertexAttrib4NbvARB;
  tbl.glVertexAttrib4NivARB = trace_glVertexAttrib4NivARB;
  tbl.glVertexAttrib4NsvARB = trace_glVertexAttrib4NsvARB;
  tbl.glVertexAttrib4NubARB = trace_glVertexAttrib4NubARB;
  tbl.glVertexAttrib4NubvARB = trace_glVertexAttrib4NubvARB;
  tbl.glVertexAttrib4NuivARB = trace_glVertexAttrib4NuivARB;
  tbl.glVertexAttrib4NusvARB = trace_glVertexAttrib4NusvARB;
  tbl.glVertexAttrib4bvARB = trace_glVertexAttrib4bvARB;
  tbl.glVertexAttrib4dARB = trace_glVertexAttrib4dARB;
  tbl.glVertexAttrib4dvARB = trace_glVertexAttrib4dvARB;
  tbl.glVertexAttrib4fARB = trace_glVertexAttrib4fARB;
  tbl.glVertexAttrib4fvARB = trace_glVertexAttrib4fvARB;
  tbl.glVertexAttrib4ivARB = trace_glVertexAttrib4ivARB;
  tbl.glVertexAttrib4sARB = trace_glVertexAttrib4sARB;
  tbl.glVertexAttrib4svARB = trace_glVertexAttrib4svARB;
  tbl.glVertexAttrib4ubvARB = trace_glVertexAttrib4ubvARB;
  tbl.glVertexAttrib4uivARB = trace_glVertexAttrib4uivARB;
  tbl.glVertexAttrib4usvARB = trace_glVertexAttrib4usvARB;
  tbl.glVertexAttribPointerARB = trace_glVertexAttribPointerARB;

  // GL_ARB_vertex_shader

  tbl.glBindAttribLocationARB = trace_glBindAttribLocationARB;
  tbl.glGetActiveAttribARB = trace_glGetActiveAttribARB;
  tbl.glGetAttribLocationARB = trace_glGetAttribLocationARB;

  // GL_ARB_vertex_type_2_10_10_10_rev

  tbl.glColorP3ui = trace_glColorP3ui;
  tbl.glColorP3uiv = trace_glColorP3uiv;
  tbl.glColorP4ui = trace_glColorP4ui;
  tbl.glColorP4uiv = trace_glColorP4uiv;
  tbl.glMultiTexCoordP1ui = trace_glMultiTexCoordP1ui;
  tbl.glMultiTexCoordP1uiv = trace_glMultiTexCoordP1uiv;
  tbl.glMultiTexCoordP2ui = trace_glMultiTexCoordP2ui;
  tbl.glMultiTexCoordP2uiv = trace_glMultiTexCoordP2uiv;
  tbl.glMultiTexCoordP3ui = trace_glMultiTexCoordP3ui;
  tbl.glMultiTexCoordP3uiv = trace_glMultiTexCoordP3uiv;
  tbl.glMultiTexCoordP4ui = trace_glMultiTexCoordP4ui;
  tbl.glMultiTexCoordP4uiv = trace_glMultiTexCoordP4uiv;
  tbl.glNormalP3ui = trace_glNormalP3ui;
  tbl.glNormalP3uiv = trace_glNormalP3uiv;
  tbl.glSecondaryColorP3ui = trace_glSecondaryColorP3ui;
  tbl.glSecondaryColorP3uiv = trace_glSecondaryColorP3uiv;
  tbl.glTexCoordP1ui = trace_glTexCoordP1ui;
  tbl.glTexCoordP1uiv = trace_glTexCoordP1uiv;
  tbl.glTexCoordP2ui = trace_glTexCoordP2ui;
  tbl.glTexCoordP2uiv = trace_glTexCoordP2uiv;
  tbl.glTexCoordP3ui = trace_glTexCoordP3ui;
  tbl.glTexCoordP3uiv = trace_glTexCoordP3uiv;
  tbl.glTexCoordP4ui = trace_glTexCoordP4ui;
  tbl.glTexCoordP4uiv = trace_glTexCoordP4uiv;
  tbl.glVertexAttribP1ui = trace_glVertexAttribP1ui;
  tbl.glVertexAttribP1uiv = trace_glVertexAttribP1uiv;
  tbl.glVertexAttribP2ui = trace_glVertexAttribP2ui;
  tbl.glVertexAttribP2uiv = trace_glVertexAttribP2uiv;
  tbl.glVertexAttribP3ui = trace_glVertexAttribP3ui;
  tbl.glVertexAttribP3uiv = trace_glVertexAttribP3uiv;
  tbl.glVertexAttribP4ui = trace_glVertexAttribP4ui;
  tbl.glVertexAttribP4uiv = trace_glVertexAttribP4uiv;
  tbl.glVertexP2ui = trace_glVertexP2ui;
  tbl.glVertexP2uiv = trace_glVertexP2uiv;
  tbl.glVertexP3ui = trace_glVertexP3ui;
  tbl.glVertexP3uiv = trace_glVertexP3uiv;
  tbl.glVertexP4ui = trace_glVertexP4ui;
  tbl.glVertexP4uiv = trace_glVertexP4uiv;

  // GL_ARB_viewport_array

  tbl.glDepthRangeArrayv = trace_glDepthRangeArrayv;
  tbl.glDepthRangeIndexed = trace_glDepthRangeIndexed;
  tbl.glGetDoublei_v = trace_glGetDoublei_v;
  tbl.glGetFloati_v = trace_glGetFloati_v;
  tbl.glScissorArrayv = trace_glScissorArrayv;
  tbl.glScissorIndexed = trace_glScissorIndexed;
  tbl.glScissorIndexedv = trace_glScissorIndexedv;
  tbl.glViewportArrayv = trace_glViewportArrayv;
  tbl.glViewportIndexedf = trace_glViewportIndexedf;
  tbl.glViewportIndexedfv = trace_glViewportIndexedfv;

  // GL_ARB_window_pos

  tbl.glWindowPos2dARB = trace_glWindowPos2dARB;
  tbl.glWindowPos2dvARB = trace_glWindowPos2dvARB;
  tbl.glWindowPos2fARB = trace_glWindowPos2fARB;
  tbl.glWindowPos2fvARB = trace_glWindowPos2fvARB;
  tbl.glWindowPos2iARB = trace_glWindowPos2iARB;
  tbl.glWindowPos2ivARB = trace_glWindowPos2ivARB;
  tbl.glWindowPos2sARB = trace_glWindowPos2sARB;
  tbl.glWindowPos2svARB = trace_glWindowPos2svARB;
  tbl.glWindowPos3dARB = trace_glWindowPos3dARB;
  tbl.glWindowPos3dvARB = trace_glWindowPos3dvARB;
  tbl.glWindowPos3fARB = trace_glWindowPos3fARB;
  tbl.glWindowPos3fvARB = trace_glWindowPos3fvARB;
  tbl.glWindowPos3iARB = trace_glWindowPos3iARB;
  tbl.glWindowPos3ivARB = trace_glWindowPos3ivARB;
  tbl.glWindowPos3sARB = trace_glWindowPos3sARB;
  tbl.glWindowPos3svARB = trace_glWindowPos3svARB;

  // GL_ATI_draw_buffers

  tbl.glDrawBuffersATI = trace_glDrawBuffersATI;

  // GL_ATI_element_array

  tbl.glDrawElementArrayATI = trace_glDrawElementArrayATI;
  tbl.glDrawRangeElementArrayATI = trace_glDrawRangeElementArrayATI;
  tbl.glElementPointerATI = trace_glElementPointerATI;

  // GL_ATI_envmap_bumpmap

  tbl.glGetTexBumpParameterfvATI = trace_glGetTexBumpParameterfvATI;
  tbl.glGetTexBumpParameterivATI = trace_glGetTexBumpParameterivATI;
  tbl.glTexBumpParameterfvATI = trace_glTexBumpParameterfvATI;
  tbl.glTexBumpParameterivATI = trace_glTexBumpParameterivATI;

  // GL_ATI_fragment_shader

  tbl.glAlphaFragmentOp1ATI = trace_glAlphaFragmentOp1ATI;
  tbl.glAlphaFragmentOp2ATI = trace_glAlphaFragmentOp2ATI;
  tbl.glAlphaFragmentOp3ATI = trace_glAlphaFragmentOp3ATI;
  tbl.glBeginFragmentShaderATI = trace_glBeginFragmentShaderATI;
  tbl.glBindFragmentShaderATI = trace_glBindFragmentShaderATI;
  tbl.glColorFragmentOp1ATI = trace_glColorFragmentOp1ATI;
  tbl.glColorFragmentOp2ATI = trace_glColorFragmentOp2ATI;
  tbl.glColorFragmentOp3ATI = trace_glColorFragmentOp3ATI;
  tbl.glDeleteFragmentShaderATI = trace_glDeleteFragmentShaderATI;
  tbl.glEndFragmentShaderATI = trace_glEndFragmentShaderATI;
  tbl.glGenFragmentShadersATI = trace_glGenFragmentShadersATI;
  tbl.glPassTexCoordATI = trace_glPassTexCoordATI;
  tbl.glSampleMapATI = trace_glSampleMapATI;
  tbl.glSetFragmentShaderConstantATI = trace_glSetFragmentShaderConstantATI;

  // GL_ATI_map_object_buffer

  tbl.glMapObjectBufferATI = trace_glMapObjectBufferATI;
  tbl.glUnmapObjectBufferATI = trace_glUnmapObjectBufferATI;

  // GL_ATI_pn_triangles

  tbl.glPNTrianglesfATI = trace_glPNTrianglesfATI;
  tbl.glPNTrianglesiATI = trace_glPNTrianglesiATI;

  // GL_ATI_separate_stencil

  tbl.glStencilFuncSeparateATI = trace_glStencilFuncSeparateATI;
  tbl.glStencilOpSeparateATI = trace_glStencilOpSeparateATI;

  // GL_ATI_vertex_array_object

  tbl.glArrayObjectATI = trace_glArrayObjectATI;
  tbl.glFreeObjectBufferATI = trace_glFreeObjectBufferATI;
  tbl.glGetArrayObjectfvATI = trace_glGetArrayObjectfvATI;
  tbl.glGetArrayObjectivATI = trace_glGetArrayObjectivATI;
  tbl.glGetObjectBufferfvATI = trace_glGetObjectBufferfvATI;
  tbl.glGetObjectBufferivATI = trace_glGetObjectBufferivATI;
  tbl.glGetVariantArrayObjectfvATI = trace_glGetVariantArrayObjectfvATI;
  tbl.glGetVariantArrayObjectivATI = trace_glGetVariantArrayObjectivATI;
  tbl.glIsObjectBufferATI = trace_glIsObjectBufferATI;
  tbl.glNewObjectBufferATI = trace_glNewObjectBufferATI;
  tbl.glUpdateObjectBufferATI = trace_glUpdateObjectBufferATI;
  tbl.glVariantArrayObjectATI = trace_glVariantArrayObjectATI;

  // GL_ATI_vertex_attrib_array_object

  tbl.glGetVertexAttribArrayObjectfvATI = trace_glGetVertexAttribArrayObjectfvATI;
  tbl.glGetVertexAttribArrayObjectivATI = trace_glGetVertexAttribArrayObjectivATI;
  tbl.glVertexAttribArrayObjectATI = trace_glVertexAttribArrayObjectATI;

  // GL_ATI_vertex_streams

  tbl.glClientActiveVertexStreamATI = trace_glClientActiveVertexStreamATI;
  tbl.glNormalStream3bATI = trace_glNormalStream3bATI;
  tbl.glNormalStream3bvATI = trace_glNormalStream3bvATI;
  tbl.glNormalStream3dATI = trace_glNormalStream3dATI;
  tbl.glNormalStream3dvATI = trace_glNormalStream3dvATI;
  tbl.glNormalStream3fATI = trace_glNormalStream3fATI;
  tbl.glNormalStream3fvATI = trace_glNormalStream3fvATI;
  tbl.glNormalStream3iATI = trace_glNormalStream3iATI;
  tbl.glNormalStream3ivATI = trace_glNormalStream3ivATI;
  tbl.glNormalStream3sATI = trace_glNormalStream3sATI;
  tbl.glNormalStream3svATI = trace_glNormalStream3svATI;
  tbl.glVertexBlendEnvfATI = trace_glVertexBlendEnvfATI;
  tbl.glVertexBlendEnviATI = trace_glVertexBlendEnviATI;
  tbl.glVertexStream1dATI = trace_glVertexStream1dATI;
  tbl.glVertexStream1dvATI = trace_glVertexStream1dvATI;
  tbl.glVertexStream1fATI = trace_glVertexStream1fATI;
  tbl.glVertexStream1fvATI = trace_glVertexStream1fvATI;
  tbl.glVertexStream1iATI = trace_glVertexStream1iATI;
  tbl.glVertexStream1ivATI = trace_glVertexStream1ivATI;
  tbl.glVertexStream1sATI = trace_glVertexStream1sATI;
  tbl.glVertexStream1svATI = trace_glVertexStream1svATI;
  tbl.glVertexStream2dATI = trace_glVertexStream2dATI;
  tbl.glVertexStream2dvATI = trace_glVertexStream2dvATI;
  tbl.glVertexStream2fATI = trace_glVertexStream2fATI;
  tbl.glVertexStream2fvATI = trace_glVertexStream2fvATI;
  tbl.glVertexStream2iATI = trace_glVertexStream2iATI;
  tbl.glVertexStream2ivATI = trace_glVertexStream2ivATI;
  tbl.glVertexStream2sATI = trace_glVertexStream2sATI;
  tbl.glVertexStream2svATI = trace_glVertexStream2svATI;
  tbl.glVertexStream3dATI = trace_glVertexStream3dATI;
  tbl.glVertexStream3dvATI = trace_glVertexStream3dvATI;
  tbl.glVertexStream3fATI = trace_glVertexStream3fATI;
  tbl.glVertexStream3fvATI = trace_glVertexStream3fvATI;
  tbl.glVertexStream3iATI = trace_glVertexStream3iATI;
  tbl.glVertexStream3ivATI = trace_glVertexStream3ivATI;
  tbl.glVertexStream3sATI = trace_glVertexStream3sATI;
  tbl.glVertexStream3svATI = trace_glVertexStream3svATI;
  tbl.glVertexStream4dATI = trace_glVertexStream4dATI;
  tbl.glVertexStream4dvATI = trace_glVertexStream4dvATI;
  tbl.glVertexStream4fATI = trace_glVertexStream4fATI;
  tbl.glVertexStream4fvATI = trace_glVertexStream4fvATI;
  tbl.glVertexStream4iATI = trace_glVertexStream4iATI;
  tbl.glVertexStream4ivATI = trace_glVertexStream4ivATI;
  tbl.glVertexStream4sATI = trace_glVertexStream4sATI;
  tbl.glVertexStream4svATI = trace_glVertexStream4svATI;

  // GL_EXT_bindable_uniform

  tbl.glGetUniformBufferSizeEXT = trace_glGetUniformBufferSizeEXT;
  tbl.glGetUniformOffsetEXT = trace_glGetUniformOffsetEXT;
  tbl.glUniformBufferEXT = trace_glUniformBufferEXT;

  // GL_EXT_blend_color

  tbl.glBlendColorEXT = trace_glBlendColorEXT;

  // GL_EXT_blend_equation_separate

  tbl.glBlendEquationSeparateEXT = trace_glBlendEquationSeparateEXT;

  // GL_EXT_blend_func_separate

  tbl.glBlendFuncSeparateEXT = trace_glBlendFuncSeparateEXT;

  // GL_EXT_blend_minmax

  tbl.glBlendEquationEXT = trace_glBlendEquationEXT;

  // GL_EXT_color_subtable

  tbl.glColorSubTableEXT = trace_glColorSubTableEXT;
  tbl.glCopyColorSubTableEXT = trace_glCopyColorSubTableEXT;

  // GL_EXT_compiled_vertex_array

  tbl.glLockArraysEXT = trace_glLockArraysEXT;
  tbl.glUnlockArraysEXT = trace_glUnlockArraysEXT;

  // GL_EXT_convolution

  tbl.glConvolutionFilter1DEXT = trace_glConvolutionFilter1DEXT;
  tbl.glConvolutionFilter2DEXT = trace_glConvolutionFilter2DEXT;
  tbl.glConvolutionParameterfEXT = trace_glConvolutionParameterfEXT;
  tbl.glConvolutionParameterfvEXT = trace_glConvolutionParameterfvEXT;
  tbl.glConvolutionParameteriEXT = trace_glConvolutionParameteriEXT;
  tbl.glConvolutionParameterivEXT = trace_glConvolutionParameterivEXT;
  tbl.glCopyConvolutionFilter1DEXT = trace_glCopyConvolutionFilter1DEXT;
  tbl.glCopyConvolutionFilter2DEXT = trace_glCopyConvolutionFilter2DEXT;
  tbl.glGetConvolutionFilterEXT = trace_glGetConvolutionFilterEXT;
  tbl.glGetConvolutionParameterfvEXT = trace_glGetConvolutionParameterfvEXT;
  tbl.glGetConvolutionParameterivEXT = trace_glGetConvolutionParameterivEXT;
  tbl.glGetSeparableFilterEXT = trace_glGetSeparableFilterEXT;
  tbl.glSeparableFilter2DEXT = trace_glSeparableFilter2DEXT;

  // GL_EXT_coordinate_frame

  tbl.glBinormal3bEXT = trace_glBinormal3bEXT;
  tbl.glBinormal3bvEXT = trace_glBinormal3bvEXT;
  tbl.glBinormal3dEXT = trace_glBinormal3dEXT;
  tbl.glBinormal3dvEXT = trace_glBinormal3dvEXT;
  tbl.glBinormal3fEXT = trace_glBinormal3fEXT;
  tbl.glBinormal3fvEXT = trace_glBinormal3fvEXT;
  tbl.glBinormal3iEXT = trace_glBinormal3iEXT;
  tbl.glBinormal3ivEXT = trace_glBinormal3ivEXT;
  tbl.glBinormal3sEXT = trace_glBinormal3sEXT;
  tbl.glBinormal3svEXT = trace_glBinormal3svEXT;
  tbl.glBinormalPointerEXT = trace_glBinormalPointerEXT;
  tbl.glTangent3bEXT = trace_glTangent3bEXT;
  tbl.glTangent3bvEXT = trace_glTangent3bvEXT;
  tbl.glTangent3dEXT = trace_glTangent3dEXT;
  tbl.glTangent3dvEXT = trace_glTangent3dvEXT;
  tbl.glTangent3fEXT = trace_glTangent3fEXT;
  tbl.glTangent3fvEXT = trace_glTangent3fvEXT;
  tbl.glTangent3iEXT = trace_glTangent3iEXT;
  tbl.glTangent3ivEXT = trace_glTangent3ivEXT;
  tbl.glTangent3sEXT = trace_glTangent3sEXT;
  tbl.glTangent3svEXT = trace_glTangent3svEXT;
  tbl.glTangentPointerEXT = trace_glTangentPointerEXT;

  // GL_EXT_copy_texture

  tbl.glCopyTexImage1DEXT = trace_glCopyTexImage1DEXT;
  tbl.glCopyTexImage2DEXT = trace_glCopyTexImage2DEXT;
  tbl.glCopyTexSubImage1DEXT = trace_glCopyTexSubImage1DEXT;
  tbl.glCopyTexSubImage2DEXT = trace_glCopyTexSubImage2DEXT;
  tbl.glCopyTexSubImage3DEXT = trace_glCopyTexSubImage3DEXT;

  // GL_EXT_cull_vertex

  tbl.glCullParameterdvEXT = trace_glCullParameterdvEXT;
  tbl.glCullParameterfvEXT = trace_glCullParameterfvEXT;

  // GL_EXT_debug_label

  tbl.glGetObjectLabelEXT = trace_glGetObjectLabelEXT;
  tbl.glLabelObjectEXT = trace_glLabelObjectEXT;

  // GL_EXT_debug_marker

  tbl.glInsertEventMarkerEXT = trace_glInsertEventMarkerEXT;
  tbl.glPopGroupMarkerEXT = trace_glPopGroupMarkerEXT;
  tbl.glPushGroupMarkerEXT = trace_glPushGroupMarkerEXT;

  // GL_EXT_depth_bounds_test

  tbl.glDepthBoundsEXT = trace_glDepthBoundsEXT;

  // GL_EXT_direct_state_access

  tbl.glBindMultiTextureEXT = trace_glBindMultiTextureEXT;
  tbl.glCheckNamedFramebufferStatusEXT = trace_glCheckNamedFramebufferStatusEXT;
  tbl.glClientAttribDefaultEXT = trace_glClientAttribDefaultEXT;
  tbl.glCompressedMultiTexImage1DEXT = trace_glCompressedMultiTexImage1DEXT;
  tbl.glCompressedMultiTexImage2DEXT = trace_glCompressedMultiTexImage2DEXT;
  tbl.glCompressedMultiTexImage3DEXT = trace_glCompressedMultiTexImage3DEXT;
  tbl.glCompressedMultiTexSubImage1DEXT = trace_glCompressedMultiTexSubImage1DEXT;
  tbl.glCompressedMultiTexSubImage2DEXT = trace_glCompressedMultiTexSubImage2DEXT;
  tbl.glCompressedMultiTexSubImage3DEXT = trace_glCompressedMultiTexSubImage3DEXT;
  tbl.glCompressedTextureImage1DEXT = trace_glCompressedTextureImage1DEXT;
  tbl.glCompressedTextureImage2DEXT = trace_glCompressedTextureImage2DEXT;
  tbl.glCompressedTextureImage3DEXT = trace_glCompressedTextureImage3DEXT;
  tbl.glCompressedTextureSubImage1DEXT = trace_glCompressedTextureSubImage1DEXT;
  tbl.glCompressedTextureSubImage2DEXT = trace_glCompressedTextureSubImage2DEXT;
  tbl.glCompressedTextureSubImage3DEXT = trace_glCompressedTextureSubImage3DEXT;
  tbl.glCopyMultiTexImage1DEXT = trace_glCopyMultiTexImage1DEXT;
  tbl.glCopyMultiTexImage2DEXT = trace_glCopyMultiTexImage2DEXT;
  tbl.glCopyMultiTexSubImage1DEXT = trace_glCopyMultiTexSubImage1DEXT;
  tbl.glCopyMultiTexSubImage2DEXT = trace_glCopyMultiTexSubImage2DEXT;
  tbl.glCopyMultiTexSubImage3DEXT = trace_glCopyMultiTexSubImage3DEXT;
  tbl.glCopyTextureImage1DEXT = trace_glCopyTextureImage1DEXT;
  tbl.glCopyTextureImage2DEXT = trace_glCopyTextureImage2DEXT;
  tbl.glCopyTextureSubImage1DEXT = trace_glCopyTextureSubImage1DEXT;
  tbl.glCopyTextureSubImage2DEXT = trace_glCopyTextureSubImage2DEXT;
  tbl.glCopyTextureSubImage3DEXT = trace_glCopyTextureSubImage3DEXT;
  tbl.glDisableClientStateIndexedEXT = trace_glDisableClientStateIndexedEXT;
  tbl.glDisableVertexArrayAttribEXT = trace_glDisableVertexArrayAttribEXT;
  tbl.glDisableVertexArrayEXT = trace_glDisableVertexArrayEXT;
  tbl.glEnableClientStateIndexedEXT = trace_glEnableClientStateIndexedEXT;
  tbl.glEnableVertexArrayAttribEXT = trace_glEnableVertexArrayAttribEXT;
  tbl.glEnableVertexArrayEXT = trace_glEnableVertexArrayEXT;
  tbl.glFlushMappedNamedBufferRangeEXT = trace_glFlushMappedNamedBufferRangeEXT;
  tbl.glFramebufferDrawBufferEXT = trace_glFramebufferDrawBufferEXT;
  tbl.glFramebufferDrawBuffersEXT = trace_glFramebufferDrawBuffersEXT;
  tbl.glFramebufferReadBufferEXT = trace_glFramebufferReadBufferEXT;
  tbl.glGenerateMultiTexMipmapEXT = trace_glGenerateMultiTexMipmapEXT;
  tbl.glGenerateTextureMipmapEXT = trace_glGenerateTextureMipmapEXT;
  tbl.glGetCompressedMultiTexImageEXT = trace_glGetCompressedMultiTexImageEXT;
  tbl.glGetCompressedTextureImageEXT = trace_glGetCompressedTextureImageEXT;
  tbl.glGetDoubleIndexedvEXT = trace_glGetDoubleIndexedvEXT;
  tbl.glGetFloatIndexedvEXT = trace_glGetFloatIndexedvEXT;
  tbl.glGetFramebufferParameterivEXT = trace_glGetFramebufferParameterivEXT;
  tbl.glGetMultiTexEnvfvEXT = trace_glGetMultiTexEnvfvEXT;
  tbl.glGetMultiTexEnvivEXT = trace_glGetMultiTexEnvivEXT;
  tbl.glGetMultiTexGendvEXT = trace_glGetMultiTexGendvEXT;
  tbl.glGetMultiTexGenfvEXT = trace_glGetMultiTexGenfvEXT;
  tbl.glGetMultiTexGenivEXT = trace_glGetMultiTexGenivEXT;
  tbl.glGetMultiTexImageEXT = trace_glGetMultiTexImageEXT;
  tbl.glGetMultiTexLevelParameterfvEXT = trace_glGetMultiTexLevelParameterfvEXT;
  tbl.glGetMultiTexLevelParameterivEXT = trace_glGetMultiTexLevelParameterivEXT;
  tbl.glGetMultiTexParameterIivEXT = trace_glGetMultiTexParameterIivEXT;
  tbl.glGetMultiTexParameterIuivEXT = trace_glGetMultiTexParameterIuivEXT;
  tbl.glGetMultiTexParameterfvEXT = trace_glGetMultiTexParameterfvEXT;
  tbl.glGetMultiTexParameterivEXT = trace_glGetMultiTexParameterivEXT;
  tbl.glGetNamedBufferParameterivEXT = trace_glGetNamedBufferParameterivEXT;
  tbl.glGetNamedBufferPointervEXT = trace_glGetNamedBufferPointervEXT;
  tbl.glGetNamedBufferSubDataEXT = trace_glGetNamedBufferSubDataEXT;
  tbl.glGetNamedFramebufferAttachmentParameterivEXT = trace_glGetNamedFramebufferAttachmentParameterivEXT;
  tbl.glGetNamedProgramLocalParameterIivEXT = trace_glGetNamedProgramLocalParameterIivEXT;
  tbl.glGetNamedProgramLocalParameterIuivEXT = trace_glGetNamedProgramLocalParameterIuivEXT;
  tbl.glGetNamedProgramLocalParameterdvEXT = trace_glGetNamedProgramLocalParameterdvEXT;
  tbl.glGetNamedProgramLocalParameterfvEXT = trace_glGetNamedProgramLocalParameterfvEXT;
  tbl.glGetNamedProgramStringEXT = trace_glGetNamedProgramStringEXT;
  tbl.glGetNamedProgramivEXT = trace_glGetNamedProgramivEXT;
  tbl.glGetNamedRenderbufferParameterivEXT = trace_glGetNamedRenderbufferParameterivEXT;
  tbl.glGetPointerIndexedvEXT = trace_glGetPointerIndexedvEXT;
  tbl.glGetTextureImageEXT = trace_glGetTextureImageEXT;
  tbl.glGetTextureLevelParameterfvEXT = trace_glGetTextureLevelParameterfvEXT;
  tbl.glGetTextureLevelParameterivEXT = trace_glGetTextureLevelParameterivEXT;
  tbl.glGetTextureParameterIivEXT = trace_glGetTextureParameterIivEXT;
  tbl.glGetTextureParameterIuivEXT = trace_glGetTextureParameterIuivEXT;
  tbl.glGetTextureParameterfvEXT = trace_glGetTextureParameterfvEXT;
  tbl.glGetTextureParameterivEXT = trace_glGetTextureParameterivEXT;
  tbl.glGetVertexArrayIntegeri_vEXT = trace_glGetVertexArrayIntegeri_vEXT;
  tbl.glGetVertexArrayIntegervEXT = trace_glGetVertexArrayIntegervEXT;
  tbl.glGetVertexArrayPointeri_vEXT = trace_glGetVertexArrayPointeri_vEXT;
  tbl.glGetVertexArrayPointervEXT = trace_glGetVertexArrayPointervEXT;
  tbl.glMapNamedBufferEXT = trace_glMapNamedBufferEXT;
  tbl.glMapNamedBufferRangeEXT = trace_glMapNamedBufferRangeEXT;
  tbl.glMatrixFrustumEXT = trace_glMatrixFrustumEXT;
  tbl.glMatrixLoadIdentityEXT = trace_glMatrixLoadIdentityEXT;
  tbl.glMatrixLoadTransposedEXT = trace_glMatrixLoadTransposedEXT;
  tbl.glMatrixLoadTransposefEXT = trace_glMatrixLoadTransposefEXT;
  tbl.glMatrixLoaddEXT = trace_glMatrixLoaddEXT;
  tbl.glMatrixLoadfEXT = trace_glMatrixLoadfEXT;
  tbl.glMatrixMultTransposedEXT = trace_glMatrixMultTransposedEXT;
  tbl.glMatrixMultTransposefEXT = trace_glMatrixMultTransposefEXT;
  tbl.glMatrixMultdEXT = trace_glMatrixMultdEXT;
  tbl.glMatrixMultfEXT = trace_glMatrixMultfEXT;
  tbl.glMatrixOrthoEXT = trace_glMatrixOrthoEXT;
  tbl.glMatrixPopEXT = trace_glMatrixPopEXT;
  tbl.glMatrixPushEXT = trace_glMatrixPushEXT;
  tbl.glMatrixRotatedEXT = trace_glMatrixRotatedEXT;
  tbl.glMatrixRotatefEXT = trace_glMatrixRotatefEXT;
  tbl.glMatrixScaledEXT = trace_glMatrixScaledEXT;
  tbl.glMatrixScalefEXT = trace_glMatrixScalefEXT;
  tbl.glMatrixTranslatedEXT = trace_glMatrixTranslatedEXT;
  tbl.glMatrixTranslatefEXT = trace_glMatrixTranslatefEXT;
  tbl.glMultiTexBufferEXT = trace_glMultiTexBufferEXT;
  tbl.glMultiTexCoordPointerEXT = trace_glMultiTexCoordPointerEXT;
  tbl.glMultiTexEnvfEXT = trace_glMultiTexEnvfEXT;
  tbl.glMultiTexEnvfvEXT = trace_glMultiTexEnvfvEXT;
  tbl.glMultiTexEnviEXT = trace_glMultiTexEnviEXT;
  tbl.glMultiTexEnvivEXT = trace_glMultiTexEnvivEXT;
  tbl.glMultiTexGendEXT = trace_glMultiTexGendEXT;
  tbl.glMultiTexGendvEXT = trace_glMultiTexGendvEXT;
  tbl.glMultiTexGenfEXT = trace_glMultiTexGenfEXT;
  tbl.glMultiTexGenfvEXT = trace_glMultiTexGenfvEXT;
  tbl.glMultiTexGeniEXT = trace_glMultiTexGeniEXT;
  tbl.glMultiTexGenivEXT = trace_glMultiTexGenivEXT;
  tbl.glMultiTexParameterIivEXT = trace_glMultiTexParameterIivEXT;
  tbl.glMultiTexParameterIuivEXT = trace_glMultiTexParameterIuivEXT;
  tbl.glMultiTexParameterfEXT = trace_glMultiTexParameterfEXT;
  tbl.glMultiTexParameterfvEXT = trace_glMultiTexParameterfvEXT;
  tbl.glMultiTexParameteriEXT = trace_glMultiTexParameteriEXT;
  tbl.glMultiTexParameterivEXT = trace_glMultiTexParameterivEXT;
  tbl.glMultiTexRenderbufferEXT = trace_glMultiTexRenderbufferEXT;
  tbl.glMultiTexSubImage1DEXT = trace_glMultiTexSubImage1DEXT;
  tbl.glMultiTexSubImage2DEXT = trace_glMultiTexSubImage2DEXT;
  tbl.glMultiTexSubImage3DEXT = trace_glMultiTexSubImage3DEXT;
  tbl.glNamedBufferDataEXT = trace_glNamedBufferDataEXT;
  tbl.glNamedBufferSubDataEXT = trace_glNamedBufferSubDataEXT;
  tbl.glNamedCopyBufferSubDataEXT = trace_glNamedCopyBufferSubDataEXT;
  tbl.glNamedFramebufferRenderbufferEXT = trace_glNamedFramebufferRenderbufferEXT;
  tbl.glNamedFramebufferTexture1DEXT = trace_glNamedFramebufferTexture1DEXT;
  tbl.glNamedFramebufferTexture2DEXT = trace_glNamedFramebufferTexture2DEXT;
  tbl.glNamedFramebufferTexture3DEXT = trace_glNamedFramebufferTexture3DEXT;
  tbl.glNamedFramebufferTextureEXT = trace_glNamedFramebufferTextureEXT;
  tbl.glNamedFramebufferTextureFaceEXT = trace_glNamedFramebufferTextureFaceEXT;
  tbl.glNamedFramebufferTextureLayerEXT = trace_glNamedFramebufferTextureLayerEXT;
  tbl.glNamedProgramLocalParameter4dEXT = trace_glNamedProgramLocalParameter4dEXT;
  tbl.glNamedProgramLocalParameter4dvEXT = trace_glNamedProgramLocalParameter4dvEXT;
  tbl.glNamedProgramLocalParameter4fEXT = trace_glNamedProgramLocalParameter4fEXT;
  tbl.glNamedProgramLocalParameter4fvEXT = trace_glNamedProgramLocalParameter4fvEXT;
  tbl.glNamedProgramLocalParameterI4iEXT = trace_glNamedProgramLocalParameterI4iEXT;
  tbl.glNamedProgramLocalParameterI4ivEXT = trace_glNamedProgramLocalParameterI4ivEXT;
  tbl.glNamedProgramLocalParameterI4uiEXT = trace_glNamedProgramLocalParameterI4uiEXT;
  tbl.glNamedProgramLocalParameterI4uivEXT = trace_glNamedProgramLocalParameterI4uivEXT;
  tbl.glNamedProgramLocalParameters4fvEXT = trace_glNamedProgramLocalParameters4fvEXT;
  tbl.glNamedProgramLocalParametersI4ivEXT = trace_glNamedProgramLocalParametersI4ivEXT;
  tbl.glNamedProgramLocalParametersI4uivEXT = trace_glNamedProgramLocalParametersI4uivEXT;
  tbl.glNamedProgramStringEXT = trace_glNamedProgramStringEXT;
  tbl.glNamedRenderbufferStorageEXT = trace_glNamedRenderbufferStorageEXT;
  tbl.glNamedRenderbufferStorageMultisampleCoverageEXT = trace_glNamedRenderbufferStorageMultisampleCoverageEXT;
  tbl.glNamedRenderbufferStorageMultisampleEXT = trace_glNamedRenderbufferStorageMultisampleEXT;
  tbl.glProgramUniform1dEXT = trace_glProgramUniform1dEXT;
  tbl.glProgramUniform1dvEXT = trace_glProgramUniform1dvEXT;
  tbl.glProgramUniform1fEXT = trace_glProgramUniform1fEXT;
  tbl.glProgramUniform1fvEXT = trace_glProgramUniform1fvEXT;
  tbl.glProgramUniform1iEXT = trace_glProgramUniform1iEXT;
  tbl.glProgramUniform1ivEXT = trace_glProgramUniform1ivEXT;
  tbl.glProgramUniform1uiEXT = trace_glProgramUniform1uiEXT;
  tbl.glProgramUniform1uivEXT = trace_glProgramUniform1uivEXT;
  tbl.glProgramUniform2dEXT = trace_glProgramUniform2dEXT;
  tbl.glProgramUniform2dvEXT = trace_glProgramUniform2dvEXT;
  tbl.glProgramUniform2fEXT = trace_glProgramUniform2fEXT;
  tbl.glProgramUniform2fvEXT = trace_glProgramUniform2fvEXT;
  tbl.glProgramUniform2iEXT = trace_glProgramUniform2iEXT;
  tbl.glProgramUniform2ivEXT = trace_glProgramUniform2ivEXT;
  tbl.glProgramUniform2uiEXT = trace_glProgramUniform2uiEXT;
  tbl.glProgramUniform2uivEXT = trace_glProgramUniform2uivEXT;
  tbl.glProgramUniform3dEXT = trace_glProgramUniform3dEXT;
  tbl.glProgramUniform3dvEXT = trace_glProgramUniform3dvEXT;
  tbl.glProgramUniform3fEXT = trace_glProgramUniform3fEXT;
  tbl.glProgramUniform3fvEXT = trace_glProgramUniform3fvEXT;
  tbl.glProgramUniform3iEXT = trace_glProgramUniform3iEXT;
  tbl.glProgramUniform3ivEXT = trace_glProgramUniform3ivEXT;
  tbl.glProgramUniform3uiEXT = trace_glProgramUniform3uiEXT;
  tbl.glProgramUniform3uivEXT = trace_glProgramUniform3uivEXT;
  tbl.glProgramUniform4dEXT = trace_glProgramUniform4dEXT;
  tbl.glProgramUniform4dvEXT = trace_glProgramUniform4dvEXT;
  tbl.glProgramUniform4fEXT = trace_glProgramUniform4fEXT;
  tbl.glProgramUniform4fvEXT = trace_glProgramUniform4fvEXT;
  tbl.glProgramUniform4iEXT = trace_glProgramUniform4iEXT;
  tbl.glProgramUniform4ivEXT = trace_glProgramUniform4ivEXT;
  tbl.glProgramUniform4uiEXT = trace_glProgramUniform4uiEXT;
  tbl.glProgramUniform4uivEXT = trace_glProgramUniform4uivEXT;
  tbl.glProgramUniformMatrix2dvEXT = trace_glProgramUniformMatrix2dvEXT;
  tbl.glProgramUniformMatrix2fvEXT = trace_glProgramUniformMatrix2fvEXT;
  tbl.glProgramUniformMatrix2x3dvEXT = trace_glProgramUniformMatrix2x3dvEXT;
  tbl.glProgramUniformMatrix2x3fvEXT = trace_glProgramUniformMatrix2x3fvEXT;
  tbl.glProgramUniformMatrix2x4dvEXT = trace_glProgramUniformMatrix2x4dvEXT;
  tbl.glProgramUniformMatrix2x4fvEXT = trace_glProgramUniformMatrix2x4fvEXT;
  tbl.glProgramUniformMatrix3dvEXT = trace_glProgramUniformMatrix3dvEXT;
  tbl.glProgramUniformMatrix3fvEXT = trace_glProgramUniformMatrix3fvEXT;
  tbl.glProgramUniformMatrix3x2dvEXT = trace_glProgramUniformMatrix3x2dvEXT;
  tbl.glProgramUniformMatrix3x2fvEXT = trace_glProgramUniformMatrix3x2fvEXT;
  tbl.glProgramUniformMatrix3x4dvEXT = trace_glProgramUniformMatrix3x4dvEXT;
  tbl.glProgramUniformMatrix3x4fvEXT = trace_glProgramUniformMatrix3x4fvEXT;
  tbl.glProgramUniformMatrix4dvEXT = trace_glProgramUniformMatrix4dvEXT;
  tbl.glProgramUniformMatrix4fvEXT = trace_glProgramUniformMatrix4fvEXT;
  tbl.glProgramUniformMatrix4x2dvEXT = trace_glProgramUniformMatrix4x2dvEXT;
  tbl.glProgramUniformMatrix4x2fvEXT = trace_glProgramUniformMatrix4x2fvEXT;
  tbl.glProgramUniformMatrix4x3dvEXT = trace_glProgramUniformMatrix4x3dvEXT;
  tbl.glProgramUniformMatrix4x3fvEXT = trace_glProgramUniformMatrix4x3fvEXT;
  tbl.glPushClientAttribDefaultEXT = trace_glPushClientAttribDefaultEXT;
  tbl.glTextureBufferEXT = trace_glTextureBufferEXT;
  tbl.glTextureParameterIivEXT = trace_glTextureParameterIivEXT;
  tbl.glTextureParameterIuivEXT = trace_glTextureParameterIuivEXT;
  tbl.glTextureParameterfEXT = trace_glTextureParameterfEXT;
  tbl.glTextureParameterfvEXT = trace_glTextureParameterfvEXT;
  tbl.glTextureParameteriEXT = trace_glTextureParameteriEXT;
  tbl.glTextureParameterivEXT = trace_glTextureParameterivEXT;
  tbl.glTextureRenderbufferEXT = trace_glTextureRenderbufferEXT;
  tbl.glTextureSubImage1DEXT = trace_glTextureSubImage1DEXT;
  tbl.glTextureSubImage2DEXT = trace_glTextureSubImage2DEXT;
  tbl.glTextureSubImage3DEXT = trace_glTextureSubImage3DEXT;
  tbl.glUnmapNamedBufferEXT = trace_glUnmapNamedBufferEXT;
  tbl.glVertexArrayColorOffsetEXT = trace_glVertexArrayColorOffsetEXT;
  tbl.glVertexArrayEdgeFlagOffsetEXT = trace_glVertexArrayEdgeFlagOffsetEXT;
  tbl.glVertexArrayFogCoordOffsetEXT = trace_glVertexArrayFogCoordOffsetEXT;
  tbl.glVertexArrayIndexOffsetEXT = trace_glVertexArrayIndexOffsetEXT;
  tbl.glVertexArrayMultiTexCoordOffsetEXT = trace_glVertexArrayMultiTexCoordOffsetEXT;
  tbl.glVertexArrayNormalOffsetEXT = trace_glVertexArrayNormalOffsetEXT;
  tbl.glVertexArraySecondaryColorOffsetEXT = trace_glVertexArraySecondaryColorOffsetEXT;
  tbl.glVertexArrayTexCoordOffsetEXT = trace_glVertexArrayTexCoordOffsetEXT;
  tbl.glVertexArrayVertexAttribIOffsetEXT = trace_glVertexArrayVertexAttribIOffsetEXT;
  tbl.glVertexArrayVertexAttribOffsetEXT = trace_glVertexArrayVertexAttribOffsetEXT;
  tbl.glVertexArrayVertexOffsetEXT = trace_glVertexArrayVertexOffsetEXT;

  // GL_EXT_discard_framebuffer

  tbl.glDiscardFramebufferEXT = trace_glDiscardFramebufferEXT;

  // GL_EXT_draw_buffers2

  tbl.glColorMaskIndexedEXT = trace_glColorMaskIndexedEXT;
  tbl.glDisableIndexedEXT = trace_glDisableIndexedEXT;
  tbl.glEnableIndexedEXT = trace_glEnableIndexedEXT;
  tbl.glGetBooleanIndexedvEXT = trace_glGetBooleanIndexedvEXT;
  tbl.glGetIntegerIndexedvEXT = trace_glGetIntegerIndexedvEXT;
  tbl.glIsEnabledIndexedEXT = trace_glIsEnabledIndexedEXT;

  // GL_EXT_draw_instanced

  tbl.glDrawArraysInstancedEXT = trace_glDrawArraysInstancedEXT;
  tbl.glDrawElementsInstancedEXT = trace_glDrawElementsInstancedEXT;

  // GL_EXT_draw_range_elements

  tbl.glDrawRangeElementsEXT = trace_glDrawRangeElementsEXT;

  // GL_EXT_fog_coord

  tbl.glFogCoordPointerEXT = trace_glFogCoordPointerEXT;
  tbl.glFogCoorddEXT = trace_glFogCoorddEXT;
  tbl.glFogCoorddvEXT = trace_glFogCoorddvEXT;
  tbl.glFogCoordfEXT = trace_glFogCoordfEXT;
  tbl.glFogCoordfvEXT = trace_glFogCoordfvEXT;

  // GL_EXT_framebuffer_blit

  tbl.glBlitFramebufferEXT = trace_glBlitFramebufferEXT;

  // GL_EXT_framebuffer_multisample

  tbl.glRenderbufferStorageMultisampleEXT = trace_glRenderbufferStorageMultisampleEXT;

  // GL_EXT_framebuffer_object

  tbl.glBindFramebufferEXT = trace_glBindFramebufferEXT;
  tbl.glBindRenderbufferEXT = trace_glBindRenderbufferEXT;
  tbl.glCheckFramebufferStatusEXT = trace_glCheckFramebufferStatusEXT;
  tbl.glDeleteFramebuffersEXT = trace_glDeleteFramebuffersEXT;
  tbl.glDeleteRenderbuffersEXT = trace_glDeleteRenderbuffersEXT;
  tbl.glFramebufferRenderbufferEXT = trace_glFramebufferRenderbufferEXT;
  tbl.glFramebufferTexture1DEXT = trace_glFramebufferTexture1DEXT;
  tbl.glFramebufferTexture2DEXT = trace_glFramebufferTexture2DEXT;
  tbl.glFramebufferTexture3DEXT = trace_glFramebufferTexture3DEXT;
  tbl.glGenFramebuffersEXT = trace_glGenFramebuffersEXT;
  tbl.glGenRenderbuffersEXT = trace_glGenRenderbuffersEXT;
  tbl.glGenerateMipmapEXT = trace_glGenerateMipmapEXT;
  tbl.glGetFramebufferAttachmentParameterivEXT = trace_glGetFramebufferAttachmentParameterivEXT;
  tbl.glGetRenderbufferParameterivEXT = trace_glGetRenderbufferParameterivEXT;
  tbl.glIsFramebufferEXT = trace_glIsFramebufferEXT;
  tbl.glIsRenderbufferEXT = trace_glIsRenderbufferEXT;
  tbl.glRenderbufferStorageEXT = trace_glRenderbufferStorageEXT;

  // GL_EXT_geometry_shader4

  tbl.glFramebufferTextureEXT = trace_glFramebufferTextureEXT;
  tbl.glFramebufferTextureFaceEXT = trace_glFramebufferTextureFaceEXT;
  tbl.glProgramParameteriEXT = trace_glProgramParameteriEXT;

  // GL_EXT_gpu_program_parameters

  tbl.glProgramEnvParameters4fvEXT = trace_glProgramEnvParameters4fvEXT;
  tbl.glProgramLocalParameters4fvEXT = trace_glProgramLocalParameters4fvEXT;

  // GL_EXT_gpu_shader4

  tbl.glBindFragDataLocationEXT = trace_glBindFragDataLocationEXT;
  tbl.glGetFragDataLocationEXT = trace_glGetFragDataLocationEXT;
  tbl.glGetUniformuivEXT = trace_glGetUniformuivEXT;
  tbl.glGetVertexAttribIivEXT = trace_glGetVertexAttribIivEXT;
  tbl.glGetVertexAttribIuivEXT = trace_glGetVertexAttribIuivEXT;
  tbl.glUniform1uiEXT = trace_glUniform1uiEXT;
  tbl.glUniform1uivEXT = trace_glUniform1uivEXT;
  tbl.glUniform2uiEXT = trace_glUniform2uiEXT;
  tbl.glUniform2uivEXT = trace_glUniform2uivEXT;
  tbl.glUniform3uiEXT = trace_glUniform3uiEXT;
  tbl.glUniform3uivEXT = trace_glUniform3uivEXT;
  tbl.glUniform4uiEXT = trace_glUniform4uiEXT;
  tbl.glUniform4uivEXT = trace_glUniform4uivEXT;
  tbl.glVertexAttribI1iEXT = trace_glVertexAttribI1iEXT;
  tbl.glVertexAttribI1ivEXT = trace_glVertexAttribI1ivEXT;
  tbl.glVertexAttribI1uiEXT = trace_glVertexAttribI1uiEXT;
  tbl.glVertexAttribI1uivEXT = trace_glVertexAttribI1uivEXT;
  tbl.glVertexAttribI2iEXT = trace_glVertexAttribI2iEXT;
  tbl.glVertexAttribI2ivEXT = trace_glVertexAttribI2ivEXT;
  tbl.glVertexAttribI2uiEXT = trace_glVertexAttribI2uiEXT;
  tbl.glVertexAttribI2uivEXT = trace_glVertexAttribI2uivEXT;
  tbl.glVertexAttribI3iEXT = trace_glVertexAttribI3iEXT;
  tbl.glVertexAttribI3ivEXT = trace_glVertexAttribI3ivEXT;
  tbl.glVertexAttribI3uiEXT = trace_glVertexAttribI3uiEXT;
  tbl.glVertexAttribI3uivEXT = trace_glVertexAttribI3uivEXT;
  tbl.glVertexAttribI4bvEXT = trace_glVertexAttribI4bvEXT;
  tbl.glVertexAttribI4iEXT = trace_glVertexAttribI4iEXT;
  tbl.glVertexAttribI4ivEXT = trace_glVertexAttribI4ivEXT;
  tbl.glVertexAttribI4svEXT = trace_glVertexAttribI4svEXT;
  tbl.glVertexAttribI4ubvEXT = trace_glVertexAttribI4ubvEXT;
  tbl.glVertexAttribI4uiEXT = trace_glVertexAttribI4uiEXT;
  tbl.glVertexAttribI4uivEXT = trace_glVertexAttribI4uivEXT;
  tbl.glVertexAttribI4usvEXT = trace_glVertexAttribI4usvEXT;
  tbl.glVertexAttribIPointerEXT = trace_glVertexAttribIPointerEXT;

  // GL_EXT_histogram

  tbl.glGetHistogramEXT = trace_glGetHistogramEXT;
  tbl.glGetHistogramParameterfvEXT = trace_glGetHistogramParameterfvEXT;
  tbl.glGetHistogramParameterivEXT = trace_glGetHistogramParameterivEXT;
  tbl.glGetMinmaxEXT = trace_glGetMinmaxEXT;
  tbl.glGetMinmaxParameterfvEXT = trace_glGetMinmaxParameterfvEXT;
  tbl.glGetMinmaxParameterivEXT = trace_glGetMinmaxParameterivEXT;
  tbl.glHistogramEXT = trace_glHistogramEXT;
  tbl.glMinmaxEXT = trace_glMinmaxEXT;
  tbl.glResetHistogramEXT = trace_glResetHistogramEXT;
  tbl.glResetMinmaxEXT = trace_glResetMinmaxEXT;

  // GL_EXT_index_func

  tbl.glIndexFuncEXT = trace_glIndexFuncEXT;

  // GL_EXT_index_material

  tbl.glIndexMaterialEXT = trace_glIndexMaterialEXT;

  // GL_EXT_light_texture

  tbl.glApplyTextureEXT = trace_glApplyTextureEXT;
  tbl.glTextureLightEXT = trace_glTextureLightEXT;
  tbl.glTextureMaterialEXT = trace_glTextureMaterialEXT;

  // GL_EXT_multi_draw_arrays

  tbl.glMultiDrawArraysEXT = trace_glMultiDrawArraysEXT;
  tbl.glMultiDrawElementsEXT = trace_glMultiDrawElementsEXT;

  // GL_EXT_multisample

  tbl.glSampleMaskEXT = trace_glSampleMaskEXT;
  tbl.glSamplePatternEXT = trace_glSamplePatternEXT;

  // GL_EXT_occlusion_query_boolean

  tbl.glBeginQueryEXT = trace_glBeginQueryEXT;
  tbl.glDeleteQueriesEXT = trace_glDeleteQueriesEXT;
  tbl.glEndQueryEXT = trace_glEndQueryEXT;
  tbl.glGenQueriesEXT = trace_glGenQueriesEXT;
  tbl.glGetQueryObjectuivEXT = trace_glGetQueryObjectuivEXT;
  tbl.glGetQueryivEXT = trace_glGetQueryivEXT;
  tbl.glIsQueryEXT = trace_glIsQueryEXT;

  // GL_EXT_paletted_texture

  tbl.glColorTableEXT = trace_glColorTableEXT;
  tbl.glGetColorTableEXT = trace_glGetColorTableEXT;
  tbl.glGetColorTableParameterfvEXT = trace_glGetColorTableParameterfvEXT;
  tbl.glGetColorTableParameterivEXT = trace_glGetColorTableParameterivEXT;

  // GL_EXT_pixel_transform

  tbl.glPixelTransformParameterfEXT = trace_glPixelTransformParameterfEXT;
  tbl.glPixelTransformParameterfvEXT = trace_glPixelTransformParameterfvEXT;
  tbl.glPixelTransformParameteriEXT = trace_glPixelTransformParameteriEXT;
  tbl.glPixelTransformParameterivEXT = trace_glPixelTransformParameterivEXT;

  // GL_EXT_point_parameters

  tbl.glPointParameterfEXT = trace_glPointParameterfEXT;
  tbl.glPointParameterfvEXT = trace_glPointParameterfvEXT;

  // GL_EXT_polygon_offset

  tbl.glPolygonOffsetEXT = trace_glPolygonOffsetEXT;

  // GL_EXT_provoking_vertex

  tbl.glProvokingVertexEXT = trace_glProvokingVertexEXT;

  // GL_EXT_secondary_color

  tbl.glSecondaryColor3bEXT = trace_glSecondaryColor3bEXT;
  tbl.glSecondaryColor3bvEXT = trace_glSecondaryColor3bvEXT;
  tbl.glSecondaryColor3dEXT = trace_glSecondaryColor3dEXT;
  tbl.glSecondaryColor3dvEXT = trace_glSecondaryColor3dvEXT;
  tbl.glSecondaryColor3fEXT = trace_glSecondaryColor3fEXT;
  tbl.glSecondaryColor3fvEXT = trace_glSecondaryColor3fvEXT;
  tbl.glSecondaryColor3iEXT = trace_glSecondaryColor3iEXT;
  tbl.glSecondaryColor3ivEXT = trace_glSecondaryColor3ivEXT;
  tbl.glSecondaryColor3sEXT = trace_glSecondaryColor3sEXT;
  tbl.glSecondaryColor3svEXT = trace_glSecondaryColor3svEXT;
  tbl.glSecondaryColor3ubEXT = trace_glSecondaryColor3ubEXT;
  tbl.glSecondaryColor3ubvEXT = trace_glSecondaryColor3ubvEXT;
  tbl.glSecondaryColor3uiEXT = trace_glSecondaryColor3uiEXT;
  tbl.glSecondaryColor3uivEXT = trace_glSecondaryColor3uivEXT;
  tbl.glSecondaryColor3usEXT = trace_glSecondaryColor3usEXT;
  tbl.glSecondaryColor3usvEXT = trace_glSecondaryColor3usvEXT;
  tbl.glSecondaryColorPointerEXT = trace_glSecondaryColorPointerEXT;

  // GL_EXT_separate_shader_objects

  tbl.glActiveProgramEXT = trace_glActiveProgramEXT;
  tbl.glCreateShaderProgramEXT = trace_glCreateShaderProgramEXT;
  tbl.glUseShaderProgramEXT = trace_glUseShaderProgramEXT;

  // GL_EXT_shader_image_load_store

  tbl.glBindImageTextureEXT = trace_glBindImageTextureEXT;
  tbl.glMemoryBarrierEXT = trace_glMemoryBarrierEXT;

  // GL_EXT_stencil_clear_tag

  tbl.glStencilClearTagEXT = trace_glStencilClearTagEXT;

  // GL_EXT_stencil_two_side

  tbl.glActiveStencilFaceEXT = trace_glActiveStencilFaceEXT;

  // GL_EXT_subtexture

  tbl.glTexSubImage1DEXT = trace_glTexSubImage1DEXT;
  tbl.glTexSubImage2DEXT = trace_glTexSubImage2DEXT;
  tbl.glTexSubImage3DEXT = trace_glTexSubImage3DEXT;

  // GL_EXT_texture3D

  tbl.glTexImage3DEXT = trace_glTexImage3DEXT;

  // GL_EXT_texture_array

  tbl.glFramebufferTextureLayerEXT = trace_glFramebufferTextureLayerEXT;

  // GL_EXT_texture_buffer_object

  tbl.glTexBufferEXT = trace_glTexBufferEXT;

  // GL_EXT_texture_integer

  tbl.glClearColorIiEXT = trace_glClearColorIiEXT;
  tbl.glClearColorIuiEXT = trace_glClearColorIuiEXT;
  tbl.glGetTexParameterIivEXT = trace_glGetTexParameterIivEXT;
  tbl.glGetTexParameterIuivEXT = trace_glGetTexParameterIuivEXT;
  tbl.glTexParameterIivEXT = trace_glTexParameterIivEXT;
  tbl.glTexParameterIuivEXT = trace_glTexParameterIuivEXT;

  // GL_EXT_texture_object

  tbl.glAreTexturesResidentEXT = trace_glAreTexturesResidentEXT;
  tbl.glBindTextureEXT = trace_glBindTextureEXT;
  tbl.glDeleteTexturesEXT = trace_glDeleteTexturesEXT;
  tbl.glGenTexturesEXT = trace_glGenTexturesEXT;
  tbl.glIsTextureEXT = trace_glIsTextureEXT;
  tbl.glPrioritizeTexturesEXT = trace_glPrioritizeTexturesEXT;

  // GL_EXT_texture_perturb_normal

  tbl.glTextureNormalEXT = trace_glTextureNormalEXT;

  // GL_EXT_timer_query

  tbl.glGetQueryObjecti64vEXT = trace_glGetQueryObjecti64vEXT;
  tbl.glGetQueryObjectui64vEXT = trace_glGetQueryObjectui64vEXT;

  // GL_EXT_transform_feedback

  tbl.glBeginTransformFeedbackEXT = trace_glBeginTransformFeedbackEXT;
  tbl.glBindBufferBaseEXT = trace_glBindBufferBaseEXT;
  tbl.glBindBufferOffsetEXT = trace_glBindBufferOffsetEXT;
  tbl.glBindBufferRangeEXT = trace_glBindBufferRangeEXT;
  tbl.glEndTransformFeedbackEXT = trace_glEndTransformFeedbackEXT;
  tbl.glGetTransformFeedbackVaryingEXT = trace_glGetTransformFeedbackVaryingEXT;
  tbl.glTransformFeedbackVaryingsEXT = trace_glTransformFeedbackVaryingsEXT;

  // GL_EXT_vertex_array

  tbl.glArrayElementEXT = trace_glArrayElementEXT;
  tbl.glColorPointerEXT = trace_glColorPointerEXT;
  tbl.glDrawArraysEXT = trace_glDrawArraysEXT;
  tbl.glEdgeFlagPointerEXT = trace_glEdgeFlagPointerEXT;
  tbl.glGetPointervEXT = trace_glGetPointervEXT;
  tbl.glIndexPointerEXT = trace_glIndexPointerEXT;
  tbl.glNormalPointerEXT = trace_glNormalPointerEXT;
  tbl.glTexCoordPointerEXT = trace_glTexCoordPointerEXT;
  tbl.glVertexPointerEXT = trace_glVertexPointerEXT;

  // GL_EXT_vertex_attrib_64bit

  tbl.glGetVertexAttribLdvEXT = trace_glGetVertexAttribLdvEXT;
  tbl.glVertexArrayVertexAttribLOffsetEXT = trace_glVertexArrayVertexAttribLOffsetEXT;
  tbl.glVertexAttribL1dEXT = trace_glVertexAttribL1dEXT;
  tbl.glVertexAttribL1dvEXT = trace_glVertexAttribL1dvEXT;
  tbl.glVertexAttribL2dEXT = trace_glVertexAttribL2dEXT;
  tbl.glVertexAttribL2dvEXT = trace_glVertexAttribL2dvEXT;
  tbl.glVertexAttribL3dEXT = trace_glVertexAttribL3dEXT;
  tbl.glVertexAttribL3dvEXT = trace_glVertexAttribL3dvEXT;
  tbl.glVertexAttribL4dEXT = trace_glVertexAttribL4dEXT;
  tbl.glVertexAttribL4dvEXT = trace_glVertexAttribL4dvEXT;
  tbl.glVertexAttribLPointerEXT = trace_glVertexAttribLPointerEXT;

  // GL_EXT_vertex_shader

  tbl.glBeginVertexShaderEXT = trace_glBeginVertexShaderEXT;
  tbl.glBindLightParameterEXT = trace_glBindLightParameterEXT;
  tbl.glBindMaterialParameterEXT = trace_glBindMaterialParameterEXT;
  tbl.glBindParameterEXT = trace_glBindParameterEXT;
  tbl.glBindTexGenParameterEXT = trace_glBindTexGenParameterEXT;
  tbl.glBindTextureUnitParameterEXT = trace_glBindTextureUnitParameterEXT;
  tbl.glBindVertexShaderEXT = trace_glBindVertexShaderEXT;
  tbl.glDeleteVertexShaderEXT = trace_glDeleteVertexShaderEXT;
  tbl.glDisableVariantClientStateEXT = trace_glDisableVariantClientStateEXT;
  tbl.glEnableVariantClientStateEXT = trace_glEnableVariantClientStateEXT;
  tbl.glEndVertexShaderEXT = trace_glEndVertexShaderEXT;
  tbl.glExtractComponentEXT = trace_glExtractComponentEXT;
  tbl.glGenSymbolsEXT = trace_glGenSymbolsEXT;
  tbl.glGenVertexShadersEXT = trace_glGenVertexShadersEXT;
  tbl.glGetInvariantBooleanvEXT = trace_glGetInvariantBooleanvEXT;
  tbl.glGetInvariantFloatvEXT = trace_glGetInvariantFloatvEXT;
  tbl.glGetInvariantIntegervEXT = trace_glGetInvariantIntegervEXT;
  tbl.glGetLocalConstantBooleanvEXT = trace_glGetLocalConstantBooleanvEXT;
  tbl.glGetLocalConstantFloatvEXT = trace_glGetLocalConstantFloatvEXT;
  tbl.glGetLocalConstantIntegervEXT = trace_glGetLocalConstantIntegervEXT;
  tbl.glGetVariantBooleanvEXT = trace_glGetVariantBooleanvEXT;
  tbl.glGetVariantFloatvEXT = trace_glGetVariantFloatvEXT;
  tbl.glGetVariantIntegervEXT = trace_glGetVariantIntegervEXT;
  tbl.glGetVariantPointervEXT = trace_glGetVariantPointervEXT;
  tbl.glInsertComponentEXT = trace_glInsertComponentEXT;
  tbl.glIsVariantEnabledEXT = trace_glIsVariantEnabledEXT;
  tbl.glSetInvariantEXT = trace_glSetInvariantEXT;
  tbl.glSetLocalConstantEXT = trace_glSetLocalConstantEXT;
  tbl.glShaderOp1EXT = trace_glShaderOp1EXT;
  tbl.glShaderOp2EXT = trace_glShaderOp2EXT;
  tbl.glShaderOp3EXT = trace_glShaderOp3EXT;
  tbl.glSwizzleEXT = trace_glSwizzleEXT;
  tbl.glVariantPointerEXT = trace_glVariantPointerEXT;
  tbl.glVariantbvEXT = trace_glVariantbvEXT;
  tbl.glVariantdvEXT = trace_glVariantdvEXT;
  tbl.glVariantfvEXT = trace_glVariantfvEXT;
  tbl.glVariantivEXT = trace_glVariantivEXT;
  tbl.glVariantsvEXT = trace_glVariantsvEXT;
  tbl.glVariantubvEXT = trace_glVariantubvEXT;
  tbl.glVariantuivEXT = trace_glVariantuivEXT;
  tbl.glVariantusvEXT = trace_glVariantusvEXT;
  tbl.glWriteMaskEXT = trace_glWriteMaskEXT;

  // GL_EXT_vertex_weighting

  tbl.glVertexWeightPointerEXT = trace_glVertexWeightPointerEXT;
  tbl.glVertexWeightfEXT = trace_glVertexWeightfEXT;
  tbl.glVertexWeightfvEXT = trace_glVertexWeightfvEXT;

  // GL_EXT_x11_sync_object

  tbl.glImportSyncEXT = trace_glImportSyncEXT;

  // GL_GREMEDY_frame_terminator

  tbl.glFrameTerminatorGREMEDY = trace_glFrameTerminatorGREMEDY;

  // GL_GREMEDY_string_marker

  tbl.glStringMarkerGREMEDY = trace_glStringMarkerGREMEDY;

  // GL_HP_image_transform

  tbl.glGetImageTransformParameterfvHP = trace_glGetImageTransformParameterfvHP;
  tbl.glGetImageTransformParameterivHP = trace_glGetImageTransformParameterivHP;
  tbl.glImageTransformParameterfHP = trace_glImageTransformParameterfHP;
  tbl.glImageTransformParameterfvHP = trace_glImageTransformParameterfvHP;
  tbl.glImageTransformParameteriHP = trace_glImageTransformParameteriHP;
  tbl.glImageTransformParameterivHP = trace_glImageTransformParameterivHP;

  // GL_IBM_multimode_draw_arrays

  tbl.glMultiModeDrawArraysIBM = trace_glMultiModeDrawArraysIBM;
  tbl.glMultiModeDrawElementsIBM = trace_glMultiModeDrawElementsIBM;

  // GL_IBM_vertex_array_lists

  tbl.glColorPointerListIBM = trace_glColorPointerListIBM;
  tbl.glEdgeFlagPointerListIBM = trace_glEdgeFlagPointerListIBM;
  tbl.glFogCoordPointerListIBM = trace_glFogCoordPointerListIBM;
  tbl.glIndexPointerListIBM = trace_glIndexPointerListIBM;
  tbl.glNormalPointerListIBM = trace_glNormalPointerListIBM;
  tbl.glSecondaryColorPointerListIBM = trace_glSecondaryColorPointerListIBM;
  tbl.glTexCoordPointerListIBM = trace_glTexCoordPointerListIBM;
  tbl.glVertexPointerListIBM = trace_glVertexPointerListIBM;

  // GL_IMG_multisampled_render_to_texture

  tbl.glFramebufferTexture2DMultisampleIMG = trace_glFramebufferTexture2DMultisampleIMG;
  tbl.glRenderbufferStorageMultisampleIMG = trace_glRenderbufferStorageMultisampleIMG;

  // GL_INGR_blend_func_separate

  tbl.glBlendFuncSeparateINGR = trace_glBlendFuncSeparateINGR;

  // GL_INTEL_parallel_arrays

  tbl.glColorPointervINTEL = trace_glColorPointervINTEL;
  tbl.glNormalPointervINTEL = trace_glNormalPointervINTEL;
  tbl.glTexCoordPointervINTEL = trace_glTexCoordPointervINTEL;
  tbl.glVertexPointervINTEL = trace_glVertexPointervINTEL;

  // GL_KHR_debug

  tbl.glDebugMessageCallback = trace_glDebugMessageCallback;
  tbl.glDebugMessageControl = trace_glDebugMessageControl;
  tbl.glDebugMessageInsert = trace_glDebugMessageInsert;
  tbl.glGetDebugMessageLog = trace_glGetDebugMessageLog;
  tbl.glGetObjectLabel = trace_glGetObjectLabel;
  tbl.glGetObjectPtrLabel = trace_glGetObjectPtrLabel;
  tbl.glObjectLabel = trace_glObjectLabel;
  tbl.glObjectPtrLabel = trace_glObjectPtrLabel;
  tbl.glPopDebugGroup = trace_glPopDebugGroup;
  tbl.glPushDebugGroup = trace_glPushDebugGroup;

  // GL_KTX_buffer_region

  tbl.glBufferRegionEnabled = trace_glBufferRegionEnabled;
  tbl.glDeleteBufferRegion = trace_glDeleteBufferRegion;
  tbl.glDrawBufferRegion = trace_glDrawBufferRegion;
  tbl.glNewBufferRegion = trace_glNewBufferRegion;
  tbl.glReadBufferRegion = trace_glReadBufferRegion;

  // GL_MESA_resize_buffers

  tbl.glResizeBuffersMESA = trace_glResizeBuffersMESA;

  // GL_MESA_window_pos

  tbl.glWindowPos2dMESA = trace_glWindowPos2dMESA;
  tbl.glWindowPos2dvMESA = trace_glWindowPos2dvMESA;
  tbl.glWindowPos2fMESA = trace_glWindowPos2fMESA;
  tbl.glWindowPos2fvMESA = trace_glWindowPos2fvMESA;
  tbl.glWindowPos2iMESA = trace_glWindowPos2iMESA;
  tbl.glWindowPos2ivMESA = trace_glWindowPos2ivMESA;
  tbl.glWindowPos2sMESA = trace_glWindowPos2sMESA;
  tbl.glWindowPos2svMESA = trace_glWindowPos2svMESA;
  tbl.glWindowPos3dMESA = trace_glWindowPos3dMESA;
  tbl.glWindowPos3dvMESA = trace_glWindowPos3dvMESA;
  tbl.glWindowPos3fMESA = trace_glWindowPos3fMESA;
  tbl.glWindowPos3fvMESA = trace_glWindowPos3fvMESA;
  tbl.glWindowPos3iMESA = trace_glWindowPos3iMESA;
  tbl.glWindowPos3ivMESA = trace_glWindowPos3ivMESA;
  tbl.glWindowPos3sMESA = trace_glWindowPos3sMESA;
  tbl.glWindowPos3svMESA = trace_glWindowPos3svMESA;
  tbl.glWindowPos4dMESA = trace_glWindowPos4dMESA;
  tbl.glWindowPos4dvMESA = trace_glWindowPos4dvMESA;
  tbl.glWindowPos4fMESA = trace_glWindowPos4fMESA;
  tbl.glWindowPos4fvMESA = trace_glWindowPos4fvMESA;
  tbl.glWindowPos4iMESA = trace_glWindowPos4iMESA;
  tbl.glWindowPos4ivMESA = trace_glWindowPos4ivMESA;
  tbl.glWindowPos4sMESA = trace_glWindowPos4sMESA;
  tbl.glWindowPos4svMESA = trace_glWindowPos4svMESA;

  // GL_NV_conditional_render

  tbl.glBeginConditionalRenderNV = trace_glBeginConditionalRenderNV;
  tbl.glEndConditionalRenderNV = trace_glEndConditionalRenderNV;

  // GL_NV_copy_image

  tbl.glCopyImageSubDataNV = trace_glCopyImageSubDataNV;

  // GL_NV_coverage_sample

  tbl.glCoverageMaskNV = trace_glCoverageMaskNV;
  tbl.glCoverageOperationNV = trace_glCoverageOperationNV;

  // GL_NV_depth_buffer_float

  tbl.glClearDepthdNV = trace_glClearDepthdNV;
  tbl.glDepthBoundsdNV = trace_glDepthBoundsdNV;
  tbl.glDepthRangedNV = trace_glDepthRangedNV;

  // GL_NV_draw_buffers

  tbl.glDrawBuffersNV = trace_glDrawBuffersNV;

  // GL_NV_evaluators

  tbl.glEvalMapsNV = trace_glEvalMapsNV;
  tbl.glGetMapAttribParameterfvNV = trace_glGetMapAttribParameterfvNV;
  tbl.glGetMapAttribParameterivNV = trace_glGetMapAttribParameterivNV;
  tbl.glGetMapControlPointsNV = trace_glGetMapControlPointsNV;
  tbl.glGetMapParameterfvNV = trace_glGetMapParameterfvNV;
  tbl.glGetMapParameterivNV = trace_glGetMapParameterivNV;
  tbl.glMapControlPointsNV = trace_glMapControlPointsNV;
  tbl.glMapParameterfvNV = trace_glMapParameterfvNV;
  tbl.glMapParameterivNV = trace_glMapParameterivNV;

  // GL_NV_explicit_multisample

  tbl.glGetMultisamplefvNV = trace_glGetMultisamplefvNV;
  tbl.glSampleMaskIndexedNV = trace_glSampleMaskIndexedNV;
  tbl.glTexRenderbufferNV = trace_glTexRenderbufferNV;

  // GL_NV_fence

  tbl.glDeleteFencesNV = trace_glDeleteFencesNV;
  tbl.glFinishFenceNV = trace_glFinishFenceNV;
  tbl.glGenFencesNV = trace_glGenFencesNV;
  tbl.glGetFenceivNV = trace_glGetFenceivNV;
  tbl.glIsFenceNV = trace_glIsFenceNV;
  tbl.glSetFenceNV = trace_glSetFenceNV;
  tbl.glTestFenceNV = trace_glTestFenceNV;

  // GL_NV_fragment_program

  tbl.glGetProgramNamedParameterdvNV = trace_glGetProgramNamedParameterdvNV;
  tbl.glGetProgramNamedParameterfvNV = trace_glGetProgramNamedParameterfvNV;
  tbl.glProgramNamedParameter4dNV = trace_glProgramNamedParameter4dNV;
  tbl.glProgramNamedParameter4dvNV = trace_glProgramNamedParameter4dvNV;
  tbl.glProgramNamedParameter4fNV = trace_glProgramNamedParameter4fNV;
  tbl.glProgramNamedParameter4fvNV = trace_glProgramNamedParameter4fvNV;

  // GL_NV_framebuffer_multisample_coverage

  tbl.glRenderbufferStorageMultisampleCoverageNV = trace_glRenderbufferStorageMultisampleCoverageNV;

  // GL_NV_geometry_program4

  tbl.glProgramVertexLimitNV = trace_glProgramVertexLimitNV;

  // GL_NV_gpu_program4

  tbl.glGetProgramEnvParameterIivNV = trace_glGetProgramEnvParameterIivNV;
  tbl.glGetProgramEnvParameterIuivNV = trace_glGetProgramEnvParameterIuivNV;
  tbl.glGetProgramLocalParameterIivNV = trace_glGetProgramLocalParameterIivNV;
  tbl.glGetProgramLocalParameterIuivNV = trace_glGetProgramLocalParameterIuivNV;
  tbl.glProgramEnvParameterI4iNV = trace_glProgramEnvParameterI4iNV;
  tbl.glProgramEnvParameterI4ivNV = trace_glProgramEnvParameterI4ivNV;
  tbl.glProgramEnvParameterI4uiNV = trace_glProgramEnvParameterI4uiNV;
  tbl.glProgramEnvParameterI4uivNV = trace_glProgramEnvParameterI4uivNV;
  tbl.glProgramEnvParametersI4ivNV = trace_glProgramEnvParametersI4ivNV;
  tbl.glProgramEnvParametersI4uivNV = trace_glProgramEnvParametersI4uivNV;
  tbl.glProgramLocalParameterI4iNV = trace_glProgramLocalParameterI4iNV;
  tbl.glProgramLocalParameterI4ivNV = trace_glProgramLocalParameterI4ivNV;
  tbl.glProgramLocalParameterI4uiNV = trace_glProgramLocalParameterI4uiNV;
  tbl.glProgramLocalParameterI4uivNV = trace_glProgramLocalParameterI4uivNV;
  tbl.glProgramLocalParametersI4ivNV = trace_glProgramLocalParametersI4ivNV;
  tbl.glProgramLocalParametersI4uivNV = trace_glProgramLocalParametersI4uivNV;

  // GL_NV_gpu_shader5

  tbl.glGetUniformi64vNV = trace_glGetUniformi64vNV;
  tbl.glProgramUniform1i64NV = trace_glProgramUniform1i64NV;
  tbl.glProgramUniform1i64vNV = trace_glProgramUniform1i64vNV;
  tbl.glProgramUniform1ui64NV = trace_glProgramUniform1ui64NV;
  tbl.glProgramUniform1ui64vNV = trace_glProgramUniform1ui64vNV;
  tbl.glProgramUniform2i64NV = trace_glProgramUniform2i64NV;
  tbl.glProgramUniform2i64vNV = trace_glProgramUniform2i64vNV;
  tbl.glProgramUniform2ui64NV = trace_glProgramUniform2ui64NV;
  tbl.glProgramUniform2ui64vNV = trace_glProgramUniform2ui64vNV;
  tbl.glProgramUniform3i64NV = trace_glProgramUniform3i64NV;
  tbl.glProgramUniform3i64vNV = trace_glProgramUniform3i64vNV;
  tbl.glProgramUniform3ui64NV = trace_glProgramUniform3ui64NV;
  tbl.glProgramUniform3ui64vNV = trace_glProgramUniform3ui64vNV;
  tbl.glProgramUniform4i64NV = trace_glProgramUniform4i64NV;
  tbl.glProgramUniform4i64vNV = trace_glProgramUniform4i64vNV;
  tbl.glProgramUniform4ui64NV = trace_glProgramUniform4ui64NV;
  tbl.glProgramUniform4ui64vNV = trace_glProgramUniform4ui64vNV;
  tbl.glUniform1i64NV = trace_glUniform1i64NV;
  tbl.glUniform1i64vNV = trace_glUniform1i64vNV;
  tbl.glUniform1ui64NV = trace_glUniform1ui64NV;
  tbl.glUniform1ui64vNV = trace_glUniform1ui64vNV;
  tbl.glUniform2i64NV = trace_glUniform2i64NV;
  tbl.glUniform2i64vNV = trace_glUniform2i64vNV;
  tbl.glUniform2ui64NV = trace_glUniform2ui64NV;
  tbl.glUniform2ui64vNV = trace_glUniform2ui64vNV;
  tbl.glUniform3i64NV = trace_glUniform3i64NV;
  tbl.glUniform3i64vNV = trace_glUniform3i64vNV;
  tbl.glUniform3ui64NV = trace_glUniform3ui64NV;
  tbl.glUniform3ui64vNV = trace_glUniform3ui64vNV;
  tbl.glUniform4i64NV = trace_glUniform4i64NV;
  tbl.glUniform4i64vNV = trace_glUniform4i64vNV;
  tbl.glUniform4ui64NV = trace_glUniform4ui64NV;
  tbl.glUniform4ui64vNV = trace_glUniform4ui64vNV;

  // GL_NV_half_float

  tbl.glColor3hNV = trace_glColor3hNV;
  tbl.glColor3hvNV = trace_glColor3hvNV;
  tbl.glColor4hNV = trace_glColor4hNV;
  tbl.glColor4hvNV = trace_glColor4hvNV;
  tbl.glFogCoordhNV = trace_glFogCoordhNV;
  tbl.glFogCoordhvNV = trace_glFogCoordhvNV;
  tbl.glMultiTexCoord1hNV = trace_glMultiTexCoord1hNV;
  tbl.glMultiTexCoord1hvNV = trace_glMultiTexCoord1hvNV;
  tbl.glMultiTexCoord2hNV = trace_glMultiTexCoord2hNV;
  tbl.glMultiTexCoord2hvNV = trace_glMultiTexCoord2hvNV;
  tbl.glMultiTexCoord3hNV = trace_glMultiTexCoord3hNV;
  tbl.glMultiTexCoord3hvNV = trace_glMultiTexCoord3hvNV;
  tbl.glMultiTexCoord4hNV = trace_glMultiTexCoord4hNV;
  tbl.glMultiTexCoord4hvNV = trace_glMultiTexCoord4hvNV;
  tbl.glNormal3hNV = trace_glNormal3hNV;
  tbl.glNormal3hvNV = trace_glNormal3hvNV;
  tbl.glSecondaryColor3hNV = trace_glSecondaryColor3hNV;
  tbl.glSecondaryColor3hvNV = trace_glSecondaryColor3hvNV;
  tbl.glTexCoord1hNV = trace_glTexCoord1hNV;
  tbl.glTexCoord1hvNV = trace_glTexCoord1hvNV;
  tbl.glTexCoord2hNV = trace_glTexCoord2hNV;
  tbl.glTexCoord2hvNV = trace_glTexCoord2hvNV;
  tbl.glTexCoord3hNV = trace_glTexCoord3hNV;
  tbl.glTexCoord3hvNV = trace_glTexCoord3hvNV;
  tbl.glTexCoord4hNV = trace_glTexCoord4hNV;
  tbl.glTexCoord4hvNV = trace_glTexCoord4hvNV;
  tbl.glVertex2hNV = trace_glVertex2hNV;
  tbl.glVertex2hvNV = trace_glVertex2hvNV;
  tbl.glVertex3hNV = trace_glVertex3hNV;
  tbl.glVertex3hvNV = trace_glVertex3hvNV;
  tbl.glVertex4hNV = trace_glVertex4hNV;
  tbl.glVertex4hvNV = trace_glVertex4hvNV;
  tbl.glVertexAttrib1hNV = trace_glVertexAttrib1hNV;
  tbl.glVertexAttrib1hvNV = trace_glVertexAttrib1hvNV;
  tbl.glVertexAttrib2hNV = trace_glVertexAttrib2hNV;
  tbl.glVertexAttrib2hvNV = trace_glVertexAttrib2hvNV;
  tbl.glVertexAttrib3hNV = trace_glVertexAttrib3hNV;
  tbl.glVertexAttrib3hvNV = trace_glVertexAttrib3hvNV;
  tbl.glVertexAttrib4hNV = trace_glVertexAttrib4hNV;
  tbl.glVertexAttrib4hvNV = trace_glVertexAttrib4hvNV;
  tbl.glVertexAttribs1hvNV = trace_glVertexAttribs1hvNV;
  tbl.glVertexAttribs2hvNV = trace_glVertexAttribs2hvNV;
  tbl.glVertexAttribs3hvNV = trace_glVertexAttribs3hvNV;
  tbl.glVertexAttribs4hvNV = trace_glVertexAttribs4hvNV;
  tbl.glVertexWeighthNV = trace_glVertexWeighthNV;
  tbl.glVertexWeighthvNV = trace_glVertexWeighthvNV;

  // GL_NV_occlusion_query

  tbl.glBeginOcclusionQueryNV = trace_glBeginOcclusionQueryNV;
  tbl.glDeleteOcclusionQueriesNV = trace_glDeleteOcclusionQueriesNV;
  tbl.glEndOcclusionQueryNV = trace_glEndOcclusionQueryNV;
  tbl.glGenOcclusionQueriesNV = trace_glGenOcclusionQueriesNV;
  tbl.glGetOcclusionQueryivNV = trace_glGetOcclusionQueryivNV;
  tbl.glGetOcclusionQueryuivNV = trace_glGetOcclusionQueryuivNV;
  tbl.glIsOcclusionQueryNV = trace_glIsOcclusionQueryNV;

  // GL_NV_parameter_buffer_object

  tbl.glProgramBufferParametersIivNV = trace_glProgramBufferParametersIivNV;
  tbl.glProgramBufferParametersIuivNV = trace_glProgramBufferParametersIuivNV;
  tbl.glProgramBufferParametersfvNV = trace_glProgramBufferParametersfvNV;

  // GL_NV_path_rendering

  tbl.glCopyPathNV = trace_glCopyPathNV;
  tbl.glCoverFillPathInstancedNV = trace_glCoverFillPathInstancedNV;
  tbl.glCoverFillPathNV = trace_glCoverFillPathNV;
  tbl.glCoverStrokePathInstancedNV = trace_glCoverStrokePathInstancedNV;
  tbl.glCoverStrokePathNV = trace_glCoverStrokePathNV;
  tbl.glDeletePathsNV = trace_glDeletePathsNV;
  tbl.glGenPathsNV = trace_glGenPathsNV;
  tbl.glGetPathColorGenfvNV = trace_glGetPathColorGenfvNV;
  tbl.glGetPathColorGenivNV = trace_glGetPathColorGenivNV;
  tbl.glGetPathCommandsNV = trace_glGetPathCommandsNV;
  tbl.glGetPathCoordsNV = trace_glGetPathCoordsNV;
  tbl.glGetPathDashArrayNV = trace_glGetPathDashArrayNV;
  tbl.glGetPathLengthNV = trace_glGetPathLengthNV;
  tbl.glGetPathMetricRangeNV = trace_glGetPathMetricRangeNV;
  tbl.glGetPathMetricsNV = trace_glGetPathMetricsNV;
  tbl.glGetPathParameterfvNV = trace_glGetPathParameterfvNV;
  tbl.glGetPathParameterivNV = trace_glGetPathParameterivNV;
  tbl.glGetPathSpacingNV = trace_glGetPathSpacingNV;
  tbl.glGetPathTexGenfvNV = trace_glGetPathTexGenfvNV;
  tbl.glGetPathTexGenivNV = trace_glGetPathTexGenivNV;
  tbl.glInterpolatePathsNV = trace_glInterpolatePathsNV;
  tbl.glIsPathNV = trace_glIsPathNV;
  tbl.glIsPointInFillPathNV = trace_glIsPointInFillPathNV;
  tbl.glIsPointInStrokePathNV = trace_glIsPointInStrokePathNV;
  tbl.glPathColorGenNV = trace_glPathColorGenNV;
  tbl.glPathCommandsNV = trace_glPathCommandsNV;
  tbl.glPathCoordsNV = trace_glPathCoordsNV;
  tbl.glPathCoverDepthFuncNV = trace_glPathCoverDepthFuncNV;
  tbl.glPathDashArrayNV = trace_glPathDashArrayNV;
  tbl.glPathFogGenNV = trace_glPathFogGenNV;
  tbl.glPathGlyphRangeNV = trace_glPathGlyphRangeNV;
  tbl.glPathGlyphsNV = trace_glPathGlyphsNV;
  tbl.glPathParameterfNV = trace_glPathParameterfNV;
  tbl.glPathParameterfvNV = trace_glPathParameterfvNV;
  tbl.glPathParameteriNV = trace_glPathParameteriNV;
  tbl.glPathParameterivNV = trace_glPathParameterivNV;
  tbl.glPathStencilDepthOffsetNV = trace_glPathStencilDepthOffsetNV;
  tbl.glPathStencilFuncNV = trace_glPathStencilFuncNV;
  tbl.glPathStringNV = trace_glPathStringNV;
  tbl.glPathSubCommandsNV = trace_glPathSubCommandsNV;
  tbl.glPathSubCoordsNV = trace_glPathSubCoordsNV;
  tbl.glPathTexGenNV = trace_glPathTexGenNV;
  tbl.glPointAlongPathNV = trace_glPointAlongPathNV;
  tbl.glStencilFillPathInstancedNV = trace_glStencilFillPathInstancedNV;
  tbl.glStencilFillPathNV = trace_glStencilFillPathNV;
  tbl.glStencilStrokePathInstancedNV = trace_glStencilStrokePathInstancedNV;
  tbl.glStencilStrokePathNV = trace_glStencilStrokePathNV;
  tbl.glTransformPathNV = trace_glTransformPathNV;
  tbl.glWeightPathsNV = trace_glWeightPathsNV;

  // GL_NV_pixel_data_range

  tbl.glFlushPixelDataRangeNV = trace_glFlushPixelDataRangeNV;
  tbl.glPixelDataRangeNV = trace_glPixelDataRangeNV;

  // GL_NV_point_sprite

  tbl.glPointParameteriNV = trace_glPointParameteriNV;
  tbl.glPointParameterivNV = trace_glPointParameterivNV;

  // GL_NV_present_video

  tbl.glGetVideoi64vNV = trace_glGetVideoi64vNV;
  tbl.glGetVideoivNV = trace_glGetVideoivNV;
  tbl.glGetVideoui64vNV = trace_glGetVideoui64vNV;
  tbl.glGetVideouivNV = trace_glGetVideouivNV;
  tbl.glPresentFrameDualFillNV = trace_glPresentFrameDualFillNV;
  tbl.glPresentFrameKeyedNV = trace_glPresentFrameKeyedNV;

  // GL_NV_primitive_restart

  tbl.glPrimitiveRestartIndexNV = trace_glPrimitiveRestartIndexNV;
  tbl.glPrimitiveRestartNV = trace_glPrimitiveRestartNV;

  // GL_NV_read_buffer

  tbl.glReadBufferNV = trace_glReadBufferNV;

  // GL_NV_register_combiners

  tbl.glCombinerInputNV = trace_glCombinerInputNV;
  tbl.glCombinerOutputNV = trace_glCombinerOutputNV;
  tbl.glCombinerParameterfNV = trace_glCombinerParameterfNV;
  tbl.glCombinerParameterfvNV = trace_glCombinerParameterfvNV;
  tbl.glCombinerParameteriNV = trace_glCombinerParameteriNV;
  tbl.glCombinerParameterivNV = trace_glCombinerParameterivNV;
  tbl.glFinalCombinerInputNV = trace_glFinalCombinerInputNV;
  tbl.glGetCombinerInputParameterfvNV = trace_glGetCombinerInputParameterfvNV;
  tbl.glGetCombinerInputParameterivNV = trace_glGetCombinerInputParameterivNV;
  tbl.glGetCombinerOutputParameterfvNV = trace_glGetCombinerOutputParameterfvNV;
  tbl.glGetCombinerOutputParameterivNV = trace_glGetCombinerOutputParameterivNV;
  tbl.glGetFinalCombinerInputParameterfvNV = trace_glGetFinalCombinerInputParameterfvNV;
  tbl.glGetFinalCombinerInputParameterivNV = trace_glGetFinalCombinerInputParameterivNV;

  // GL_NV_register_combiners2

  tbl.glCombinerStageParameterfvNV = trace_glCombinerStageParameterfvNV;
  tbl.glGetCombinerStageParameterfvNV = trace_glGetCombinerStageParameterfvNV;

  // GL_NV_shader_buffer_load

  tbl.glGetBufferParameterui64vNV = trace_glGetBufferParameterui64vNV;
  tbl.glGetIntegerui64vNV = trace_glGetIntegerui64vNV;
  tbl.glGetNamedBufferParameterui64vNV = trace_glGetNamedBufferParameterui64vNV;
  tbl.glGetUniformui64vNV = trace_glGetUniformui64vNV;
  tbl.glIsBufferResidentNV = trace_glIsBufferResidentNV;
  tbl.glIsNamedBufferResidentNV = trace_glIsNamedBufferResidentNV;
  tbl.glMakeBufferNonResidentNV = trace_glMakeBufferNonResidentNV;
  tbl.glMakeBufferResidentNV = trace_glMakeBufferResidentNV;
  tbl.glMakeNamedBufferNonResidentNV = trace_glMakeNamedBufferNonResidentNV;
  tbl.glMakeNamedBufferResidentNV = trace_glMakeNamedBufferResidentNV;
  tbl.glProgramUniformui64NV = trace_glProgramUniformui64NV;
  tbl.glProgramUniformui64vNV = trace_glProgramUniformui64vNV;
  tbl.glUniformui64NV = trace_glUniformui64NV;
  tbl.glUniformui64vNV = trace_glUniformui64vNV;

  // GL_NV_texture_barrier

  tbl.glTextureBarrierNV = trace_glTextureBarrierNV;

  // GL_NV_texture_multisample

  tbl.glTexImage2DMultisampleCoverageNV = trace_glTexImage2DMultisampleCoverageNV;
  tbl.glTexImage3DMultisampleCoverageNV = trace_glTexImage3DMultisampleCoverageNV;
  tbl.glTextureImage2DMultisampleCoverageNV = trace_glTextureImage2DMultisampleCoverageNV;
  tbl.glTextureImage2DMultisampleNV = trace_glTextureImage2DMultisampleNV;
  tbl.glTextureImage3DMultisampleCoverageNV = trace_glTextureImage3DMultisampleCoverageNV;
  tbl.glTextureImage3DMultisampleNV = trace_glTextureImage3DMultisampleNV;

  // GL_NV_transform_feedback

  tbl.glActiveVaryingNV = trace_glActiveVaryingNV;
  tbl.glBeginTransformFeedbackNV = trace_glBeginTransformFeedbackNV;
  tbl.glBindBufferBaseNV = trace_glBindBufferBaseNV;
  tbl.glBindBufferOffsetNV = trace_glBindBufferOffsetNV;
  tbl.glBindBufferRangeNV = trace_glBindBufferRangeNV;
  tbl.glEndTransformFeedbackNV = trace_glEndTransformFeedbackNV;
  tbl.glGetActiveVaryingNV = trace_glGetActiveVaryingNV;
  tbl.glGetTransformFeedbackVaryingNV = trace_glGetTransformFeedbackVaryingNV;
  tbl.glGetVaryingLocationNV = trace_glGetVaryingLocationNV;
  tbl.glTransformFeedbackAttribsNV = trace_glTransformFeedbackAttribsNV;
  tbl.glTransformFeedbackVaryingsNV = trace_glTransformFeedbackVaryingsNV;

  // GL_NV_transform_feedback2

  tbl.glBindTransformFeedbackNV = trace_glBindTransformFeedbackNV;
  tbl.glDeleteTransformFeedbacksNV = trace_glDeleteTransformFeedbacksNV;
  tbl.glDrawTransformFeedbackNV = trace_glDrawTransformFeedbackNV;
  tbl.glGenTransformFeedbacksNV = trace_glGenTransformFeedbacksNV;
  tbl.glIsTransformFeedbackNV = trace_glIsTransformFeedbackNV;
  tbl.glPauseTransformFeedbackNV = trace_glPauseTransformFeedbackNV;
  tbl.glResumeTransformFeedbackNV = trace_glResumeTransformFeedbackNV;

  // GL_NV_vertex_array_range

  tbl.glFlushVertexArrayRangeNV = trace_glFlushVertexArrayRangeNV;
  tbl.glVertexArrayRangeNV = trace_glVertexArrayRangeNV;

  // GL_NV_vertex_attrib_integer_64bit

  tbl.glGetVertexAttribLi64vNV = trace_glGetVertexAttribLi64vNV;
  tbl.glGetVertexAttribLui64vNV = trace_glGetVertexAttribLui64vNV;
  tbl.glVertexAttribL1i64NV = trace_glVertexAttribL1i64NV;
  tbl.glVertexAttribL1i64vNV = trace_glVertexAttribL1i64vNV;
  tbl.glVertexAttribL1ui64NV = trace_glVertexAttribL1ui64NV;
  tbl.glVertexAttribL1ui64vNV = trace_glVertexAttribL1ui64vNV;
  tbl.glVertexAttribL2i64NV = trace_glVertexAttribL2i64NV;
  tbl.glVertexAttribL2i64vNV = trace_glVertexAttribL2i64vNV;
  tbl.glVertexAttribL2ui64NV = trace_glVertexAttribL2ui64NV;
  tbl.glVertexAttribL2ui64vNV = trace_glVertexAttribL2ui64vNV;
  tbl.glVertexAttribL3i64NV = trace_glVertexAttribL3i64NV;
  tbl.glVertexAttribL3i64vNV = trace_glVertexAttribL3i64vNV;
  tbl.glVertexAttribL3ui64NV = trace_glVertexAttribL3ui64NV;
  tbl.glVertexAttribL3ui64vNV = trace_glVertexAttribL3ui64vNV;
  tbl.glVertexAttribL4i64NV = trace_glVertexAttribL4i64NV;
  tbl.glVertexAttribL4i64vNV = trace_glVertexAttribL4i64vNV;
  tbl.glVertexAttribL4ui64NV = trace_glVertexAttribL4ui64NV;
  tbl.glVertexAttribL4ui64vNV = trace_glVertexAttribL4ui64vNV;
  tbl.glVertexAttribLFormatNV = trace_glVertexAttribLFormatNV;

  // GL_NV_vertex_buffer_unified_memory

  tbl.glBufferAddressRangeNV = trace_glBufferAddressRangeNV;
  tbl.glColorFormatNV = trace_glColorFormatNV;
  tbl.glEdgeFlagFormatNV = trace_glEdgeFlagFormatNV;
  tbl.glFogCoordFormatNV = trace_glFogCoordFormatNV;
  tbl.glGetIntegerui64i_vNV = trace_glGetIntegerui64i_vNV;
  tbl.glIndexFormatNV = trace_glIndexFormatNV;
  tbl.glNormalFormatNV = trace_glNormalFormatNV;
  tbl.glSecondaryColorFormatNV = trace_glSecondaryColorFormatNV;
  tbl.glTexCoordFormatNV = trace_glTexCoordFormatNV;
  tbl.glVertexAttribFormatNV = trace_glVertexAttribFormatNV;
  tbl.glVertexAttribIFormatNV = trace_glVertexAttribIFormatNV;
  tbl.glVertexFormatNV = trace_glVertexFormatNV;

  // GL_NV_vertex_program

  tbl.glAreProgramsResidentNV = trace_glAreProgramsResidentNV;
  tbl.glBindProgramNV = trace_glBindProgramNV;
  tbl.glDeleteProgramsNV = trace_glDeleteProgramsNV;
  tbl.glExecuteProgramNV = trace_glExecuteProgramNV;
  tbl.glGenProgramsNV = trace_glGenProgramsNV;
  tbl.glGetProgramParameterdvNV = trace_glGetProgramParameterdvNV;
  tbl.glGetProgramParameterfvNV = trace_glGetProgramParameterfvNV;
  tbl.glGetProgramStringNV = trace_glGetProgramStringNV;
  tbl.glGetProgramivNV = trace_glGetProgramivNV;
  tbl.glGetTrackMatrixivNV = trace_glGetTrackMatrixivNV;
  tbl.glGetVertexAttribPointervNV = trace_glGetVertexAttribPointervNV;
  tbl.glGetVertexAttribdvNV = trace_glGetVertexAttribdvNV;
  tbl.glGetVertexAttribfvNV = trace_glGetVertexAttribfvNV;
  tbl.glGetVertexAttribivNV = trace_glGetVertexAttribivNV;
  tbl.glIsProgramNV = trace_glIsProgramNV;
  tbl.glLoadProgramNV = trace_glLoadProgramNV;
  tbl.glProgramParameter4dNV = trace_glProgramParameter4dNV;
  tbl.glProgramParameter4dvNV = trace_glProgramParameter4dvNV;
  tbl.glProgramParameter4fNV = trace_glProgramParameter4fNV;
  tbl.glProgramParameter4fvNV = trace_glProgramParameter4fvNV;
  tbl.glProgramParameters4dvNV = trace_glProgramParameters4dvNV;
  tbl.glProgramParameters4fvNV = trace_glProgramParameters4fvNV;
  tbl.glRequestResidentProgramsNV = trace_glRequestResidentProgramsNV;
  tbl.glTrackMatrixNV = trace_glTrackMatrixNV;
  tbl.glVertexAttrib1dNV = trace_glVertexAttrib1dNV;
  tbl.glVertexAttrib1dvNV = trace_glVertexAttrib1dvNV;
  tbl.glVertexAttrib1fNV = trace_glVertexAttrib1fNV;
  tbl.glVertexAttrib1fvNV = trace_glVertexAttrib1fvNV;
  tbl.glVertexAttrib1sNV = trace_glVertexAttrib1sNV;
  tbl.glVertexAttrib1svNV = trace_glVertexAttrib1svNV;
  tbl.glVertexAttrib2dNV = trace_glVertexAttrib2dNV;
  tbl.glVertexAttrib2dvNV = trace_glVertexAttrib2dvNV;
  tbl.glVertexAttrib2fNV = trace_glVertexAttrib2fNV;
  tbl.glVertexAttrib2fvNV = trace_glVertexAttrib2fvNV;
  tbl.glVertexAttrib2sNV = trace_glVertexAttrib2sNV;
  tbl.glVertexAttrib2svNV = trace_glVertexAttrib2svNV;
  tbl.glVertexAttrib3dNV = trace_glVertexAttrib3dNV;
  tbl.glVertexAttrib3dvNV = trace_glVertexAttrib3dvNV;
  tbl.glVertexAttrib3fNV = trace_glVertexAttrib3fNV;
  tbl.glVertexAttrib3fvNV = trace_glVertexAttrib3fvNV;
  tbl.glVertexAttrib3sNV = trace_glVertexAttrib3sNV;
  tbl.glVertexAttrib3svNV = trace_glVertexAttrib3svNV;
  tbl.glVertexAttrib4dNV = trace_glVertexAttrib4dNV;
  tbl.glVertexAttrib4dvNV = trace_glVertexAttrib4dvNV;
  tbl.glVertexAttrib4fNV = trace_glVertexAttrib4fNV;
  tbl.glVertexAttrib4fvNV = trace_glVertexAttrib4fvNV;
  tbl.glVertexAttrib4sNV = trace_glVertexAttrib4sNV;
  tbl.glVertexAttrib4svNV = trace_glVertexAttrib4svNV;
  tbl.glVertexAttrib4ubNV = trace_glVertexAttrib4ubNV;
  tbl.glVertexAttrib4ubvNV = trace_glVertexAttrib4ubvNV;
  tbl.glVertexAttribPointerNV = trace_glVertexAttribPointerNV;
  tbl.glVertexAttribs1dvNV = trace_glVertexAttribs1dvNV;
  tbl.glVertexAttribs1fvNV = trace_glVertexAttribs1fvNV;
  tbl.glVertexAttribs1svNV = trace_glVertexAttribs1svNV;
  tbl.glVertexAttribs2dvNV = trace_glVertexAttribs2dvNV;
  tbl.glVertexAttribs2fvNV = trace_glVertexAttribs2fvNV;
  tbl.glVertexAttribs2svNV = trace_glVertexAttribs2svNV;
  tbl.glVertexAttribs3dvNV = trace_glVertexAttribs3dvNV;
  tbl.glVertexAttribs3fvNV = trace_glVertexAttribs3fvNV;
  tbl.glVertexAttribs3svNV = trace_glVertexAttribs3svNV;
  tbl.glVertexAttribs4dvNV = trace_glVertexAttribs4dvNV;
  tbl.glVertexAttribs4fvNV = trace_glVertexAttribs4fvNV;
  tbl.glVertexAttribs4svNV = trace_glVertexAttribs4svNV;
  tbl.glVertexAttribs4ubvNV = trace_glVertexAttribs4ubvNV;

  // GL_NV_video_capture

  tbl.glBeginVideoCaptureNV = trace_glBeginVideoCaptureNV;
  tbl.glBindVideoCaptureStreamBufferNV = trace_glBindVideoCaptureStreamBufferNV;
  tbl.glBindVideoCaptureStreamTextureNV = trace_glBindVideoCaptureStreamTextureNV;
  tbl.glEndVideoCaptureNV = trace_glEndVideoCaptureNV;
  tbl.glGetVideoCaptureStreamdvNV = trace_glGetVideoCaptureStreamdvNV;
  tbl.glGetVideoCaptureStreamfvNV = trace_glGetVideoCaptureStreamfvNV;
  tbl.glGetVideoCaptureStreamivNV = trace_glGetVideoCaptureStreamivNV;
  tbl.glGetVideoCaptureivNV = trace_glGetVideoCaptureivNV;
  tbl.glVideoCaptureNV = trace_glVideoCaptureNV;
  tbl.glVideoCaptureStreamParameterdvNV = trace_glVideoCaptureStreamParameterdvNV;
  tbl.glVideoCaptureStreamParameterfvNV = trace_glVideoCaptureStreamParameterfvNV;
  tbl.glVideoCaptureStreamParameterivNV = trace_glVideoCaptureStreamParameterivNV;

  // GL_OES_blend_equation_separate

  tbl.glBlendEquationSeparateOES = trace_glBlendEquationSeparateOES;

  // GL_OES_blend_func_separate

  tbl.glBlendFuncSeparateOES = trace_glBlendFuncSeparateOES;

  // GL_OES_blend_subtract

  tbl.glBlendEquationOES = trace_glBlendEquationOES;

  // GL_OES_framebuffer_object

  tbl.glBindFramebufferOES = trace_glBindFramebufferOES;
  tbl.glBindRenderbufferOES = trace_glBindRenderbufferOES;
  tbl.glCheckFramebufferStatusOES = trace_glCheckFramebufferStatusOES;
  tbl.glDeleteFramebuffersOES = trace_glDeleteFramebuffersOES;
  tbl.glDeleteRenderbuffersOES = trace_glDeleteRenderbuffersOES;
  tbl.glFramebufferRenderbufferOES = trace_glFramebufferRenderbufferOES;
  tbl.glFramebufferTexture2DOES = trace_glFramebufferTexture2DOES;
  tbl.glGenFramebuffersOES = trace_glGenFramebuffersOES;
  tbl.glGenRenderbuffersOES = trace_glGenRenderbuffersOES;
  tbl.glGenerateMipmapOES = trace_glGenerateMipmapOES;
  tbl.glGetFramebufferAttachmentParameterivOES = trace_glGetFramebufferAttachmentParameterivOES;
  tbl.glGetRenderbufferParameterivOES = trace_glGetRenderbufferParameterivOES;
  tbl.glIsFramebufferOES = trace_glIsFramebufferOES;
  tbl.glIsRenderbufferOES = trace_glIsRenderbufferOES;
  tbl.glRenderbufferStorageOES = trace_glRenderbufferStorageOES;

  // GL_OES_get_program_binary

  tbl.glGetProgramBinaryOES = trace_glGetProgramBinaryOES;
  tbl.glProgramBinaryOES = trace_glProgramBinaryOES;

  // GL_OES_mapbuffer

  tbl.glGetBufferPointervOES = trace_glGetBufferPointervOES;
  tbl.glMapBufferOES = trace_glMapBufferOES;
  tbl.glUnmapBufferOES = trace_glUnmapBufferOES;

  // GL_OES_matrix_palette

  tbl.glCurrentPaletteMatrixOES = trace_glCurrentPaletteMatrixOES;

  // GL_OES_texture_3D

  tbl.glCompressedTexImage3DOES = trace_glCompressedTexImage3DOES;
  tbl.glCompressedTexSubImage3DOES = trace_glCompressedTexSubImage3DOES;
  tbl.glCopyTexSubImage3DOES = trace_glCopyTexSubImage3DOES;
  tbl.glFramebufferTexture3DOES = trace_glFramebufferTexture3DOES;
  tbl.glTexImage3DOES = trace_glTexImage3DOES;
  tbl.glTexSubImage3DOES = trace_glTexSubImage3DOES;

  // GL_OES_texture_cube_map

  tbl.glGetTexGenfvOES = trace_glGetTexGenfvOES;
  tbl.glGetTexGenivOES = trace_glGetTexGenivOES;
  tbl.glGetTexGenxvOES = trace_glGetTexGenxvOES;
  tbl.glTexGenfOES = trace_glTexGenfOES;
  tbl.glTexGenfvOES = trace_glTexGenfvOES;
  tbl.glTexGeniOES = trace_glTexGeniOES;
  tbl.glTexGenivOES = trace_glTexGenivOES;
  tbl.glTexGenxOES = trace_glTexGenxOES;
  tbl.glTexGenxvOES = trace_glTexGenxvOES;

  // GL_OES_vertex_array_object

  tbl.glBindVertexArrayOES = trace_glBindVertexArrayOES;
  tbl.glDeleteVertexArraysOES = trace_glDeleteVertexArraysOES;
  tbl.glGenVertexArraysOES = trace_glGenVertexArraysOES;
  tbl.glIsVertexArrayOES = trace_glIsVertexArrayOES;

  // GL_PGI_misc_hints

  tbl.glHintPGI = trace_glHintPGI;

  // GL_REGAL_ES1_0_compatibility

  tbl.glAlphaFuncx = trace_glAlphaFuncx;
  tbl.glClearColorx = trace_glClearColorx;
  tbl.glClearDepthx = trace_glClearDepthx;
  tbl.glColor4x = trace_glColor4x;
  tbl.glDepthRangex = trace_glDepthRangex;
  tbl.glFogx = trace_glFogx;
  tbl.glFogxv = trace_glFogxv;
  tbl.glFrustumf = trace_glFrustumf;
  tbl.glFrustumx = trace_glFrustumx;
  tbl.glLightModelx = trace_glLightModelx;
  tbl.glLightModelxv = trace_glLightModelxv;
  tbl.glLightx = trace_glLightx;
  tbl.glLightxv = trace_glLightxv;
  tbl.glLineWidthx = trace_glLineWidthx;
  tbl.glLoadMatrixx = trace_glLoadMatrixx;
  tbl.glMaterialx = trace_glMaterialx;
  tbl.glMaterialxv = trace_glMaterialxv;
  tbl.glMultMatrixx = trace_glMultMatrixx;
  tbl.glMultiTexCoord4x = trace_glMultiTexCoord4x;
  tbl.glNormal3x = trace_glNormal3x;
  tbl.glOrthof = trace_glOrthof;
  tbl.glOrthox = trace_glOrthox;
  tbl.glPointSizex = trace_glPointSizex;
  tbl.glPolygonOffsetx = trace_glPolygonOffsetx;
  tbl.glRotatex = trace_glRotatex;
  tbl.glSampleCoveragex = trace_glSampleCoveragex;
  tbl.glScalex = trace_glScalex;
  tbl.glTexEnvx = trace_glTexEnvx;
  tbl.glTexEnvxv = trace_glTexEnvxv;
  tbl.glTexParameterx = trace_glTexParameterx;
  tbl.glTranslatex = trace_glTranslatex;

  // GL_REGAL_ES1_1_compatibility

  tbl.glClipPlanef = trace_glClipPlanef;
  tbl.glClipPlanex = trace_glClipPlanex;
  tbl.glGetClipPlanef = trace_glGetClipPlanef;
  tbl.glGetClipPlanex = trace_glGetClipPlanex;
  tbl.glGetFixedv = trace_glGetFixedv;
  tbl.glGetLightxv = trace_glGetLightxv;
  tbl.glGetMaterialxv = trace_glGetMaterialxv;
  tbl.glGetTexEnvxv = trace_glGetTexEnvxv;
  tbl.glGetTexParameterxv = trace_glGetTexParameterxv;
  tbl.glPointParameterx = trace_glPointParameterx;
  tbl.glPointParameterxv = trace_glPointParameterxv;
  tbl.glPointSizePointerOES = trace_glPointSizePointerOES;
  tbl.glTexParameterxv = trace_glTexParameterxv;

  // GL_SGIS_detail_texture

  tbl.glDetailTexFuncSGIS = trace_glDetailTexFuncSGIS;
  tbl.glGetDetailTexFuncSGIS = trace_glGetDetailTexFuncSGIS;

  // GL_SGIS_fog_function

  tbl.glFogFuncSGIS = trace_glFogFuncSGIS;
  tbl.glGetFogFuncSGIS = trace_glGetFogFuncSGIS;

  // GL_SGIS_multisample

  tbl.glSampleMaskSGIS = trace_glSampleMaskSGIS;
  tbl.glSamplePatternSGIS = trace_glSamplePatternSGIS;

  // GL_SGIS_pixel_texture

  tbl.glGetPixelTexGenParameterfvSGIS = trace_glGetPixelTexGenParameterfvSGIS;
  tbl.glGetPixelTexGenParameterivSGIS = trace_glGetPixelTexGenParameterivSGIS;
  tbl.glPixelTexGenParameterfSGIS = trace_glPixelTexGenParameterfSGIS;
  tbl.glPixelTexGenParameterfvSGIS = trace_glPixelTexGenParameterfvSGIS;
  tbl.glPixelTexGenParameteriSGIS = trace_glPixelTexGenParameteriSGIS;
  tbl.glPixelTexGenParameterivSGIS = trace_glPixelTexGenParameterivSGIS;

  // GL_SGIS_point_parameters

  tbl.glPointParameterfSGIS = trace_glPointParameterfSGIS;
  tbl.glPointParameterfvSGIS = trace_glPointParameterfvSGIS;

  // GL_SGIS_sharpen_texture

  tbl.glGetSharpenTexFuncSGIS = trace_glGetSharpenTexFuncSGIS;
  tbl.glSharpenTexFuncSGIS = trace_glSharpenTexFuncSGIS;

  // GL_SGIS_texture4D

  tbl.glTexImage4DSGIS = trace_glTexImage4DSGIS;
  tbl.glTexSubImage4DSGIS = trace_glTexSubImage4DSGIS;

  // GL_SGIS_texture_color_mask

  tbl.glTextureColorMaskSGIS = trace_glTextureColorMaskSGIS;

  // GL_SGIS_texture_filter4

  tbl.glGetTexFilterFuncSGIS = trace_glGetTexFilterFuncSGIS;
  tbl.glTexFilterFuncSGIS = trace_glTexFilterFuncSGIS;

  // GL_SGIX_async

  tbl.glAsyncMarkerSGIX = trace_glAsyncMarkerSGIX;
  tbl.glDeleteAsyncMarkersSGIX = trace_glDeleteAsyncMarkersSGIX;
  tbl.glFinishAsyncSGIX = trace_glFinishAsyncSGIX;
  tbl.glGenAsyncMarkersSGIX = trace_glGenAsyncMarkersSGIX;
  tbl.glIsAsyncMarkerSGIX = trace_glIsAsyncMarkerSGIX;
  tbl.glPollAsyncSGIX = trace_glPollAsyncSGIX;

  // GL_SGIX_flush_raster

  tbl.glFlushRasterSGIX = trace_glFlushRasterSGIX;

  // GL_SGIX_fragment_lighting

  tbl.glFragmentColorMaterialSGIX = trace_glFragmentColorMaterialSGIX;
  tbl.glFragmentLightModelfSGIX = trace_glFragmentLightModelfSGIX;
  tbl.glFragmentLightModelfvSGIX = trace_glFragmentLightModelfvSGIX;
  tbl.glFragmentLightModeliSGIX = trace_glFragmentLightModeliSGIX;
  tbl.glFragmentLightModelivSGIX = trace_glFragmentLightModelivSGIX;
  tbl.glFragmentLightfSGIX = trace_glFragmentLightfSGIX;
  tbl.glFragmentLightfvSGIX = trace_glFragmentLightfvSGIX;
  tbl.glFragmentLightiSGIX = trace_glFragmentLightiSGIX;
  tbl.glFragmentLightivSGIX = trace_glFragmentLightivSGIX;
  tbl.glFragmentMaterialfSGIX = trace_glFragmentMaterialfSGIX;
  tbl.glFragmentMaterialfvSGIX = trace_glFragmentMaterialfvSGIX;
  tbl.glFragmentMaterialiSGIX = trace_glFragmentMaterialiSGIX;
  tbl.glFragmentMaterialivSGIX = trace_glFragmentMaterialivSGIX;
  tbl.glGetFragmentLightfvSGIX = trace_glGetFragmentLightfvSGIX;
  tbl.glGetFragmentLightivSGIX = trace_glGetFragmentLightivSGIX;
  tbl.glGetFragmentMaterialfvSGIX = trace_glGetFragmentMaterialfvSGIX;
  tbl.glGetFragmentMaterialivSGIX = trace_glGetFragmentMaterialivSGIX;
  tbl.glLightEnviSGIX = trace_glLightEnviSGIX;

  // GL_SGIX_framezoom

  tbl.glFrameZoomSGIX = trace_glFrameZoomSGIX;

  // GL_SGIX_igloo_interface

  tbl.glIglooInterfaceSGIX = trace_glIglooInterfaceSGIX;

  // GL_SGIX_instruments

  tbl.glGetInstrumentsSGIX = trace_glGetInstrumentsSGIX;
  tbl.glInstrumentsBufferSGIX = trace_glInstrumentsBufferSGIX;
  tbl.glPollInstrumentsSGIX = trace_glPollInstrumentsSGIX;
  tbl.glReadInstrumentsSGIX = trace_glReadInstrumentsSGIX;
  tbl.glStartInstrumentsSGIX = trace_glStartInstrumentsSGIX;
  tbl.glStopInstrumentsSGIX = trace_glStopInstrumentsSGIX;

  // GL_SGIX_list_priority

  tbl.glGetListParameterfvSGIX = trace_glGetListParameterfvSGIX;
  tbl.glGetListParameterivSGIX = trace_glGetListParameterivSGIX;
  tbl.glListParameterfSGIX = trace_glListParameterfSGIX;
  tbl.glListParameterfvSGIX = trace_glListParameterfvSGIX;
  tbl.glListParameteriSGIX = trace_glListParameteriSGIX;
  tbl.glListParameterivSGIX = trace_glListParameterivSGIX;

  // GL_SGIX_pixel_texture

  tbl.glPixelTexGenSGIX = trace_glPixelTexGenSGIX;

  // GL_SGIX_polynomial_ffd

  tbl.glDeformSGIX = trace_glDeformSGIX;
  tbl.glDeformationMap3dSGIX = trace_glDeformationMap3dSGIX;
  tbl.glDeformationMap3fSGIX = trace_glDeformationMap3fSGIX;
  tbl.glLoadIdentityDeformationMapSGIX = trace_glLoadIdentityDeformationMapSGIX;

  // GL_SGIX_reference_plane

  tbl.glReferencePlaneSGIX = trace_glReferencePlaneSGIX;

  // GL_SGIX_sprite

  tbl.glSpriteParameterfSGIX = trace_glSpriteParameterfSGIX;
  tbl.glSpriteParameterfvSGIX = trace_glSpriteParameterfvSGIX;
  tbl.glSpriteParameteriSGIX = trace_glSpriteParameteriSGIX;
  tbl.glSpriteParameterivSGIX = trace_glSpriteParameterivSGIX;

  // GL_SGIX_tag_sample_buffer

  tbl.glTagSampleBufferSGIX = trace_glTagSampleBufferSGIX;

  // GL_SGI_color_table

  tbl.glColorTableParameterfvSGI = trace_glColorTableParameterfvSGI;
  tbl.glColorTableParameterivSGI = trace_glColorTableParameterivSGI;
  tbl.glColorTableSGI = trace_glColorTableSGI;
  tbl.glCopyColorTableSGI = trace_glCopyColorTableSGI;
  tbl.glGetColorTableParameterfvSGI = trace_glGetColorTableParameterfvSGI;
  tbl.glGetColorTableParameterivSGI = trace_glGetColorTableParameterivSGI;
  tbl.glGetColorTableSGI = trace_glGetColorTableSGI;

  // GL_SUNX_constant_data

  tbl.glFinishTextureSUNX = trace_glFinishTextureSUNX;

  // GL_SUN_global_alpha

  tbl.glGlobalAlphaFactorbSUN = trace_glGlobalAlphaFactorbSUN;
  tbl.glGlobalAlphaFactordSUN = trace_glGlobalAlphaFactordSUN;
  tbl.glGlobalAlphaFactorfSUN = trace_glGlobalAlphaFactorfSUN;
  tbl.glGlobalAlphaFactoriSUN = trace_glGlobalAlphaFactoriSUN;
  tbl.glGlobalAlphaFactorsSUN = trace_glGlobalAlphaFactorsSUN;
  tbl.glGlobalAlphaFactorubSUN = trace_glGlobalAlphaFactorubSUN;
  tbl.glGlobalAlphaFactoruiSUN = trace_glGlobalAlphaFactoruiSUN;
  tbl.glGlobalAlphaFactorusSUN = trace_glGlobalAlphaFactorusSUN;

  // GL_SUN_mesh_array

  tbl.glDrawMeshArraysSUN = trace_glDrawMeshArraysSUN;

  // GL_SUN_triangle_list

  tbl.glReplacementCodePointerSUN = trace_glReplacementCodePointerSUN;
  tbl.glReplacementCodeubSUN = trace_glReplacementCodeubSUN;
  tbl.glReplacementCodeubvSUN = trace_glReplacementCodeubvSUN;
  tbl.glReplacementCodeuiSUN = trace_glReplacementCodeuiSUN;
  tbl.glReplacementCodeuivSUN = trace_glReplacementCodeuivSUN;
  tbl.glReplacementCodeusSUN = trace_glReplacementCodeusSUN;
  tbl.glReplacementCodeusvSUN = trace_glReplacementCodeusvSUN;

  // GL_SUN_vertex

  tbl.glColor3fVertex3fSUN = trace_glColor3fVertex3fSUN;
  tbl.glColor3fVertex3fvSUN = trace_glColor3fVertex3fvSUN;
  tbl.glColor4fNormal3fVertex3fSUN = trace_glColor4fNormal3fVertex3fSUN;
  tbl.glColor4fNormal3fVertex3fvSUN = trace_glColor4fNormal3fVertex3fvSUN;
  tbl.glColor4ubVertex2fSUN = trace_glColor4ubVertex2fSUN;
  tbl.glColor4ubVertex2fvSUN = trace_glColor4ubVertex2fvSUN;
  tbl.glColor4ubVertex3fSUN = trace_glColor4ubVertex3fSUN;
  tbl.glColor4ubVertex3fvSUN = trace_glColor4ubVertex3fvSUN;
  tbl.glNormal3fVertex3fSUN = trace_glNormal3fVertex3fSUN;
  tbl.glNormal3fVertex3fvSUN = trace_glNormal3fVertex3fvSUN;
  tbl.glReplacementCodeuiColor3fVertex3fSUN = trace_glReplacementCodeuiColor3fVertex3fSUN;
  tbl.glReplacementCodeuiColor3fVertex3fvSUN = trace_glReplacementCodeuiColor3fVertex3fvSUN;
  tbl.glReplacementCodeuiColor4fNormal3fVertex3fSUN = trace_glReplacementCodeuiColor4fNormal3fVertex3fSUN;
  tbl.glReplacementCodeuiColor4fNormal3fVertex3fvSUN = trace_glReplacementCodeuiColor4fNormal3fVertex3fvSUN;
  tbl.glReplacementCodeuiColor4ubVertex3fSUN = trace_glReplacementCodeuiColor4ubVertex3fSUN;
  tbl.glReplacementCodeuiColor4ubVertex3fvSUN = trace_glReplacementCodeuiColor4ubVertex3fvSUN;
  tbl.glReplacementCodeuiNormal3fVertex3fSUN = trace_glReplacementCodeuiNormal3fVertex3fSUN;
  tbl.glReplacementCodeuiNormal3fVertex3fvSUN = trace_glReplacementCodeuiNormal3fVertex3fvSUN;
  tbl.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN = trace_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN;
  tbl.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN = trace_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN;
  tbl.glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN = trace_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN;
  tbl.glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN = trace_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN;
  tbl.glReplacementCodeuiTexCoord2fVertex3fSUN = trace_glReplacementCodeuiTexCoord2fVertex3fSUN;
  tbl.glReplacementCodeuiTexCoord2fVertex3fvSUN = trace_glReplacementCodeuiTexCoord2fVertex3fvSUN;
  tbl.glReplacementCodeuiVertex3fSUN = trace_glReplacementCodeuiVertex3fSUN;
  tbl.glReplacementCodeuiVertex3fvSUN = trace_glReplacementCodeuiVertex3fvSUN;
  tbl.glTexCoord2fColor3fVertex3fSUN = trace_glTexCoord2fColor3fVertex3fSUN;
  tbl.glTexCoord2fColor3fVertex3fvSUN = trace_glTexCoord2fColor3fVertex3fvSUN;
  tbl.glTexCoord2fColor4fNormal3fVertex3fSUN = trace_glTexCoord2fColor4fNormal3fVertex3fSUN;
  tbl.glTexCoord2fColor4fNormal3fVertex3fvSUN = trace_glTexCoord2fColor4fNormal3fVertex3fvSUN;
  tbl.glTexCoord2fColor4ubVertex3fSUN = trace_glTexCoord2fColor4ubVertex3fSUN;
  tbl.glTexCoord2fColor4ubVertex3fvSUN = trace_glTexCoord2fColor4ubVertex3fvSUN;
  tbl.glTexCoord2fNormal3fVertex3fSUN = trace_glTexCoord2fNormal3fVertex3fSUN;
  tbl.glTexCoord2fNormal3fVertex3fvSUN = trace_glTexCoord2fNormal3fVertex3fvSUN;
  tbl.glTexCoord2fVertex3fSUN = trace_glTexCoord2fVertex3fSUN;
  tbl.glTexCoord2fVertex3fvSUN = trace_glTexCoord2fVertex3fvSUN;
  tbl.glTexCoord4fColor4fNormal3fVertex4fSUN = trace_glTexCoord4fColor4fNormal3fVertex4fSUN;
  tbl.glTexCoord4fColor4fNormal3fVertex4fvSUN = trace_glTexCoord4fColor4fNormal3fVertex4fvSUN;
  tbl.glTexCoord4fVertex4fSUN = trace_glTexCoord4fVertex4fSUN;
  tbl.glTexCoord4fVertex4fvSUN = trace_glTexCoord4fVertex4fvSUN;

  // GL_WIN_swap_hint

  tbl.glAddSwapHintRectWIN = trace_glAddSwapHintRectWIN;

}

void InitDispatchTableGlobalTrace(DispatchTableGlobal &tbl)
{

#if REGAL_SYS_WGL
  // WGL_3DL_stereo_control

  tbl.wglSetStereoEmitterState3DL = trace_wglSetStereoEmitterState3DL;

  // WGL_AMD_gpu_association

  tbl.wglBlitContextFramebufferAMD = trace_wglBlitContextFramebufferAMD;
  tbl.wglCreateAssociatedContextAMD = trace_wglCreateAssociatedContextAMD;
  tbl.wglCreateAssociatedContextAttribsAMD = trace_wglCreateAssociatedContextAttribsAMD;
  tbl.wglDeleteAssociatedContextAMD = trace_wglDeleteAssociatedContextAMD;
  tbl.wglGetContextGPUIDAMD = trace_wglGetContextGPUIDAMD;
  tbl.wglGetCurrentAssociatedContextAMD = trace_wglGetCurrentAssociatedContextAMD;
  tbl.wglGetGPUIDsAMD = trace_wglGetGPUIDsAMD;
  tbl.wglGetGPUInfoAMD = trace_wglGetGPUInfoAMD;
  tbl.wglMakeAssociatedContextCurrentAMD = trace_wglMakeAssociatedContextCurrentAMD;

  // WGL_ARB_buffer_region

  tbl.wglCreateBufferRegionARB = trace_wglCreateBufferRegionARB;
  tbl.wglDeleteBufferRegionARB = trace_wglDeleteBufferRegionARB;
  tbl.wglRestoreBufferRegionARB = trace_wglRestoreBufferRegionARB;
  tbl.wglSaveBufferRegionARB = trace_wglSaveBufferRegionARB;

  // WGL_ARB_create_context

  tbl.wglCreateContextAttribsARB = trace_wglCreateContextAttribsARB;

  // WGL_ARB_extensions_string

  tbl.wglGetExtensionsStringARB = trace_wglGetExtensionsStringARB;

  // WGL_ARB_make_current_read

  tbl.wglGetCurrentReadDCARB = trace_wglGetCurrentReadDCARB;
  tbl.wglMakeContextCurrentARB = trace_wglMakeContextCurrentARB;

  // WGL_ARB_pbuffer

  tbl.wglCreatePbufferARB = trace_wglCreatePbufferARB;
  tbl.wglDestroyPbufferARB = trace_wglDestroyPbufferARB;
  tbl.wglGetPbufferDCARB = trace_wglGetPbufferDCARB;
  tbl.wglQueryPbufferARB = trace_wglQueryPbufferARB;
  tbl.wglReleasePbufferDCARB = trace_wglReleasePbufferDCARB;

  // WGL_ARB_render_texture

  tbl.wglBindTexImageARB = trace_wglBindTexImageARB;
  tbl.wglReleaseTexImageARB = trace_wglReleaseTexImageARB;
  tbl.wglSetPbufferAttribARB = trace_wglSetPbufferAttribARB;

  // WGL_EXT_display_color_table

  tbl.wglBindDisplayColorTableEXT = trace_wglBindDisplayColorTableEXT;
  tbl.wglCreateDisplayColorTableEXT = trace_wglCreateDisplayColorTableEXT;
  tbl.wglDestroyDisplayColorTableEXT = trace_wglDestroyDisplayColorTableEXT;
  tbl.wglLoadDisplayColorTableEXT = trace_wglLoadDisplayColorTableEXT;

  // WGL_EXT_extensions_string

  tbl.wglGetExtensionsStringEXT = trace_wglGetExtensionsStringEXT;

  // WGL_EXT_make_current_read

  tbl.wglGetCurrentReadDCEXT = trace_wglGetCurrentReadDCEXT;
  tbl.wglMakeContextCurrentEXT = trace_wglMakeContextCurrentEXT;

  // WGL_EXT_pbuffer

  tbl.wglCreatePbufferEXT = trace_wglCreatePbufferEXT;
  tbl.wglDestroyPbufferEXT = trace_wglDestroyPbufferEXT;
  tbl.wglGetPbufferDCEXT = trace_wglGetPbufferDCEXT;
  tbl.wglQueryPbufferEXT = trace_wglQueryPbufferEXT;
  tbl.wglReleasePbufferDCEXT = trace_wglReleasePbufferDCEXT;

  // WGL_EXT_pixel_format

  tbl.wglChoosePixelFormatEXT = trace_wglChoosePixelFormatEXT;

  // WGL_EXT_swap_control

  tbl.wglGetSwapIntervalEXT = trace_wglGetSwapIntervalEXT;
  tbl.wglSwapIntervalEXT = trace_wglSwapIntervalEXT;

  // WGL_GDI

  tbl.wglChoosePixelFormat = trace_wglChoosePixelFormat;
  tbl.wglDescribePixelFormat = trace_wglDescribePixelFormat;
  tbl.wglGetPixelFormat = trace_wglGetPixelFormat;
  tbl.wglSetPixelFormat = trace_wglSetPixelFormat;
  tbl.wglSwapBuffers = trace_wglSwapBuffers;

  // WGL_I3D_digital_video_control

  tbl.wglGetDigitalVideoParametersI3D = trace_wglGetDigitalVideoParametersI3D;
  tbl.wglSetDigitalVideoParametersI3D = trace_wglSetDigitalVideoParametersI3D;

  // WGL_I3D_gamma

  tbl.wglGetGammaTableI3D = trace_wglGetGammaTableI3D;
  tbl.wglGetGammaTableParametersI3D = trace_wglGetGammaTableParametersI3D;
  tbl.wglSetGammaTableI3D = trace_wglSetGammaTableI3D;
  tbl.wglSetGammaTableParametersI3D = trace_wglSetGammaTableParametersI3D;

  // WGL_I3D_genlock

  tbl.wglDisableGenlockI3D = trace_wglDisableGenlockI3D;
  tbl.wglEnableGenlockI3D = trace_wglEnableGenlockI3D;
  tbl.wglGenlockSampleRateI3D = trace_wglGenlockSampleRateI3D;
  tbl.wglGenlockSourceDelayI3D = trace_wglGenlockSourceDelayI3D;
  tbl.wglGenlockSourceEdgeI3D = trace_wglGenlockSourceEdgeI3D;
  tbl.wglGenlockSourceI3D = trace_wglGenlockSourceI3D;
  tbl.wglGetGenlockSampleRateI3D = trace_wglGetGenlockSampleRateI3D;
  tbl.wglGetGenlockSourceDelayI3D = trace_wglGetGenlockSourceDelayI3D;
  tbl.wglGetGenlockSourceEdgeI3D = trace_wglGetGenlockSourceEdgeI3D;
  tbl.wglGetGenlockSourceI3D = trace_wglGetGenlockSourceI3D;
  tbl.wglIsEnabledGenlockI3D = trace_wglIsEnabledGenlockI3D;
  tbl.wglQueryGenlockMaxSourceDelayI3D = trace_wglQueryGenlockMaxSourceDelayI3D;

  // WGL_I3D_image_buffer

  tbl.wglAssociateImageBufferEventsI3D = trace_wglAssociateImageBufferEventsI3D;
  tbl.wglCreateImageBufferI3D = trace_wglCreateImageBufferI3D;
  tbl.wglDestroyImageBufferI3D = trace_wglDestroyImageBufferI3D;
  tbl.wglReleaseImageBufferEventsI3D = trace_wglReleaseImageBufferEventsI3D;

  // WGL_I3D_swap_frame_lock

  tbl.wglDisableFrameLockI3D = trace_wglDisableFrameLockI3D;
  tbl.wglEnableFrameLockI3D = trace_wglEnableFrameLockI3D;
  tbl.wglIsEnabledFrameLockI3D = trace_wglIsEnabledFrameLockI3D;
  tbl.wglQueryFrameLockMasterI3D = trace_wglQueryFrameLockMasterI3D;

  // WGL_I3D_swap_frame_usage

  tbl.wglBeginFrameTrackingI3D = trace_wglBeginFrameTrackingI3D;
  tbl.wglEndFrameTrackingI3D = trace_wglEndFrameTrackingI3D;
  tbl.wglGetFrameUsageI3D = trace_wglGetFrameUsageI3D;
  tbl.wglQueryFrameTrackingI3D = trace_wglQueryFrameTrackingI3D;

  // WGL_NV_DX_interop

  tbl.wglDXCloseDeviceNV = trace_wglDXCloseDeviceNV;
  tbl.wglDXLockObjectsNV = trace_wglDXLockObjectsNV;
  tbl.wglDXObjectAccessNV = trace_wglDXObjectAccessNV;
  tbl.wglDXOpenDeviceNV = trace_wglDXOpenDeviceNV;
  tbl.wglDXRegisterObjectNV = trace_wglDXRegisterObjectNV;
  tbl.wglDXSetResourceShareHandleNV = trace_wglDXSetResourceShareHandleNV;
  tbl.wglDXUnlockObjectsNV = trace_wglDXUnlockObjectsNV;
  tbl.wglDXUnregisterObjectNV = trace_wglDXUnregisterObjectNV;

  // WGL_NV_copy_image

  tbl.wglCopyImageSubDataNV = trace_wglCopyImageSubDataNV;

  // WGL_NV_gpu_affinity

  tbl.wglCreateAffinityDCNV = trace_wglCreateAffinityDCNV;
  tbl.wglDeleteDCNV = trace_wglDeleteDCNV;
  tbl.wglEnumGpusFromAffinityDCNV = trace_wglEnumGpusFromAffinityDCNV;
  tbl.wglEnumGpusNV = trace_wglEnumGpusNV;

  // WGL_NV_present_video

  tbl.wglBindVideoDeviceNV = trace_wglBindVideoDeviceNV;
  tbl.wglEnumerateVideoDevicesNV = trace_wglEnumerateVideoDevicesNV;
  tbl.wglQueryCurrentContextNV = trace_wglQueryCurrentContextNV;

  // WGL_NV_swap_group

  tbl.wglBindSwapBarrierNV = trace_wglBindSwapBarrierNV;
  tbl.wglJoinSwapGroupNV = trace_wglJoinSwapGroupNV;
  tbl.wglQueryFrameCountNV = trace_wglQueryFrameCountNV;
  tbl.wglQueryMaxSwapGroupsNV = trace_wglQueryMaxSwapGroupsNV;
  tbl.wglQuerySwapGroupNV = trace_wglQuerySwapGroupNV;
  tbl.wglResetFrameCountNV = trace_wglResetFrameCountNV;

  // WGL_NV_vertex_array_range

  tbl.wglAllocateMemoryNV = trace_wglAllocateMemoryNV;
  tbl.wglFreeMemoryNV = trace_wglFreeMemoryNV;

  // WGL_NV_video_capture

  tbl.wglBindVideoCaptureDeviceNV = trace_wglBindVideoCaptureDeviceNV;
  tbl.wglEnumerateVideoCaptureDevicesNV = trace_wglEnumerateVideoCaptureDevicesNV;
  tbl.wglLockVideoCaptureDeviceNV = trace_wglLockVideoCaptureDeviceNV;
  tbl.wglQueryVideoCaptureDeviceNV = trace_wglQueryVideoCaptureDeviceNV;
  tbl.wglReleaseVideoCaptureDeviceNV = trace_wglReleaseVideoCaptureDeviceNV;

  // WGL_NV_video_output

  tbl.wglBindVideoImageNV = trace_wglBindVideoImageNV;
  tbl.wglGetVideoDeviceNV = trace_wglGetVideoDeviceNV;
  tbl.wglGetVideoInfoNV = trace_wglGetVideoInfoNV;
  tbl.wglReleaseVideoDeviceNV = trace_wglReleaseVideoDeviceNV;
  tbl.wglReleaseVideoImageNV = trace_wglReleaseVideoImageNV;
  tbl.wglSendPbufferToVideoNV = trace_wglSendPbufferToVideoNV;

  // WGL_OML_sync_control

  tbl.wglGetMscRateOML = trace_wglGetMscRateOML;
  tbl.wglGetSyncValuesOML = trace_wglGetSyncValuesOML;
  tbl.wglSwapBuffersMscOML = trace_wglSwapBuffersMscOML;
  tbl.wglSwapLayerBuffersMscOML = trace_wglSwapLayerBuffersMscOML;
  tbl.wglWaitForMscOML = trace_wglWaitForMscOML;
  tbl.wglWaitForSbcOML = trace_wglWaitForSbcOML;

  // WGL_core

  tbl.wglCopyContext = trace_wglCopyContext;
  tbl.wglCreateContext = trace_wglCreateContext;
  tbl.wglCreateLayerContext = trace_wglCreateLayerContext;
  tbl.wglDeleteContext = trace_wglDeleteContext;
  tbl.wglDescribeLayerPlane = trace_wglDescribeLayerPlane;
  tbl.wglGetCurrentContext = trace_wglGetCurrentContext;
  tbl.wglGetCurrentDC = trace_wglGetCurrentDC;
  tbl.wglGetLayerPaletteEntries = trace_wglGetLayerPaletteEntries;
  tbl.wglMakeCurrent = trace_wglMakeCurrent;
  tbl.wglRealizeLayerPalette = trace_wglRealizeLayerPalette;
  tbl.wglSetLayerPaletteEntries = trace_wglSetLayerPaletteEntries;
  tbl.wglShareLists = trace_wglShareLists;
  tbl.wglSwapLayerBuffers = trace_wglSwapLayerBuffers;
  tbl.wglSwapMultipleBuffers = trace_wglSwapMultipleBuffers;
  tbl.wglUseFontBitmapsA = trace_wglUseFontBitmapsA;
  tbl.wglUseFontBitmapsW = trace_wglUseFontBitmapsW;
  tbl.wglUseFontOutlinesA = trace_wglUseFontOutlinesA;
  tbl.wglUseFontOutlinesW = trace_wglUseFontOutlinesW;
#endif // REGAL_SYS_WGL

#if REGAL_SYS_GLX

  // GLX_VERSION_1_0

  tbl.glXChooseVisual = trace_glXChooseVisual;
  tbl.glXCopyContext = trace_glXCopyContext;
  tbl.glXCreateContext = trace_glXCreateContext;
  tbl.glXCreateGLXPixmap = trace_glXCreateGLXPixmap;
  tbl.glXDestroyContext = trace_glXDestroyContext;
  tbl.glXDestroyGLXPixmap = trace_glXDestroyGLXPixmap;
  tbl.glXGetConfig = trace_glXGetConfig;
  tbl.glXGetCurrentContext = trace_glXGetCurrentContext;
  tbl.glXGetCurrentDrawable = trace_glXGetCurrentDrawable;
  tbl.glXIsDirect = trace_glXIsDirect;
  tbl.glXMakeCurrent = trace_glXMakeCurrent;
  tbl.glXQueryExtension = trace_glXQueryExtension;
  tbl.glXQueryVersion = trace_glXQueryVersion;
  tbl.glXSwapBuffers = trace_glXSwapBuffers;
  tbl.glXUseXFont = trace_glXUseXFont;
  tbl.glXWaitGL = trace_glXWaitGL;
  tbl.glXWaitX = trace_glXWaitX;

  // GLX_VERSION_1_1

  tbl.glXGetClientString = trace_glXGetClientString;
  tbl.glXQueryExtensionsString = trace_glXQueryExtensionsString;
  tbl.glXQueryServerString = trace_glXQueryServerString;

  // GLX_VERSION_1_2

  tbl.glXGetCurrentDisplay = trace_glXGetCurrentDisplay;

  // GLX_VERSION_1_3

  tbl.glXChooseFBConfig = trace_glXChooseFBConfig;
  tbl.glXCreateNewContext = trace_glXCreateNewContext;
  tbl.glXCreatePbuffer = trace_glXCreatePbuffer;
  tbl.glXCreatePixmap = trace_glXCreatePixmap;
  tbl.glXCreateWindow = trace_glXCreateWindow;
  tbl.glXDestroyPbuffer = trace_glXDestroyPbuffer;
  tbl.glXDestroyPixmap = trace_glXDestroyPixmap;
  tbl.glXDestroyWindow = trace_glXDestroyWindow;
  tbl.glXGetCurrentReadDrawable = trace_glXGetCurrentReadDrawable;
  tbl.glXGetFBConfigAttrib = trace_glXGetFBConfigAttrib;
  tbl.glXGetFBConfigs = trace_glXGetFBConfigs;
  tbl.glXGetSelectedEvent = trace_glXGetSelectedEvent;
  tbl.glXGetVisualFromFBConfig = trace_glXGetVisualFromFBConfig;
  tbl.glXMakeContextCurrent = trace_glXMakeContextCurrent;
  tbl.glXQueryContext = trace_glXQueryContext;
  tbl.glXQueryDrawable = trace_glXQueryDrawable;
  tbl.glXSelectEvent = trace_glXSelectEvent;

  // GLX_VERSION_1_4

  tbl.glXGetProcAddress = trace_glXGetProcAddress;

  // GLX_ARB_create_context

  tbl.glXCreateContextAttribsARB = trace_glXCreateContextAttribsARB;

  // GLX_ARB_get_proc_address

  tbl.glXGetProcAddressARB = trace_glXGetProcAddressARB;

  // GLX_EXT_import_context

  tbl.glXFreeContextEXT = trace_glXFreeContextEXT;
  tbl.glXGetContextIDEXT = trace_glXGetContextIDEXT;
  tbl.glXImportContextEXT = trace_glXImportContextEXT;
  tbl.glXQueryContextInfoEXT = trace_glXQueryContextInfoEXT;

  // GLX_EXT_swap_control

  tbl.glXSwapIntervalEXT = trace_glXSwapIntervalEXT;

  // GLX_EXT_texture_from_pixmap

  tbl.glXBindTexImageEXT = trace_glXBindTexImageEXT;
  tbl.glXReleaseTexImageEXT = trace_glXReleaseTexImageEXT;

  // GLX_MESA_agp_offset

  tbl.glXGetAGPOffsetMESA = trace_glXGetAGPOffsetMESA;

  // GLX_MESA_copy_sub_buffer

  tbl.glXCopySubBufferMESA = trace_glXCopySubBufferMESA;

  // GLX_MESA_pixmap_colormap

  tbl.glXCreateGLXPixmapMESA = trace_glXCreateGLXPixmapMESA;

  // GLX_MESA_release_buffers

  tbl.glXReleaseBuffersMESA = trace_glXReleaseBuffersMESA;

  // GLX_MESA_set_3dfx_mode

  tbl.glXSet3DfxModeMESA = trace_glXSet3DfxModeMESA;

  // GLX_MESA_swap_control

  tbl.glXGetSwapIntervalMESA = trace_glXGetSwapIntervalMESA;
  tbl.glXSwapIntervalMESA = trace_glXSwapIntervalMESA;

  // GLX_NV_copy_image

  tbl.glXCopyImageSubDataNV = trace_glXCopyImageSubDataNV;

  // GLX_NV_present_video

  tbl.glXBindVideoDeviceNV = trace_glXBindVideoDeviceNV;
  tbl.glXEnumerateVideoDevicesNV = trace_glXEnumerateVideoDevicesNV;

  // GLX_NV_swap_group

  tbl.glXBindSwapBarrierNV = trace_glXBindSwapBarrierNV;
  tbl.glXJoinSwapGroupNV = trace_glXJoinSwapGroupNV;
  tbl.glXQueryFrameCountNV = trace_glXQueryFrameCountNV;
  tbl.glXQueryMaxSwapGroupsNV = trace_glXQueryMaxSwapGroupsNV;
  tbl.glXQuerySwapGroupNV = trace_glXQuerySwapGroupNV;
  tbl.glXResetFrameCountNV = trace_glXResetFrameCountNV;

  // GLX_NV_vertex_array_range

  tbl.glXAllocateMemoryNV = trace_glXAllocateMemoryNV;
  tbl.glXFreeMemoryNV = trace_glXFreeMemoryNV;

  // GLX_NV_video_capture

  tbl.glXBindVideoCaptureDeviceNV = trace_glXBindVideoCaptureDeviceNV;
  tbl.glXEnumerateVideoCaptureDevicesNV = trace_glXEnumerateVideoCaptureDevicesNV;
  tbl.glXLockVideoCaptureDeviceNV = trace_glXLockVideoCaptureDeviceNV;
  tbl.glXQueryVideoCaptureDeviceNV = trace_glXQueryVideoCaptureDeviceNV;
  tbl.glXReleaseVideoCaptureDeviceNV = trace_glXReleaseVideoCaptureDeviceNV;

  // GLX_NV_video_output

  tbl.glXBindVideoImageNV = trace_glXBindVideoImageNV;
  tbl.glXGetVideoDeviceNV = trace_glXGetVideoDeviceNV;
  tbl.glXGetVideoInfoNV = trace_glXGetVideoInfoNV;
  tbl.glXReleaseVideoDeviceNV = trace_glXReleaseVideoDeviceNV;
  tbl.glXReleaseVideoImageNV = trace_glXReleaseVideoImageNV;
  tbl.glXSendPbufferToVideoNV = trace_glXSendPbufferToVideoNV;

  // GLX_OML_sync_control

  tbl.glXGetMscRateOML = trace_glXGetMscRateOML;
  tbl.glXGetSyncValuesOML = trace_glXGetSyncValuesOML;
  tbl.glXSwapBuffersMscOML = trace_glXSwapBuffersMscOML;
  tbl.glXWaitForMscOML = trace_glXWaitForMscOML;
  tbl.glXWaitForSbcOML = trace_glXWaitForSbcOML;

  // GLX_SGIX_fbconfig

  tbl.glXCreateContextWithConfigSGIX = trace_glXCreateContextWithConfigSGIX;
  tbl.glXCreateGLXPixmapWithConfigSGIX = trace_glXCreateGLXPixmapWithConfigSGIX;
  tbl.glXGetFBConfigAttribSGIX = trace_glXGetFBConfigAttribSGIX;
  tbl.glXGetFBConfigFromVisualSGIX = trace_glXGetFBConfigFromVisualSGIX;
  tbl.glXGetVisualFromFBConfigSGIX = trace_glXGetVisualFromFBConfigSGIX;

  // GLX_SGIX_pbuffer

  tbl.glXCreateGLXPbufferSGIX = trace_glXCreateGLXPbufferSGIX;
  tbl.glXDestroyGLXPbufferSGIX = trace_glXDestroyGLXPbufferSGIX;
  tbl.glXGetSelectedEventSGIX = trace_glXGetSelectedEventSGIX;
  tbl.glXQueryGLXPbufferSGIX = trace_glXQueryGLXPbufferSGIX;
  tbl.glXSelectEventSGIX = trace_glXSelectEventSGIX;

  // GLX_SGIX_swap_barrier

  tbl.glXBindSwapBarrierSGIX = trace_glXBindSwapBarrierSGIX;
  tbl.glXQueryMaxSwapBarriersSGIX = trace_glXQueryMaxSwapBarriersSGIX;

  // GLX_SGIX_swap_group

  tbl.glXJoinSwapGroupSGIX = trace_glXJoinSwapGroupSGIX;

  // GLX_SGIX_video_resize

  tbl.glXBindChannelToWindowSGIX = trace_glXBindChannelToWindowSGIX;
  tbl.glXChannelRectSGIX = trace_glXChannelRectSGIX;
  tbl.glXChannelRectSyncSGIX = trace_glXChannelRectSyncSGIX;
  tbl.glXQueryChannelDeltasSGIX = trace_glXQueryChannelDeltasSGIX;
  tbl.glXQueryChannelRectSGIX = trace_glXQueryChannelRectSGIX;

  // GLX_SGI_cushion

  tbl.glXCushionSGI = trace_glXCushionSGI;

  // GLX_SGI_make_current_read

  tbl.glXGetCurrentReadDrawableSGI = trace_glXGetCurrentReadDrawableSGI;
  tbl.glXMakeCurrentReadSGI = trace_glXMakeCurrentReadSGI;

  // GLX_SGI_swap_control

  tbl.glXSwapIntervalSGI = trace_glXSwapIntervalSGI;

  // GLX_SGI_video_sync

  tbl.glXGetVideoSyncSGI = trace_glXGetVideoSyncSGI;
  tbl.glXWaitVideoSyncSGI = trace_glXWaitVideoSyncSGI;
#endif // REGAL_SYS_GLX

#if REGAL_SYS_OSX

  // CGL_VERSION_1_0

  tbl.CGLChoosePixelFormat = trace_CGLChoosePixelFormat;
  tbl.CGLClearDrawable = trace_CGLClearDrawable;
  tbl.CGLCopyContext = trace_CGLCopyContext;
  tbl.CGLCreateContext = trace_CGLCreateContext;
  tbl.CGLDescribePixelFormat = trace_CGLDescribePixelFormat;
  tbl.CGLDescribeRenderer = trace_CGLDescribeRenderer;
  tbl.CGLDestroyContext = trace_CGLDestroyContext;
  tbl.CGLDestroyPixelFormat = trace_CGLDestroyPixelFormat;
  tbl.CGLDestroyRendererInfo = trace_CGLDestroyRendererInfo;
  tbl.CGLDisable = trace_CGLDisable;
  tbl.CGLEnable = trace_CGLEnable;
  tbl.CGLErrorString = trace_CGLErrorString;
  tbl.CGLFlushDrawable = trace_CGLFlushDrawable;
  tbl.CGLGetOffScreen = trace_CGLGetOffScreen;
  tbl.CGLGetOption = trace_CGLGetOption;
  tbl.CGLGetParameter = trace_CGLGetParameter;
  tbl.CGLGetVersion = trace_CGLGetVersion;
  tbl.CGLGetVirtualScreen = trace_CGLGetVirtualScreen;
  tbl.CGLIsEnabled = trace_CGLIsEnabled;
  tbl.CGLQueryRendererInfo = trace_CGLQueryRendererInfo;
  tbl.CGLSetFullScreen = trace_CGLSetFullScreen;
  tbl.CGLSetOffScreen = trace_CGLSetOffScreen;
  tbl.CGLSetOption = trace_CGLSetOption;
  tbl.CGLSetParameter = trace_CGLSetParameter;
  tbl.CGLSetVirtualScreen = trace_CGLSetVirtualScreen;

  // CGL_VERSION_1_1

  tbl.CGLCreatePBuffer = trace_CGLCreatePBuffer;
  tbl.CGLDescribePBuffer = trace_CGLDescribePBuffer;
  tbl.CGLDestroyPBuffer = trace_CGLDestroyPBuffer;
  tbl.CGLGetPBuffer = trace_CGLGetPBuffer;
  tbl.CGLSetPBuffer = trace_CGLSetPBuffer;
  tbl.CGLTexImagePBuffer = trace_CGLTexImagePBuffer;

  // CGL_VERSION_1_2

  tbl.CGLGetContextRetainCount = trace_CGLGetContextRetainCount;
  tbl.CGLGetGlobalOption = trace_CGLGetGlobalOption;
  tbl.CGLGetPBufferRetainCount = trace_CGLGetPBufferRetainCount;
  tbl.CGLGetPixelFormat = trace_CGLGetPixelFormat;
  tbl.CGLGetPixelFormatRetainCount = trace_CGLGetPixelFormatRetainCount;
  tbl.CGLLockContext = trace_CGLLockContext;
  tbl.CGLReleaseContext = trace_CGLReleaseContext;
  tbl.CGLReleasePBuffer = trace_CGLReleasePBuffer;
  tbl.CGLReleasePixelFormat = trace_CGLReleasePixelFormat;
  tbl.CGLRetainContext = trace_CGLRetainContext;
  tbl.CGLRetainPBuffer = trace_CGLRetainPBuffer;
  tbl.CGLRetainPixelFormat = trace_CGLRetainPixelFormat;
  tbl.CGLSetGlobalOption = trace_CGLSetGlobalOption;
  tbl.CGLUnlockContext = trace_CGLUnlockContext;

  // CGL_VERSION_1_3

  tbl.CGLGetCurrentContext = trace_CGLGetCurrentContext;
  tbl.CGLGetShareGroup = trace_CGLGetShareGroup;
  tbl.CGLGetSurface = trace_CGLGetSurface;
  tbl.CGLSetCurrentContext = trace_CGLSetCurrentContext;
  tbl.CGLSetSurface = trace_CGLSetSurface;
  tbl.CGLTexImageIOSurface2D = trace_CGLTexImageIOSurface2D;
  tbl.CGLUpdateContext = trace_CGLUpdateContext;
#endif // REGAL_SYS_OSX

#if REGAL_SYS_EGL

  // EGL_ANGLE_query_surface_pointer

  tbl.eglQuerySurfacePointerANGLE = trace_eglQuerySurfacePointerANGLE;

  // EGL_KHR_fence_sync

  tbl.eglClientWaitSyncKHR = trace_eglClientWaitSyncKHR;
  tbl.eglCreateSyncKHR = trace_eglCreateSyncKHR;
  tbl.eglDestroySyncKHR = trace_eglDestroySyncKHR;
  tbl.eglGetSyncAttribKHR = trace_eglGetSyncAttribKHR;

  // EGL_KHR_image_base

  tbl.eglCreateImageKHR = trace_eglCreateImageKHR;
  tbl.eglDestroyImageKHR = trace_eglDestroyImageKHR;

  // EGL_KHR_lock_surface

  tbl.eglLockSurfaceKHR = trace_eglLockSurfaceKHR;
  tbl.eglUnlockSurfaceKHR = trace_eglUnlockSurfaceKHR;

  // EGL_MESA_drm_image

  tbl.eglCreateDRMImageMESA = trace_eglCreateDRMImageMESA;
  tbl.eglExportDRMImageMESA = trace_eglExportDRMImageMESA;

  // EGL_NV_post_sub_buffer

  tbl.eglPostSubBufferNV = trace_eglPostSubBufferNV;

  // EGL_NV_sync

  tbl.eglClientWaitSyncNV = trace_eglClientWaitSyncNV;
  tbl.eglCreateFenceSyncNV = trace_eglCreateFenceSyncNV;
  tbl.eglDestroySyncNV = trace_eglDestroySyncNV;
  tbl.eglFenceNV = trace_eglFenceNV;
  tbl.eglGetSyncAttribNV = trace_eglGetSyncAttribNV;
  tbl.eglSignalSyncNV = trace_eglSignalSyncNV;

  // EGL_NV_system_time

  tbl.eglGetSystemTimeFrequencyNV = trace_eglGetSystemTimeFrequencyNV;
  tbl.eglGetSystemTimeNV = trace_eglGetSystemTimeNV;

  // EGL_VERSION_1_0

  tbl.eglChooseConfig = trace_eglChooseConfig;
  tbl.eglCopyBuffers = trace_eglCopyBuffers;
  tbl.eglCreateContext = trace_eglCreateContext;
  tbl.eglCreatePbufferSurface = trace_eglCreatePbufferSurface;
  tbl.eglCreatePixmapSurface = trace_eglCreatePixmapSurface;
  tbl.eglCreateWindowSurface = trace_eglCreateWindowSurface;
  tbl.eglDestroyContext = trace_eglDestroyContext;
  tbl.eglDestroySurface = trace_eglDestroySurface;
  tbl.eglGetConfigAttrib = trace_eglGetConfigAttrib;
  tbl.eglGetConfigs = trace_eglGetConfigs;
  tbl.eglGetCurrentContext = trace_eglGetCurrentContext;
  tbl.eglGetCurrentDisplay = trace_eglGetCurrentDisplay;
  tbl.eglGetCurrentSurface = trace_eglGetCurrentSurface;
  tbl.eglGetDisplay = trace_eglGetDisplay;
  tbl.eglGetError = trace_eglGetError;
  tbl.eglGetProcAddress = trace_eglGetProcAddress;
  tbl.eglInitialize = trace_eglInitialize;
  tbl.eglMakeCurrent = trace_eglMakeCurrent;
  tbl.eglQueryContext = trace_eglQueryContext;
  tbl.eglQueryString = trace_eglQueryString;
  tbl.eglQuerySurface = trace_eglQuerySurface;
  tbl.eglSwapBuffers = trace_eglSwapBuffers;
  tbl.eglTerminate = trace_eglTerminate;
  tbl.eglWaitGL = trace_eglWaitGL;
  tbl.eglWaitNative = trace_eglWaitNative;

  // EGL_VERSION_1_1

  tbl.eglBindTexImage = trace_eglBindTexImage;
  tbl.eglReleaseTexImage = trace_eglReleaseTexImage;

  // EGL_VERSION_1_2

  tbl.eglBindAPI = trace_eglBindAPI;
  tbl.eglCreatePbufferFromClientBuffer = trace_eglCreatePbufferFromClientBuffer;
  tbl.eglQueryAPI = trace_eglQueryAPI;
  tbl.eglReleaseThread = trace_eglReleaseThread;
  tbl.eglSurfaceAttrib = trace_eglSurfaceAttrib;
  tbl.eglSwapInterval = trace_eglSwapInterval;
  tbl.eglWaitClient = trace_eglWaitClient;
#endif // REGAL_SYS_EGL

}

REGAL_NAMESPACE_END

#endif
