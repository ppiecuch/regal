/* NOTE: Do not edit this file, it is generated by a script:
   Export.py --api gl 4.4 --api wgl 4.4 --api glx 4.4 --api cgl 1.4 --api egl 1.0 --outdir .
*/

/*
  Copyright (c) 2011-2013 NVIDIA Corporation
  Copyright (c) 2011-2013 Cass Everitt
  Copyright (c) 2012-2013 Scott Nations
  Copyright (c) 2012 Mathias Schott
  Copyright (c) 2012-2013 Nigel Stewart
  Copyright (c) 2012-2013 Google Inc.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without modification,
  are permitted provided that the following conditions are met:

    Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.

    Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
  OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
  Intended formatting conventions:
  $ astyle --style=allman --indent=spaces=2 --indent-switches
*/

#include "pch.h" /* For MS precompiled header support */

#include "RegalUtil.h"

#if REGAL_SYS_GLX && !REGAL_SYS_X11

REGAL_GLOBAL_BEGIN

#include "RegalLog.h"
#include "RegalPush.h"
#include "RegalToken.h"
#include "RegalHelper.h"
#include "RegalContext.h"
#include "RegalDispatch.h"
#include "RegalDispatcherGL.h"
#include "RegalDispatcherGlobal.h"

using namespace ::REGAL_NAMESPACE_INTERNAL::Logging;
using namespace ::REGAL_NAMESPACE_INTERNAL::Token;

REGAL_GLOBAL_END

REGAL_NAMESPACE_BEGIN

// GLX_VERSION_1_0

static XVisualInfo *REGAL_CALL GLX_glXChooseVisual(Display *dpy, int screen, int *attribList)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    XVisualInfo * ret = _next->call(&_next->glXChooseVisual)(dpy, screen, attribList);
    return ret;
}

static void REGAL_CALL GLX_glXCopyContext(Display *dpy, GLXContext src, GLXContext dst, unsigned long mask)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    _next->call(&_next->glXCopyContext)(dpy, src, dst, mask);
}

static GLXContext REGAL_CALL GLX_glXCreateContext(Display *dpy, XVisualInfo *vis, GLXContext shareList, Bool direct)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    GLXContext  ret = _next->call(&_next->glXCreateContext)(dpy, vis, shareList, direct);
    return ret;
}

static GLXPixmap REGAL_CALL GLX_glXCreateGLXPixmap(Display *dpy, XVisualInfo *vis, Pixmap pixmap)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    GLXPixmap  ret = _next->call(&_next->glXCreateGLXPixmap)(dpy, vis, pixmap);
    return ret;
}

static void REGAL_CALL GLX_glXDestroyContext(Display *dpy, GLXContext ctx)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    _next->call(&_next->glXDestroyContext)(dpy, ctx);
}

static void REGAL_CALL GLX_glXDestroyGLXPixmap(Display *dpy, GLXPixmap pix)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    _next->call(&_next->glXDestroyGLXPixmap)(dpy, pix);
}

static int REGAL_CALL GLX_glXGetConfig(Display *dpy, XVisualInfo *vis, int attrib, int *value)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    int  ret = _next->call(&_next->glXGetConfig)(dpy, vis, attrib, value);
    return ret;
}

static GLXContext REGAL_CALL GLX_glXGetCurrentContext(void)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    GLXContext  ret = _next->call(&_next->glXGetCurrentContext)();
    return ret;
}

static GLXDrawable REGAL_CALL GLX_glXGetCurrentDrawable(void)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    GLXDrawable  ret = _next->call(&_next->glXGetCurrentDrawable)();
    return ret;
}

static Bool REGAL_CALL GLX_glXIsDirect(Display *dpy, GLXContext ctx)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    Bool  ret = _next->call(&_next->glXIsDirect)(dpy, ctx);
    return ret;
}

static Bool REGAL_CALL GLX_glXMakeCurrent(Display *dpy, GLXDrawable drawable, GLXContext ctx)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    Bool  ret = _next->call(&_next->glXMakeCurrent)(dpy, drawable, ctx);
    return ret;
}

static Bool REGAL_CALL GLX_glXQueryExtension(Display *dpy, int *errorBase, int *eventBase)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    Bool  ret = _next->call(&_next->glXQueryExtension)(dpy, errorBase, eventBase);
    return ret;
}

static Bool REGAL_CALL GLX_glXQueryVersion(Display *dpy, int *major, int *minor)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    Bool  ret = _next->call(&_next->glXQueryVersion)(dpy, major, minor);
    return ret;
}

static void REGAL_CALL GLX_glXSwapBuffers(Display *dpy, GLXDrawable drawable)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    _next->call(&_next->glXSwapBuffers)(dpy, drawable);
}

static void REGAL_CALL GLX_glXUseXFont(Font font, int first, int count, int listBase)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    _next->call(&_next->glXUseXFont)(font, first, count, listBase);
}

static void REGAL_CALL GLX_glXWaitGL(void)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    _next->call(&_next->glXWaitGL)();
}

static void REGAL_CALL GLX_glXWaitX(void)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    _next->call(&_next->glXWaitX)();
}

// GLX_VERSION_1_1

static const char *REGAL_CALL GLX_glXGetClientString(Display *dpy, int name)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    const char * ret = _next->call(&_next->glXGetClientString)(dpy, name);
    return ret;
}

static const char *REGAL_CALL GLX_glXQueryExtensionsString(Display *dpy, int screen)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);

    const char *extensions = "";
    return extensions;

    const char * ret = _next->call(&_next->glXQueryExtensionsString)(dpy, screen);
    return ret;
}

static const char *REGAL_CALL GLX_glXQueryServerString(Display *dpy, int screen, int name)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    const char * ret = _next->call(&_next->glXQueryServerString)(dpy, screen, name);
    return ret;
}

// GLX_VERSION_1_2

static Display *REGAL_CALL GLX_glXGetCurrentDisplay(void)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    Display * ret = _next->call(&_next->glXGetCurrentDisplay)();
    return ret;
}

// GLX_VERSION_1_3

static GLXFBConfig *REGAL_CALL GLX_glXChooseFBConfig(Display *dpy, int screen, const int *attrib_list, int *nelements)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);

    static GLXFBConfig configs[1];
    return configs;

    GLXFBConfig * ret = _next->call(&_next->glXChooseFBConfig)(dpy, screen, attrib_list, nelements);
    return ret;
}

static GLXContext REGAL_CALL GLX_glXCreateNewContext(Display *dpy, GLXFBConfig config, int render_type, GLXContext share_list, Bool direct)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    GLXContext  ret = _next->call(&_next->glXCreateNewContext)(dpy, config, render_type, share_list, direct);
    return ret;
}

static GLXPbuffer REGAL_CALL GLX_glXCreatePbuffer(Display *dpy, GLXFBConfig config, const int *attrib_list)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    GLXPbuffer  ret = _next->call(&_next->glXCreatePbuffer)(dpy, config, attrib_list);
    return ret;
}

static GLXPixmap REGAL_CALL GLX_glXCreatePixmap(Display *dpy, GLXFBConfig config, Pixmap pixmap, const int *attrib_list)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    GLXPixmap  ret = _next->call(&_next->glXCreatePixmap)(dpy, config, pixmap, attrib_list);
    return ret;
}

static GLXWindow REGAL_CALL GLX_glXCreateWindow(Display *dpy, GLXFBConfig config, Window win, const int *attrib_list)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    GLXWindow  ret = _next->call(&_next->glXCreateWindow)(dpy, config, win, attrib_list);
    return ret;
}

static void REGAL_CALL GLX_glXDestroyPbuffer(Display *dpy, GLXPbuffer pbuf)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    _next->call(&_next->glXDestroyPbuffer)(dpy, pbuf);
}

static void REGAL_CALL GLX_glXDestroyPixmap(Display *dpy, GLXPixmap pixmap)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    _next->call(&_next->glXDestroyPixmap)(dpy, pixmap);
}

static void REGAL_CALL GLX_glXDestroyWindow(Display *dpy, GLXWindow win)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    _next->call(&_next->glXDestroyWindow)(dpy, win);
}

static GLXDrawable REGAL_CALL GLX_glXGetCurrentReadDrawable(void)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    GLXDrawable  ret = _next->call(&_next->glXGetCurrentReadDrawable)();
    return ret;
}

static int REGAL_CALL GLX_glXGetFBConfigAttrib(Display *dpy, GLXFBConfig config, int attribute, int *value)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    int  ret = _next->call(&_next->glXGetFBConfigAttrib)(dpy, config, attribute, value);
    return ret;
}

static GLXFBConfig *REGAL_CALL GLX_glXGetFBConfigs(Display *dpy, int screen, int *nelements)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    GLXFBConfig * ret = _next->call(&_next->glXGetFBConfigs)(dpy, screen, nelements);
    return ret;
}

static void REGAL_CALL GLX_glXGetSelectedEvent(Display *dpy, GLXDrawable draw, unsigned long *event_mask)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    _next->call(&_next->glXGetSelectedEvent)(dpy, draw, event_mask);
}

static XVisualInfo *REGAL_CALL GLX_glXGetVisualFromFBConfig(Display *dpy, GLXFBConfig config)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);

    static XVisualInfo vi;
    return &vi;

    XVisualInfo * ret = _next->call(&_next->glXGetVisualFromFBConfig)(dpy, config);
    return ret;
}

static Bool REGAL_CALL GLX_glXMakeContextCurrent(Display *display, GLXDrawable draw, GLXDrawable read, GLXContext ctx)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    Bool  ret = _next->call(&_next->glXMakeContextCurrent)(display, draw, read, ctx);
    return ret;
}

static int REGAL_CALL GLX_glXQueryContext(Display *dpy, GLXContext ctx, int attribute, int *value)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    int  ret = _next->call(&_next->glXQueryContext)(dpy, ctx, attribute, value);
    return ret;
}

static void REGAL_CALL GLX_glXQueryDrawable(Display *dpy, GLXDrawable draw, int attribute, unsigned int *value)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    _next->call(&_next->glXQueryDrawable)(dpy, draw, attribute, value);
}

static void REGAL_CALL GLX_glXSelectEvent(Display *dpy, GLXDrawable draw, unsigned long event_mask)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    _next->call(&_next->glXSelectEvent)(dpy, draw, event_mask);
}

// GLX_VERSION_1_4

static __GLXextFuncPtr REGAL_CALL GLX_glXGetProcAddress(const GLubyte *procName)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    __GLXextFuncPtr  ret = _next->call(&_next->glXGetProcAddress)(procName);
    return ret;
}

// GLX_AMD_gpu_association

static void REGAL_CALL GLX_glXBlitContextFramebufferAMD(GLXContext dstCtx, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    _next->call(&_next->glXBlitContextFramebufferAMD)(dstCtx, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
}

static GLXContext REGAL_CALL GLX_glXCreateAssociatedContextAMD(unsigned int id, GLXContext share_list)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    GLXContext  ret = _next->call(&_next->glXCreateAssociatedContextAMD)(id, share_list);
    return ret;
}

static GLXContext REGAL_CALL GLX_glXCreateAssociatedContextAttribsAMD(unsigned int id, GLXContext share_context, const int *attribList)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    GLXContext  ret = _next->call(&_next->glXCreateAssociatedContextAttribsAMD)(id, share_context, attribList);
    return ret;
}

static Bool REGAL_CALL GLX_glXDeleteAssociatedContextAMD(GLXContext ctx)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    Bool  ret = _next->call(&_next->glXDeleteAssociatedContextAMD)(ctx);
    return ret;
}

static unsigned int REGAL_CALL GLX_glXGetContextGPUIDAMD(GLXContext ctx)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    unsigned int  ret = _next->call(&_next->glXGetContextGPUIDAMD)(ctx);
    return ret;
}

static GLXContext REGAL_CALL GLX_glXGetCurrentAssociatedContextAMD(void)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    GLXContext  ret = _next->call(&_next->glXGetCurrentAssociatedContextAMD)();
    return ret;
}

static unsigned int REGAL_CALL GLX_glXGetGPUIDsAMD(unsigned int maxCount, unsigned int *ids)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    unsigned int  ret = _next->call(&_next->glXGetGPUIDsAMD)(maxCount, ids);
    return ret;
}

static int REGAL_CALL GLX_glXGetGPUInfoAMD(unsigned int id, int property, GLenum dataType, unsigned int size, GLvoid *data)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    int  ret = _next->call(&_next->glXGetGPUInfoAMD)(id, property, dataType, size, data);
    return ret;
}

static Bool REGAL_CALL GLX_glXMakeAssociatedContextCurrentAMD(GLXContext ctx)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    Bool  ret = _next->call(&_next->glXMakeAssociatedContextCurrentAMD)(ctx);
    return ret;
}

// GLX_ARB_create_context

static GLXContext REGAL_CALL GLX_glXCreateContextAttribsARB(Display *dpy, GLXFBConfig config, GLXContext share_context, Bool direct, const int *attrib_list)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    GLXContext  ret = _next->call(&_next->glXCreateContextAttribsARB)(dpy, config, share_context, direct, attrib_list);
    return ret;
}

// GLX_ARB_get_proc_address

static __GLXextFuncPtr REGAL_CALL GLX_glXGetProcAddressARB(const GLubyte *procName)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    __GLXextFuncPtr  ret = _next->call(&_next->glXGetProcAddressARB)(procName);
    return ret;
}

// GLX_ATI_render_texture

static void REGAL_CALL GLX_glXBindTexImageATI(Display *dpy, GLXPbuffer pbuf, int buffer)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    _next->call(&_next->glXBindTexImageATI)(dpy, pbuf, buffer);
}

static void REGAL_CALL GLX_glXDrawableAttribATI(Display *dpy, GLXDrawable draw, const int *attrib_list)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    _next->call(&_next->glXDrawableAttribATI)(dpy, draw, attrib_list);
}

static void REGAL_CALL GLX_glXReleaseTexImageATI(Display *dpy, GLXPbuffer pbuf, int buffer)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    _next->call(&_next->glXReleaseTexImageATI)(dpy, pbuf, buffer);
}

// GLX_EXT_import_context

static void REGAL_CALL GLX_glXFreeContextEXT(Display *dpy, GLXContext context)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    _next->call(&_next->glXFreeContextEXT)(dpy, context);
}

static GLXContextID REGAL_CALL GLX_glXGetContextIDEXT(const GLXContext context)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    GLXContextID  ret = _next->call(&_next->glXGetContextIDEXT)(context);
    return ret;
}

static GLXContext REGAL_CALL GLX_glXImportContextEXT(Display *dpy, GLXContextID contextID)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    GLXContext  ret = _next->call(&_next->glXImportContextEXT)(dpy, contextID);
    return ret;
}

static int REGAL_CALL GLX_glXQueryContextInfoEXT(Display *dpy, GLXContext context, int attribute, int *value)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    int  ret = _next->call(&_next->glXQueryContextInfoEXT)(dpy, context, attribute, value);
    return ret;
}

// GLX_EXT_swap_control

static void REGAL_CALL GLX_glXSwapIntervalEXT(Display *dpy, GLXDrawable drawable, int interval)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    _next->call(&_next->glXSwapIntervalEXT)(dpy, drawable, interval);
}

// GLX_EXT_texture_from_pixmap

static void REGAL_CALL GLX_glXBindTexImageEXT(Display *display, GLXDrawable drawable, int buffer, const int *attrib_list)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    _next->call(&_next->glXBindTexImageEXT)(display, drawable, buffer, attrib_list);
}

static void REGAL_CALL GLX_glXReleaseTexImageEXT(Display *display, GLXDrawable drawable, int buffer)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    _next->call(&_next->glXReleaseTexImageEXT)(display, drawable, buffer);
}

// GLX_MESA_agp_offset

static unsigned int REGAL_CALL GLX_glXGetAGPOffsetMESA(const void *pointer)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    unsigned int  ret = _next->call(&_next->glXGetAGPOffsetMESA)(pointer);
    return ret;
}

// GLX_MESA_copy_sub_buffer

static void REGAL_CALL GLX_glXCopySubBufferMESA(Display *dpy, GLXDrawable drawable, int x, int y, int width, int height)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    _next->call(&_next->glXCopySubBufferMESA)(dpy, drawable, x, y, width, height);
}

// GLX_MESA_pixmap_colormap

static GLXPixmap REGAL_CALL GLX_glXCreateGLXPixmapMESA(Display *dpy, XVisualInfo *visual, Pixmap pixmap, Colormap cmap)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    GLXPixmap  ret = _next->call(&_next->glXCreateGLXPixmapMESA)(dpy, visual, pixmap, cmap);
    return ret;
}

// GLX_MESA_release_buffers

static Bool REGAL_CALL GLX_glXReleaseBuffersMESA(Display *dpy, GLXDrawable d)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    Bool  ret = _next->call(&_next->glXReleaseBuffersMESA)(dpy, d);
    return ret;
}

// GLX_MESA_set_3dfx_mode

static GLboolean REGAL_CALL GLX_glXSet3DfxModeMESA(GLint mode)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    GLboolean  ret = _next->call(&_next->glXSet3DfxModeMESA)(mode);
    return ret;
}

// GLX_MESA_swap_control

static int REGAL_CALL GLX_glXGetSwapIntervalMESA(void)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    int  ret = _next->call(&_next->glXGetSwapIntervalMESA)();
    return ret;
}

static int REGAL_CALL GLX_glXSwapIntervalMESA(unsigned int interval)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    int  ret = _next->call(&_next->glXSwapIntervalMESA)(interval);
    return ret;
}

// GLX_NV_copy_image

static void REGAL_CALL GLX_glXCopyImageSubDataNV(Display *dpy, GLXContext srcCtx, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLXContext dstCtx, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    _next->call(&_next->glXCopyImageSubDataNV)(dpy, srcCtx, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstCtx, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
}

// GLX_NV_present_video

static int REGAL_CALL GLX_glXBindVideoDeviceNV(Display *dpy, unsigned int video_slot, unsigned int video_device, const int *attrib_list)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    int  ret = _next->call(&_next->glXBindVideoDeviceNV)(dpy, video_slot, video_device, attrib_list);
    return ret;
}

static unsigned int *REGAL_CALL GLX_glXEnumerateVideoDevicesNV(Display *dpy, int screen, int *nelements)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    unsigned int * ret = _next->call(&_next->glXEnumerateVideoDevicesNV)(dpy, screen, nelements);
    return ret;
}

// GLX_NV_swap_group

static Bool REGAL_CALL GLX_glXBindSwapBarrierNV(Display *dpy, GLuint group, GLuint barrier)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    Bool  ret = _next->call(&_next->glXBindSwapBarrierNV)(dpy, group, barrier);
    return ret;
}

static Bool REGAL_CALL GLX_glXJoinSwapGroupNV(Display *dpy, GLXDrawable drawable, GLuint group)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    Bool  ret = _next->call(&_next->glXJoinSwapGroupNV)(dpy, drawable, group);
    return ret;
}

static Bool REGAL_CALL GLX_glXQueryFrameCountNV(Display *dpy, int screen, GLuint *count)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    Bool  ret = _next->call(&_next->glXQueryFrameCountNV)(dpy, screen, count);
    return ret;
}

static Bool REGAL_CALL GLX_glXQueryMaxSwapGroupsNV(Display *dpy, int screen, GLuint *maxGroups, GLuint *maxBarriers)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    Bool  ret = _next->call(&_next->glXQueryMaxSwapGroupsNV)(dpy, screen, maxGroups, maxBarriers);
    return ret;
}

static Bool REGAL_CALL GLX_glXQuerySwapGroupNV(Display *dpy, GLXDrawable drawable, GLuint *group, GLuint *barrier)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    Bool  ret = _next->call(&_next->glXQuerySwapGroupNV)(dpy, drawable, group, barrier);
    return ret;
}

static Bool REGAL_CALL GLX_glXResetFrameCountNV(Display *dpy, int screen)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    Bool  ret = _next->call(&_next->glXResetFrameCountNV)(dpy, screen);
    return ret;
}

// GLX_NV_vertex_array_range

static void *REGAL_CALL GLX_glXAllocateMemoryNV(GLsizei size, GLfloat readFrequency, GLfloat writeFrequency, GLfloat priority)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    void * ret = _next->call(&_next->glXAllocateMemoryNV)(size, readFrequency, writeFrequency, priority);
    return ret;
}

static void REGAL_CALL GLX_glXFreeMemoryNV(void *pointer)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    _next->call(&_next->glXFreeMemoryNV)(pointer);
}

// GLX_NV_video_capture

static int REGAL_CALL GLX_glXBindVideoCaptureDeviceNV(Display *dpy, unsigned int video_capture_slot, GLXVideoCaptureDeviceNV device)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    int  ret = _next->call(&_next->glXBindVideoCaptureDeviceNV)(dpy, video_capture_slot, device);
    return ret;
}

static GLXVideoCaptureDeviceNV *REGAL_CALL GLX_glXEnumerateVideoCaptureDevicesNV(Display *dpy, int screen, int *nelements)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    GLXVideoCaptureDeviceNV * ret = _next->call(&_next->glXEnumerateVideoCaptureDevicesNV)(dpy, screen, nelements);
    return ret;
}

static void REGAL_CALL GLX_glXLockVideoCaptureDeviceNV(Display *dpy, GLXVideoCaptureDeviceNV device)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    _next->call(&_next->glXLockVideoCaptureDeviceNV)(dpy, device);
}

static int REGAL_CALL GLX_glXQueryVideoCaptureDeviceNV(Display *dpy, GLXVideoCaptureDeviceNV device, int attribute, int *value)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    int  ret = _next->call(&_next->glXQueryVideoCaptureDeviceNV)(dpy, device, attribute, value);
    return ret;
}

static void REGAL_CALL GLX_glXReleaseVideoCaptureDeviceNV(Display *dpy, GLXVideoCaptureDeviceNV device)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    _next->call(&_next->glXReleaseVideoCaptureDeviceNV)(dpy, device);
}

// GLX_NV_video_output

static int REGAL_CALL GLX_glXBindVideoImageNV(Display *dpy, GLXVideoDeviceNV VideoDevice, GLXPbuffer pbuf, int iVideoBuffer)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    int  ret = _next->call(&_next->glXBindVideoImageNV)(dpy, VideoDevice, pbuf, iVideoBuffer);
    return ret;
}

static int REGAL_CALL GLX_glXGetVideoDeviceNV(Display *dpy, int screen, int numVideoDevices, GLXVideoDeviceNV *pVideoDevice)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    int  ret = _next->call(&_next->glXGetVideoDeviceNV)(dpy, screen, numVideoDevices, pVideoDevice);
    return ret;
}

static int REGAL_CALL GLX_glXGetVideoInfoNV(Display *dpy, int screen, GLXVideoDeviceNV VideoDevice, unsigned long *pulCounterOutputPbuffer, unsigned long *pulCounterOutputVideo)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    int  ret = _next->call(&_next->glXGetVideoInfoNV)(dpy, screen, VideoDevice, pulCounterOutputPbuffer, pulCounterOutputVideo);
    return ret;
}

static int REGAL_CALL GLX_glXReleaseVideoDeviceNV(Display *dpy, int screen, GLXVideoDeviceNV VideoDevice)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    int  ret = _next->call(&_next->glXReleaseVideoDeviceNV)(dpy, screen, VideoDevice);
    return ret;
}

static int REGAL_CALL GLX_glXReleaseVideoImageNV(Display *dpy, GLXPbuffer pbuf)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    int  ret = _next->call(&_next->glXReleaseVideoImageNV)(dpy, pbuf);
    return ret;
}

static int REGAL_CALL GLX_glXSendPbufferToVideoNV(Display *dpy, GLXPbuffer pbuf, int iBufferType, unsigned long *pulCounterPbuffer, GLboolean bBlock)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    int  ret = _next->call(&_next->glXSendPbufferToVideoNV)(dpy, pbuf, iBufferType, pulCounterPbuffer, bBlock);
    return ret;
}

// GLX_OML_sync_control

static Bool REGAL_CALL GLX_glXGetMscRateOML(Display *dpy, GLXDrawable drawable, int32_t *numerator, int32_t *denominator)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    Bool  ret = _next->call(&_next->glXGetMscRateOML)(dpy, drawable, numerator, denominator);
    return ret;
}

static Bool REGAL_CALL GLX_glXGetSyncValuesOML(Display *dpy, GLXDrawable drawable, int64_t *ust, int64_t *msc, int64_t *sbc)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    Bool  ret = _next->call(&_next->glXGetSyncValuesOML)(dpy, drawable, ust, msc, sbc);
    return ret;
}

static int64_t REGAL_CALL GLX_glXSwapBuffersMscOML(Display *dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    int64_t  ret = _next->call(&_next->glXSwapBuffersMscOML)(dpy, drawable, target_msc, divisor, remainder);
    return ret;
}

static Bool REGAL_CALL GLX_glXWaitForMscOML(Display *dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder, int64_t *ust, int64_t *msc, int64_t *sbc)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    Bool  ret = _next->call(&_next->glXWaitForMscOML)(dpy, drawable, target_msc, divisor, remainder, ust, msc, sbc);
    return ret;
}

static Bool REGAL_CALL GLX_glXWaitForSbcOML(Display *dpy, GLXDrawable drawable, int64_t target_sbc, int64_t *ust, int64_t *msc, int64_t *sbc)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    Bool  ret = _next->call(&_next->glXWaitForSbcOML)(dpy, drawable, target_sbc, ust, msc, sbc);
    return ret;
}

// GLX_SGIX_fbconfig

static GLXFBConfigSGIX *REGAL_CALL GLX_glXChooseFBConfigSGIX(Display *dpy, int screen, const int *attrib_list, int *nelements)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    GLXFBConfigSGIX * ret = _next->call(&_next->glXChooseFBConfigSGIX)(dpy, screen, attrib_list, nelements);
    return ret;
}

static GLXContext REGAL_CALL GLX_glXCreateContextWithConfigSGIX(Display *dpy, GLXFBConfig config, int render_type, GLXContext share_list, Bool direct)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    GLXContext  ret = _next->call(&_next->glXCreateContextWithConfigSGIX)(dpy, config, render_type, share_list, direct);
    return ret;
}

static GLXPixmap REGAL_CALL GLX_glXCreateGLXPixmapWithConfigSGIX(Display *dpy, GLXFBConfig config, Pixmap pixmap)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    GLXPixmap  ret = _next->call(&_next->glXCreateGLXPixmapWithConfigSGIX)(dpy, config, pixmap);
    return ret;
}

static int REGAL_CALL GLX_glXGetFBConfigAttribSGIX(Display *dpy, GLXFBConfigSGIX config, int attribute, int *value)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    int  ret = _next->call(&_next->glXGetFBConfigAttribSGIX)(dpy, config, attribute, value);
    return ret;
}

static GLXFBConfigSGIX REGAL_CALL GLX_glXGetFBConfigFromVisualSGIX(Display *dpy, XVisualInfo *vis)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    GLXFBConfigSGIX  ret = _next->call(&_next->glXGetFBConfigFromVisualSGIX)(dpy, vis);
    return ret;
}

static XVisualInfo *REGAL_CALL GLX_glXGetVisualFromFBConfigSGIX(Display *dpy, GLXFBConfig config)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    XVisualInfo * ret = _next->call(&_next->glXGetVisualFromFBConfigSGIX)(dpy, config);
    return ret;
}

// GLX_SGIX_pbuffer

static GLXPbuffer REGAL_CALL GLX_glXCreateGLXPbufferSGIX(Display *dpy, GLXFBConfig config, unsigned int width, unsigned int height, int *attrib_list)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    GLXPbuffer  ret = _next->call(&_next->glXCreateGLXPbufferSGIX)(dpy, config, width, height, attrib_list);
    return ret;
}

static void REGAL_CALL GLX_glXDestroyGLXPbufferSGIX(Display *dpy, GLXPbuffer pbuf)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    _next->call(&_next->glXDestroyGLXPbufferSGIX)(dpy, pbuf);
}

static void REGAL_CALL GLX_glXGetSelectedEventSGIX(Display *dpy, GLXDrawable drawable, unsigned long *mask)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    _next->call(&_next->glXGetSelectedEventSGIX)(dpy, drawable, mask);
}

static void REGAL_CALL GLX_glXQueryGLXPbufferSGIX(Display *dpy, GLXPbuffer pbuf, int attribute, unsigned int *value)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    _next->call(&_next->glXQueryGLXPbufferSGIX)(dpy, pbuf, attribute, value);
}

static void REGAL_CALL GLX_glXSelectEventSGIX(Display *dpy, GLXDrawable drawable, unsigned long mask)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    _next->call(&_next->glXSelectEventSGIX)(dpy, drawable, mask);
}

// GLX_SGIX_swap_barrier

static void REGAL_CALL GLX_glXBindSwapBarrierSGIX(Display *dpy, GLXDrawable drawable, int barrier)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    _next->call(&_next->glXBindSwapBarrierSGIX)(dpy, drawable, barrier);
}

static Bool REGAL_CALL GLX_glXQueryMaxSwapBarriersSGIX(Display *dpy, int screen, int *max)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    Bool  ret = _next->call(&_next->glXQueryMaxSwapBarriersSGIX)(dpy, screen, max);
    return ret;
}

// GLX_SGIX_swap_group

static void REGAL_CALL GLX_glXJoinSwapGroupSGIX(Display *dpy, GLXDrawable drawable, GLXDrawable member)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    _next->call(&_next->glXJoinSwapGroupSGIX)(dpy, drawable, member);
}

// GLX_SGIX_video_resize

static int REGAL_CALL GLX_glXBindChannelToWindowSGIX(Display *display, int screen, int channel, Window window)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    int  ret = _next->call(&_next->glXBindChannelToWindowSGIX)(display, screen, channel, window);
    return ret;
}

static int REGAL_CALL GLX_glXChannelRectSGIX(Display *display, int screen, int channel, int x, int y, int w, int h)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    int  ret = _next->call(&_next->glXChannelRectSGIX)(display, screen, channel, x, y, w, h);
    return ret;
}

static int REGAL_CALL GLX_glXChannelRectSyncSGIX(Display *display, int screen, int channel, GLenum synctype)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    int  ret = _next->call(&_next->glXChannelRectSyncSGIX)(display, screen, channel, synctype);
    return ret;
}

static int REGAL_CALL GLX_glXQueryChannelDeltasSGIX(Display *display, int screen, int channel, int *x, int *y, int *w, int *h)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    int  ret = _next->call(&_next->glXQueryChannelDeltasSGIX)(display, screen, channel, x, y, w, h);
    return ret;
}

static int REGAL_CALL GLX_glXQueryChannelRectSGIX(Display *display, int screen, int channel, int *dx, int *dy, int *dw, int *dh)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    int  ret = _next->call(&_next->glXQueryChannelRectSGIX)(display, screen, channel, dx, dy, dw, dh);
    return ret;
}

// GLX_SGI_cushion

static void REGAL_CALL GLX_glXCushionSGI(Display *dpy, Window window, float cushion)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    _next->call(&_next->glXCushionSGI)(dpy, window, cushion);
}

// GLX_SGI_make_current_read

static GLXDrawable REGAL_CALL GLX_glXGetCurrentReadDrawableSGI(void)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    GLXDrawable  ret = _next->call(&_next->glXGetCurrentReadDrawableSGI)();
    return ret;
}

static Bool REGAL_CALL GLX_glXMakeCurrentReadSGI(Display *dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    Bool  ret = _next->call(&_next->glXMakeCurrentReadSGI)(dpy, draw, read, ctx);
    return ret;
}

// GLX_SGI_swap_control

static int REGAL_CALL GLX_glXSwapIntervalSGI(int interval)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    int  ret = _next->call(&_next->glXSwapIntervalSGI)(interval);
    return ret;
}

// GLX_SGI_video_sync

static int REGAL_CALL GLX_glXGetVideoSyncSGI(unsigned int *count)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    int  ret = _next->call(&_next->glXGetVideoSyncSGI)(count);
    return ret;
}

static int REGAL_CALL GLX_glXWaitVideoSyncSGI(int divisor, int remainder, unsigned int *count)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    int  ret = _next->call(&_next->glXWaitVideoSyncSGI)(divisor, remainder, count);
    return ret;
}

// GLX_SUN_get_transparent_index

static Status REGAL_CALL GLX_glXGetTransparentIndexSUN(Display *dpy, Window overlay, Window underlay, unsigned long *pTransparentIndex)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    Status  ret = _next->call(&_next->glXGetTransparentIndexSUN)(dpy, overlay, underlay, pTransparentIndex);
    return ret;
}

// GLX_SUN_video_resize

static int REGAL_CALL GLX_glXGetVideoResizeSUN(Display *display, GLXDrawable window, float *factor)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    int  ret = _next->call(&_next->glXGetVideoResizeSUN)(display, window, factor);
    return ret;
}

static int REGAL_CALL GLX_glXVideoResizeSUN(Display *display, GLXDrawable window, float factor)
{
    DispatchTableGlobal *_next = dispatcherGlobal.glx.next();
    RegalAssert(_next);
    int  ret = _next->call(&_next->glXVideoResizeSUN)(display, window, factor);
    return ret;
}

void InitDispatchTableGLX(DispatchTableGL &tbl)
{

}

void InitDispatchTableGlobalGLX(DispatchTableGlobal &tbl)
{

#if REGAL_SYS_GLX
  // GLX_VERSION_1_0

  tbl.glXChooseVisual = GLX_glXChooseVisual;
  tbl.glXCopyContext = GLX_glXCopyContext;
  tbl.glXCreateContext = GLX_glXCreateContext;
  tbl.glXCreateGLXPixmap = GLX_glXCreateGLXPixmap;
  tbl.glXDestroyContext = GLX_glXDestroyContext;
  tbl.glXDestroyGLXPixmap = GLX_glXDestroyGLXPixmap;
  tbl.glXGetConfig = GLX_glXGetConfig;
  tbl.glXGetCurrentContext = GLX_glXGetCurrentContext;
  tbl.glXGetCurrentDrawable = GLX_glXGetCurrentDrawable;
  tbl.glXIsDirect = GLX_glXIsDirect;
  tbl.glXMakeCurrent = GLX_glXMakeCurrent;
  tbl.glXQueryExtension = GLX_glXQueryExtension;
  tbl.glXQueryVersion = GLX_glXQueryVersion;
  tbl.glXSwapBuffers = GLX_glXSwapBuffers;
  tbl.glXUseXFont = GLX_glXUseXFont;
  tbl.glXWaitGL = GLX_glXWaitGL;
  tbl.glXWaitX = GLX_glXWaitX;

  // GLX_VERSION_1_1

  tbl.glXGetClientString = GLX_glXGetClientString;
  tbl.glXQueryExtensionsString = GLX_glXQueryExtensionsString;
  tbl.glXQueryServerString = GLX_glXQueryServerString;

  // GLX_VERSION_1_2

  tbl.glXGetCurrentDisplay = GLX_glXGetCurrentDisplay;

  // GLX_VERSION_1_3

  tbl.glXChooseFBConfig = GLX_glXChooseFBConfig;
  tbl.glXCreateNewContext = GLX_glXCreateNewContext;
  tbl.glXCreatePbuffer = GLX_glXCreatePbuffer;
  tbl.glXCreatePixmap = GLX_glXCreatePixmap;
  tbl.glXCreateWindow = GLX_glXCreateWindow;
  tbl.glXDestroyPbuffer = GLX_glXDestroyPbuffer;
  tbl.glXDestroyPixmap = GLX_glXDestroyPixmap;
  tbl.glXDestroyWindow = GLX_glXDestroyWindow;
  tbl.glXGetCurrentReadDrawable = GLX_glXGetCurrentReadDrawable;
  tbl.glXGetFBConfigAttrib = GLX_glXGetFBConfigAttrib;
  tbl.glXGetFBConfigs = GLX_glXGetFBConfigs;
  tbl.glXGetSelectedEvent = GLX_glXGetSelectedEvent;
  tbl.glXGetVisualFromFBConfig = GLX_glXGetVisualFromFBConfig;
  tbl.glXMakeContextCurrent = GLX_glXMakeContextCurrent;
  tbl.glXQueryContext = GLX_glXQueryContext;
  tbl.glXQueryDrawable = GLX_glXQueryDrawable;
  tbl.glXSelectEvent = GLX_glXSelectEvent;

  // GLX_VERSION_1_4

  tbl.glXGetProcAddress = GLX_glXGetProcAddress;

  // GLX_AMD_gpu_association

  tbl.glXBlitContextFramebufferAMD = GLX_glXBlitContextFramebufferAMD;
  tbl.glXCreateAssociatedContextAMD = GLX_glXCreateAssociatedContextAMD;
  tbl.glXCreateAssociatedContextAttribsAMD = GLX_glXCreateAssociatedContextAttribsAMD;
  tbl.glXDeleteAssociatedContextAMD = GLX_glXDeleteAssociatedContextAMD;
  tbl.glXGetContextGPUIDAMD = GLX_glXGetContextGPUIDAMD;
  tbl.glXGetCurrentAssociatedContextAMD = GLX_glXGetCurrentAssociatedContextAMD;
  tbl.glXGetGPUIDsAMD = GLX_glXGetGPUIDsAMD;
  tbl.glXGetGPUInfoAMD = GLX_glXGetGPUInfoAMD;
  tbl.glXMakeAssociatedContextCurrentAMD = GLX_glXMakeAssociatedContextCurrentAMD;

  // GLX_ARB_create_context

  tbl.glXCreateContextAttribsARB = GLX_glXCreateContextAttribsARB;

  // GLX_ARB_get_proc_address

  tbl.glXGetProcAddressARB = GLX_glXGetProcAddressARB;

  // GLX_ATI_render_texture

  tbl.glXBindTexImageATI = GLX_glXBindTexImageATI;
  tbl.glXDrawableAttribATI = GLX_glXDrawableAttribATI;
  tbl.glXReleaseTexImageATI = GLX_glXReleaseTexImageATI;

  // GLX_EXT_import_context

  tbl.glXFreeContextEXT = GLX_glXFreeContextEXT;
  tbl.glXGetContextIDEXT = GLX_glXGetContextIDEXT;
  tbl.glXImportContextEXT = GLX_glXImportContextEXT;
  tbl.glXQueryContextInfoEXT = GLX_glXQueryContextInfoEXT;

  // GLX_EXT_swap_control

  tbl.glXSwapIntervalEXT = GLX_glXSwapIntervalEXT;

  // GLX_EXT_texture_from_pixmap

  tbl.glXBindTexImageEXT = GLX_glXBindTexImageEXT;
  tbl.glXReleaseTexImageEXT = GLX_glXReleaseTexImageEXT;

  // GLX_MESA_agp_offset

  tbl.glXGetAGPOffsetMESA = GLX_glXGetAGPOffsetMESA;

  // GLX_MESA_copy_sub_buffer

  tbl.glXCopySubBufferMESA = GLX_glXCopySubBufferMESA;

  // GLX_MESA_pixmap_colormap

  tbl.glXCreateGLXPixmapMESA = GLX_glXCreateGLXPixmapMESA;

  // GLX_MESA_release_buffers

  tbl.glXReleaseBuffersMESA = GLX_glXReleaseBuffersMESA;

  // GLX_MESA_set_3dfx_mode

  tbl.glXSet3DfxModeMESA = GLX_glXSet3DfxModeMESA;

  // GLX_MESA_swap_control

  tbl.glXGetSwapIntervalMESA = GLX_glXGetSwapIntervalMESA;
  tbl.glXSwapIntervalMESA = GLX_glXSwapIntervalMESA;

  // GLX_NV_copy_image

  tbl.glXCopyImageSubDataNV = GLX_glXCopyImageSubDataNV;

  // GLX_NV_present_video

  tbl.glXBindVideoDeviceNV = GLX_glXBindVideoDeviceNV;
  tbl.glXEnumerateVideoDevicesNV = GLX_glXEnumerateVideoDevicesNV;

  // GLX_NV_swap_group

  tbl.glXBindSwapBarrierNV = GLX_glXBindSwapBarrierNV;
  tbl.glXJoinSwapGroupNV = GLX_glXJoinSwapGroupNV;
  tbl.glXQueryFrameCountNV = GLX_glXQueryFrameCountNV;
  tbl.glXQueryMaxSwapGroupsNV = GLX_glXQueryMaxSwapGroupsNV;
  tbl.glXQuerySwapGroupNV = GLX_glXQuerySwapGroupNV;
  tbl.glXResetFrameCountNV = GLX_glXResetFrameCountNV;

  // GLX_NV_vertex_array_range

  tbl.glXAllocateMemoryNV = GLX_glXAllocateMemoryNV;
  tbl.glXFreeMemoryNV = GLX_glXFreeMemoryNV;

  // GLX_NV_video_capture

  tbl.glXBindVideoCaptureDeviceNV = GLX_glXBindVideoCaptureDeviceNV;
  tbl.glXEnumerateVideoCaptureDevicesNV = GLX_glXEnumerateVideoCaptureDevicesNV;
  tbl.glXLockVideoCaptureDeviceNV = GLX_glXLockVideoCaptureDeviceNV;
  tbl.glXQueryVideoCaptureDeviceNV = GLX_glXQueryVideoCaptureDeviceNV;
  tbl.glXReleaseVideoCaptureDeviceNV = GLX_glXReleaseVideoCaptureDeviceNV;

  // GLX_NV_video_output

  tbl.glXBindVideoImageNV = GLX_glXBindVideoImageNV;
  tbl.glXGetVideoDeviceNV = GLX_glXGetVideoDeviceNV;
  tbl.glXGetVideoInfoNV = GLX_glXGetVideoInfoNV;
  tbl.glXReleaseVideoDeviceNV = GLX_glXReleaseVideoDeviceNV;
  tbl.glXReleaseVideoImageNV = GLX_glXReleaseVideoImageNV;
  tbl.glXSendPbufferToVideoNV = GLX_glXSendPbufferToVideoNV;

  // GLX_OML_sync_control

  tbl.glXGetMscRateOML = GLX_glXGetMscRateOML;
  tbl.glXGetSyncValuesOML = GLX_glXGetSyncValuesOML;
  tbl.glXSwapBuffersMscOML = GLX_glXSwapBuffersMscOML;
  tbl.glXWaitForMscOML = GLX_glXWaitForMscOML;
  tbl.glXWaitForSbcOML = GLX_glXWaitForSbcOML;

  // GLX_SGIX_fbconfig

  tbl.glXChooseFBConfigSGIX = GLX_glXChooseFBConfigSGIX;
  tbl.glXCreateContextWithConfigSGIX = GLX_glXCreateContextWithConfigSGIX;
  tbl.glXCreateGLXPixmapWithConfigSGIX = GLX_glXCreateGLXPixmapWithConfigSGIX;
  tbl.glXGetFBConfigAttribSGIX = GLX_glXGetFBConfigAttribSGIX;
  tbl.glXGetFBConfigFromVisualSGIX = GLX_glXGetFBConfigFromVisualSGIX;
  tbl.glXGetVisualFromFBConfigSGIX = GLX_glXGetVisualFromFBConfigSGIX;

  // GLX_SGIX_pbuffer

  tbl.glXCreateGLXPbufferSGIX = GLX_glXCreateGLXPbufferSGIX;
  tbl.glXDestroyGLXPbufferSGIX = GLX_glXDestroyGLXPbufferSGIX;
  tbl.glXGetSelectedEventSGIX = GLX_glXGetSelectedEventSGIX;
  tbl.glXQueryGLXPbufferSGIX = GLX_glXQueryGLXPbufferSGIX;
  tbl.glXSelectEventSGIX = GLX_glXSelectEventSGIX;

  // GLX_SGIX_swap_barrier

  tbl.glXBindSwapBarrierSGIX = GLX_glXBindSwapBarrierSGIX;
  tbl.glXQueryMaxSwapBarriersSGIX = GLX_glXQueryMaxSwapBarriersSGIX;

  // GLX_SGIX_swap_group

  tbl.glXJoinSwapGroupSGIX = GLX_glXJoinSwapGroupSGIX;

  // GLX_SGIX_video_resize

  tbl.glXBindChannelToWindowSGIX = GLX_glXBindChannelToWindowSGIX;
  tbl.glXChannelRectSGIX = GLX_glXChannelRectSGIX;
  tbl.glXChannelRectSyncSGIX = GLX_glXChannelRectSyncSGIX;
  tbl.glXQueryChannelDeltasSGIX = GLX_glXQueryChannelDeltasSGIX;
  tbl.glXQueryChannelRectSGIX = GLX_glXQueryChannelRectSGIX;

  // GLX_SGI_cushion

  tbl.glXCushionSGI = GLX_glXCushionSGI;

  // GLX_SGI_make_current_read

  tbl.glXGetCurrentReadDrawableSGI = GLX_glXGetCurrentReadDrawableSGI;
  tbl.glXMakeCurrentReadSGI = GLX_glXMakeCurrentReadSGI;

  // GLX_SGI_swap_control

  tbl.glXSwapIntervalSGI = GLX_glXSwapIntervalSGI;

  // GLX_SGI_video_sync

  tbl.glXGetVideoSyncSGI = GLX_glXGetVideoSyncSGI;
  tbl.glXWaitVideoSyncSGI = GLX_glXWaitVideoSyncSGI;

  // GLX_SUN_get_transparent_index

  tbl.glXGetTransparentIndexSUN = GLX_glXGetTransparentIndexSUN;

  // GLX_SUN_video_resize

  tbl.glXGetVideoResizeSUN = GLX_glXGetVideoResizeSUN;
  tbl.glXVideoResizeSUN = GLX_glXVideoResizeSUN;
#endif // REGAL_SYS_GLX

}

REGAL_NAMESPACE_END

#endif
