/* NOTE: Do not edit this file, it is generated by a script:
   Export.py --api gl 4.4 --api wgl 4.4 --api glx 4.4 --api cgl 1.4 --api egl 1.0 --outdir .
*/

/*
  Copyright (c) 2011-2013 NVIDIA Corporation
  Copyright (c) 2011-2013 Cass Everitt
  Copyright (c) 2012-2013 Scott Nations
  Copyright (c) 2012 Mathias Schott
  Copyright (c) 2012-2013 Nigel Stewart
  Copyright (c) 2012-2013 Google Inc.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without modification,
  are permitted provided that the following conditions are met:

    Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.

    Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
  OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
  Intended formatting conventions:
  $ astyle --style=allman --indent=spaces=2 --indent-switches
*/

#include "pch.h" /* For MS precompiled header support */

#include "RegalUtil.h"

#if REGAL_DRIVER && REGAL_LOADER

REGAL_GLOBAL_BEGIN

#include <string>
using namespace std;

#include "RegalLog.h"
#include "RegalBreak.h"
#include "RegalPush.h"
#include "RegalToken.h"
#include "RegalHelper.h"
#include "RegalPrivate.h"
#include "RegalContext.h"
#include "RegalDispatcherGL.h"
#include "RegalDispatcherGlobal.h"

REGAL_GLOBAL_END

REGAL_NAMESPACE_BEGIN

using namespace ::REGAL_NAMESPACE_INTERNAL::Logging;
using namespace ::REGAL_NAMESPACE_INTERNAL::Token;

namespace Loader
{

  static DispatchTableGL &_getDispatchGL()
  {
    RegalContext * _context = REGAL_GET_CONTEXT();
    RegalAssert(_context);
    return _context->dispatcher.driver;
  }

  static void _getProcAddress(void (**func)(), void (*funcRegal)(), const char *name)
  {
    GetProcAddress(*func, name);
    RegalAssert(*func!=funcRegal);
    if (*func==funcRegal)
      *func = NULL;
  }

// GL_VERSION_1_0

  static void REGAL_CALL glAccum(GLenum op, GLfloat value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glAccum),reinterpret_cast<void (*)()>(glAccum),"glAccum");
    _driver.call(&_driver.glAccum)(op, value);
  }

  static void REGAL_CALL glAlphaFunc(GLenum func, GLclampf ref)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glAlphaFunc),reinterpret_cast<void (*)()>(glAlphaFunc),"glAlphaFunc");
    _driver.call(&_driver.glAlphaFunc)(func, ref);
  }

  static void REGAL_CALL glBegin(GLenum mode)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBegin),reinterpret_cast<void (*)()>(glBegin),"glBegin");
    _driver.call(&_driver.glBegin)(mode);
  }

  static void REGAL_CALL glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBitmap),reinterpret_cast<void (*)()>(glBitmap),"glBitmap");
    _driver.call(&_driver.glBitmap)(width, height, xorig, yorig, xmove, ymove, bitmap);
  }

  static void REGAL_CALL glBlendFunc(GLenum sfactor, GLenum dfactor)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBlendFunc),reinterpret_cast<void (*)()>(glBlendFunc),"glBlendFunc");
    _driver.call(&_driver.glBlendFunc)(sfactor, dfactor);
  }

  static void REGAL_CALL glCallList(GLuint list)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCallList),reinterpret_cast<void (*)()>(glCallList),"glCallList");
    _driver.call(&_driver.glCallList)(list);
  }

  static void REGAL_CALL glCallLists(GLsizei n, GLenum type, const GLvoid *lists)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCallLists),reinterpret_cast<void (*)()>(glCallLists),"glCallLists");
    _driver.call(&_driver.glCallLists)(n, type, lists);
  }

  static void REGAL_CALL glClear(GLbitfield mask)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glClear),reinterpret_cast<void (*)()>(glClear),"glClear");
    _driver.call(&_driver.glClear)(mask);
  }

  static void REGAL_CALL glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glClearAccum),reinterpret_cast<void (*)()>(glClearAccum),"glClearAccum");
    _driver.call(&_driver.glClearAccum)(red, green, blue, alpha);
  }

  static void REGAL_CALL glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glClearColor),reinterpret_cast<void (*)()>(glClearColor),"glClearColor");
    _driver.call(&_driver.glClearColor)(red, green, blue, alpha);
  }

  static void REGAL_CALL glClearDepth(GLclampd depth)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glClearDepth),reinterpret_cast<void (*)()>(glClearDepth),"glClearDepth");
    _driver.call(&_driver.glClearDepth)(depth);
  }

  static void REGAL_CALL glClearIndex(GLfloat c)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glClearIndex),reinterpret_cast<void (*)()>(glClearIndex),"glClearIndex");
    _driver.call(&_driver.glClearIndex)(c);
  }

  static void REGAL_CALL glClearStencil(GLint s)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glClearStencil),reinterpret_cast<void (*)()>(glClearStencil),"glClearStencil");
    _driver.call(&_driver.glClearStencil)(s);
  }

  static void REGAL_CALL glClipPlane(GLenum plane, const GLdouble *equation)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glClipPlane),reinterpret_cast<void (*)()>(glClipPlane),"glClipPlane");
    _driver.call(&_driver.glClipPlane)(plane, equation);
  }

  static void REGAL_CALL glColor3b(GLbyte red, GLbyte green, GLbyte blue)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColor3b),reinterpret_cast<void (*)()>(glColor3b),"glColor3b");
    _driver.call(&_driver.glColor3b)(red, green, blue);
  }

  static void REGAL_CALL glColor3bv(const GLbyte *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColor3bv),reinterpret_cast<void (*)()>(glColor3bv),"glColor3bv");
    _driver.call(&_driver.glColor3bv)(v);
  }

  static void REGAL_CALL glColor3d(GLdouble red, GLdouble green, GLdouble blue)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColor3d),reinterpret_cast<void (*)()>(glColor3d),"glColor3d");
    _driver.call(&_driver.glColor3d)(red, green, blue);
  }

  static void REGAL_CALL glColor3dv(const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColor3dv),reinterpret_cast<void (*)()>(glColor3dv),"glColor3dv");
    _driver.call(&_driver.glColor3dv)(v);
  }

  static void REGAL_CALL glColor3f(GLfloat red, GLfloat green, GLfloat blue)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColor3f),reinterpret_cast<void (*)()>(glColor3f),"glColor3f");
    _driver.call(&_driver.glColor3f)(red, green, blue);
  }

  static void REGAL_CALL glColor3fv(const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColor3fv),reinterpret_cast<void (*)()>(glColor3fv),"glColor3fv");
    _driver.call(&_driver.glColor3fv)(v);
  }

  static void REGAL_CALL glColor3i(GLint red, GLint green, GLint blue)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColor3i),reinterpret_cast<void (*)()>(glColor3i),"glColor3i");
    _driver.call(&_driver.glColor3i)(red, green, blue);
  }

  static void REGAL_CALL glColor3iv(const GLint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColor3iv),reinterpret_cast<void (*)()>(glColor3iv),"glColor3iv");
    _driver.call(&_driver.glColor3iv)(v);
  }

  static void REGAL_CALL glColor3s(GLshort red, GLshort green, GLshort blue)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColor3s),reinterpret_cast<void (*)()>(glColor3s),"glColor3s");
    _driver.call(&_driver.glColor3s)(red, green, blue);
  }

  static void REGAL_CALL glColor3sv(const GLshort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColor3sv),reinterpret_cast<void (*)()>(glColor3sv),"glColor3sv");
    _driver.call(&_driver.glColor3sv)(v);
  }

  static void REGAL_CALL glColor3ub(GLubyte red, GLubyte green, GLubyte blue)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColor3ub),reinterpret_cast<void (*)()>(glColor3ub),"glColor3ub");
    _driver.call(&_driver.glColor3ub)(red, green, blue);
  }

  static void REGAL_CALL glColor3ubv(const GLubyte *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColor3ubv),reinterpret_cast<void (*)()>(glColor3ubv),"glColor3ubv");
    _driver.call(&_driver.glColor3ubv)(v);
  }

  static void REGAL_CALL glColor3ui(GLuint red, GLuint green, GLuint blue)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColor3ui),reinterpret_cast<void (*)()>(glColor3ui),"glColor3ui");
    _driver.call(&_driver.glColor3ui)(red, green, blue);
  }

  static void REGAL_CALL glColor3uiv(const GLuint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColor3uiv),reinterpret_cast<void (*)()>(glColor3uiv),"glColor3uiv");
    _driver.call(&_driver.glColor3uiv)(v);
  }

  static void REGAL_CALL glColor3us(GLushort red, GLushort green, GLushort blue)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColor3us),reinterpret_cast<void (*)()>(glColor3us),"glColor3us");
    _driver.call(&_driver.glColor3us)(red, green, blue);
  }

  static void REGAL_CALL glColor3usv(const GLushort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColor3usv),reinterpret_cast<void (*)()>(glColor3usv),"glColor3usv");
    _driver.call(&_driver.glColor3usv)(v);
  }

  static void REGAL_CALL glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColor4b),reinterpret_cast<void (*)()>(glColor4b),"glColor4b");
    _driver.call(&_driver.glColor4b)(red, green, blue, alpha);
  }

  static void REGAL_CALL glColor4bv(const GLbyte *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColor4bv),reinterpret_cast<void (*)()>(glColor4bv),"glColor4bv");
    _driver.call(&_driver.glColor4bv)(v);
  }

  static void REGAL_CALL glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColor4d),reinterpret_cast<void (*)()>(glColor4d),"glColor4d");
    _driver.call(&_driver.glColor4d)(red, green, blue, alpha);
  }

  static void REGAL_CALL glColor4dv(const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColor4dv),reinterpret_cast<void (*)()>(glColor4dv),"glColor4dv");
    _driver.call(&_driver.glColor4dv)(v);
  }

  static void REGAL_CALL glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColor4f),reinterpret_cast<void (*)()>(glColor4f),"glColor4f");
    _driver.call(&_driver.glColor4f)(red, green, blue, alpha);
  }

  static void REGAL_CALL glColor4fv(const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColor4fv),reinterpret_cast<void (*)()>(glColor4fv),"glColor4fv");
    _driver.call(&_driver.glColor4fv)(v);
  }

  static void REGAL_CALL glColor4i(GLint red, GLint green, GLint blue, GLint alpha)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColor4i),reinterpret_cast<void (*)()>(glColor4i),"glColor4i");
    _driver.call(&_driver.glColor4i)(red, green, blue, alpha);
  }

  static void REGAL_CALL glColor4iv(const GLint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColor4iv),reinterpret_cast<void (*)()>(glColor4iv),"glColor4iv");
    _driver.call(&_driver.glColor4iv)(v);
  }

  static void REGAL_CALL glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColor4s),reinterpret_cast<void (*)()>(glColor4s),"glColor4s");
    _driver.call(&_driver.glColor4s)(red, green, blue, alpha);
  }

  static void REGAL_CALL glColor4sv(const GLshort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColor4sv),reinterpret_cast<void (*)()>(glColor4sv),"glColor4sv");
    _driver.call(&_driver.glColor4sv)(v);
  }

  static void REGAL_CALL glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColor4ub),reinterpret_cast<void (*)()>(glColor4ub),"glColor4ub");
    _driver.call(&_driver.glColor4ub)(red, green, blue, alpha);
  }

  static void REGAL_CALL glColor4ubv(const GLubyte *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColor4ubv),reinterpret_cast<void (*)()>(glColor4ubv),"glColor4ubv");
    _driver.call(&_driver.glColor4ubv)(v);
  }

  static void REGAL_CALL glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColor4ui),reinterpret_cast<void (*)()>(glColor4ui),"glColor4ui");
    _driver.call(&_driver.glColor4ui)(red, green, blue, alpha);
  }

  static void REGAL_CALL glColor4uiv(const GLuint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColor4uiv),reinterpret_cast<void (*)()>(glColor4uiv),"glColor4uiv");
    _driver.call(&_driver.glColor4uiv)(v);
  }

  static void REGAL_CALL glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColor4us),reinterpret_cast<void (*)()>(glColor4us),"glColor4us");
    _driver.call(&_driver.glColor4us)(red, green, blue, alpha);
  }

  static void REGAL_CALL glColor4usv(const GLushort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColor4usv),reinterpret_cast<void (*)()>(glColor4usv),"glColor4usv");
    _driver.call(&_driver.glColor4usv)(v);
  }

  static void REGAL_CALL glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColorMask),reinterpret_cast<void (*)()>(glColorMask),"glColorMask");
    _driver.call(&_driver.glColorMask)(red, green, blue, alpha);
  }

  static void REGAL_CALL glColorMaterial(GLenum face, GLenum mode)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColorMaterial),reinterpret_cast<void (*)()>(glColorMaterial),"glColorMaterial");
    _driver.call(&_driver.glColorMaterial)(face, mode);
  }

  static void REGAL_CALL glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCopyPixels),reinterpret_cast<void (*)()>(glCopyPixels),"glCopyPixels");
    _driver.call(&_driver.glCopyPixels)(x, y, width, height, type);
  }

  static void REGAL_CALL glCullFace(GLenum mode)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCullFace),reinterpret_cast<void (*)()>(glCullFace),"glCullFace");
    _driver.call(&_driver.glCullFace)(mode);
  }

  static void REGAL_CALL glDeleteLists(GLuint list, GLsizei range)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDeleteLists),reinterpret_cast<void (*)()>(glDeleteLists),"glDeleteLists");
    _driver.call(&_driver.glDeleteLists)(list, range);
  }

  static void REGAL_CALL glDepthFunc(GLenum func)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDepthFunc),reinterpret_cast<void (*)()>(glDepthFunc),"glDepthFunc");
    _driver.call(&_driver.glDepthFunc)(func);
  }

  static void REGAL_CALL glDepthMask(GLboolean flag)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDepthMask),reinterpret_cast<void (*)()>(glDepthMask),"glDepthMask");
    _driver.call(&_driver.glDepthMask)(flag);
  }

  static void REGAL_CALL glDepthRange(GLclampd zNear, GLclampd zFar)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDepthRange),reinterpret_cast<void (*)()>(glDepthRange),"glDepthRange");
    _driver.call(&_driver.glDepthRange)(zNear, zFar);
  }

  static void REGAL_CALL glDisable(GLenum cap)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDisable),reinterpret_cast<void (*)()>(glDisable),"glDisable");
    _driver.call(&_driver.glDisable)(cap);
  }

  static void REGAL_CALL glDrawBuffer(GLenum mode)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDrawBuffer),reinterpret_cast<void (*)()>(glDrawBuffer),"glDrawBuffer");
    _driver.call(&_driver.glDrawBuffer)(mode);
  }

  static void REGAL_CALL glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDrawPixels),reinterpret_cast<void (*)()>(glDrawPixels),"glDrawPixels");
    _driver.call(&_driver.glDrawPixels)(width, height, format, type, pixels);
  }

  static void REGAL_CALL glEdgeFlag(GLboolean flag)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glEdgeFlag),reinterpret_cast<void (*)()>(glEdgeFlag),"glEdgeFlag");
    _driver.call(&_driver.glEdgeFlag)(flag);
  }

  static void REGAL_CALL glEdgeFlagv(const GLboolean *flag)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glEdgeFlagv),reinterpret_cast<void (*)()>(glEdgeFlagv),"glEdgeFlagv");
    _driver.call(&_driver.glEdgeFlagv)(flag);
  }

  static void REGAL_CALL glEnable(GLenum cap)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glEnable),reinterpret_cast<void (*)()>(glEnable),"glEnable");
    _driver.call(&_driver.glEnable)(cap);
  }

  static void REGAL_CALL glEnd(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glEnd),reinterpret_cast<void (*)()>(glEnd),"glEnd");
    _driver.call(&_driver.glEnd)();
  }

  static void REGAL_CALL glEndList(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glEndList),reinterpret_cast<void (*)()>(glEndList),"glEndList");
    _driver.call(&_driver.glEndList)();
  }

  static void REGAL_CALL glEvalCoord1d(GLdouble u)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glEvalCoord1d),reinterpret_cast<void (*)()>(glEvalCoord1d),"glEvalCoord1d");
    _driver.call(&_driver.glEvalCoord1d)(u);
  }

  static void REGAL_CALL glEvalCoord1dv(const GLdouble *u)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glEvalCoord1dv),reinterpret_cast<void (*)()>(glEvalCoord1dv),"glEvalCoord1dv");
    _driver.call(&_driver.glEvalCoord1dv)(u);
  }

  static void REGAL_CALL glEvalCoord1f(GLfloat u)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glEvalCoord1f),reinterpret_cast<void (*)()>(glEvalCoord1f),"glEvalCoord1f");
    _driver.call(&_driver.glEvalCoord1f)(u);
  }

  static void REGAL_CALL glEvalCoord1fv(const GLfloat *u)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glEvalCoord1fv),reinterpret_cast<void (*)()>(glEvalCoord1fv),"glEvalCoord1fv");
    _driver.call(&_driver.glEvalCoord1fv)(u);
  }

  static void REGAL_CALL glEvalCoord2d(GLdouble u, GLdouble v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glEvalCoord2d),reinterpret_cast<void (*)()>(glEvalCoord2d),"glEvalCoord2d");
    _driver.call(&_driver.glEvalCoord2d)(u, v);
  }

  static void REGAL_CALL glEvalCoord2dv(const GLdouble *u)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glEvalCoord2dv),reinterpret_cast<void (*)()>(glEvalCoord2dv),"glEvalCoord2dv");
    _driver.call(&_driver.glEvalCoord2dv)(u);
  }

  static void REGAL_CALL glEvalCoord2f(GLfloat u, GLfloat v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glEvalCoord2f),reinterpret_cast<void (*)()>(glEvalCoord2f),"glEvalCoord2f");
    _driver.call(&_driver.glEvalCoord2f)(u, v);
  }

  static void REGAL_CALL glEvalCoord2fv(const GLfloat *u)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glEvalCoord2fv),reinterpret_cast<void (*)()>(glEvalCoord2fv),"glEvalCoord2fv");
    _driver.call(&_driver.glEvalCoord2fv)(u);
  }

  static void REGAL_CALL glEvalMesh1(GLenum mode, GLint i1, GLint i2)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glEvalMesh1),reinterpret_cast<void (*)()>(glEvalMesh1),"glEvalMesh1");
    _driver.call(&_driver.glEvalMesh1)(mode, i1, i2);
  }

  static void REGAL_CALL glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glEvalMesh2),reinterpret_cast<void (*)()>(glEvalMesh2),"glEvalMesh2");
    _driver.call(&_driver.glEvalMesh2)(mode, i1, i2, j1, j2);
  }

  static void REGAL_CALL glEvalPoint1(GLint i)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glEvalPoint1),reinterpret_cast<void (*)()>(glEvalPoint1),"glEvalPoint1");
    _driver.call(&_driver.glEvalPoint1)(i);
  }

  static void REGAL_CALL glEvalPoint2(GLint i, GLint j)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glEvalPoint2),reinterpret_cast<void (*)()>(glEvalPoint2),"glEvalPoint2");
    _driver.call(&_driver.glEvalPoint2)(i, j);
  }

  static void REGAL_CALL glFeedbackBuffer(GLsizei size, GLenum type, GLfloat *buffer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFeedbackBuffer),reinterpret_cast<void (*)()>(glFeedbackBuffer),"glFeedbackBuffer");
    _driver.call(&_driver.glFeedbackBuffer)(size, type, buffer);
  }

  static void REGAL_CALL glFinish(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFinish),reinterpret_cast<void (*)()>(glFinish),"glFinish");
    _driver.call(&_driver.glFinish)();
  }

  static void REGAL_CALL glFlush(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFlush),reinterpret_cast<void (*)()>(glFlush),"glFlush");
    _driver.call(&_driver.glFlush)();
  }

  static void REGAL_CALL glFogf(GLenum pname, GLfloat param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFogf),reinterpret_cast<void (*)()>(glFogf),"glFogf");
    _driver.call(&_driver.glFogf)(pname, param);
  }

  static void REGAL_CALL glFogfv(GLenum pname, const GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFogfv),reinterpret_cast<void (*)()>(glFogfv),"glFogfv");
    _driver.call(&_driver.glFogfv)(pname, params);
  }

  static void REGAL_CALL glFogi(GLenum pname, GLint param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFogi),reinterpret_cast<void (*)()>(glFogi),"glFogi");
    _driver.call(&_driver.glFogi)(pname, param);
  }

  static void REGAL_CALL glFogiv(GLenum pname, const GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFogiv),reinterpret_cast<void (*)()>(glFogiv),"glFogiv");
    _driver.call(&_driver.glFogiv)(pname, params);
  }

  static void REGAL_CALL glFrontFace(GLenum mode)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFrontFace),reinterpret_cast<void (*)()>(glFrontFace),"glFrontFace");
    _driver.call(&_driver.glFrontFace)(mode);
  }

  static void REGAL_CALL glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFrustum),reinterpret_cast<void (*)()>(glFrustum),"glFrustum");
    _driver.call(&_driver.glFrustum)(left, right, bottom, top, zNear, zFar);
  }

  static GLuint REGAL_CALL glGenLists(GLsizei range)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGenLists),reinterpret_cast<void (*)()>(glGenLists),"glGenLists");
    return _driver.call(&_driver.glGenLists)(range);
  }

  static void REGAL_CALL glGetBooleanv(GLenum pname, GLboolean *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetBooleanv),reinterpret_cast<void (*)()>(glGetBooleanv),"glGetBooleanv");
    _driver.call(&_driver.glGetBooleanv)(pname, params);
  }

  static void REGAL_CALL glGetClipPlane(GLenum plane, GLdouble *equation)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetClipPlane),reinterpret_cast<void (*)()>(glGetClipPlane),"glGetClipPlane");
    _driver.call(&_driver.glGetClipPlane)(plane, equation);
  }

  static void REGAL_CALL glGetDoublev(GLenum pname, GLdouble *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetDoublev),reinterpret_cast<void (*)()>(glGetDoublev),"glGetDoublev");
    _driver.call(&_driver.glGetDoublev)(pname, params);
  }

  static GLenum REGAL_CALL glGetError(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetError),reinterpret_cast<void (*)()>(glGetError),"glGetError");
    return _driver.call(&_driver.glGetError)();
  }

  static void REGAL_CALL glGetFloatv(GLenum pname, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetFloatv),reinterpret_cast<void (*)()>(glGetFloatv),"glGetFloatv");
    _driver.call(&_driver.glGetFloatv)(pname, params);
  }

  static void REGAL_CALL glGetIntegerv(GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetIntegerv),reinterpret_cast<void (*)()>(glGetIntegerv),"glGetIntegerv");
    _driver.call(&_driver.glGetIntegerv)(pname, params);
  }

  static void REGAL_CALL glGetLightfv(GLenum light, GLenum pname, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetLightfv),reinterpret_cast<void (*)()>(glGetLightfv),"glGetLightfv");
    _driver.call(&_driver.glGetLightfv)(light, pname, params);
  }

  static void REGAL_CALL glGetLightiv(GLenum light, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetLightiv),reinterpret_cast<void (*)()>(glGetLightiv),"glGetLightiv");
    _driver.call(&_driver.glGetLightiv)(light, pname, params);
  }

  static void REGAL_CALL glGetMapdv(GLenum target, GLenum query, GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetMapdv),reinterpret_cast<void (*)()>(glGetMapdv),"glGetMapdv");
    _driver.call(&_driver.glGetMapdv)(target, query, v);
  }

  static void REGAL_CALL glGetMapfv(GLenum target, GLenum query, GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetMapfv),reinterpret_cast<void (*)()>(glGetMapfv),"glGetMapfv");
    _driver.call(&_driver.glGetMapfv)(target, query, v);
  }

  static void REGAL_CALL glGetMapiv(GLenum target, GLenum query, GLint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetMapiv),reinterpret_cast<void (*)()>(glGetMapiv),"glGetMapiv");
    _driver.call(&_driver.glGetMapiv)(target, query, v);
  }

  static void REGAL_CALL glGetMaterialfv(GLenum face, GLenum pname, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetMaterialfv),reinterpret_cast<void (*)()>(glGetMaterialfv),"glGetMaterialfv");
    _driver.call(&_driver.glGetMaterialfv)(face, pname, params);
  }

  static void REGAL_CALL glGetMaterialiv(GLenum face, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetMaterialiv),reinterpret_cast<void (*)()>(glGetMaterialiv),"glGetMaterialiv");
    _driver.call(&_driver.glGetMaterialiv)(face, pname, params);
  }

  static void REGAL_CALL glGetPixelMapfv(GLenum map, GLfloat *values)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetPixelMapfv),reinterpret_cast<void (*)()>(glGetPixelMapfv),"glGetPixelMapfv");
    _driver.call(&_driver.glGetPixelMapfv)(map, values);
  }

  static void REGAL_CALL glGetPixelMapuiv(GLenum map, GLuint *values)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetPixelMapuiv),reinterpret_cast<void (*)()>(glGetPixelMapuiv),"glGetPixelMapuiv");
    _driver.call(&_driver.glGetPixelMapuiv)(map, values);
  }

  static void REGAL_CALL glGetPixelMapusv(GLenum map, GLushort *values)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetPixelMapusv),reinterpret_cast<void (*)()>(glGetPixelMapusv),"glGetPixelMapusv");
    _driver.call(&_driver.glGetPixelMapusv)(map, values);
  }

  static void REGAL_CALL glGetPolygonStipple(GLubyte *mask)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetPolygonStipple),reinterpret_cast<void (*)()>(glGetPolygonStipple),"glGetPolygonStipple");
    _driver.call(&_driver.glGetPolygonStipple)(mask);
  }

  static const GLubyte *REGAL_CALL glGetString(GLenum name)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetString),reinterpret_cast<void (*)()>(glGetString),"glGetString");
    return _driver.call(&_driver.glGetString)(name);
  }

  static void REGAL_CALL glGetTexEnvfv(GLenum target, GLenum pname, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetTexEnvfv),reinterpret_cast<void (*)()>(glGetTexEnvfv),"glGetTexEnvfv");
    _driver.call(&_driver.glGetTexEnvfv)(target, pname, params);
  }

  static void REGAL_CALL glGetTexEnviv(GLenum target, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetTexEnviv),reinterpret_cast<void (*)()>(glGetTexEnviv),"glGetTexEnviv");
    _driver.call(&_driver.glGetTexEnviv)(target, pname, params);
  }

  static void REGAL_CALL glGetTexGendv(GLenum coord, GLenum pname, GLdouble *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetTexGendv),reinterpret_cast<void (*)()>(glGetTexGendv),"glGetTexGendv");
    _driver.call(&_driver.glGetTexGendv)(coord, pname, params);
  }

  static void REGAL_CALL glGetTexGenfv(GLenum coord, GLenum pname, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetTexGenfv),reinterpret_cast<void (*)()>(glGetTexGenfv),"glGetTexGenfv");
    _driver.call(&_driver.glGetTexGenfv)(coord, pname, params);
  }

  static void REGAL_CALL glGetTexGeniv(GLenum coord, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetTexGeniv),reinterpret_cast<void (*)()>(glGetTexGeniv),"glGetTexGeniv");
    _driver.call(&_driver.glGetTexGeniv)(coord, pname, params);
  }

  static void REGAL_CALL glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetTexImage),reinterpret_cast<void (*)()>(glGetTexImage),"glGetTexImage");
    _driver.call(&_driver.glGetTexImage)(target, level, format, type, pixels);
  }

  static void REGAL_CALL glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetTexLevelParameterfv),reinterpret_cast<void (*)()>(glGetTexLevelParameterfv),"glGetTexLevelParameterfv");
    _driver.call(&_driver.glGetTexLevelParameterfv)(target, level, pname, params);
  }

  static void REGAL_CALL glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetTexLevelParameteriv),reinterpret_cast<void (*)()>(glGetTexLevelParameteriv),"glGetTexLevelParameteriv");
    _driver.call(&_driver.glGetTexLevelParameteriv)(target, level, pname, params);
  }

  static void REGAL_CALL glGetTexParameterfv(GLenum target, GLenum pname, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetTexParameterfv),reinterpret_cast<void (*)()>(glGetTexParameterfv),"glGetTexParameterfv");
    _driver.call(&_driver.glGetTexParameterfv)(target, pname, params);
  }

  static void REGAL_CALL glGetTexParameteriv(GLenum target, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetTexParameteriv),reinterpret_cast<void (*)()>(glGetTexParameteriv),"glGetTexParameteriv");
    _driver.call(&_driver.glGetTexParameteriv)(target, pname, params);
  }

  static void REGAL_CALL glHint(GLenum target, GLenum mode)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glHint),reinterpret_cast<void (*)()>(glHint),"glHint");
    _driver.call(&_driver.glHint)(target, mode);
  }

  static void REGAL_CALL glIndexMask(GLuint mask)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIndexMask),reinterpret_cast<void (*)()>(glIndexMask),"glIndexMask");
    _driver.call(&_driver.glIndexMask)(mask);
  }

  static void REGAL_CALL glIndexd(GLdouble c)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIndexd),reinterpret_cast<void (*)()>(glIndexd),"glIndexd");
    _driver.call(&_driver.glIndexd)(c);
  }

  static void REGAL_CALL glIndexdv(const GLdouble *c)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIndexdv),reinterpret_cast<void (*)()>(glIndexdv),"glIndexdv");
    _driver.call(&_driver.glIndexdv)(c);
  }

  static void REGAL_CALL glIndexf(GLfloat c)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIndexf),reinterpret_cast<void (*)()>(glIndexf),"glIndexf");
    _driver.call(&_driver.glIndexf)(c);
  }

  static void REGAL_CALL glIndexfv(const GLfloat *c)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIndexfv),reinterpret_cast<void (*)()>(glIndexfv),"glIndexfv");
    _driver.call(&_driver.glIndexfv)(c);
  }

  static void REGAL_CALL glIndexi(GLint c)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIndexi),reinterpret_cast<void (*)()>(glIndexi),"glIndexi");
    _driver.call(&_driver.glIndexi)(c);
  }

  static void REGAL_CALL glIndexiv(const GLint *c)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIndexiv),reinterpret_cast<void (*)()>(glIndexiv),"glIndexiv");
    _driver.call(&_driver.glIndexiv)(c);
  }

  static void REGAL_CALL glIndexs(GLshort c)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIndexs),reinterpret_cast<void (*)()>(glIndexs),"glIndexs");
    _driver.call(&_driver.glIndexs)(c);
  }

  static void REGAL_CALL glIndexsv(const GLshort *c)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIndexsv),reinterpret_cast<void (*)()>(glIndexsv),"glIndexsv");
    _driver.call(&_driver.glIndexsv)(c);
  }

  static void REGAL_CALL glInitNames(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glInitNames),reinterpret_cast<void (*)()>(glInitNames),"glInitNames");
    _driver.call(&_driver.glInitNames)();
  }

  static GLboolean REGAL_CALL glIsEnabled(GLenum cap)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIsEnabled),reinterpret_cast<void (*)()>(glIsEnabled),"glIsEnabled");
    return _driver.call(&_driver.glIsEnabled)(cap);
  }

  static GLboolean REGAL_CALL glIsList(GLuint list)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIsList),reinterpret_cast<void (*)()>(glIsList),"glIsList");
    return _driver.call(&_driver.glIsList)(list);
  }

  static void REGAL_CALL glLightModelf(GLenum pname, GLfloat param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glLightModelf),reinterpret_cast<void (*)()>(glLightModelf),"glLightModelf");
    _driver.call(&_driver.glLightModelf)(pname, param);
  }

  static void REGAL_CALL glLightModelfv(GLenum pname, const GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glLightModelfv),reinterpret_cast<void (*)()>(glLightModelfv),"glLightModelfv");
    _driver.call(&_driver.glLightModelfv)(pname, params);
  }

  static void REGAL_CALL glLightModeli(GLenum pname, GLint param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glLightModeli),reinterpret_cast<void (*)()>(glLightModeli),"glLightModeli");
    _driver.call(&_driver.glLightModeli)(pname, param);
  }

  static void REGAL_CALL glLightModeliv(GLenum pname, const GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glLightModeliv),reinterpret_cast<void (*)()>(glLightModeliv),"glLightModeliv");
    _driver.call(&_driver.glLightModeliv)(pname, params);
  }

  static void REGAL_CALL glLightf(GLenum light, GLenum pname, GLfloat param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glLightf),reinterpret_cast<void (*)()>(glLightf),"glLightf");
    _driver.call(&_driver.glLightf)(light, pname, param);
  }

  static void REGAL_CALL glLightfv(GLenum light, GLenum pname, const GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glLightfv),reinterpret_cast<void (*)()>(glLightfv),"glLightfv");
    _driver.call(&_driver.glLightfv)(light, pname, params);
  }

  static void REGAL_CALL glLighti(GLenum light, GLenum pname, GLint param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glLighti),reinterpret_cast<void (*)()>(glLighti),"glLighti");
    _driver.call(&_driver.glLighti)(light, pname, param);
  }

  static void REGAL_CALL glLightiv(GLenum light, GLenum pname, const GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glLightiv),reinterpret_cast<void (*)()>(glLightiv),"glLightiv");
    _driver.call(&_driver.glLightiv)(light, pname, params);
  }

  static void REGAL_CALL glLineStipple(GLint factor, GLushort pattern)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glLineStipple),reinterpret_cast<void (*)()>(glLineStipple),"glLineStipple");
    _driver.call(&_driver.glLineStipple)(factor, pattern);
  }

  static void REGAL_CALL glLineWidth(GLfloat width)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glLineWidth),reinterpret_cast<void (*)()>(glLineWidth),"glLineWidth");
    _driver.call(&_driver.glLineWidth)(width);
  }

  static void REGAL_CALL glListBase(GLuint base)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glListBase),reinterpret_cast<void (*)()>(glListBase),"glListBase");
    _driver.call(&_driver.glListBase)(base);
  }

  static void REGAL_CALL glLoadIdentity(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glLoadIdentity),reinterpret_cast<void (*)()>(glLoadIdentity),"glLoadIdentity");
    _driver.call(&_driver.glLoadIdentity)();
  }

  static void REGAL_CALL glLoadMatrixd(const GLdouble *m)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glLoadMatrixd),reinterpret_cast<void (*)()>(glLoadMatrixd),"glLoadMatrixd");
    _driver.call(&_driver.glLoadMatrixd)(m);
  }

  static void REGAL_CALL glLoadMatrixf(const GLfloat *m)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glLoadMatrixf),reinterpret_cast<void (*)()>(glLoadMatrixf),"glLoadMatrixf");
    _driver.call(&_driver.glLoadMatrixf)(m);
  }

  static void REGAL_CALL glLoadName(GLuint name)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glLoadName),reinterpret_cast<void (*)()>(glLoadName),"glLoadName");
    _driver.call(&_driver.glLoadName)(name);
  }

  static void REGAL_CALL glLogicOp(GLenum opcode)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glLogicOp),reinterpret_cast<void (*)()>(glLogicOp),"glLogicOp");
    _driver.call(&_driver.glLogicOp)(opcode);
  }

  static void REGAL_CALL glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMap1d),reinterpret_cast<void (*)()>(glMap1d),"glMap1d");
    _driver.call(&_driver.glMap1d)(target, u1, u2, stride, order, points);
  }

  static void REGAL_CALL glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMap1f),reinterpret_cast<void (*)()>(glMap1f),"glMap1f");
    _driver.call(&_driver.glMap1f)(target, u1, u2, stride, order, points);
  }

  static void REGAL_CALL glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMap2d),reinterpret_cast<void (*)()>(glMap2d),"glMap2d");
    _driver.call(&_driver.glMap2d)(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
  }

  static void REGAL_CALL glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMap2f),reinterpret_cast<void (*)()>(glMap2f),"glMap2f");
    _driver.call(&_driver.glMap2f)(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
  }

  static void REGAL_CALL glMapGrid1d(GLint un, GLdouble u1, GLdouble u2)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMapGrid1d),reinterpret_cast<void (*)()>(glMapGrid1d),"glMapGrid1d");
    _driver.call(&_driver.glMapGrid1d)(un, u1, u2);
  }

  static void REGAL_CALL glMapGrid1f(GLint un, GLfloat u1, GLfloat u2)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMapGrid1f),reinterpret_cast<void (*)()>(glMapGrid1f),"glMapGrid1f");
    _driver.call(&_driver.glMapGrid1f)(un, u1, u2);
  }

  static void REGAL_CALL glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMapGrid2d),reinterpret_cast<void (*)()>(glMapGrid2d),"glMapGrid2d");
    _driver.call(&_driver.glMapGrid2d)(un, u1, u2, vn, v1, v2);
  }

  static void REGAL_CALL glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMapGrid2f),reinterpret_cast<void (*)()>(glMapGrid2f),"glMapGrid2f");
    _driver.call(&_driver.glMapGrid2f)(un, u1, u2, vn, v1, v2);
  }

  static void REGAL_CALL glMaterialf(GLenum face, GLenum pname, GLfloat param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMaterialf),reinterpret_cast<void (*)()>(glMaterialf),"glMaterialf");
    _driver.call(&_driver.glMaterialf)(face, pname, param);
  }

  static void REGAL_CALL glMaterialfv(GLenum face, GLenum pname, const GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMaterialfv),reinterpret_cast<void (*)()>(glMaterialfv),"glMaterialfv");
    _driver.call(&_driver.glMaterialfv)(face, pname, params);
  }

  static void REGAL_CALL glMateriali(GLenum face, GLenum pname, GLint param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMateriali),reinterpret_cast<void (*)()>(glMateriali),"glMateriali");
    _driver.call(&_driver.glMateriali)(face, pname, param);
  }

  static void REGAL_CALL glMaterialiv(GLenum face, GLenum pname, const GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMaterialiv),reinterpret_cast<void (*)()>(glMaterialiv),"glMaterialiv");
    _driver.call(&_driver.glMaterialiv)(face, pname, params);
  }

  static void REGAL_CALL glMatrixMode(GLenum mode)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMatrixMode),reinterpret_cast<void (*)()>(glMatrixMode),"glMatrixMode");
    _driver.call(&_driver.glMatrixMode)(mode);
  }

  static void REGAL_CALL glMultMatrixd(const GLdouble *m)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultMatrixd),reinterpret_cast<void (*)()>(glMultMatrixd),"glMultMatrixd");
    _driver.call(&_driver.glMultMatrixd)(m);
  }

  static void REGAL_CALL glMultMatrixf(const GLfloat *m)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultMatrixf),reinterpret_cast<void (*)()>(glMultMatrixf),"glMultMatrixf");
    _driver.call(&_driver.glMultMatrixf)(m);
  }

  static void REGAL_CALL glNewList(GLuint list, GLenum mode)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNewList),reinterpret_cast<void (*)()>(glNewList),"glNewList");
    _driver.call(&_driver.glNewList)(list, mode);
  }

  static void REGAL_CALL glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNormal3b),reinterpret_cast<void (*)()>(glNormal3b),"glNormal3b");
    _driver.call(&_driver.glNormal3b)(nx, ny, nz);
  }

  static void REGAL_CALL glNormal3bv(const GLbyte *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNormal3bv),reinterpret_cast<void (*)()>(glNormal3bv),"glNormal3bv");
    _driver.call(&_driver.glNormal3bv)(v);
  }

  static void REGAL_CALL glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNormal3d),reinterpret_cast<void (*)()>(glNormal3d),"glNormal3d");
    _driver.call(&_driver.glNormal3d)(nx, ny, nz);
  }

  static void REGAL_CALL glNormal3dv(const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNormal3dv),reinterpret_cast<void (*)()>(glNormal3dv),"glNormal3dv");
    _driver.call(&_driver.glNormal3dv)(v);
  }

  static void REGAL_CALL glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNormal3f),reinterpret_cast<void (*)()>(glNormal3f),"glNormal3f");
    _driver.call(&_driver.glNormal3f)(nx, ny, nz);
  }

  static void REGAL_CALL glNormal3fv(const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNormal3fv),reinterpret_cast<void (*)()>(glNormal3fv),"glNormal3fv");
    _driver.call(&_driver.glNormal3fv)(v);
  }

  static void REGAL_CALL glNormal3i(GLint nx, GLint ny, GLint nz)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNormal3i),reinterpret_cast<void (*)()>(glNormal3i),"glNormal3i");
    _driver.call(&_driver.glNormal3i)(nx, ny, nz);
  }

  static void REGAL_CALL glNormal3iv(const GLint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNormal3iv),reinterpret_cast<void (*)()>(glNormal3iv),"glNormal3iv");
    _driver.call(&_driver.glNormal3iv)(v);
  }

  static void REGAL_CALL glNormal3s(GLshort nx, GLshort ny, GLshort nz)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNormal3s),reinterpret_cast<void (*)()>(glNormal3s),"glNormal3s");
    _driver.call(&_driver.glNormal3s)(nx, ny, nz);
  }

  static void REGAL_CALL glNormal3sv(const GLshort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNormal3sv),reinterpret_cast<void (*)()>(glNormal3sv),"glNormal3sv");
    _driver.call(&_driver.glNormal3sv)(v);
  }

  static void REGAL_CALL glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glOrtho),reinterpret_cast<void (*)()>(glOrtho),"glOrtho");
    _driver.call(&_driver.glOrtho)(left, right, bottom, top, zNear, zFar);
  }

  static void REGAL_CALL glPassThrough(GLfloat token)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPassThrough),reinterpret_cast<void (*)()>(glPassThrough),"glPassThrough");
    _driver.call(&_driver.glPassThrough)(token);
  }

  static void REGAL_CALL glPixelMapfv(GLenum map, GLsizei mapsize, const GLfloat *values)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPixelMapfv),reinterpret_cast<void (*)()>(glPixelMapfv),"glPixelMapfv");
    _driver.call(&_driver.glPixelMapfv)(map, mapsize, values);
  }

  static void REGAL_CALL glPixelMapuiv(GLenum map, GLsizei mapsize, const GLuint *values)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPixelMapuiv),reinterpret_cast<void (*)()>(glPixelMapuiv),"glPixelMapuiv");
    _driver.call(&_driver.glPixelMapuiv)(map, mapsize, values);
  }

  static void REGAL_CALL glPixelMapusv(GLenum map, GLsizei mapsize, const GLushort *values)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPixelMapusv),reinterpret_cast<void (*)()>(glPixelMapusv),"glPixelMapusv");
    _driver.call(&_driver.glPixelMapusv)(map, mapsize, values);
  }

  static void REGAL_CALL glPixelStoref(GLenum pname, GLfloat param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPixelStoref),reinterpret_cast<void (*)()>(glPixelStoref),"glPixelStoref");
    _driver.call(&_driver.glPixelStoref)(pname, param);
  }

  static void REGAL_CALL glPixelStorei(GLenum pname, GLint param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPixelStorei),reinterpret_cast<void (*)()>(glPixelStorei),"glPixelStorei");
    _driver.call(&_driver.glPixelStorei)(pname, param);
  }

  static void REGAL_CALL glPixelTransferf(GLenum pname, GLfloat param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPixelTransferf),reinterpret_cast<void (*)()>(glPixelTransferf),"glPixelTransferf");
    _driver.call(&_driver.glPixelTransferf)(pname, param);
  }

  static void REGAL_CALL glPixelTransferi(GLenum pname, GLint param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPixelTransferi),reinterpret_cast<void (*)()>(glPixelTransferi),"glPixelTransferi");
    _driver.call(&_driver.glPixelTransferi)(pname, param);
  }

  static void REGAL_CALL glPixelZoom(GLfloat xfactor, GLfloat yfactor)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPixelZoom),reinterpret_cast<void (*)()>(glPixelZoom),"glPixelZoom");
    _driver.call(&_driver.glPixelZoom)(xfactor, yfactor);
  }

  static void REGAL_CALL glPointSize(GLfloat size)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPointSize),reinterpret_cast<void (*)()>(glPointSize),"glPointSize");
    _driver.call(&_driver.glPointSize)(size);
  }

  static void REGAL_CALL glPolygonMode(GLenum face, GLenum mode)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPolygonMode),reinterpret_cast<void (*)()>(glPolygonMode),"glPolygonMode");
    _driver.call(&_driver.glPolygonMode)(face, mode);
  }

  static void REGAL_CALL glPolygonStipple(const GLubyte *mask)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPolygonStipple),reinterpret_cast<void (*)()>(glPolygonStipple),"glPolygonStipple");
    _driver.call(&_driver.glPolygonStipple)(mask);
  }

  static void REGAL_CALL glPopAttrib(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPopAttrib),reinterpret_cast<void (*)()>(glPopAttrib),"glPopAttrib");
    _driver.call(&_driver.glPopAttrib)();
  }

  static void REGAL_CALL glPopMatrix(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPopMatrix),reinterpret_cast<void (*)()>(glPopMatrix),"glPopMatrix");
    _driver.call(&_driver.glPopMatrix)();
  }

  static void REGAL_CALL glPopName(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPopName),reinterpret_cast<void (*)()>(glPopName),"glPopName");
    _driver.call(&_driver.glPopName)();
  }

  static void REGAL_CALL glPushAttrib(GLbitfield mask)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPushAttrib),reinterpret_cast<void (*)()>(glPushAttrib),"glPushAttrib");
    _driver.call(&_driver.glPushAttrib)(mask);
  }

  static void REGAL_CALL glPushMatrix(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPushMatrix),reinterpret_cast<void (*)()>(glPushMatrix),"glPushMatrix");
    _driver.call(&_driver.glPushMatrix)();
  }

  static void REGAL_CALL glPushName(GLuint name)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPushName),reinterpret_cast<void (*)()>(glPushName),"glPushName");
    _driver.call(&_driver.glPushName)(name);
  }

  static void REGAL_CALL glRasterPos2d(GLdouble x, GLdouble y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glRasterPos2d),reinterpret_cast<void (*)()>(glRasterPos2d),"glRasterPos2d");
    _driver.call(&_driver.glRasterPos2d)(x, y);
  }

  static void REGAL_CALL glRasterPos2dv(const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glRasterPos2dv),reinterpret_cast<void (*)()>(glRasterPos2dv),"glRasterPos2dv");
    _driver.call(&_driver.glRasterPos2dv)(v);
  }

  static void REGAL_CALL glRasterPos2f(GLfloat x, GLfloat y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glRasterPos2f),reinterpret_cast<void (*)()>(glRasterPos2f),"glRasterPos2f");
    _driver.call(&_driver.glRasterPos2f)(x, y);
  }

  static void REGAL_CALL glRasterPos2fv(const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glRasterPos2fv),reinterpret_cast<void (*)()>(glRasterPos2fv),"glRasterPos2fv");
    _driver.call(&_driver.glRasterPos2fv)(v);
  }

  static void REGAL_CALL glRasterPos2i(GLint x, GLint y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glRasterPos2i),reinterpret_cast<void (*)()>(glRasterPos2i),"glRasterPos2i");
    _driver.call(&_driver.glRasterPos2i)(x, y);
  }

  static void REGAL_CALL glRasterPos2iv(const GLint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glRasterPos2iv),reinterpret_cast<void (*)()>(glRasterPos2iv),"glRasterPos2iv");
    _driver.call(&_driver.glRasterPos2iv)(v);
  }

  static void REGAL_CALL glRasterPos2s(GLshort x, GLshort y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glRasterPos2s),reinterpret_cast<void (*)()>(glRasterPos2s),"glRasterPos2s");
    _driver.call(&_driver.glRasterPos2s)(x, y);
  }

  static void REGAL_CALL glRasterPos2sv(const GLshort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glRasterPos2sv),reinterpret_cast<void (*)()>(glRasterPos2sv),"glRasterPos2sv");
    _driver.call(&_driver.glRasterPos2sv)(v);
  }

  static void REGAL_CALL glRasterPos3d(GLdouble x, GLdouble y, GLdouble z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glRasterPos3d),reinterpret_cast<void (*)()>(glRasterPos3d),"glRasterPos3d");
    _driver.call(&_driver.glRasterPos3d)(x, y, z);
  }

  static void REGAL_CALL glRasterPos3dv(const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glRasterPos3dv),reinterpret_cast<void (*)()>(glRasterPos3dv),"glRasterPos3dv");
    _driver.call(&_driver.glRasterPos3dv)(v);
  }

  static void REGAL_CALL glRasterPos3f(GLfloat x, GLfloat y, GLfloat z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glRasterPos3f),reinterpret_cast<void (*)()>(glRasterPos3f),"glRasterPos3f");
    _driver.call(&_driver.glRasterPos3f)(x, y, z);
  }

  static void REGAL_CALL glRasterPos3fv(const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glRasterPos3fv),reinterpret_cast<void (*)()>(glRasterPos3fv),"glRasterPos3fv");
    _driver.call(&_driver.glRasterPos3fv)(v);
  }

  static void REGAL_CALL glRasterPos3i(GLint x, GLint y, GLint z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glRasterPos3i),reinterpret_cast<void (*)()>(glRasterPos3i),"glRasterPos3i");
    _driver.call(&_driver.glRasterPos3i)(x, y, z);
  }

  static void REGAL_CALL glRasterPos3iv(const GLint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glRasterPos3iv),reinterpret_cast<void (*)()>(glRasterPos3iv),"glRasterPos3iv");
    _driver.call(&_driver.glRasterPos3iv)(v);
  }

  static void REGAL_CALL glRasterPos3s(GLshort x, GLshort y, GLshort z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glRasterPos3s),reinterpret_cast<void (*)()>(glRasterPos3s),"glRasterPos3s");
    _driver.call(&_driver.glRasterPos3s)(x, y, z);
  }

  static void REGAL_CALL glRasterPos3sv(const GLshort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glRasterPos3sv),reinterpret_cast<void (*)()>(glRasterPos3sv),"glRasterPos3sv");
    _driver.call(&_driver.glRasterPos3sv)(v);
  }

  static void REGAL_CALL glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glRasterPos4d),reinterpret_cast<void (*)()>(glRasterPos4d),"glRasterPos4d");
    _driver.call(&_driver.glRasterPos4d)(x, y, z, w);
  }

  static void REGAL_CALL glRasterPos4dv(const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glRasterPos4dv),reinterpret_cast<void (*)()>(glRasterPos4dv),"glRasterPos4dv");
    _driver.call(&_driver.glRasterPos4dv)(v);
  }

  static void REGAL_CALL glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glRasterPos4f),reinterpret_cast<void (*)()>(glRasterPos4f),"glRasterPos4f");
    _driver.call(&_driver.glRasterPos4f)(x, y, z, w);
  }

  static void REGAL_CALL glRasterPos4fv(const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glRasterPos4fv),reinterpret_cast<void (*)()>(glRasterPos4fv),"glRasterPos4fv");
    _driver.call(&_driver.glRasterPos4fv)(v);
  }

  static void REGAL_CALL glRasterPos4i(GLint x, GLint y, GLint z, GLint w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glRasterPos4i),reinterpret_cast<void (*)()>(glRasterPos4i),"glRasterPos4i");
    _driver.call(&_driver.glRasterPos4i)(x, y, z, w);
  }

  static void REGAL_CALL glRasterPos4iv(const GLint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glRasterPos4iv),reinterpret_cast<void (*)()>(glRasterPos4iv),"glRasterPos4iv");
    _driver.call(&_driver.glRasterPos4iv)(v);
  }

  static void REGAL_CALL glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glRasterPos4s),reinterpret_cast<void (*)()>(glRasterPos4s),"glRasterPos4s");
    _driver.call(&_driver.glRasterPos4s)(x, y, z, w);
  }

  static void REGAL_CALL glRasterPos4sv(const GLshort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glRasterPos4sv),reinterpret_cast<void (*)()>(glRasterPos4sv),"glRasterPos4sv");
    _driver.call(&_driver.glRasterPos4sv)(v);
  }

  static void REGAL_CALL glReadBuffer(GLenum mode)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glReadBuffer),reinterpret_cast<void (*)()>(glReadBuffer),"glReadBuffer");
    _driver.call(&_driver.glReadBuffer)(mode);
  }

  static void REGAL_CALL glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glReadPixels),reinterpret_cast<void (*)()>(glReadPixels),"glReadPixels");
    _driver.call(&_driver.glReadPixels)(x, y, width, height, format, type, pixels);
  }

  static void REGAL_CALL glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glRectd),reinterpret_cast<void (*)()>(glRectd),"glRectd");
    _driver.call(&_driver.glRectd)(x1, y1, x2, y2);
  }

  static void REGAL_CALL glRectdv(const GLdouble *v1, const GLdouble *v2)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glRectdv),reinterpret_cast<void (*)()>(glRectdv),"glRectdv");
    _driver.call(&_driver.glRectdv)(v1, v2);
  }

  static void REGAL_CALL glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glRectf),reinterpret_cast<void (*)()>(glRectf),"glRectf");
    _driver.call(&_driver.glRectf)(x1, y1, x2, y2);
  }

  static void REGAL_CALL glRectfv(const GLfloat *v1, const GLfloat *v2)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glRectfv),reinterpret_cast<void (*)()>(glRectfv),"glRectfv");
    _driver.call(&_driver.glRectfv)(v1, v2);
  }

  static void REGAL_CALL glRecti(GLint x1, GLint y1, GLint x2, GLint y2)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glRecti),reinterpret_cast<void (*)()>(glRecti),"glRecti");
    _driver.call(&_driver.glRecti)(x1, y1, x2, y2);
  }

  static void REGAL_CALL glRectiv(const GLint *v1, const GLint *v2)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glRectiv),reinterpret_cast<void (*)()>(glRectiv),"glRectiv");
    _driver.call(&_driver.glRectiv)(v1, v2);
  }

  static void REGAL_CALL glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glRects),reinterpret_cast<void (*)()>(glRects),"glRects");
    _driver.call(&_driver.glRects)(x1, y1, x2, y2);
  }

  static void REGAL_CALL glRectsv(const GLshort *v1, const GLshort *v2)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glRectsv),reinterpret_cast<void (*)()>(glRectsv),"glRectsv");
    _driver.call(&_driver.glRectsv)(v1, v2);
  }

  static GLint REGAL_CALL glRenderMode(GLenum mode)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glRenderMode),reinterpret_cast<void (*)()>(glRenderMode),"glRenderMode");
    return _driver.call(&_driver.glRenderMode)(mode);
  }

  static void REGAL_CALL glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glRotated),reinterpret_cast<void (*)()>(glRotated),"glRotated");
    _driver.call(&_driver.glRotated)(angle, x, y, z);
  }

  static void REGAL_CALL glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glRotatef),reinterpret_cast<void (*)()>(glRotatef),"glRotatef");
    _driver.call(&_driver.glRotatef)(angle, x, y, z);
  }

  static void REGAL_CALL glScaled(GLdouble x, GLdouble y, GLdouble z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glScaled),reinterpret_cast<void (*)()>(glScaled),"glScaled");
    _driver.call(&_driver.glScaled)(x, y, z);
  }

  static void REGAL_CALL glScalef(GLfloat x, GLfloat y, GLfloat z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glScalef),reinterpret_cast<void (*)()>(glScalef),"glScalef");
    _driver.call(&_driver.glScalef)(x, y, z);
  }

  static void REGAL_CALL glScissor(GLint x, GLint y, GLsizei width, GLsizei height)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glScissor),reinterpret_cast<void (*)()>(glScissor),"glScissor");
    _driver.call(&_driver.glScissor)(x, y, width, height);
  }

  static void REGAL_CALL glSelectBuffer(GLsizei size, GLuint *buffer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSelectBuffer),reinterpret_cast<void (*)()>(glSelectBuffer),"glSelectBuffer");
    _driver.call(&_driver.glSelectBuffer)(size, buffer);
  }

  static void REGAL_CALL glShadeModel(GLenum mode)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glShadeModel),reinterpret_cast<void (*)()>(glShadeModel),"glShadeModel");
    _driver.call(&_driver.glShadeModel)(mode);
  }

  static void REGAL_CALL glStencilFunc(GLenum func, GLint ref, GLuint mask)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glStencilFunc),reinterpret_cast<void (*)()>(glStencilFunc),"glStencilFunc");
    _driver.call(&_driver.glStencilFunc)(func, ref, mask);
  }

  static void REGAL_CALL glStencilMask(GLuint mask)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glStencilMask),reinterpret_cast<void (*)()>(glStencilMask),"glStencilMask");
    _driver.call(&_driver.glStencilMask)(mask);
  }

  static void REGAL_CALL glStencilOp(GLenum fail, GLenum zfail, GLenum zpass)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glStencilOp),reinterpret_cast<void (*)()>(glStencilOp),"glStencilOp");
    _driver.call(&_driver.glStencilOp)(fail, zfail, zpass);
  }

  static void REGAL_CALL glTexCoord1d(GLdouble s)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord1d),reinterpret_cast<void (*)()>(glTexCoord1d),"glTexCoord1d");
    _driver.call(&_driver.glTexCoord1d)(s);
  }

  static void REGAL_CALL glTexCoord1dv(const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord1dv),reinterpret_cast<void (*)()>(glTexCoord1dv),"glTexCoord1dv");
    _driver.call(&_driver.glTexCoord1dv)(v);
  }

  static void REGAL_CALL glTexCoord1f(GLfloat s)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord1f),reinterpret_cast<void (*)()>(glTexCoord1f),"glTexCoord1f");
    _driver.call(&_driver.glTexCoord1f)(s);
  }

  static void REGAL_CALL glTexCoord1fv(const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord1fv),reinterpret_cast<void (*)()>(glTexCoord1fv),"glTexCoord1fv");
    _driver.call(&_driver.glTexCoord1fv)(v);
  }

  static void REGAL_CALL glTexCoord1i(GLint s)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord1i),reinterpret_cast<void (*)()>(glTexCoord1i),"glTexCoord1i");
    _driver.call(&_driver.glTexCoord1i)(s);
  }

  static void REGAL_CALL glTexCoord1iv(const GLint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord1iv),reinterpret_cast<void (*)()>(glTexCoord1iv),"glTexCoord1iv");
    _driver.call(&_driver.glTexCoord1iv)(v);
  }

  static void REGAL_CALL glTexCoord1s(GLshort s)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord1s),reinterpret_cast<void (*)()>(glTexCoord1s),"glTexCoord1s");
    _driver.call(&_driver.glTexCoord1s)(s);
  }

  static void REGAL_CALL glTexCoord1sv(const GLshort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord1sv),reinterpret_cast<void (*)()>(glTexCoord1sv),"glTexCoord1sv");
    _driver.call(&_driver.glTexCoord1sv)(v);
  }

  static void REGAL_CALL glTexCoord2d(GLdouble s, GLdouble t)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord2d),reinterpret_cast<void (*)()>(glTexCoord2d),"glTexCoord2d");
    _driver.call(&_driver.glTexCoord2d)(s, t);
  }

  static void REGAL_CALL glTexCoord2dv(const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord2dv),reinterpret_cast<void (*)()>(glTexCoord2dv),"glTexCoord2dv");
    _driver.call(&_driver.glTexCoord2dv)(v);
  }

  static void REGAL_CALL glTexCoord2f(GLfloat s, GLfloat t)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord2f),reinterpret_cast<void (*)()>(glTexCoord2f),"glTexCoord2f");
    _driver.call(&_driver.glTexCoord2f)(s, t);
  }

  static void REGAL_CALL glTexCoord2fv(const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord2fv),reinterpret_cast<void (*)()>(glTexCoord2fv),"glTexCoord2fv");
    _driver.call(&_driver.glTexCoord2fv)(v);
  }

  static void REGAL_CALL glTexCoord2i(GLint s, GLint t)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord2i),reinterpret_cast<void (*)()>(glTexCoord2i),"glTexCoord2i");
    _driver.call(&_driver.glTexCoord2i)(s, t);
  }

  static void REGAL_CALL glTexCoord2iv(const GLint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord2iv),reinterpret_cast<void (*)()>(glTexCoord2iv),"glTexCoord2iv");
    _driver.call(&_driver.glTexCoord2iv)(v);
  }

  static void REGAL_CALL glTexCoord2s(GLshort s, GLshort t)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord2s),reinterpret_cast<void (*)()>(glTexCoord2s),"glTexCoord2s");
    _driver.call(&_driver.glTexCoord2s)(s, t);
  }

  static void REGAL_CALL glTexCoord2sv(const GLshort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord2sv),reinterpret_cast<void (*)()>(glTexCoord2sv),"glTexCoord2sv");
    _driver.call(&_driver.glTexCoord2sv)(v);
  }

  static void REGAL_CALL glTexCoord3d(GLdouble s, GLdouble t, GLdouble r)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord3d),reinterpret_cast<void (*)()>(glTexCoord3d),"glTexCoord3d");
    _driver.call(&_driver.glTexCoord3d)(s, t, r);
  }

  static void REGAL_CALL glTexCoord3dv(const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord3dv),reinterpret_cast<void (*)()>(glTexCoord3dv),"glTexCoord3dv");
    _driver.call(&_driver.glTexCoord3dv)(v);
  }

  static void REGAL_CALL glTexCoord3f(GLfloat s, GLfloat t, GLfloat r)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord3f),reinterpret_cast<void (*)()>(glTexCoord3f),"glTexCoord3f");
    _driver.call(&_driver.glTexCoord3f)(s, t, r);
  }

  static void REGAL_CALL glTexCoord3fv(const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord3fv),reinterpret_cast<void (*)()>(glTexCoord3fv),"glTexCoord3fv");
    _driver.call(&_driver.glTexCoord3fv)(v);
  }

  static void REGAL_CALL glTexCoord3i(GLint s, GLint t, GLint r)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord3i),reinterpret_cast<void (*)()>(glTexCoord3i),"glTexCoord3i");
    _driver.call(&_driver.glTexCoord3i)(s, t, r);
  }

  static void REGAL_CALL glTexCoord3iv(const GLint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord3iv),reinterpret_cast<void (*)()>(glTexCoord3iv),"glTexCoord3iv");
    _driver.call(&_driver.glTexCoord3iv)(v);
  }

  static void REGAL_CALL glTexCoord3s(GLshort s, GLshort t, GLshort r)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord3s),reinterpret_cast<void (*)()>(glTexCoord3s),"glTexCoord3s");
    _driver.call(&_driver.glTexCoord3s)(s, t, r);
  }

  static void REGAL_CALL glTexCoord3sv(const GLshort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord3sv),reinterpret_cast<void (*)()>(glTexCoord3sv),"glTexCoord3sv");
    _driver.call(&_driver.glTexCoord3sv)(v);
  }

  static void REGAL_CALL glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord4d),reinterpret_cast<void (*)()>(glTexCoord4d),"glTexCoord4d");
    _driver.call(&_driver.glTexCoord4d)(s, t, r, q);
  }

  static void REGAL_CALL glTexCoord4dv(const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord4dv),reinterpret_cast<void (*)()>(glTexCoord4dv),"glTexCoord4dv");
    _driver.call(&_driver.glTexCoord4dv)(v);
  }

  static void REGAL_CALL glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord4f),reinterpret_cast<void (*)()>(glTexCoord4f),"glTexCoord4f");
    _driver.call(&_driver.glTexCoord4f)(s, t, r, q);
  }

  static void REGAL_CALL glTexCoord4fv(const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord4fv),reinterpret_cast<void (*)()>(glTexCoord4fv),"glTexCoord4fv");
    _driver.call(&_driver.glTexCoord4fv)(v);
  }

  static void REGAL_CALL glTexCoord4i(GLint s, GLint t, GLint r, GLint q)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord4i),reinterpret_cast<void (*)()>(glTexCoord4i),"glTexCoord4i");
    _driver.call(&_driver.glTexCoord4i)(s, t, r, q);
  }

  static void REGAL_CALL glTexCoord4iv(const GLint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord4iv),reinterpret_cast<void (*)()>(glTexCoord4iv),"glTexCoord4iv");
    _driver.call(&_driver.glTexCoord4iv)(v);
  }

  static void REGAL_CALL glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord4s),reinterpret_cast<void (*)()>(glTexCoord4s),"glTexCoord4s");
    _driver.call(&_driver.glTexCoord4s)(s, t, r, q);
  }

  static void REGAL_CALL glTexCoord4sv(const GLshort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord4sv),reinterpret_cast<void (*)()>(glTexCoord4sv),"glTexCoord4sv");
    _driver.call(&_driver.glTexCoord4sv)(v);
  }

  static void REGAL_CALL glTexEnvf(GLenum target, GLenum pname, GLfloat param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexEnvf),reinterpret_cast<void (*)()>(glTexEnvf),"glTexEnvf");
    _driver.call(&_driver.glTexEnvf)(target, pname, param);
  }

  static void REGAL_CALL glTexEnvfv(GLenum target, GLenum pname, const GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexEnvfv),reinterpret_cast<void (*)()>(glTexEnvfv),"glTexEnvfv");
    _driver.call(&_driver.glTexEnvfv)(target, pname, params);
  }

  static void REGAL_CALL glTexEnvi(GLenum target, GLenum pname, GLint param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexEnvi),reinterpret_cast<void (*)()>(glTexEnvi),"glTexEnvi");
    _driver.call(&_driver.glTexEnvi)(target, pname, param);
  }

  static void REGAL_CALL glTexEnviv(GLenum target, GLenum pname, const GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexEnviv),reinterpret_cast<void (*)()>(glTexEnviv),"glTexEnviv");
    _driver.call(&_driver.glTexEnviv)(target, pname, params);
  }

  static void REGAL_CALL glTexGend(GLenum coord, GLenum pname, GLdouble param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexGend),reinterpret_cast<void (*)()>(glTexGend),"glTexGend");
    _driver.call(&_driver.glTexGend)(coord, pname, param);
  }

  static void REGAL_CALL glTexGendv(GLenum coord, GLenum pname, const GLdouble *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexGendv),reinterpret_cast<void (*)()>(glTexGendv),"glTexGendv");
    _driver.call(&_driver.glTexGendv)(coord, pname, params);
  }

  static void REGAL_CALL glTexGenf(GLenum coord, GLenum pname, GLfloat param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexGenf),reinterpret_cast<void (*)()>(glTexGenf),"glTexGenf");
    _driver.call(&_driver.glTexGenf)(coord, pname, param);
  }

  static void REGAL_CALL glTexGenfv(GLenum coord, GLenum pname, const GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexGenfv),reinterpret_cast<void (*)()>(glTexGenfv),"glTexGenfv");
    _driver.call(&_driver.glTexGenfv)(coord, pname, params);
  }

  static void REGAL_CALL glTexGeni(GLenum coord, GLenum pname, GLint param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexGeni),reinterpret_cast<void (*)()>(glTexGeni),"glTexGeni");
    _driver.call(&_driver.glTexGeni)(coord, pname, param);
  }

  static void REGAL_CALL glTexGeniv(GLenum coord, GLenum pname, const GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexGeniv),reinterpret_cast<void (*)()>(glTexGeniv),"glTexGeniv");
    _driver.call(&_driver.glTexGeniv)(coord, pname, params);
  }

  static void REGAL_CALL glTexImage1D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexImage1D),reinterpret_cast<void (*)()>(glTexImage1D),"glTexImage1D");
    _driver.call(&_driver.glTexImage1D)(target, level, internalformat, width, border, format, type, pixels);
  }

  static void REGAL_CALL glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexImage2D),reinterpret_cast<void (*)()>(glTexImage2D),"glTexImage2D");
    _driver.call(&_driver.glTexImage2D)(target, level, internalformat, width, height, border, format, type, pixels);
  }

  static void REGAL_CALL glTexParameterf(GLenum target, GLenum pname, GLfloat param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexParameterf),reinterpret_cast<void (*)()>(glTexParameterf),"glTexParameterf");
    _driver.call(&_driver.glTexParameterf)(target, pname, param);
  }

  static void REGAL_CALL glTexParameterfv(GLenum target, GLenum pname, const GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexParameterfv),reinterpret_cast<void (*)()>(glTexParameterfv),"glTexParameterfv");
    _driver.call(&_driver.glTexParameterfv)(target, pname, params);
  }

  static void REGAL_CALL glTexParameteri(GLenum target, GLenum pname, GLint param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexParameteri),reinterpret_cast<void (*)()>(glTexParameteri),"glTexParameteri");
    _driver.call(&_driver.glTexParameteri)(target, pname, param);
  }

  static void REGAL_CALL glTexParameteriv(GLenum target, GLenum pname, const GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexParameteriv),reinterpret_cast<void (*)()>(glTexParameteriv),"glTexParameteriv");
    _driver.call(&_driver.glTexParameteriv)(target, pname, params);
  }

  static void REGAL_CALL glTranslated(GLdouble x, GLdouble y, GLdouble z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTranslated),reinterpret_cast<void (*)()>(glTranslated),"glTranslated");
    _driver.call(&_driver.glTranslated)(x, y, z);
  }

  static void REGAL_CALL glTranslatef(GLfloat x, GLfloat y, GLfloat z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTranslatef),reinterpret_cast<void (*)()>(glTranslatef),"glTranslatef");
    _driver.call(&_driver.glTranslatef)(x, y, z);
  }

  static void REGAL_CALL glVertex2d(GLdouble x, GLdouble y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertex2d),reinterpret_cast<void (*)()>(glVertex2d),"glVertex2d");
    _driver.call(&_driver.glVertex2d)(x, y);
  }

  static void REGAL_CALL glVertex2dv(const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertex2dv),reinterpret_cast<void (*)()>(glVertex2dv),"glVertex2dv");
    _driver.call(&_driver.glVertex2dv)(v);
  }

  static void REGAL_CALL glVertex2f(GLfloat x, GLfloat y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertex2f),reinterpret_cast<void (*)()>(glVertex2f),"glVertex2f");
    _driver.call(&_driver.glVertex2f)(x, y);
  }

  static void REGAL_CALL glVertex2fv(const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertex2fv),reinterpret_cast<void (*)()>(glVertex2fv),"glVertex2fv");
    _driver.call(&_driver.glVertex2fv)(v);
  }

  static void REGAL_CALL glVertex2i(GLint x, GLint y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertex2i),reinterpret_cast<void (*)()>(glVertex2i),"glVertex2i");
    _driver.call(&_driver.glVertex2i)(x, y);
  }

  static void REGAL_CALL glVertex2iv(const GLint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertex2iv),reinterpret_cast<void (*)()>(glVertex2iv),"glVertex2iv");
    _driver.call(&_driver.glVertex2iv)(v);
  }

  static void REGAL_CALL glVertex2s(GLshort x, GLshort y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertex2s),reinterpret_cast<void (*)()>(glVertex2s),"glVertex2s");
    _driver.call(&_driver.glVertex2s)(x, y);
  }

  static void REGAL_CALL glVertex2sv(const GLshort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertex2sv),reinterpret_cast<void (*)()>(glVertex2sv),"glVertex2sv");
    _driver.call(&_driver.glVertex2sv)(v);
  }

  static void REGAL_CALL glVertex3d(GLdouble x, GLdouble y, GLdouble z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertex3d),reinterpret_cast<void (*)()>(glVertex3d),"glVertex3d");
    _driver.call(&_driver.glVertex3d)(x, y, z);
  }

  static void REGAL_CALL glVertex3dv(const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertex3dv),reinterpret_cast<void (*)()>(glVertex3dv),"glVertex3dv");
    _driver.call(&_driver.glVertex3dv)(v);
  }

  static void REGAL_CALL glVertex3f(GLfloat x, GLfloat y, GLfloat z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertex3f),reinterpret_cast<void (*)()>(glVertex3f),"glVertex3f");
    _driver.call(&_driver.glVertex3f)(x, y, z);
  }

  static void REGAL_CALL glVertex3fv(const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertex3fv),reinterpret_cast<void (*)()>(glVertex3fv),"glVertex3fv");
    _driver.call(&_driver.glVertex3fv)(v);
  }

  static void REGAL_CALL glVertex3i(GLint x, GLint y, GLint z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertex3i),reinterpret_cast<void (*)()>(glVertex3i),"glVertex3i");
    _driver.call(&_driver.glVertex3i)(x, y, z);
  }

  static void REGAL_CALL glVertex3iv(const GLint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertex3iv),reinterpret_cast<void (*)()>(glVertex3iv),"glVertex3iv");
    _driver.call(&_driver.glVertex3iv)(v);
  }

  static void REGAL_CALL glVertex3s(GLshort x, GLshort y, GLshort z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertex3s),reinterpret_cast<void (*)()>(glVertex3s),"glVertex3s");
    _driver.call(&_driver.glVertex3s)(x, y, z);
  }

  static void REGAL_CALL glVertex3sv(const GLshort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertex3sv),reinterpret_cast<void (*)()>(glVertex3sv),"glVertex3sv");
    _driver.call(&_driver.glVertex3sv)(v);
  }

  static void REGAL_CALL glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertex4d),reinterpret_cast<void (*)()>(glVertex4d),"glVertex4d");
    _driver.call(&_driver.glVertex4d)(x, y, z, w);
  }

  static void REGAL_CALL glVertex4dv(const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertex4dv),reinterpret_cast<void (*)()>(glVertex4dv),"glVertex4dv");
    _driver.call(&_driver.glVertex4dv)(v);
  }

  static void REGAL_CALL glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertex4f),reinterpret_cast<void (*)()>(glVertex4f),"glVertex4f");
    _driver.call(&_driver.glVertex4f)(x, y, z, w);
  }

  static void REGAL_CALL glVertex4fv(const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertex4fv),reinterpret_cast<void (*)()>(glVertex4fv),"glVertex4fv");
    _driver.call(&_driver.glVertex4fv)(v);
  }

  static void REGAL_CALL glVertex4i(GLint x, GLint y, GLint z, GLint w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertex4i),reinterpret_cast<void (*)()>(glVertex4i),"glVertex4i");
    _driver.call(&_driver.glVertex4i)(x, y, z, w);
  }

  static void REGAL_CALL glVertex4iv(const GLint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertex4iv),reinterpret_cast<void (*)()>(glVertex4iv),"glVertex4iv");
    _driver.call(&_driver.glVertex4iv)(v);
  }

  static void REGAL_CALL glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertex4s),reinterpret_cast<void (*)()>(glVertex4s),"glVertex4s");
    _driver.call(&_driver.glVertex4s)(x, y, z, w);
  }

  static void REGAL_CALL glVertex4sv(const GLshort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertex4sv),reinterpret_cast<void (*)()>(glVertex4sv),"glVertex4sv");
    _driver.call(&_driver.glVertex4sv)(v);
  }

  static void REGAL_CALL glViewport(GLint x, GLint y, GLsizei width, GLsizei height)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glViewport),reinterpret_cast<void (*)()>(glViewport),"glViewport");
    _driver.call(&_driver.glViewport)(x, y, width, height);
  }

// GL_VERSION_1_1

  static GLboolean REGAL_CALL glAreTexturesResident(GLsizei n, const GLuint *textures, GLboolean *residences)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glAreTexturesResident),reinterpret_cast<void (*)()>(glAreTexturesResident),"glAreTexturesResident");
    return _driver.call(&_driver.glAreTexturesResident)(n, textures, residences);
  }

  static void REGAL_CALL glArrayElement(GLint index)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glArrayElement),reinterpret_cast<void (*)()>(glArrayElement),"glArrayElement");
    _driver.call(&_driver.glArrayElement)(index);
  }

  static void REGAL_CALL glBindTexture(GLenum target, GLuint texture)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBindTexture),reinterpret_cast<void (*)()>(glBindTexture),"glBindTexture");
    _driver.call(&_driver.glBindTexture)(target, texture);
  }

  static void REGAL_CALL glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColorPointer),reinterpret_cast<void (*)()>(glColorPointer),"glColorPointer");
    _driver.call(&_driver.glColorPointer)(size, type, stride, pointer);
  }

  static void REGAL_CALL glCopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCopyTexImage1D),reinterpret_cast<void (*)()>(glCopyTexImage1D),"glCopyTexImage1D");
    _driver.call(&_driver.glCopyTexImage1D)(target, level, internalformat, x, y, width, border);
  }

  static void REGAL_CALL glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCopyTexImage2D),reinterpret_cast<void (*)()>(glCopyTexImage2D),"glCopyTexImage2D");
    _driver.call(&_driver.glCopyTexImage2D)(target, level, internalformat, x, y, width, height, border);
  }

  static void REGAL_CALL glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCopyTexSubImage1D),reinterpret_cast<void (*)()>(glCopyTexSubImage1D),"glCopyTexSubImage1D");
    _driver.call(&_driver.glCopyTexSubImage1D)(target, level, xoffset, x, y, width);
  }

  static void REGAL_CALL glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCopyTexSubImage2D),reinterpret_cast<void (*)()>(glCopyTexSubImage2D),"glCopyTexSubImage2D");
    _driver.call(&_driver.glCopyTexSubImage2D)(target, level, xoffset, yoffset, x, y, width, height);
  }

  static void REGAL_CALL glDeleteTextures(GLsizei n, const GLuint *textures)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDeleteTextures),reinterpret_cast<void (*)()>(glDeleteTextures),"glDeleteTextures");
    _driver.call(&_driver.glDeleteTextures)(n, textures);
  }

  static void REGAL_CALL glDisableClientState(GLenum cap)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDisableClientState),reinterpret_cast<void (*)()>(glDisableClientState),"glDisableClientState");
    _driver.call(&_driver.glDisableClientState)(cap);
  }

  static void REGAL_CALL glDrawArrays(GLenum mode, GLint first, GLsizei count)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDrawArrays),reinterpret_cast<void (*)()>(glDrawArrays),"glDrawArrays");
    _driver.call(&_driver.glDrawArrays)(mode, first, count);
  }

  static void REGAL_CALL glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDrawElements),reinterpret_cast<void (*)()>(glDrawElements),"glDrawElements");
    _driver.call(&_driver.glDrawElements)(mode, count, type, indices);
  }

  static void REGAL_CALL glEdgeFlagPointer(GLsizei stride, const GLvoid *pointer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glEdgeFlagPointer),reinterpret_cast<void (*)()>(glEdgeFlagPointer),"glEdgeFlagPointer");
    _driver.call(&_driver.glEdgeFlagPointer)(stride, pointer);
  }

  static void REGAL_CALL glEnableClientState(GLenum cap)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glEnableClientState),reinterpret_cast<void (*)()>(glEnableClientState),"glEnableClientState");
    _driver.call(&_driver.glEnableClientState)(cap);
  }

  static void REGAL_CALL glGenTextures(GLsizei n, GLuint *textures)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGenTextures),reinterpret_cast<void (*)()>(glGenTextures),"glGenTextures");
    _driver.call(&_driver.glGenTextures)(n, textures);
  }

  static void REGAL_CALL glGetPointerv(GLenum pname, GLvoid **params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetPointerv),reinterpret_cast<void (*)()>(glGetPointerv),"glGetPointerv");
    _driver.call(&_driver.glGetPointerv)(pname, params);
  }

  static void REGAL_CALL glIndexPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIndexPointer),reinterpret_cast<void (*)()>(glIndexPointer),"glIndexPointer");
    _driver.call(&_driver.glIndexPointer)(type, stride, pointer);
  }

  static void REGAL_CALL glIndexub(GLubyte c)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIndexub),reinterpret_cast<void (*)()>(glIndexub),"glIndexub");
    _driver.call(&_driver.glIndexub)(c);
  }

  static void REGAL_CALL glIndexubv(const GLubyte *c)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIndexubv),reinterpret_cast<void (*)()>(glIndexubv),"glIndexubv");
    _driver.call(&_driver.glIndexubv)(c);
  }

  static void REGAL_CALL glInterleavedArrays(GLenum format, GLsizei stride, const GLvoid *pointer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glInterleavedArrays),reinterpret_cast<void (*)()>(glInterleavedArrays),"glInterleavedArrays");
    _driver.call(&_driver.glInterleavedArrays)(format, stride, pointer);
  }

  static GLboolean REGAL_CALL glIsTexture(GLuint texture)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIsTexture),reinterpret_cast<void (*)()>(glIsTexture),"glIsTexture");
    return _driver.call(&_driver.glIsTexture)(texture);
  }

  static void REGAL_CALL glNormalPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNormalPointer),reinterpret_cast<void (*)()>(glNormalPointer),"glNormalPointer");
    _driver.call(&_driver.glNormalPointer)(type, stride, pointer);
  }

  static void REGAL_CALL glPolygonOffset(GLfloat factor, GLfloat units)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPolygonOffset),reinterpret_cast<void (*)()>(glPolygonOffset),"glPolygonOffset");
    _driver.call(&_driver.glPolygonOffset)(factor, units);
  }

  static void REGAL_CALL glPopClientAttrib(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPopClientAttrib),reinterpret_cast<void (*)()>(glPopClientAttrib),"glPopClientAttrib");
    _driver.call(&_driver.glPopClientAttrib)();
  }

  static void REGAL_CALL glPrioritizeTextures(GLsizei n, const GLuint *textures, const GLclampf *priorities)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPrioritizeTextures),reinterpret_cast<void (*)()>(glPrioritizeTextures),"glPrioritizeTextures");
    _driver.call(&_driver.glPrioritizeTextures)(n, textures, priorities);
  }

  static void REGAL_CALL glPushClientAttrib(GLbitfield mask)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPushClientAttrib),reinterpret_cast<void (*)()>(glPushClientAttrib),"glPushClientAttrib");
    _driver.call(&_driver.glPushClientAttrib)(mask);
  }

  static void REGAL_CALL glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoordPointer),reinterpret_cast<void (*)()>(glTexCoordPointer),"glTexCoordPointer");
    _driver.call(&_driver.glTexCoordPointer)(size, type, stride, pointer);
  }

  static void REGAL_CALL glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexSubImage1D),reinterpret_cast<void (*)()>(glTexSubImage1D),"glTexSubImage1D");
    _driver.call(&_driver.glTexSubImage1D)(target, level, xoffset, width, format, type, pixels);
  }

  static void REGAL_CALL glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexSubImage2D),reinterpret_cast<void (*)()>(glTexSubImage2D),"glTexSubImage2D");
    _driver.call(&_driver.glTexSubImage2D)(target, level, xoffset, yoffset, width, height, format, type, pixels);
  }

  static void REGAL_CALL glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexPointer),reinterpret_cast<void (*)()>(glVertexPointer),"glVertexPointer");
    _driver.call(&_driver.glVertexPointer)(size, type, stride, pointer);
  }

// GL_VERSION_1_2

  static void REGAL_CALL glBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBlendColor),reinterpret_cast<void (*)()>(glBlendColor),"glBlendColor");
    _driver.call(&_driver.glBlendColor)(red, green, blue, alpha);
  }

  static void REGAL_CALL glBlendEquation(GLenum mode)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBlendEquation),reinterpret_cast<void (*)()>(glBlendEquation),"glBlendEquation");
    _driver.call(&_driver.glBlendEquation)(mode);
  }

  static void REGAL_CALL glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCopyTexSubImage3D),reinterpret_cast<void (*)()>(glCopyTexSubImage3D),"glCopyTexSubImage3D");
    _driver.call(&_driver.glCopyTexSubImage3D)(target, level, xoffset, yoffset, zoffset, x, y, width, height);
  }

  static void REGAL_CALL glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDrawRangeElements),reinterpret_cast<void (*)()>(glDrawRangeElements),"glDrawRangeElements");
    _driver.call(&_driver.glDrawRangeElements)(mode, start, end, count, type, indices);
  }

  static void REGAL_CALL glTexImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexImage3D),reinterpret_cast<void (*)()>(glTexImage3D),"glTexImage3D");
    _driver.call(&_driver.glTexImage3D)(target, level, internalformat, width, height, depth, border, format, type, pixels);
  }

  static void REGAL_CALL glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexSubImage3D),reinterpret_cast<void (*)()>(glTexSubImage3D),"glTexSubImage3D");
    _driver.call(&_driver.glTexSubImage3D)(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
  }

// GL_VERSION_1_3

  static void REGAL_CALL glActiveTexture(GLenum texture)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glActiveTexture),reinterpret_cast<void (*)()>(glActiveTexture),"glActiveTexture");
    _driver.call(&_driver.glActiveTexture)(texture);
  }

  static void REGAL_CALL glClientActiveTexture(GLenum texture)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glClientActiveTexture),reinterpret_cast<void (*)()>(glClientActiveTexture),"glClientActiveTexture");
    _driver.call(&_driver.glClientActiveTexture)(texture);
  }

  static void REGAL_CALL glCompressedTexImage1D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCompressedTexImage1D),reinterpret_cast<void (*)()>(glCompressedTexImage1D),"glCompressedTexImage1D");
    _driver.call(&_driver.glCompressedTexImage1D)(target, level, internalformat, width, border, imageSize, data);
  }

  static void REGAL_CALL glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCompressedTexImage2D),reinterpret_cast<void (*)()>(glCompressedTexImage2D),"glCompressedTexImage2D");
    _driver.call(&_driver.glCompressedTexImage2D)(target, level, internalformat, width, height, border, imageSize, data);
  }

  static void REGAL_CALL glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCompressedTexImage3D),reinterpret_cast<void (*)()>(glCompressedTexImage3D),"glCompressedTexImage3D");
    _driver.call(&_driver.glCompressedTexImage3D)(target, level, internalformat, width, height, depth, border, imageSize, data);
  }

  static void REGAL_CALL glCompressedTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCompressedTexSubImage1D),reinterpret_cast<void (*)()>(glCompressedTexSubImage1D),"glCompressedTexSubImage1D");
    _driver.call(&_driver.glCompressedTexSubImage1D)(target, level, xoffset, width, format, imageSize, data);
  }

  static void REGAL_CALL glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCompressedTexSubImage2D),reinterpret_cast<void (*)()>(glCompressedTexSubImage2D),"glCompressedTexSubImage2D");
    _driver.call(&_driver.glCompressedTexSubImage2D)(target, level, xoffset, yoffset, width, height, format, imageSize, data);
  }

  static void REGAL_CALL glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCompressedTexSubImage3D),reinterpret_cast<void (*)()>(glCompressedTexSubImage3D),"glCompressedTexSubImage3D");
    _driver.call(&_driver.glCompressedTexSubImage3D)(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
  }

  static void REGAL_CALL glGetCompressedTexImage(GLenum target, GLint lod, GLvoid *img)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetCompressedTexImage),reinterpret_cast<void (*)()>(glGetCompressedTexImage),"glGetCompressedTexImage");
    _driver.call(&_driver.glGetCompressedTexImage)(target, lod, img);
  }

  static void REGAL_CALL glLoadTransposeMatrixd(const GLdouble *m)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glLoadTransposeMatrixd),reinterpret_cast<void (*)()>(glLoadTransposeMatrixd),"glLoadTransposeMatrixd");
    _driver.call(&_driver.glLoadTransposeMatrixd)(m);
  }

  static void REGAL_CALL glLoadTransposeMatrixf(const GLfloat *m)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glLoadTransposeMatrixf),reinterpret_cast<void (*)()>(glLoadTransposeMatrixf),"glLoadTransposeMatrixf");
    _driver.call(&_driver.glLoadTransposeMatrixf)(m);
  }

  static void REGAL_CALL glMultTransposeMatrixd(const GLdouble *m)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultTransposeMatrixd),reinterpret_cast<void (*)()>(glMultTransposeMatrixd),"glMultTransposeMatrixd");
    _driver.call(&_driver.glMultTransposeMatrixd)(m);
  }

  static void REGAL_CALL glMultTransposeMatrixf(const GLfloat *m)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultTransposeMatrixf),reinterpret_cast<void (*)()>(glMultTransposeMatrixf),"glMultTransposeMatrixf");
    _driver.call(&_driver.glMultTransposeMatrixf)(m);
  }

  static void REGAL_CALL glMultiTexCoord1d(GLenum target, GLdouble s)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord1d),reinterpret_cast<void (*)()>(glMultiTexCoord1d),"glMultiTexCoord1d");
    _driver.call(&_driver.glMultiTexCoord1d)(target, s);
  }

  static void REGAL_CALL glMultiTexCoord1dv(GLenum target, const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord1dv),reinterpret_cast<void (*)()>(glMultiTexCoord1dv),"glMultiTexCoord1dv");
    _driver.call(&_driver.glMultiTexCoord1dv)(target, v);
  }

  static void REGAL_CALL glMultiTexCoord1f(GLenum target, GLfloat s)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord1f),reinterpret_cast<void (*)()>(glMultiTexCoord1f),"glMultiTexCoord1f");
    _driver.call(&_driver.glMultiTexCoord1f)(target, s);
  }

  static void REGAL_CALL glMultiTexCoord1fv(GLenum target, const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord1fv),reinterpret_cast<void (*)()>(glMultiTexCoord1fv),"glMultiTexCoord1fv");
    _driver.call(&_driver.glMultiTexCoord1fv)(target, v);
  }

  static void REGAL_CALL glMultiTexCoord1i(GLenum target, GLint s)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord1i),reinterpret_cast<void (*)()>(glMultiTexCoord1i),"glMultiTexCoord1i");
    _driver.call(&_driver.glMultiTexCoord1i)(target, s);
  }

  static void REGAL_CALL glMultiTexCoord1iv(GLenum target, const GLint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord1iv),reinterpret_cast<void (*)()>(glMultiTexCoord1iv),"glMultiTexCoord1iv");
    _driver.call(&_driver.glMultiTexCoord1iv)(target, v);
  }

  static void REGAL_CALL glMultiTexCoord1s(GLenum target, GLshort s)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord1s),reinterpret_cast<void (*)()>(glMultiTexCoord1s),"glMultiTexCoord1s");
    _driver.call(&_driver.glMultiTexCoord1s)(target, s);
  }

  static void REGAL_CALL glMultiTexCoord1sv(GLenum target, const GLshort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord1sv),reinterpret_cast<void (*)()>(glMultiTexCoord1sv),"glMultiTexCoord1sv");
    _driver.call(&_driver.glMultiTexCoord1sv)(target, v);
  }

  static void REGAL_CALL glMultiTexCoord2d(GLenum target, GLdouble s, GLdouble t)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord2d),reinterpret_cast<void (*)()>(glMultiTexCoord2d),"glMultiTexCoord2d");
    _driver.call(&_driver.glMultiTexCoord2d)(target, s, t);
  }

  static void REGAL_CALL glMultiTexCoord2dv(GLenum target, const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord2dv),reinterpret_cast<void (*)()>(glMultiTexCoord2dv),"glMultiTexCoord2dv");
    _driver.call(&_driver.glMultiTexCoord2dv)(target, v);
  }

  static void REGAL_CALL glMultiTexCoord2f(GLenum target, GLfloat s, GLfloat t)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord2f),reinterpret_cast<void (*)()>(glMultiTexCoord2f),"glMultiTexCoord2f");
    _driver.call(&_driver.glMultiTexCoord2f)(target, s, t);
  }

  static void REGAL_CALL glMultiTexCoord2fv(GLenum target, const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord2fv),reinterpret_cast<void (*)()>(glMultiTexCoord2fv),"glMultiTexCoord2fv");
    _driver.call(&_driver.glMultiTexCoord2fv)(target, v);
  }

  static void REGAL_CALL glMultiTexCoord2i(GLenum target, GLint s, GLint t)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord2i),reinterpret_cast<void (*)()>(glMultiTexCoord2i),"glMultiTexCoord2i");
    _driver.call(&_driver.glMultiTexCoord2i)(target, s, t);
  }

  static void REGAL_CALL glMultiTexCoord2iv(GLenum target, const GLint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord2iv),reinterpret_cast<void (*)()>(glMultiTexCoord2iv),"glMultiTexCoord2iv");
    _driver.call(&_driver.glMultiTexCoord2iv)(target, v);
  }

  static void REGAL_CALL glMultiTexCoord2s(GLenum target, GLshort s, GLshort t)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord2s),reinterpret_cast<void (*)()>(glMultiTexCoord2s),"glMultiTexCoord2s");
    _driver.call(&_driver.glMultiTexCoord2s)(target, s, t);
  }

  static void REGAL_CALL glMultiTexCoord2sv(GLenum target, const GLshort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord2sv),reinterpret_cast<void (*)()>(glMultiTexCoord2sv),"glMultiTexCoord2sv");
    _driver.call(&_driver.glMultiTexCoord2sv)(target, v);
  }

  static void REGAL_CALL glMultiTexCoord3d(GLenum target, GLdouble s, GLdouble t, GLdouble r)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord3d),reinterpret_cast<void (*)()>(glMultiTexCoord3d),"glMultiTexCoord3d");
    _driver.call(&_driver.glMultiTexCoord3d)(target, s, t, r);
  }

  static void REGAL_CALL glMultiTexCoord3dv(GLenum target, const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord3dv),reinterpret_cast<void (*)()>(glMultiTexCoord3dv),"glMultiTexCoord3dv");
    _driver.call(&_driver.glMultiTexCoord3dv)(target, v);
  }

  static void REGAL_CALL glMultiTexCoord3f(GLenum target, GLfloat s, GLfloat t, GLfloat r)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord3f),reinterpret_cast<void (*)()>(glMultiTexCoord3f),"glMultiTexCoord3f");
    _driver.call(&_driver.glMultiTexCoord3f)(target, s, t, r);
  }

  static void REGAL_CALL glMultiTexCoord3fv(GLenum target, const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord3fv),reinterpret_cast<void (*)()>(glMultiTexCoord3fv),"glMultiTexCoord3fv");
    _driver.call(&_driver.glMultiTexCoord3fv)(target, v);
  }

  static void REGAL_CALL glMultiTexCoord3i(GLenum target, GLint s, GLint t, GLint r)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord3i),reinterpret_cast<void (*)()>(glMultiTexCoord3i),"glMultiTexCoord3i");
    _driver.call(&_driver.glMultiTexCoord3i)(target, s, t, r);
  }

  static void REGAL_CALL glMultiTexCoord3iv(GLenum target, const GLint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord3iv),reinterpret_cast<void (*)()>(glMultiTexCoord3iv),"glMultiTexCoord3iv");
    _driver.call(&_driver.glMultiTexCoord3iv)(target, v);
  }

  static void REGAL_CALL glMultiTexCoord3s(GLenum target, GLshort s, GLshort t, GLshort r)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord3s),reinterpret_cast<void (*)()>(glMultiTexCoord3s),"glMultiTexCoord3s");
    _driver.call(&_driver.glMultiTexCoord3s)(target, s, t, r);
  }

  static void REGAL_CALL glMultiTexCoord3sv(GLenum target, const GLshort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord3sv),reinterpret_cast<void (*)()>(glMultiTexCoord3sv),"glMultiTexCoord3sv");
    _driver.call(&_driver.glMultiTexCoord3sv)(target, v);
  }

  static void REGAL_CALL glMultiTexCoord4d(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord4d),reinterpret_cast<void (*)()>(glMultiTexCoord4d),"glMultiTexCoord4d");
    _driver.call(&_driver.glMultiTexCoord4d)(target, s, t, r, q);
  }

  static void REGAL_CALL glMultiTexCoord4dv(GLenum target, const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord4dv),reinterpret_cast<void (*)()>(glMultiTexCoord4dv),"glMultiTexCoord4dv");
    _driver.call(&_driver.glMultiTexCoord4dv)(target, v);
  }

  static void REGAL_CALL glMultiTexCoord4f(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord4f),reinterpret_cast<void (*)()>(glMultiTexCoord4f),"glMultiTexCoord4f");
    _driver.call(&_driver.glMultiTexCoord4f)(target, s, t, r, q);
  }

  static void REGAL_CALL glMultiTexCoord4fv(GLenum target, const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord4fv),reinterpret_cast<void (*)()>(glMultiTexCoord4fv),"glMultiTexCoord4fv");
    _driver.call(&_driver.glMultiTexCoord4fv)(target, v);
  }

  static void REGAL_CALL glMultiTexCoord4i(GLenum target, GLint s, GLint t, GLint r, GLint q)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord4i),reinterpret_cast<void (*)()>(glMultiTexCoord4i),"glMultiTexCoord4i");
    _driver.call(&_driver.glMultiTexCoord4i)(target, s, t, r, q);
  }

  static void REGAL_CALL glMultiTexCoord4iv(GLenum target, const GLint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord4iv),reinterpret_cast<void (*)()>(glMultiTexCoord4iv),"glMultiTexCoord4iv");
    _driver.call(&_driver.glMultiTexCoord4iv)(target, v);
  }

  static void REGAL_CALL glMultiTexCoord4s(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord4s),reinterpret_cast<void (*)()>(glMultiTexCoord4s),"glMultiTexCoord4s");
    _driver.call(&_driver.glMultiTexCoord4s)(target, s, t, r, q);
  }

  static void REGAL_CALL glMultiTexCoord4sv(GLenum target, const GLshort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord4sv),reinterpret_cast<void (*)()>(glMultiTexCoord4sv),"glMultiTexCoord4sv");
    _driver.call(&_driver.glMultiTexCoord4sv)(target, v);
  }

  static void REGAL_CALL glSampleCoverage(GLclampf value, GLboolean invert)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSampleCoverage),reinterpret_cast<void (*)()>(glSampleCoverage),"glSampleCoverage");
    _driver.call(&_driver.glSampleCoverage)(value, invert);
  }

// GL_VERSION_1_4

  static void REGAL_CALL glBlendFuncSeparate(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBlendFuncSeparate),reinterpret_cast<void (*)()>(glBlendFuncSeparate),"glBlendFuncSeparate");
    _driver.call(&_driver.glBlendFuncSeparate)(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
  }

  static void REGAL_CALL glFogCoordPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFogCoordPointer),reinterpret_cast<void (*)()>(glFogCoordPointer),"glFogCoordPointer");
    _driver.call(&_driver.glFogCoordPointer)(type, stride, pointer);
  }

  static void REGAL_CALL glFogCoordd(GLdouble coord)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFogCoordd),reinterpret_cast<void (*)()>(glFogCoordd),"glFogCoordd");
    _driver.call(&_driver.glFogCoordd)(coord);
  }

  static void REGAL_CALL glFogCoorddv(const GLdouble *coord)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFogCoorddv),reinterpret_cast<void (*)()>(glFogCoorddv),"glFogCoorddv");
    _driver.call(&_driver.glFogCoorddv)(coord);
  }

  static void REGAL_CALL glFogCoordf(GLfloat coord)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFogCoordf),reinterpret_cast<void (*)()>(glFogCoordf),"glFogCoordf");
    _driver.call(&_driver.glFogCoordf)(coord);
  }

  static void REGAL_CALL glFogCoordfv(const GLfloat *coord)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFogCoordfv),reinterpret_cast<void (*)()>(glFogCoordfv),"glFogCoordfv");
    _driver.call(&_driver.glFogCoordfv)(coord);
  }

  static void REGAL_CALL glMultiDrawArrays(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiDrawArrays),reinterpret_cast<void (*)()>(glMultiDrawArrays),"glMultiDrawArrays");
    _driver.call(&_driver.glMultiDrawArrays)(mode, first, count, primcount);
  }

  static void REGAL_CALL glMultiDrawElements(GLenum mode, const GLsizei *count, GLenum type, const GLvoid * const *indices, GLsizei primcount)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiDrawElements),reinterpret_cast<void (*)()>(glMultiDrawElements),"glMultiDrawElements");
    _driver.call(&_driver.glMultiDrawElements)(mode, count, type, indices, primcount);
  }

  static void REGAL_CALL glPointParameterf(GLenum pname, GLfloat param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPointParameterf),reinterpret_cast<void (*)()>(glPointParameterf),"glPointParameterf");
    _driver.call(&_driver.glPointParameterf)(pname, param);
  }

  static void REGAL_CALL glPointParameterfv(GLenum pname, const GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPointParameterfv),reinterpret_cast<void (*)()>(glPointParameterfv),"glPointParameterfv");
    _driver.call(&_driver.glPointParameterfv)(pname, params);
  }

  static void REGAL_CALL glPointParameteri(GLenum pname, GLint param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPointParameteri),reinterpret_cast<void (*)()>(glPointParameteri),"glPointParameteri");
    _driver.call(&_driver.glPointParameteri)(pname, param);
  }

  static void REGAL_CALL glPointParameteriv(GLenum pname, const GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPointParameteriv),reinterpret_cast<void (*)()>(glPointParameteriv),"glPointParameteriv");
    _driver.call(&_driver.glPointParameteriv)(pname, params);
  }

  static void REGAL_CALL glSecondaryColor3b(GLbyte red, GLbyte green, GLbyte blue)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSecondaryColor3b),reinterpret_cast<void (*)()>(glSecondaryColor3b),"glSecondaryColor3b");
    _driver.call(&_driver.glSecondaryColor3b)(red, green, blue);
  }

  static void REGAL_CALL glSecondaryColor3bv(const GLbyte *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSecondaryColor3bv),reinterpret_cast<void (*)()>(glSecondaryColor3bv),"glSecondaryColor3bv");
    _driver.call(&_driver.glSecondaryColor3bv)(v);
  }

  static void REGAL_CALL glSecondaryColor3d(GLdouble red, GLdouble green, GLdouble blue)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSecondaryColor3d),reinterpret_cast<void (*)()>(glSecondaryColor3d),"glSecondaryColor3d");
    _driver.call(&_driver.glSecondaryColor3d)(red, green, blue);
  }

  static void REGAL_CALL glSecondaryColor3dv(const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSecondaryColor3dv),reinterpret_cast<void (*)()>(glSecondaryColor3dv),"glSecondaryColor3dv");
    _driver.call(&_driver.glSecondaryColor3dv)(v);
  }

  static void REGAL_CALL glSecondaryColor3f(GLfloat red, GLfloat green, GLfloat blue)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSecondaryColor3f),reinterpret_cast<void (*)()>(glSecondaryColor3f),"glSecondaryColor3f");
    _driver.call(&_driver.glSecondaryColor3f)(red, green, blue);
  }

  static void REGAL_CALL glSecondaryColor3fv(const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSecondaryColor3fv),reinterpret_cast<void (*)()>(glSecondaryColor3fv),"glSecondaryColor3fv");
    _driver.call(&_driver.glSecondaryColor3fv)(v);
  }

  static void REGAL_CALL glSecondaryColor3i(GLint red, GLint green, GLint blue)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSecondaryColor3i),reinterpret_cast<void (*)()>(glSecondaryColor3i),"glSecondaryColor3i");
    _driver.call(&_driver.glSecondaryColor3i)(red, green, blue);
  }

  static void REGAL_CALL glSecondaryColor3iv(const GLint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSecondaryColor3iv),reinterpret_cast<void (*)()>(glSecondaryColor3iv),"glSecondaryColor3iv");
    _driver.call(&_driver.glSecondaryColor3iv)(v);
  }

  static void REGAL_CALL glSecondaryColor3s(GLshort red, GLshort green, GLshort blue)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSecondaryColor3s),reinterpret_cast<void (*)()>(glSecondaryColor3s),"glSecondaryColor3s");
    _driver.call(&_driver.glSecondaryColor3s)(red, green, blue);
  }

  static void REGAL_CALL glSecondaryColor3sv(const GLshort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSecondaryColor3sv),reinterpret_cast<void (*)()>(glSecondaryColor3sv),"glSecondaryColor3sv");
    _driver.call(&_driver.glSecondaryColor3sv)(v);
  }

  static void REGAL_CALL glSecondaryColor3ub(GLubyte red, GLubyte green, GLubyte blue)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSecondaryColor3ub),reinterpret_cast<void (*)()>(glSecondaryColor3ub),"glSecondaryColor3ub");
    _driver.call(&_driver.glSecondaryColor3ub)(red, green, blue);
  }

  static void REGAL_CALL glSecondaryColor3ubv(const GLubyte *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSecondaryColor3ubv),reinterpret_cast<void (*)()>(glSecondaryColor3ubv),"glSecondaryColor3ubv");
    _driver.call(&_driver.glSecondaryColor3ubv)(v);
  }

  static void REGAL_CALL glSecondaryColor3ui(GLuint red, GLuint green, GLuint blue)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSecondaryColor3ui),reinterpret_cast<void (*)()>(glSecondaryColor3ui),"glSecondaryColor3ui");
    _driver.call(&_driver.glSecondaryColor3ui)(red, green, blue);
  }

  static void REGAL_CALL glSecondaryColor3uiv(const GLuint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSecondaryColor3uiv),reinterpret_cast<void (*)()>(glSecondaryColor3uiv),"glSecondaryColor3uiv");
    _driver.call(&_driver.glSecondaryColor3uiv)(v);
  }

  static void REGAL_CALL glSecondaryColor3us(GLushort red, GLushort green, GLushort blue)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSecondaryColor3us),reinterpret_cast<void (*)()>(glSecondaryColor3us),"glSecondaryColor3us");
    _driver.call(&_driver.glSecondaryColor3us)(red, green, blue);
  }

  static void REGAL_CALL glSecondaryColor3usv(const GLushort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSecondaryColor3usv),reinterpret_cast<void (*)()>(glSecondaryColor3usv),"glSecondaryColor3usv");
    _driver.call(&_driver.glSecondaryColor3usv)(v);
  }

  static void REGAL_CALL glSecondaryColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSecondaryColorPointer),reinterpret_cast<void (*)()>(glSecondaryColorPointer),"glSecondaryColorPointer");
    _driver.call(&_driver.glSecondaryColorPointer)(size, type, stride, pointer);
  }

  static void REGAL_CALL glWindowPos2d(GLdouble x, GLdouble y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos2d),reinterpret_cast<void (*)()>(glWindowPos2d),"glWindowPos2d");
    _driver.call(&_driver.glWindowPos2d)(x, y);
  }

  static void REGAL_CALL glWindowPos2dv(const GLdouble *p)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos2dv),reinterpret_cast<void (*)()>(glWindowPos2dv),"glWindowPos2dv");
    _driver.call(&_driver.glWindowPos2dv)(p);
  }

  static void REGAL_CALL glWindowPos2f(GLfloat x, GLfloat y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos2f),reinterpret_cast<void (*)()>(glWindowPos2f),"glWindowPos2f");
    _driver.call(&_driver.glWindowPos2f)(x, y);
  }

  static void REGAL_CALL glWindowPos2fv(const GLfloat *p)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos2fv),reinterpret_cast<void (*)()>(glWindowPos2fv),"glWindowPos2fv");
    _driver.call(&_driver.glWindowPos2fv)(p);
  }

  static void REGAL_CALL glWindowPos2i(GLint x, GLint y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos2i),reinterpret_cast<void (*)()>(glWindowPos2i),"glWindowPos2i");
    _driver.call(&_driver.glWindowPos2i)(x, y);
  }

  static void REGAL_CALL glWindowPos2iv(const GLint *p)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos2iv),reinterpret_cast<void (*)()>(glWindowPos2iv),"glWindowPos2iv");
    _driver.call(&_driver.glWindowPos2iv)(p);
  }

  static void REGAL_CALL glWindowPos2s(GLshort x, GLshort y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos2s),reinterpret_cast<void (*)()>(glWindowPos2s),"glWindowPos2s");
    _driver.call(&_driver.glWindowPos2s)(x, y);
  }

  static void REGAL_CALL glWindowPos2sv(const GLshort *p)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos2sv),reinterpret_cast<void (*)()>(glWindowPos2sv),"glWindowPos2sv");
    _driver.call(&_driver.glWindowPos2sv)(p);
  }

  static void REGAL_CALL glWindowPos3d(GLdouble x, GLdouble y, GLdouble z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos3d),reinterpret_cast<void (*)()>(glWindowPos3d),"glWindowPos3d");
    _driver.call(&_driver.glWindowPos3d)(x, y, z);
  }

  static void REGAL_CALL glWindowPos3dv(const GLdouble *p)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos3dv),reinterpret_cast<void (*)()>(glWindowPos3dv),"glWindowPos3dv");
    _driver.call(&_driver.glWindowPos3dv)(p);
  }

  static void REGAL_CALL glWindowPos3f(GLfloat x, GLfloat y, GLfloat z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos3f),reinterpret_cast<void (*)()>(glWindowPos3f),"glWindowPos3f");
    _driver.call(&_driver.glWindowPos3f)(x, y, z);
  }

  static void REGAL_CALL glWindowPos3fv(const GLfloat *p)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos3fv),reinterpret_cast<void (*)()>(glWindowPos3fv),"glWindowPos3fv");
    _driver.call(&_driver.glWindowPos3fv)(p);
  }

  static void REGAL_CALL glWindowPos3i(GLint x, GLint y, GLint z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos3i),reinterpret_cast<void (*)()>(glWindowPos3i),"glWindowPos3i");
    _driver.call(&_driver.glWindowPos3i)(x, y, z);
  }

  static void REGAL_CALL glWindowPos3iv(const GLint *p)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos3iv),reinterpret_cast<void (*)()>(glWindowPos3iv),"glWindowPos3iv");
    _driver.call(&_driver.glWindowPos3iv)(p);
  }

  static void REGAL_CALL glWindowPos3s(GLshort x, GLshort y, GLshort z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos3s),reinterpret_cast<void (*)()>(glWindowPos3s),"glWindowPos3s");
    _driver.call(&_driver.glWindowPos3s)(x, y, z);
  }

  static void REGAL_CALL glWindowPos3sv(const GLshort *p)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos3sv),reinterpret_cast<void (*)()>(glWindowPos3sv),"glWindowPos3sv");
    _driver.call(&_driver.glWindowPos3sv)(p);
  }

// GL_VERSION_1_5

  static void REGAL_CALL glBeginQuery(GLenum target, GLuint id)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBeginQuery),reinterpret_cast<void (*)()>(glBeginQuery),"glBeginQuery");
    _driver.call(&_driver.glBeginQuery)(target, id);
  }

  static void REGAL_CALL glBindBuffer(GLenum target, GLuint buffer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBindBuffer),reinterpret_cast<void (*)()>(glBindBuffer),"glBindBuffer");
    _driver.call(&_driver.glBindBuffer)(target, buffer);
  }

  static void REGAL_CALL glBufferData(GLenum target, GLsizeiptr size, const GLvoid *data, GLenum usage)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBufferData),reinterpret_cast<void (*)()>(glBufferData),"glBufferData");
    _driver.call(&_driver.glBufferData)(target, size, data, usage);
  }

  static void REGAL_CALL glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBufferSubData),reinterpret_cast<void (*)()>(glBufferSubData),"glBufferSubData");
    _driver.call(&_driver.glBufferSubData)(target, offset, size, data);
  }

  static void REGAL_CALL glDeleteBuffers(GLsizei n, const GLuint *buffers)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDeleteBuffers),reinterpret_cast<void (*)()>(glDeleteBuffers),"glDeleteBuffers");
    _driver.call(&_driver.glDeleteBuffers)(n, buffers);
  }

  static void REGAL_CALL glDeleteQueries(GLsizei n, const GLuint *ids)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDeleteQueries),reinterpret_cast<void (*)()>(glDeleteQueries),"glDeleteQueries");
    _driver.call(&_driver.glDeleteQueries)(n, ids);
  }

  static void REGAL_CALL glEndQuery(GLenum target)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glEndQuery),reinterpret_cast<void (*)()>(glEndQuery),"glEndQuery");
    _driver.call(&_driver.glEndQuery)(target);
  }

  static void REGAL_CALL glGenBuffers(GLsizei n, GLuint *buffers)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGenBuffers),reinterpret_cast<void (*)()>(glGenBuffers),"glGenBuffers");
    _driver.call(&_driver.glGenBuffers)(n, buffers);
  }

  static void REGAL_CALL glGenQueries(GLsizei n, GLuint *ids)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGenQueries),reinterpret_cast<void (*)()>(glGenQueries),"glGenQueries");
    _driver.call(&_driver.glGenQueries)(n, ids);
  }

  static void REGAL_CALL glGetBufferParameteriv(GLenum target, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetBufferParameteriv),reinterpret_cast<void (*)()>(glGetBufferParameteriv),"glGetBufferParameteriv");
    _driver.call(&_driver.glGetBufferParameteriv)(target, pname, params);
  }

  static void REGAL_CALL glGetBufferPointerv(GLenum target, GLenum pname, GLvoid **params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetBufferPointerv),reinterpret_cast<void (*)()>(glGetBufferPointerv),"glGetBufferPointerv");
    _driver.call(&_driver.glGetBufferPointerv)(target, pname, params);
  }

  static void REGAL_CALL glGetBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, GLvoid *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetBufferSubData),reinterpret_cast<void (*)()>(glGetBufferSubData),"glGetBufferSubData");
    _driver.call(&_driver.glGetBufferSubData)(target, offset, size, data);
  }

  static void REGAL_CALL glGetQueryObjectiv(GLuint id, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetQueryObjectiv),reinterpret_cast<void (*)()>(glGetQueryObjectiv),"glGetQueryObjectiv");
    _driver.call(&_driver.glGetQueryObjectiv)(id, pname, params);
  }

  static void REGAL_CALL glGetQueryObjectuiv(GLuint id, GLenum pname, GLuint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetQueryObjectuiv),reinterpret_cast<void (*)()>(glGetQueryObjectuiv),"glGetQueryObjectuiv");
    _driver.call(&_driver.glGetQueryObjectuiv)(id, pname, params);
  }

  static void REGAL_CALL glGetQueryiv(GLenum target, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetQueryiv),reinterpret_cast<void (*)()>(glGetQueryiv),"glGetQueryiv");
    _driver.call(&_driver.glGetQueryiv)(target, pname, params);
  }

  static GLboolean REGAL_CALL glIsBuffer(GLuint buffer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIsBuffer),reinterpret_cast<void (*)()>(glIsBuffer),"glIsBuffer");
    return _driver.call(&_driver.glIsBuffer)(buffer);
  }

  static GLboolean REGAL_CALL glIsQuery(GLuint id)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIsQuery),reinterpret_cast<void (*)()>(glIsQuery),"glIsQuery");
    return _driver.call(&_driver.glIsQuery)(id);
  }

  static GLvoid *REGAL_CALL glMapBuffer(GLenum target, GLenum access)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMapBuffer),reinterpret_cast<void (*)()>(glMapBuffer),"glMapBuffer");
    return _driver.call(&_driver.glMapBuffer)(target, access);
  }

  static GLboolean REGAL_CALL glUnmapBuffer(GLenum target)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUnmapBuffer),reinterpret_cast<void (*)()>(glUnmapBuffer),"glUnmapBuffer");
    return _driver.call(&_driver.glUnmapBuffer)(target);
  }

// GL_VERSION_2_0

  static void REGAL_CALL glAttachShader(GLuint program, GLuint shader)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glAttachShader),reinterpret_cast<void (*)()>(glAttachShader),"glAttachShader");
    _driver.call(&_driver.glAttachShader)(program, shader);
  }

  static void REGAL_CALL glBindAttribLocation(GLuint program, GLuint index, const GLchar *name)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBindAttribLocation),reinterpret_cast<void (*)()>(glBindAttribLocation),"glBindAttribLocation");
    _driver.call(&_driver.glBindAttribLocation)(program, index, name);
  }

  static void REGAL_CALL glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBlendEquationSeparate),reinterpret_cast<void (*)()>(glBlendEquationSeparate),"glBlendEquationSeparate");
    _driver.call(&_driver.glBlendEquationSeparate)(modeRGB, modeAlpha);
  }

  static void REGAL_CALL glCompileShader(GLuint shader)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCompileShader),reinterpret_cast<void (*)()>(glCompileShader),"glCompileShader");
    _driver.call(&_driver.glCompileShader)(shader);
  }

  static GLuint REGAL_CALL glCreateProgram(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCreateProgram),reinterpret_cast<void (*)()>(glCreateProgram),"glCreateProgram");
    return _driver.call(&_driver.glCreateProgram)();
  }

  static GLuint REGAL_CALL glCreateShader(GLenum type)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCreateShader),reinterpret_cast<void (*)()>(glCreateShader),"glCreateShader");
    return _driver.call(&_driver.glCreateShader)(type);
  }

  static void REGAL_CALL glDeleteProgram(GLuint program)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDeleteProgram),reinterpret_cast<void (*)()>(glDeleteProgram),"glDeleteProgram");
    _driver.call(&_driver.glDeleteProgram)(program);
  }

  static void REGAL_CALL glDeleteShader(GLuint shader)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDeleteShader),reinterpret_cast<void (*)()>(glDeleteShader),"glDeleteShader");
    _driver.call(&_driver.glDeleteShader)(shader);
  }

  static void REGAL_CALL glDetachShader(GLuint program, GLuint shader)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDetachShader),reinterpret_cast<void (*)()>(glDetachShader),"glDetachShader");
    _driver.call(&_driver.glDetachShader)(program, shader);
  }

  static void REGAL_CALL glDisableVertexAttribArray(GLuint index)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDisableVertexAttribArray),reinterpret_cast<void (*)()>(glDisableVertexAttribArray),"glDisableVertexAttribArray");
    _driver.call(&_driver.glDisableVertexAttribArray)(index);
  }

  static void REGAL_CALL glDrawBuffers(GLsizei n, const GLenum *bufs)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDrawBuffers),reinterpret_cast<void (*)()>(glDrawBuffers),"glDrawBuffers");
    _driver.call(&_driver.glDrawBuffers)(n, bufs);
  }

  static void REGAL_CALL glEnableVertexAttribArray(GLuint index)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glEnableVertexAttribArray),reinterpret_cast<void (*)()>(glEnableVertexAttribArray),"glEnableVertexAttribArray");
    _driver.call(&_driver.glEnableVertexAttribArray)(index);
  }

  static void REGAL_CALL glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetActiveAttrib),reinterpret_cast<void (*)()>(glGetActiveAttrib),"glGetActiveAttrib");
    _driver.call(&_driver.glGetActiveAttrib)(program, index, bufSize, length, size, type, name);
  }

  static void REGAL_CALL glGetActiveUniform(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetActiveUniform),reinterpret_cast<void (*)()>(glGetActiveUniform),"glGetActiveUniform");
    _driver.call(&_driver.glGetActiveUniform)(program, index, bufSize, length, size, type, name);
  }

  static void REGAL_CALL glGetAttachedShaders(GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetAttachedShaders),reinterpret_cast<void (*)()>(glGetAttachedShaders),"glGetAttachedShaders");
    _driver.call(&_driver.glGetAttachedShaders)(program, maxCount, count, shaders);
  }

  static GLint REGAL_CALL glGetAttribLocation(GLuint program, const GLchar *name)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetAttribLocation),reinterpret_cast<void (*)()>(glGetAttribLocation),"glGetAttribLocation");
    return _driver.call(&_driver.glGetAttribLocation)(program, name);
  }

  static void REGAL_CALL glGetProgramInfoLog(GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetProgramInfoLog),reinterpret_cast<void (*)()>(glGetProgramInfoLog),"glGetProgramInfoLog");
    _driver.call(&_driver.glGetProgramInfoLog)(program, bufSize, length, infoLog);
  }

  static void REGAL_CALL glGetProgramiv(GLuint program, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetProgramiv),reinterpret_cast<void (*)()>(glGetProgramiv),"glGetProgramiv");
    _driver.call(&_driver.glGetProgramiv)(program, pname, params);
  }

  static void REGAL_CALL glGetShaderInfoLog(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetShaderInfoLog),reinterpret_cast<void (*)()>(glGetShaderInfoLog),"glGetShaderInfoLog");
    _driver.call(&_driver.glGetShaderInfoLog)(shader, bufSize, length, infoLog);
  }

  static void REGAL_CALL glGetShaderSource(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetShaderSource),reinterpret_cast<void (*)()>(glGetShaderSource),"glGetShaderSource");
    _driver.call(&_driver.glGetShaderSource)(shader, bufSize, length, source);
  }

  static void REGAL_CALL glGetShaderiv(GLuint shader, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetShaderiv),reinterpret_cast<void (*)()>(glGetShaderiv),"glGetShaderiv");
    _driver.call(&_driver.glGetShaderiv)(shader, pname, params);
  }

  static GLint REGAL_CALL glGetUniformLocation(GLuint program, const GLchar *name)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetUniformLocation),reinterpret_cast<void (*)()>(glGetUniformLocation),"glGetUniformLocation");
    return _driver.call(&_driver.glGetUniformLocation)(program, name);
  }

  static void REGAL_CALL glGetUniformfv(GLuint program, GLint location, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetUniformfv),reinterpret_cast<void (*)()>(glGetUniformfv),"glGetUniformfv");
    _driver.call(&_driver.glGetUniformfv)(program, location, params);
  }

  static void REGAL_CALL glGetUniformiv(GLuint program, GLint location, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetUniformiv),reinterpret_cast<void (*)()>(glGetUniformiv),"glGetUniformiv");
    _driver.call(&_driver.glGetUniformiv)(program, location, params);
  }

  static void REGAL_CALL glGetVertexAttribPointerv(GLuint index, GLenum pname, GLvoid **pointer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetVertexAttribPointerv),reinterpret_cast<void (*)()>(glGetVertexAttribPointerv),"glGetVertexAttribPointerv");
    _driver.call(&_driver.glGetVertexAttribPointerv)(index, pname, pointer);
  }

  static void REGAL_CALL glGetVertexAttribdv(GLuint index, GLenum pname, GLdouble *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetVertexAttribdv),reinterpret_cast<void (*)()>(glGetVertexAttribdv),"glGetVertexAttribdv");
    _driver.call(&_driver.glGetVertexAttribdv)(index, pname, params);
  }

  static void REGAL_CALL glGetVertexAttribfv(GLuint index, GLenum pname, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetVertexAttribfv),reinterpret_cast<void (*)()>(glGetVertexAttribfv),"glGetVertexAttribfv");
    _driver.call(&_driver.glGetVertexAttribfv)(index, pname, params);
  }

  static void REGAL_CALL glGetVertexAttribiv(GLuint index, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetVertexAttribiv),reinterpret_cast<void (*)()>(glGetVertexAttribiv),"glGetVertexAttribiv");
    _driver.call(&_driver.glGetVertexAttribiv)(index, pname, params);
  }

  static GLboolean REGAL_CALL glIsProgram(GLuint program)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIsProgram),reinterpret_cast<void (*)()>(glIsProgram),"glIsProgram");
    return _driver.call(&_driver.glIsProgram)(program);
  }

  static GLboolean REGAL_CALL glIsShader(GLuint shader)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIsShader),reinterpret_cast<void (*)()>(glIsShader),"glIsShader");
    return _driver.call(&_driver.glIsShader)(shader);
  }

  static void REGAL_CALL glLinkProgram(GLuint program)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glLinkProgram),reinterpret_cast<void (*)()>(glLinkProgram),"glLinkProgram");
    _driver.call(&_driver.glLinkProgram)(program);
  }

  static void REGAL_CALL glShaderSource(GLuint shader, GLsizei count, const GLchar * const *string, const GLint *length)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glShaderSource),reinterpret_cast<void (*)()>(glShaderSource),"glShaderSource");
    _driver.call(&_driver.glShaderSource)(shader, count, string, length);
  }

  static void REGAL_CALL glStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glStencilFuncSeparate),reinterpret_cast<void (*)()>(glStencilFuncSeparate),"glStencilFuncSeparate");
    _driver.call(&_driver.glStencilFuncSeparate)(face, func, ref, mask);
  }

  static void REGAL_CALL glStencilMaskSeparate(GLenum face, GLuint mask)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glStencilMaskSeparate),reinterpret_cast<void (*)()>(glStencilMaskSeparate),"glStencilMaskSeparate");
    _driver.call(&_driver.glStencilMaskSeparate)(face, mask);
  }

  static void REGAL_CALL glStencilOpSeparate(GLenum face, GLenum fail, GLenum zfail, GLenum zpass)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glStencilOpSeparate),reinterpret_cast<void (*)()>(glStencilOpSeparate),"glStencilOpSeparate");
    _driver.call(&_driver.glStencilOpSeparate)(face, fail, zfail, zpass);
  }

  static void REGAL_CALL glUniform1f(GLint location, GLfloat v0)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform1f),reinterpret_cast<void (*)()>(glUniform1f),"glUniform1f");
    _driver.call(&_driver.glUniform1f)(location, v0);
  }

  static void REGAL_CALL glUniform1fv(GLint location, GLsizei count, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform1fv),reinterpret_cast<void (*)()>(glUniform1fv),"glUniform1fv");
    _driver.call(&_driver.glUniform1fv)(location, count, value);
  }

  static void REGAL_CALL glUniform1i(GLint location, GLint v0)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform1i),reinterpret_cast<void (*)()>(glUniform1i),"glUniform1i");
    _driver.call(&_driver.glUniform1i)(location, v0);
  }

  static void REGAL_CALL glUniform1iv(GLint location, GLsizei count, const GLint *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform1iv),reinterpret_cast<void (*)()>(glUniform1iv),"glUniform1iv");
    _driver.call(&_driver.glUniform1iv)(location, count, value);
  }

  static void REGAL_CALL glUniform2f(GLint location, GLfloat v0, GLfloat v1)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform2f),reinterpret_cast<void (*)()>(glUniform2f),"glUniform2f");
    _driver.call(&_driver.glUniform2f)(location, v0, v1);
  }

  static void REGAL_CALL glUniform2fv(GLint location, GLsizei count, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform2fv),reinterpret_cast<void (*)()>(glUniform2fv),"glUniform2fv");
    _driver.call(&_driver.glUniform2fv)(location, count, value);
  }

  static void REGAL_CALL glUniform2i(GLint location, GLint v0, GLint v1)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform2i),reinterpret_cast<void (*)()>(glUniform2i),"glUniform2i");
    _driver.call(&_driver.glUniform2i)(location, v0, v1);
  }

  static void REGAL_CALL glUniform2iv(GLint location, GLsizei count, const GLint *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform2iv),reinterpret_cast<void (*)()>(glUniform2iv),"glUniform2iv");
    _driver.call(&_driver.glUniform2iv)(location, count, value);
  }

  static void REGAL_CALL glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform3f),reinterpret_cast<void (*)()>(glUniform3f),"glUniform3f");
    _driver.call(&_driver.glUniform3f)(location, v0, v1, v2);
  }

  static void REGAL_CALL glUniform3fv(GLint location, GLsizei count, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform3fv),reinterpret_cast<void (*)()>(glUniform3fv),"glUniform3fv");
    _driver.call(&_driver.glUniform3fv)(location, count, value);
  }

  static void REGAL_CALL glUniform3i(GLint location, GLint v0, GLint v1, GLint v2)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform3i),reinterpret_cast<void (*)()>(glUniform3i),"glUniform3i");
    _driver.call(&_driver.glUniform3i)(location, v0, v1, v2);
  }

  static void REGAL_CALL glUniform3iv(GLint location, GLsizei count, const GLint *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform3iv),reinterpret_cast<void (*)()>(glUniform3iv),"glUniform3iv");
    _driver.call(&_driver.glUniform3iv)(location, count, value);
  }

  static void REGAL_CALL glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform4f),reinterpret_cast<void (*)()>(glUniform4f),"glUniform4f");
    _driver.call(&_driver.glUniform4f)(location, v0, v1, v2, v3);
  }

  static void REGAL_CALL glUniform4fv(GLint location, GLsizei count, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform4fv),reinterpret_cast<void (*)()>(glUniform4fv),"glUniform4fv");
    _driver.call(&_driver.glUniform4fv)(location, count, value);
  }

  static void REGAL_CALL glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform4i),reinterpret_cast<void (*)()>(glUniform4i),"glUniform4i");
    _driver.call(&_driver.glUniform4i)(location, v0, v1, v2, v3);
  }

  static void REGAL_CALL glUniform4iv(GLint location, GLsizei count, const GLint *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform4iv),reinterpret_cast<void (*)()>(glUniform4iv),"glUniform4iv");
    _driver.call(&_driver.glUniform4iv)(location, count, value);
  }

  static void REGAL_CALL glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniformMatrix2fv),reinterpret_cast<void (*)()>(glUniformMatrix2fv),"glUniformMatrix2fv");
    _driver.call(&_driver.glUniformMatrix2fv)(location, count, transpose, value);
  }

  static void REGAL_CALL glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniformMatrix3fv),reinterpret_cast<void (*)()>(glUniformMatrix3fv),"glUniformMatrix3fv");
    _driver.call(&_driver.glUniformMatrix3fv)(location, count, transpose, value);
  }

  static void REGAL_CALL glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniformMatrix4fv),reinterpret_cast<void (*)()>(glUniformMatrix4fv),"glUniformMatrix4fv");
    _driver.call(&_driver.glUniformMatrix4fv)(location, count, transpose, value);
  }

  static void REGAL_CALL glUseProgram(GLuint program)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUseProgram),reinterpret_cast<void (*)()>(glUseProgram),"glUseProgram");
    _driver.call(&_driver.glUseProgram)(program);
  }

  static void REGAL_CALL glValidateProgram(GLuint program)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glValidateProgram),reinterpret_cast<void (*)()>(glValidateProgram),"glValidateProgram");
    _driver.call(&_driver.glValidateProgram)(program);
  }

  static void REGAL_CALL glVertexAttrib1d(GLuint index, GLdouble x)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib1d),reinterpret_cast<void (*)()>(glVertexAttrib1d),"glVertexAttrib1d");
    _driver.call(&_driver.glVertexAttrib1d)(index, x);
  }

  static void REGAL_CALL glVertexAttrib1dv(GLuint index, const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib1dv),reinterpret_cast<void (*)()>(glVertexAttrib1dv),"glVertexAttrib1dv");
    _driver.call(&_driver.glVertexAttrib1dv)(index, v);
  }

  static void REGAL_CALL glVertexAttrib1f(GLuint index, GLfloat x)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib1f),reinterpret_cast<void (*)()>(glVertexAttrib1f),"glVertexAttrib1f");
    _driver.call(&_driver.glVertexAttrib1f)(index, x);
  }

  static void REGAL_CALL glVertexAttrib1fv(GLuint index, const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib1fv),reinterpret_cast<void (*)()>(glVertexAttrib1fv),"glVertexAttrib1fv");
    _driver.call(&_driver.glVertexAttrib1fv)(index, v);
  }

  static void REGAL_CALL glVertexAttrib1s(GLuint index, GLshort x)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib1s),reinterpret_cast<void (*)()>(glVertexAttrib1s),"glVertexAttrib1s");
    _driver.call(&_driver.glVertexAttrib1s)(index, x);
  }

  static void REGAL_CALL glVertexAttrib1sv(GLuint index, const GLshort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib1sv),reinterpret_cast<void (*)()>(glVertexAttrib1sv),"glVertexAttrib1sv");
    _driver.call(&_driver.glVertexAttrib1sv)(index, v);
  }

  static void REGAL_CALL glVertexAttrib2d(GLuint index, GLdouble x, GLdouble y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib2d),reinterpret_cast<void (*)()>(glVertexAttrib2d),"glVertexAttrib2d");
    _driver.call(&_driver.glVertexAttrib2d)(index, x, y);
  }

  static void REGAL_CALL glVertexAttrib2dv(GLuint index, const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib2dv),reinterpret_cast<void (*)()>(glVertexAttrib2dv),"glVertexAttrib2dv");
    _driver.call(&_driver.glVertexAttrib2dv)(index, v);
  }

  static void REGAL_CALL glVertexAttrib2f(GLuint index, GLfloat x, GLfloat y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib2f),reinterpret_cast<void (*)()>(glVertexAttrib2f),"glVertexAttrib2f");
    _driver.call(&_driver.glVertexAttrib2f)(index, x, y);
  }

  static void REGAL_CALL glVertexAttrib2fv(GLuint index, const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib2fv),reinterpret_cast<void (*)()>(glVertexAttrib2fv),"glVertexAttrib2fv");
    _driver.call(&_driver.glVertexAttrib2fv)(index, v);
  }

  static void REGAL_CALL glVertexAttrib2s(GLuint index, GLshort x, GLshort y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib2s),reinterpret_cast<void (*)()>(glVertexAttrib2s),"glVertexAttrib2s");
    _driver.call(&_driver.glVertexAttrib2s)(index, x, y);
  }

  static void REGAL_CALL glVertexAttrib2sv(GLuint index, const GLshort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib2sv),reinterpret_cast<void (*)()>(glVertexAttrib2sv),"glVertexAttrib2sv");
    _driver.call(&_driver.glVertexAttrib2sv)(index, v);
  }

  static void REGAL_CALL glVertexAttrib3d(GLuint index, GLdouble x, GLdouble y, GLdouble z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib3d),reinterpret_cast<void (*)()>(glVertexAttrib3d),"glVertexAttrib3d");
    _driver.call(&_driver.glVertexAttrib3d)(index, x, y, z);
  }

  static void REGAL_CALL glVertexAttrib3dv(GLuint index, const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib3dv),reinterpret_cast<void (*)()>(glVertexAttrib3dv),"glVertexAttrib3dv");
    _driver.call(&_driver.glVertexAttrib3dv)(index, v);
  }

  static void REGAL_CALL glVertexAttrib3f(GLuint index, GLfloat x, GLfloat y, GLfloat z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib3f),reinterpret_cast<void (*)()>(glVertexAttrib3f),"glVertexAttrib3f");
    _driver.call(&_driver.glVertexAttrib3f)(index, x, y, z);
  }

  static void REGAL_CALL glVertexAttrib3fv(GLuint index, const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib3fv),reinterpret_cast<void (*)()>(glVertexAttrib3fv),"glVertexAttrib3fv");
    _driver.call(&_driver.glVertexAttrib3fv)(index, v);
  }

  static void REGAL_CALL glVertexAttrib3s(GLuint index, GLshort x, GLshort y, GLshort z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib3s),reinterpret_cast<void (*)()>(glVertexAttrib3s),"glVertexAttrib3s");
    _driver.call(&_driver.glVertexAttrib3s)(index, x, y, z);
  }

  static void REGAL_CALL glVertexAttrib3sv(GLuint index, const GLshort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib3sv),reinterpret_cast<void (*)()>(glVertexAttrib3sv),"glVertexAttrib3sv");
    _driver.call(&_driver.glVertexAttrib3sv)(index, v);
  }

  static void REGAL_CALL glVertexAttrib4Nbv(GLuint index, const GLbyte *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib4Nbv),reinterpret_cast<void (*)()>(glVertexAttrib4Nbv),"glVertexAttrib4Nbv");
    _driver.call(&_driver.glVertexAttrib4Nbv)(index, v);
  }

  static void REGAL_CALL glVertexAttrib4Niv(GLuint index, const GLint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib4Niv),reinterpret_cast<void (*)()>(glVertexAttrib4Niv),"glVertexAttrib4Niv");
    _driver.call(&_driver.glVertexAttrib4Niv)(index, v);
  }

  static void REGAL_CALL glVertexAttrib4Nsv(GLuint index, const GLshort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib4Nsv),reinterpret_cast<void (*)()>(glVertexAttrib4Nsv),"glVertexAttrib4Nsv");
    _driver.call(&_driver.glVertexAttrib4Nsv)(index, v);
  }

  static void REGAL_CALL glVertexAttrib4Nub(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib4Nub),reinterpret_cast<void (*)()>(glVertexAttrib4Nub),"glVertexAttrib4Nub");
    _driver.call(&_driver.glVertexAttrib4Nub)(index, x, y, z, w);
  }

  static void REGAL_CALL glVertexAttrib4Nubv(GLuint index, const GLubyte *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib4Nubv),reinterpret_cast<void (*)()>(glVertexAttrib4Nubv),"glVertexAttrib4Nubv");
    _driver.call(&_driver.glVertexAttrib4Nubv)(index, v);
  }

  static void REGAL_CALL glVertexAttrib4Nuiv(GLuint index, const GLuint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib4Nuiv),reinterpret_cast<void (*)()>(glVertexAttrib4Nuiv),"glVertexAttrib4Nuiv");
    _driver.call(&_driver.glVertexAttrib4Nuiv)(index, v);
  }

  static void REGAL_CALL glVertexAttrib4Nusv(GLuint index, const GLushort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib4Nusv),reinterpret_cast<void (*)()>(glVertexAttrib4Nusv),"glVertexAttrib4Nusv");
    _driver.call(&_driver.glVertexAttrib4Nusv)(index, v);
  }

  static void REGAL_CALL glVertexAttrib4bv(GLuint index, const GLbyte *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib4bv),reinterpret_cast<void (*)()>(glVertexAttrib4bv),"glVertexAttrib4bv");
    _driver.call(&_driver.glVertexAttrib4bv)(index, v);
  }

  static void REGAL_CALL glVertexAttrib4d(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib4d),reinterpret_cast<void (*)()>(glVertexAttrib4d),"glVertexAttrib4d");
    _driver.call(&_driver.glVertexAttrib4d)(index, x, y, z, w);
  }

  static void REGAL_CALL glVertexAttrib4dv(GLuint index, const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib4dv),reinterpret_cast<void (*)()>(glVertexAttrib4dv),"glVertexAttrib4dv");
    _driver.call(&_driver.glVertexAttrib4dv)(index, v);
  }

  static void REGAL_CALL glVertexAttrib4f(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib4f),reinterpret_cast<void (*)()>(glVertexAttrib4f),"glVertexAttrib4f");
    _driver.call(&_driver.glVertexAttrib4f)(index, x, y, z, w);
  }

  static void REGAL_CALL glVertexAttrib4fv(GLuint index, const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib4fv),reinterpret_cast<void (*)()>(glVertexAttrib4fv),"glVertexAttrib4fv");
    _driver.call(&_driver.glVertexAttrib4fv)(index, v);
  }

  static void REGAL_CALL glVertexAttrib4iv(GLuint index, const GLint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib4iv),reinterpret_cast<void (*)()>(glVertexAttrib4iv),"glVertexAttrib4iv");
    _driver.call(&_driver.glVertexAttrib4iv)(index, v);
  }

  static void REGAL_CALL glVertexAttrib4s(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib4s),reinterpret_cast<void (*)()>(glVertexAttrib4s),"glVertexAttrib4s");
    _driver.call(&_driver.glVertexAttrib4s)(index, x, y, z, w);
  }

  static void REGAL_CALL glVertexAttrib4sv(GLuint index, const GLshort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib4sv),reinterpret_cast<void (*)()>(glVertexAttrib4sv),"glVertexAttrib4sv");
    _driver.call(&_driver.glVertexAttrib4sv)(index, v);
  }

  static void REGAL_CALL glVertexAttrib4ubv(GLuint index, const GLubyte *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib4ubv),reinterpret_cast<void (*)()>(glVertexAttrib4ubv),"glVertexAttrib4ubv");
    _driver.call(&_driver.glVertexAttrib4ubv)(index, v);
  }

  static void REGAL_CALL glVertexAttrib4uiv(GLuint index, const GLuint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib4uiv),reinterpret_cast<void (*)()>(glVertexAttrib4uiv),"glVertexAttrib4uiv");
    _driver.call(&_driver.glVertexAttrib4uiv)(index, v);
  }

  static void REGAL_CALL glVertexAttrib4usv(GLuint index, const GLushort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib4usv),reinterpret_cast<void (*)()>(glVertexAttrib4usv),"glVertexAttrib4usv");
    _driver.call(&_driver.glVertexAttrib4usv)(index, v);
  }

  static void REGAL_CALL glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribPointer),reinterpret_cast<void (*)()>(glVertexAttribPointer),"glVertexAttribPointer");
    _driver.call(&_driver.glVertexAttribPointer)(index, size, type, normalized, stride, pointer);
  }

// GL_VERSION_2_1

  static void REGAL_CALL glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniformMatrix2x3fv),reinterpret_cast<void (*)()>(glUniformMatrix2x3fv),"glUniformMatrix2x3fv");
    _driver.call(&_driver.glUniformMatrix2x3fv)(location, count, transpose, value);
  }

  static void REGAL_CALL glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniformMatrix2x4fv),reinterpret_cast<void (*)()>(glUniformMatrix2x4fv),"glUniformMatrix2x4fv");
    _driver.call(&_driver.glUniformMatrix2x4fv)(location, count, transpose, value);
  }

  static void REGAL_CALL glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniformMatrix3x2fv),reinterpret_cast<void (*)()>(glUniformMatrix3x2fv),"glUniformMatrix3x2fv");
    _driver.call(&_driver.glUniformMatrix3x2fv)(location, count, transpose, value);
  }

  static void REGAL_CALL glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniformMatrix3x4fv),reinterpret_cast<void (*)()>(glUniformMatrix3x4fv),"glUniformMatrix3x4fv");
    _driver.call(&_driver.glUniformMatrix3x4fv)(location, count, transpose, value);
  }

  static void REGAL_CALL glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniformMatrix4x2fv),reinterpret_cast<void (*)()>(glUniformMatrix4x2fv),"glUniformMatrix4x2fv");
    _driver.call(&_driver.glUniformMatrix4x2fv)(location, count, transpose, value);
  }

  static void REGAL_CALL glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniformMatrix4x3fv),reinterpret_cast<void (*)()>(glUniformMatrix4x3fv),"glUniformMatrix4x3fv");
    _driver.call(&_driver.glUniformMatrix4x3fv)(location, count, transpose, value);
  }

// GL_VERSION_3_0

  static void REGAL_CALL glBeginConditionalRender(GLuint id, GLenum mode)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBeginConditionalRender),reinterpret_cast<void (*)()>(glBeginConditionalRender),"glBeginConditionalRender");
    _driver.call(&_driver.glBeginConditionalRender)(id, mode);
  }

  static void REGAL_CALL glBeginTransformFeedback(GLenum primitiveMode)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBeginTransformFeedback),reinterpret_cast<void (*)()>(glBeginTransformFeedback),"glBeginTransformFeedback");
    _driver.call(&_driver.glBeginTransformFeedback)(primitiveMode);
  }

  static void REGAL_CALL glBindFragDataLocation(GLuint program, GLuint color, const GLchar *name)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBindFragDataLocation),reinterpret_cast<void (*)()>(glBindFragDataLocation),"glBindFragDataLocation");
    _driver.call(&_driver.glBindFragDataLocation)(program, color, name);
  }

  static void REGAL_CALL glClampColor(GLenum target, GLenum clamp)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glClampColor),reinterpret_cast<void (*)()>(glClampColor),"glClampColor");
    _driver.call(&_driver.glClampColor)(target, clamp);
  }

  static void REGAL_CALL glClearBufferfi(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glClearBufferfi),reinterpret_cast<void (*)()>(glClearBufferfi),"glClearBufferfi");
    _driver.call(&_driver.glClearBufferfi)(buffer, drawbuffer, depth, stencil);
  }

  static void REGAL_CALL glClearBufferfv(GLenum buffer, GLint drawbuffer, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glClearBufferfv),reinterpret_cast<void (*)()>(glClearBufferfv),"glClearBufferfv");
    _driver.call(&_driver.glClearBufferfv)(buffer, drawbuffer, value);
  }

  static void REGAL_CALL glClearBufferiv(GLenum buffer, GLint drawbuffer, const GLint *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glClearBufferiv),reinterpret_cast<void (*)()>(glClearBufferiv),"glClearBufferiv");
    _driver.call(&_driver.glClearBufferiv)(buffer, drawbuffer, value);
  }

  static void REGAL_CALL glClearBufferuiv(GLenum buffer, GLint drawbuffer, const GLuint *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glClearBufferuiv),reinterpret_cast<void (*)()>(glClearBufferuiv),"glClearBufferuiv");
    _driver.call(&_driver.glClearBufferuiv)(buffer, drawbuffer, value);
  }

  static void REGAL_CALL glColorMaski(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColorMaski),reinterpret_cast<void (*)()>(glColorMaski),"glColorMaski");
    _driver.call(&_driver.glColorMaski)(index, r, g, b, a);
  }

  static void REGAL_CALL glDisablei(GLenum cap, GLuint index)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDisablei),reinterpret_cast<void (*)()>(glDisablei),"glDisablei");
    _driver.call(&_driver.glDisablei)(cap, index);
  }

  static void REGAL_CALL glEnablei(GLenum cap, GLuint index)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glEnablei),reinterpret_cast<void (*)()>(glEnablei),"glEnablei");
    _driver.call(&_driver.glEnablei)(cap, index);
  }

  static void REGAL_CALL glEndConditionalRender(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glEndConditionalRender),reinterpret_cast<void (*)()>(glEndConditionalRender),"glEndConditionalRender");
    _driver.call(&_driver.glEndConditionalRender)();
  }

  static void REGAL_CALL glEndTransformFeedback(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glEndTransformFeedback),reinterpret_cast<void (*)()>(glEndTransformFeedback),"glEndTransformFeedback");
    _driver.call(&_driver.glEndTransformFeedback)();
  }

  static void REGAL_CALL glGetBooleani_v(GLenum target, GLuint index, GLboolean *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetBooleani_v),reinterpret_cast<void (*)()>(glGetBooleani_v),"glGetBooleani_v");
    _driver.call(&_driver.glGetBooleani_v)(target, index, data);
  }

  static GLint REGAL_CALL glGetFragDataLocation(GLuint program, const GLchar *name)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetFragDataLocation),reinterpret_cast<void (*)()>(glGetFragDataLocation),"glGetFragDataLocation");
    return _driver.call(&_driver.glGetFragDataLocation)(program, name);
  }

  static const GLubyte *REGAL_CALL glGetStringi(GLenum name, GLuint index)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetStringi),reinterpret_cast<void (*)()>(glGetStringi),"glGetStringi");
    return _driver.call(&_driver.glGetStringi)(name, index);
  }

  static void REGAL_CALL glGetTexParameterIiv(GLenum target, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetTexParameterIiv),reinterpret_cast<void (*)()>(glGetTexParameterIiv),"glGetTexParameterIiv");
    _driver.call(&_driver.glGetTexParameterIiv)(target, pname, params);
  }

  static void REGAL_CALL glGetTexParameterIuiv(GLenum target, GLenum pname, GLuint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetTexParameterIuiv),reinterpret_cast<void (*)()>(glGetTexParameterIuiv),"glGetTexParameterIuiv");
    _driver.call(&_driver.glGetTexParameterIuiv)(target, pname, params);
  }

  static void REGAL_CALL glGetTransformFeedbackVarying(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetTransformFeedbackVarying),reinterpret_cast<void (*)()>(glGetTransformFeedbackVarying),"glGetTransformFeedbackVarying");
    _driver.call(&_driver.glGetTransformFeedbackVarying)(program, index, bufSize, length, size, type, name);
  }

  static void REGAL_CALL glGetUniformuiv(GLuint program, GLint location, GLuint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetUniformuiv),reinterpret_cast<void (*)()>(glGetUniformuiv),"glGetUniformuiv");
    _driver.call(&_driver.glGetUniformuiv)(program, location, params);
  }

  static void REGAL_CALL glGetVertexAttribIiv(GLuint index, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetVertexAttribIiv),reinterpret_cast<void (*)()>(glGetVertexAttribIiv),"glGetVertexAttribIiv");
    _driver.call(&_driver.glGetVertexAttribIiv)(index, pname, params);
  }

  static void REGAL_CALL glGetVertexAttribIuiv(GLuint index, GLenum pname, GLuint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetVertexAttribIuiv),reinterpret_cast<void (*)()>(glGetVertexAttribIuiv),"glGetVertexAttribIuiv");
    _driver.call(&_driver.glGetVertexAttribIuiv)(index, pname, params);
  }

  static GLboolean REGAL_CALL glIsEnabledi(GLenum target, GLuint index)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIsEnabledi),reinterpret_cast<void (*)()>(glIsEnabledi),"glIsEnabledi");
    return _driver.call(&_driver.glIsEnabledi)(target, index);
  }

  static void REGAL_CALL glTexParameterIiv(GLenum target, GLenum pname, const GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexParameterIiv),reinterpret_cast<void (*)()>(glTexParameterIiv),"glTexParameterIiv");
    _driver.call(&_driver.glTexParameterIiv)(target, pname, params);
  }

  static void REGAL_CALL glTexParameterIuiv(GLenum target, GLenum pname, const GLuint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexParameterIuiv),reinterpret_cast<void (*)()>(glTexParameterIuiv),"glTexParameterIuiv");
    _driver.call(&_driver.glTexParameterIuiv)(target, pname, params);
  }

  static void REGAL_CALL glTransformFeedbackVaryings(GLuint program, GLsizei count, const GLchar * const *varyings, GLenum bufferMode)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTransformFeedbackVaryings),reinterpret_cast<void (*)()>(glTransformFeedbackVaryings),"glTransformFeedbackVaryings");
    _driver.call(&_driver.glTransformFeedbackVaryings)(program, count, varyings, bufferMode);
  }

  static void REGAL_CALL glUniform1ui(GLint location, GLuint v0)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform1ui),reinterpret_cast<void (*)()>(glUniform1ui),"glUniform1ui");
    _driver.call(&_driver.glUniform1ui)(location, v0);
  }

  static void REGAL_CALL glUniform1uiv(GLint location, GLsizei count, const GLuint *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform1uiv),reinterpret_cast<void (*)()>(glUniform1uiv),"glUniform1uiv");
    _driver.call(&_driver.glUniform1uiv)(location, count, value);
  }

  static void REGAL_CALL glUniform2ui(GLint location, GLuint v0, GLuint v1)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform2ui),reinterpret_cast<void (*)()>(glUniform2ui),"glUniform2ui");
    _driver.call(&_driver.glUniform2ui)(location, v0, v1);
  }

  static void REGAL_CALL glUniform2uiv(GLint location, GLsizei count, const GLuint *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform2uiv),reinterpret_cast<void (*)()>(glUniform2uiv),"glUniform2uiv");
    _driver.call(&_driver.glUniform2uiv)(location, count, value);
  }

  static void REGAL_CALL glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform3ui),reinterpret_cast<void (*)()>(glUniform3ui),"glUniform3ui");
    _driver.call(&_driver.glUniform3ui)(location, v0, v1, v2);
  }

  static void REGAL_CALL glUniform3uiv(GLint location, GLsizei count, const GLuint *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform3uiv),reinterpret_cast<void (*)()>(glUniform3uiv),"glUniform3uiv");
    _driver.call(&_driver.glUniform3uiv)(location, count, value);
  }

  static void REGAL_CALL glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform4ui),reinterpret_cast<void (*)()>(glUniform4ui),"glUniform4ui");
    _driver.call(&_driver.glUniform4ui)(location, v0, v1, v2, v3);
  }

  static void REGAL_CALL glUniform4uiv(GLint location, GLsizei count, const GLuint *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform4uiv),reinterpret_cast<void (*)()>(glUniform4uiv),"glUniform4uiv");
    _driver.call(&_driver.glUniform4uiv)(location, count, value);
  }

  static void REGAL_CALL glVertexAttribI1i(GLuint index, GLint x)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribI1i),reinterpret_cast<void (*)()>(glVertexAttribI1i),"glVertexAttribI1i");
    _driver.call(&_driver.glVertexAttribI1i)(index, x);
  }

  static void REGAL_CALL glVertexAttribI1iv(GLuint index, const GLint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribI1iv),reinterpret_cast<void (*)()>(glVertexAttribI1iv),"glVertexAttribI1iv");
    _driver.call(&_driver.glVertexAttribI1iv)(index, v);
  }

  static void REGAL_CALL glVertexAttribI1ui(GLuint index, GLuint x)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribI1ui),reinterpret_cast<void (*)()>(glVertexAttribI1ui),"glVertexAttribI1ui");
    _driver.call(&_driver.glVertexAttribI1ui)(index, x);
  }

  static void REGAL_CALL glVertexAttribI1uiv(GLuint index, const GLuint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribI1uiv),reinterpret_cast<void (*)()>(glVertexAttribI1uiv),"glVertexAttribI1uiv");
    _driver.call(&_driver.glVertexAttribI1uiv)(index, v);
  }

  static void REGAL_CALL glVertexAttribI2i(GLuint index, GLint x, GLint y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribI2i),reinterpret_cast<void (*)()>(glVertexAttribI2i),"glVertexAttribI2i");
    _driver.call(&_driver.glVertexAttribI2i)(index, x, y);
  }

  static void REGAL_CALL glVertexAttribI2iv(GLuint index, const GLint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribI2iv),reinterpret_cast<void (*)()>(glVertexAttribI2iv),"glVertexAttribI2iv");
    _driver.call(&_driver.glVertexAttribI2iv)(index, v);
  }

  static void REGAL_CALL glVertexAttribI2ui(GLuint index, GLuint x, GLuint y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribI2ui),reinterpret_cast<void (*)()>(glVertexAttribI2ui),"glVertexAttribI2ui");
    _driver.call(&_driver.glVertexAttribI2ui)(index, x, y);
  }

  static void REGAL_CALL glVertexAttribI2uiv(GLuint index, const GLuint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribI2uiv),reinterpret_cast<void (*)()>(glVertexAttribI2uiv),"glVertexAttribI2uiv");
    _driver.call(&_driver.glVertexAttribI2uiv)(index, v);
  }

  static void REGAL_CALL glVertexAttribI3i(GLuint index, GLint x, GLint y, GLint z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribI3i),reinterpret_cast<void (*)()>(glVertexAttribI3i),"glVertexAttribI3i");
    _driver.call(&_driver.glVertexAttribI3i)(index, x, y, z);
  }

  static void REGAL_CALL glVertexAttribI3iv(GLuint index, const GLint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribI3iv),reinterpret_cast<void (*)()>(glVertexAttribI3iv),"glVertexAttribI3iv");
    _driver.call(&_driver.glVertexAttribI3iv)(index, v);
  }

  static void REGAL_CALL glVertexAttribI3ui(GLuint index, GLuint x, GLuint y, GLuint z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribI3ui),reinterpret_cast<void (*)()>(glVertexAttribI3ui),"glVertexAttribI3ui");
    _driver.call(&_driver.glVertexAttribI3ui)(index, x, y, z);
  }

  static void REGAL_CALL glVertexAttribI3uiv(GLuint index, const GLuint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribI3uiv),reinterpret_cast<void (*)()>(glVertexAttribI3uiv),"glVertexAttribI3uiv");
    _driver.call(&_driver.glVertexAttribI3uiv)(index, v);
  }

  static void REGAL_CALL glVertexAttribI4bv(GLuint index, const GLbyte *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribI4bv),reinterpret_cast<void (*)()>(glVertexAttribI4bv),"glVertexAttribI4bv");
    _driver.call(&_driver.glVertexAttribI4bv)(index, v);
  }

  static void REGAL_CALL glVertexAttribI4i(GLuint index, GLint x, GLint y, GLint z, GLint w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribI4i),reinterpret_cast<void (*)()>(glVertexAttribI4i),"glVertexAttribI4i");
    _driver.call(&_driver.glVertexAttribI4i)(index, x, y, z, w);
  }

  static void REGAL_CALL glVertexAttribI4iv(GLuint index, const GLint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribI4iv),reinterpret_cast<void (*)()>(glVertexAttribI4iv),"glVertexAttribI4iv");
    _driver.call(&_driver.glVertexAttribI4iv)(index, v);
  }

  static void REGAL_CALL glVertexAttribI4sv(GLuint index, const GLshort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribI4sv),reinterpret_cast<void (*)()>(glVertexAttribI4sv),"glVertexAttribI4sv");
    _driver.call(&_driver.glVertexAttribI4sv)(index, v);
  }

  static void REGAL_CALL glVertexAttribI4ubv(GLuint index, const GLubyte *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribI4ubv),reinterpret_cast<void (*)()>(glVertexAttribI4ubv),"glVertexAttribI4ubv");
    _driver.call(&_driver.glVertexAttribI4ubv)(index, v);
  }

  static void REGAL_CALL glVertexAttribI4ui(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribI4ui),reinterpret_cast<void (*)()>(glVertexAttribI4ui),"glVertexAttribI4ui");
    _driver.call(&_driver.glVertexAttribI4ui)(index, x, y, z, w);
  }

  static void REGAL_CALL glVertexAttribI4uiv(GLuint index, const GLuint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribI4uiv),reinterpret_cast<void (*)()>(glVertexAttribI4uiv),"glVertexAttribI4uiv");
    _driver.call(&_driver.glVertexAttribI4uiv)(index, v);
  }

  static void REGAL_CALL glVertexAttribI4usv(GLuint index, const GLushort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribI4usv),reinterpret_cast<void (*)()>(glVertexAttribI4usv),"glVertexAttribI4usv");
    _driver.call(&_driver.glVertexAttribI4usv)(index, v);
  }

  static void REGAL_CALL glVertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribIPointer),reinterpret_cast<void (*)()>(glVertexAttribIPointer),"glVertexAttribIPointer");
    _driver.call(&_driver.glVertexAttribIPointer)(index, size, type, stride, pointer);
  }

// GL_VERSION_3_1

  static void REGAL_CALL glDrawArraysInstanced(GLenum mode, GLint start, GLsizei count, GLsizei primcount)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDrawArraysInstanced),reinterpret_cast<void (*)()>(glDrawArraysInstanced),"glDrawArraysInstanced");
    _driver.call(&_driver.glDrawArraysInstanced)(mode, start, count, primcount);
  }

  static void REGAL_CALL glDrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDrawElementsInstanced),reinterpret_cast<void (*)()>(glDrawElementsInstanced),"glDrawElementsInstanced");
    _driver.call(&_driver.glDrawElementsInstanced)(mode, count, type, indices, primcount);
  }

  static void REGAL_CALL glPrimitiveRestartIndex(GLuint index)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPrimitiveRestartIndex),reinterpret_cast<void (*)()>(glPrimitiveRestartIndex),"glPrimitiveRestartIndex");
    _driver.call(&_driver.glPrimitiveRestartIndex)(index);
  }

  static void REGAL_CALL glTexBuffer(GLenum target, GLenum internalformat, GLuint buffer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexBuffer),reinterpret_cast<void (*)()>(glTexBuffer),"glTexBuffer");
    _driver.call(&_driver.glTexBuffer)(target, internalformat, buffer);
  }

// GL_VERSION_3_2

  static void REGAL_CALL glFramebufferTexture(GLenum target, GLenum attachment, GLuint texture, GLint level)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFramebufferTexture),reinterpret_cast<void (*)()>(glFramebufferTexture),"glFramebufferTexture");
    _driver.call(&_driver.glFramebufferTexture)(target, attachment, texture, level);
  }

  static void REGAL_CALL glGetBufferParameteri64v(GLenum target, GLenum pname, GLint64 *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetBufferParameteri64v),reinterpret_cast<void (*)()>(glGetBufferParameteri64v),"glGetBufferParameteri64v");
    _driver.call(&_driver.glGetBufferParameteri64v)(target, pname, params);
  }

  static void REGAL_CALL glGetInteger64i_v(GLenum target, GLuint index, GLint64 *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetInteger64i_v),reinterpret_cast<void (*)()>(glGetInteger64i_v),"glGetInteger64i_v");
    _driver.call(&_driver.glGetInteger64i_v)(target, index, data);
  }

// GL_VERSION_3_3

  static void REGAL_CALL glVertexAttribDivisor(GLuint index, GLuint divisor)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribDivisor),reinterpret_cast<void (*)()>(glVertexAttribDivisor),"glVertexAttribDivisor");
    _driver.call(&_driver.glVertexAttribDivisor)(index, divisor);
  }

// GL_VERSION_4_0

  static void REGAL_CALL glBlendEquationSeparatei(GLuint buf, GLenum modeRGB, GLenum modeAlpha)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBlendEquationSeparatei),reinterpret_cast<void (*)()>(glBlendEquationSeparatei),"glBlendEquationSeparatei");
    _driver.call(&_driver.glBlendEquationSeparatei)(buf, modeRGB, modeAlpha);
  }

  static void REGAL_CALL glBlendEquationi(GLuint buf, GLenum mode)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBlendEquationi),reinterpret_cast<void (*)()>(glBlendEquationi),"glBlendEquationi");
    _driver.call(&_driver.glBlendEquationi)(buf, mode);
  }

  static void REGAL_CALL glBlendFuncSeparatei(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBlendFuncSeparatei),reinterpret_cast<void (*)()>(glBlendFuncSeparatei),"glBlendFuncSeparatei");
    _driver.call(&_driver.glBlendFuncSeparatei)(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
  }

  static void REGAL_CALL glBlendFunci(GLuint buf, GLenum src, GLenum dst)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBlendFunci),reinterpret_cast<void (*)()>(glBlendFunci),"glBlendFunci");
    _driver.call(&_driver.glBlendFunci)(buf, src, dst);
  }

// GL_3DFX_tbuffer

  static void REGAL_CALL glTbufferMask3DFX(GLuint mask)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTbufferMask3DFX),reinterpret_cast<void (*)()>(glTbufferMask3DFX),"glTbufferMask3DFX");
    _driver.call(&_driver.glTbufferMask3DFX)(mask);
  }

// GL_AMD_debug_output

  static void REGAL_CALL glDebugMessageCallbackAMD(GLDEBUGPROCAMD callback, GLvoid *userParam)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDebugMessageCallbackAMD),reinterpret_cast<void (*)()>(glDebugMessageCallbackAMD),"glDebugMessageCallbackAMD");
    _driver.call(&_driver.glDebugMessageCallbackAMD)(callback, userParam);
  }

  static void REGAL_CALL glDebugMessageEnableAMD(GLenum category, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDebugMessageEnableAMD),reinterpret_cast<void (*)()>(glDebugMessageEnableAMD),"glDebugMessageEnableAMD");
    _driver.call(&_driver.glDebugMessageEnableAMD)(category, severity, count, ids, enabled);
  }

  static void REGAL_CALL glDebugMessageInsertAMD(GLenum category, GLenum severity, GLuint id, GLsizei length, const GLchar *buf)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDebugMessageInsertAMD),reinterpret_cast<void (*)()>(glDebugMessageInsertAMD),"glDebugMessageInsertAMD");
    _driver.call(&_driver.glDebugMessageInsertAMD)(category, severity, id, length, buf);
  }

  static GLuint REGAL_CALL glGetDebugMessageLogAMD(GLuint count, GLsizei bufsize, GLenum *categories, GLuint *severities, GLuint *ids, GLsizei *lengths, GLchar *message)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetDebugMessageLogAMD),reinterpret_cast<void (*)()>(glGetDebugMessageLogAMD),"glGetDebugMessageLogAMD");
    return _driver.call(&_driver.glGetDebugMessageLogAMD)(count, bufsize, categories, severities, ids, lengths, message);
  }

// GL_AMD_draw_buffers_blend

  static void REGAL_CALL glBlendEquationIndexedAMD(GLuint buf, GLenum mode)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBlendEquationIndexedAMD),reinterpret_cast<void (*)()>(glBlendEquationIndexedAMD),"glBlendEquationIndexedAMD");
    _driver.call(&_driver.glBlendEquationIndexedAMD)(buf, mode);
  }

  static void REGAL_CALL glBlendEquationSeparateIndexedAMD(GLuint buf, GLenum modeRGB, GLenum modeAlpha)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBlendEquationSeparateIndexedAMD),reinterpret_cast<void (*)()>(glBlendEquationSeparateIndexedAMD),"glBlendEquationSeparateIndexedAMD");
    _driver.call(&_driver.glBlendEquationSeparateIndexedAMD)(buf, modeRGB, modeAlpha);
  }

  static void REGAL_CALL glBlendFuncIndexedAMD(GLuint buf, GLenum src, GLenum dst)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBlendFuncIndexedAMD),reinterpret_cast<void (*)()>(glBlendFuncIndexedAMD),"glBlendFuncIndexedAMD");
    _driver.call(&_driver.glBlendFuncIndexedAMD)(buf, src, dst);
  }

  static void REGAL_CALL glBlendFuncSeparateIndexedAMD(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBlendFuncSeparateIndexedAMD),reinterpret_cast<void (*)()>(glBlendFuncSeparateIndexedAMD),"glBlendFuncSeparateIndexedAMD");
    _driver.call(&_driver.glBlendFuncSeparateIndexedAMD)(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
  }

// GL_AMD_interleaved_elements

  static void REGAL_CALL glVertexAttribParameteriAMD(GLuint index, GLenum pname, GLint param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribParameteriAMD),reinterpret_cast<void (*)()>(glVertexAttribParameteriAMD),"glVertexAttribParameteriAMD");
    _driver.call(&_driver.glVertexAttribParameteriAMD)(index, pname, param);
  }

// GL_AMD_multi_draw_indirect

  static void REGAL_CALL glMultiDrawArraysIndirectAMD(GLenum mode, const GLvoid *indirect, GLsizei primcount, GLsizei stride)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiDrawArraysIndirectAMD),reinterpret_cast<void (*)()>(glMultiDrawArraysIndirectAMD),"glMultiDrawArraysIndirectAMD");
    _driver.call(&_driver.glMultiDrawArraysIndirectAMD)(mode, indirect, primcount, stride);
  }

  static void REGAL_CALL glMultiDrawElementsIndirectAMD(GLenum mode, GLenum type, const GLvoid *indirect, GLsizei primcount, GLsizei stride)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiDrawElementsIndirectAMD),reinterpret_cast<void (*)()>(glMultiDrawElementsIndirectAMD),"glMultiDrawElementsIndirectAMD");
    _driver.call(&_driver.glMultiDrawElementsIndirectAMD)(mode, type, indirect, primcount, stride);
  }

// GL_AMD_name_gen_delete

  static void REGAL_CALL glDeleteNamesAMD(GLenum identifier, GLuint num, const GLuint *names)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDeleteNamesAMD),reinterpret_cast<void (*)()>(glDeleteNamesAMD),"glDeleteNamesAMD");
    _driver.call(&_driver.glDeleteNamesAMD)(identifier, num, names);
  }

  static void REGAL_CALL glGenNamesAMD(GLenum identifier, GLuint num, GLuint *names)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGenNamesAMD),reinterpret_cast<void (*)()>(glGenNamesAMD),"glGenNamesAMD");
    _driver.call(&_driver.glGenNamesAMD)(identifier, num, names);
  }

  static GLboolean REGAL_CALL glIsNameAMD(GLenum identifier, GLuint name)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIsNameAMD),reinterpret_cast<void (*)()>(glIsNameAMD),"glIsNameAMD");
    return _driver.call(&_driver.glIsNameAMD)(identifier, name);
  }

// GL_AMD_performance_monitor

  static void REGAL_CALL glBeginPerfMonitorAMD(GLuint monitor)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBeginPerfMonitorAMD),reinterpret_cast<void (*)()>(glBeginPerfMonitorAMD),"glBeginPerfMonitorAMD");
    _driver.call(&_driver.glBeginPerfMonitorAMD)(monitor);
  }

  static void REGAL_CALL glDeletePerfMonitorsAMD(GLsizei n, GLuint *monitors)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDeletePerfMonitorsAMD),reinterpret_cast<void (*)()>(glDeletePerfMonitorsAMD),"glDeletePerfMonitorsAMD");
    _driver.call(&_driver.glDeletePerfMonitorsAMD)(n, monitors);
  }

  static void REGAL_CALL glEndPerfMonitorAMD(GLuint monitor)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glEndPerfMonitorAMD),reinterpret_cast<void (*)()>(glEndPerfMonitorAMD),"glEndPerfMonitorAMD");
    _driver.call(&_driver.glEndPerfMonitorAMD)(monitor);
  }

  static void REGAL_CALL glGenPerfMonitorsAMD(GLsizei n, GLuint *monitors)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGenPerfMonitorsAMD),reinterpret_cast<void (*)()>(glGenPerfMonitorsAMD),"glGenPerfMonitorsAMD");
    _driver.call(&_driver.glGenPerfMonitorsAMD)(n, monitors);
  }

  static void REGAL_CALL glGetPerfMonitorCounterDataAMD(GLuint monitor, GLenum pname, GLsizei dataSize, GLuint *data, GLint *bytesWritten)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetPerfMonitorCounterDataAMD),reinterpret_cast<void (*)()>(glGetPerfMonitorCounterDataAMD),"glGetPerfMonitorCounterDataAMD");
    _driver.call(&_driver.glGetPerfMonitorCounterDataAMD)(monitor, pname, dataSize, data, bytesWritten);
  }

  static void REGAL_CALL glGetPerfMonitorCounterInfoAMD(GLuint group, GLuint counter, GLenum pname, GLvoid *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetPerfMonitorCounterInfoAMD),reinterpret_cast<void (*)()>(glGetPerfMonitorCounterInfoAMD),"glGetPerfMonitorCounterInfoAMD");
    _driver.call(&_driver.glGetPerfMonitorCounterInfoAMD)(group, counter, pname, data);
  }

  static void REGAL_CALL glGetPerfMonitorCounterStringAMD(GLuint group, GLuint counter, GLsizei bufSize, GLsizei *length, GLchar *counterString)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetPerfMonitorCounterStringAMD),reinterpret_cast<void (*)()>(glGetPerfMonitorCounterStringAMD),"glGetPerfMonitorCounterStringAMD");
    _driver.call(&_driver.glGetPerfMonitorCounterStringAMD)(group, counter, bufSize, length, counterString);
  }

  static void REGAL_CALL glGetPerfMonitorCountersAMD(GLuint group, GLint *numCounters, GLint *maxActiveCounters, GLsizei countersSize, GLuint *counters)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetPerfMonitorCountersAMD),reinterpret_cast<void (*)()>(glGetPerfMonitorCountersAMD),"glGetPerfMonitorCountersAMD");
    _driver.call(&_driver.glGetPerfMonitorCountersAMD)(group, numCounters, maxActiveCounters, countersSize, counters);
  }

  static void REGAL_CALL glGetPerfMonitorGroupStringAMD(GLuint group, GLsizei bufSize, GLsizei *length, GLchar *groupString)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetPerfMonitorGroupStringAMD),reinterpret_cast<void (*)()>(glGetPerfMonitorGroupStringAMD),"glGetPerfMonitorGroupStringAMD");
    _driver.call(&_driver.glGetPerfMonitorGroupStringAMD)(group, bufSize, length, groupString);
  }

  static void REGAL_CALL glGetPerfMonitorGroupsAMD(GLint *numGroups, GLsizei groupsSize, GLuint *groups)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetPerfMonitorGroupsAMD),reinterpret_cast<void (*)()>(glGetPerfMonitorGroupsAMD),"glGetPerfMonitorGroupsAMD");
    _driver.call(&_driver.glGetPerfMonitorGroupsAMD)(numGroups, groupsSize, groups);
  }

  static void REGAL_CALL glSelectPerfMonitorCountersAMD(GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint *counterList)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSelectPerfMonitorCountersAMD),reinterpret_cast<void (*)()>(glSelectPerfMonitorCountersAMD),"glSelectPerfMonitorCountersAMD");
    _driver.call(&_driver.glSelectPerfMonitorCountersAMD)(monitor, enable, group, numCounters, counterList);
  }

// GL_AMD_sample_positions

  static void REGAL_CALL glSetMultisamplefvAMD(GLenum pname, GLuint index, const GLfloat *val)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSetMultisamplefvAMD),reinterpret_cast<void (*)()>(glSetMultisamplefvAMD),"glSetMultisamplefvAMD");
    _driver.call(&_driver.glSetMultisamplefvAMD)(pname, index, val);
  }

// GL_AMD_sparse_texture

  static void REGAL_CALL glTexStorageSparseAMD(GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexStorageSparseAMD),reinterpret_cast<void (*)()>(glTexStorageSparseAMD),"glTexStorageSparseAMD");
    _driver.call(&_driver.glTexStorageSparseAMD)(target, internalFormat, width, height, depth, layers, flags);
  }

  static void REGAL_CALL glTextureStorageSparseAMD(GLuint texture, GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTextureStorageSparseAMD),reinterpret_cast<void (*)()>(glTextureStorageSparseAMD),"glTextureStorageSparseAMD");
    _driver.call(&_driver.glTextureStorageSparseAMD)(texture, target, internalFormat, width, height, depth, layers, flags);
  }

// GL_AMD_stencil_operation_extended

  static void REGAL_CALL glStencilOpValueAMD(GLenum face, GLuint value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glStencilOpValueAMD),reinterpret_cast<void (*)()>(glStencilOpValueAMD),"glStencilOpValueAMD");
    _driver.call(&_driver.glStencilOpValueAMD)(face, value);
  }

// GL_AMD_vertex_shader_tessellator

  static void REGAL_CALL glTessellationFactorAMD(GLfloat factor)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTessellationFactorAMD),reinterpret_cast<void (*)()>(glTessellationFactorAMD),"glTessellationFactorAMD");
    _driver.call(&_driver.glTessellationFactorAMD)(factor);
  }

  static void REGAL_CALL glTessellationModeAMD(GLenum mode)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTessellationModeAMD),reinterpret_cast<void (*)()>(glTessellationModeAMD),"glTessellationModeAMD");
    _driver.call(&_driver.glTessellationModeAMD)(mode);
  }

// GL_ANGLE_framebuffer_blit

  static void REGAL_CALL glBlitFramebufferANGLE(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBlitFramebufferANGLE),reinterpret_cast<void (*)()>(glBlitFramebufferANGLE),"glBlitFramebufferANGLE");
    _driver.call(&_driver.glBlitFramebufferANGLE)(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
  }

// GL_ANGLE_framebuffer_multisample

  static void REGAL_CALL glRenderbufferStorageMultisampleANGLE(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glRenderbufferStorageMultisampleANGLE),reinterpret_cast<void (*)()>(glRenderbufferStorageMultisampleANGLE),"glRenderbufferStorageMultisampleANGLE");
    _driver.call(&_driver.glRenderbufferStorageMultisampleANGLE)(target, samples, internalformat, width, height);
  }

// GL_ANGLE_instanced_arrays

  static void REGAL_CALL glDrawArraysInstancedANGLE(GLenum mode, GLint first, GLsizei count, GLsizei primcount)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDrawArraysInstancedANGLE),reinterpret_cast<void (*)()>(glDrawArraysInstancedANGLE),"glDrawArraysInstancedANGLE");
    _driver.call(&_driver.glDrawArraysInstancedANGLE)(mode, first, count, primcount);
  }

  static void REGAL_CALL glDrawElementsInstancedANGLE(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDrawElementsInstancedANGLE),reinterpret_cast<void (*)()>(glDrawElementsInstancedANGLE),"glDrawElementsInstancedANGLE");
    _driver.call(&_driver.glDrawElementsInstancedANGLE)(mode, count, type, indices, primcount);
  }

  static void REGAL_CALL glVertexAttribDivisorANGLE(GLuint index, GLuint divisor)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribDivisorANGLE),reinterpret_cast<void (*)()>(glVertexAttribDivisorANGLE),"glVertexAttribDivisorANGLE");
    _driver.call(&_driver.glVertexAttribDivisorANGLE)(index, divisor);
  }

// GL_ANGLE_timer_query

  static void REGAL_CALL glBeginQueryANGLE(GLenum target, GLuint id)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBeginQueryANGLE),reinterpret_cast<void (*)()>(glBeginQueryANGLE),"glBeginQueryANGLE");
    _driver.call(&_driver.glBeginQueryANGLE)(target, id);
  }

  static void REGAL_CALL glDeleteQueriesANGLE(GLsizei n, const GLuint *ids)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDeleteQueriesANGLE),reinterpret_cast<void (*)()>(glDeleteQueriesANGLE),"glDeleteQueriesANGLE");
    _driver.call(&_driver.glDeleteQueriesANGLE)(n, ids);
  }

  static void REGAL_CALL glEndQueryANGLE(GLenum target)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glEndQueryANGLE),reinterpret_cast<void (*)()>(glEndQueryANGLE),"glEndQueryANGLE");
    _driver.call(&_driver.glEndQueryANGLE)(target);
  }

  static void REGAL_CALL glGenQueriesANGLE(GLsizei n, GLuint *ids)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGenQueriesANGLE),reinterpret_cast<void (*)()>(glGenQueriesANGLE),"glGenQueriesANGLE");
    _driver.call(&_driver.glGenQueriesANGLE)(n, ids);
  }

  static void REGAL_CALL glGetQueryObjecti64vANGLE(GLuint id, GLenum pname, GLint64 *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetQueryObjecti64vANGLE),reinterpret_cast<void (*)()>(glGetQueryObjecti64vANGLE),"glGetQueryObjecti64vANGLE");
    _driver.call(&_driver.glGetQueryObjecti64vANGLE)(id, pname, params);
  }

  static void REGAL_CALL glGetQueryObjectivANGLE(GLuint id, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetQueryObjectivANGLE),reinterpret_cast<void (*)()>(glGetQueryObjectivANGLE),"glGetQueryObjectivANGLE");
    _driver.call(&_driver.glGetQueryObjectivANGLE)(id, pname, params);
  }

  static void REGAL_CALL glGetQueryObjectui64vANGLE(GLuint id, GLenum pname, GLuint64 *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetQueryObjectui64vANGLE),reinterpret_cast<void (*)()>(glGetQueryObjectui64vANGLE),"glGetQueryObjectui64vANGLE");
    _driver.call(&_driver.glGetQueryObjectui64vANGLE)(id, pname, params);
  }

  static void REGAL_CALL glGetQueryObjectuivANGLE(GLuint id, GLenum pname, GLuint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetQueryObjectuivANGLE),reinterpret_cast<void (*)()>(glGetQueryObjectuivANGLE),"glGetQueryObjectuivANGLE");
    _driver.call(&_driver.glGetQueryObjectuivANGLE)(id, pname, params);
  }

  static void REGAL_CALL glGetQueryivANGLE(GLenum target, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetQueryivANGLE),reinterpret_cast<void (*)()>(glGetQueryivANGLE),"glGetQueryivANGLE");
    _driver.call(&_driver.glGetQueryivANGLE)(target, pname, params);
  }

  static GLboolean REGAL_CALL glIsQueryANGLE(GLuint id)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIsQueryANGLE),reinterpret_cast<void (*)()>(glIsQueryANGLE),"glIsQueryANGLE");
    return _driver.call(&_driver.glIsQueryANGLE)(id);
  }

  static void REGAL_CALL glQueryCounterANGLE(GLuint id, GLenum target)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glQueryCounterANGLE),reinterpret_cast<void (*)()>(glQueryCounterANGLE),"glQueryCounterANGLE");
    _driver.call(&_driver.glQueryCounterANGLE)(id, target);
  }

// GL_ANGLE_translated_shader_source

  static void REGAL_CALL glGetTranslatedShaderSourceANGLE(GLuint shader, GLsizei bufsize, GLsizei *length, GLchar *source)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetTranslatedShaderSourceANGLE),reinterpret_cast<void (*)()>(glGetTranslatedShaderSourceANGLE),"glGetTranslatedShaderSourceANGLE");
    _driver.call(&_driver.glGetTranslatedShaderSourceANGLE)(shader, bufsize, length, source);
  }

// GL_APPLE_copy_texture_levels

  static void REGAL_CALL glCopyTextureLevelsAPPLE(GLuint destinationTexture, GLuint sourceTexture, GLint sourceBaseLevel, GLsizei sourceLevelCount)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCopyTextureLevelsAPPLE),reinterpret_cast<void (*)()>(glCopyTextureLevelsAPPLE),"glCopyTextureLevelsAPPLE");
    _driver.call(&_driver.glCopyTextureLevelsAPPLE)(destinationTexture, sourceTexture, sourceBaseLevel, sourceLevelCount);
  }

// GL_APPLE_element_array

  static void REGAL_CALL glDrawElementArrayAPPLE(GLenum mode, GLint first, GLsizei count)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDrawElementArrayAPPLE),reinterpret_cast<void (*)()>(glDrawElementArrayAPPLE),"glDrawElementArrayAPPLE");
    _driver.call(&_driver.glDrawElementArrayAPPLE)(mode, first, count);
  }

  static void REGAL_CALL glDrawRangeElementArrayAPPLE(GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDrawRangeElementArrayAPPLE),reinterpret_cast<void (*)()>(glDrawRangeElementArrayAPPLE),"glDrawRangeElementArrayAPPLE");
    _driver.call(&_driver.glDrawRangeElementArrayAPPLE)(mode, start, end, first, count);
  }

  static void REGAL_CALL glElementPointerAPPLE(GLenum type, const GLvoid *pointer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glElementPointerAPPLE),reinterpret_cast<void (*)()>(glElementPointerAPPLE),"glElementPointerAPPLE");
    _driver.call(&_driver.glElementPointerAPPLE)(type, pointer);
  }

  static void REGAL_CALL glMultiDrawElementArrayAPPLE(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiDrawElementArrayAPPLE),reinterpret_cast<void (*)()>(glMultiDrawElementArrayAPPLE),"glMultiDrawElementArrayAPPLE");
    _driver.call(&_driver.glMultiDrawElementArrayAPPLE)(mode, first, count, primcount);
  }

  static void REGAL_CALL glMultiDrawRangeElementArrayAPPLE(GLenum mode, GLuint start, GLuint end, const GLint *first, const GLsizei *count, GLsizei primcount)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiDrawRangeElementArrayAPPLE),reinterpret_cast<void (*)()>(glMultiDrawRangeElementArrayAPPLE),"glMultiDrawRangeElementArrayAPPLE");
    _driver.call(&_driver.glMultiDrawRangeElementArrayAPPLE)(mode, start, end, first, count, primcount);
  }

// GL_APPLE_fence

  static void REGAL_CALL glDeleteFencesAPPLE(GLsizei n, const GLuint *fences)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDeleteFencesAPPLE),reinterpret_cast<void (*)()>(glDeleteFencesAPPLE),"glDeleteFencesAPPLE");
    _driver.call(&_driver.glDeleteFencesAPPLE)(n, fences);
  }

  static void REGAL_CALL glFinishFenceAPPLE(GLuint fence)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFinishFenceAPPLE),reinterpret_cast<void (*)()>(glFinishFenceAPPLE),"glFinishFenceAPPLE");
    _driver.call(&_driver.glFinishFenceAPPLE)(fence);
  }

  static void REGAL_CALL glFinishObjectAPPLE(GLenum object, GLint name)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFinishObjectAPPLE),reinterpret_cast<void (*)()>(glFinishObjectAPPLE),"glFinishObjectAPPLE");
    _driver.call(&_driver.glFinishObjectAPPLE)(object, name);
  }

  static void REGAL_CALL glGenFencesAPPLE(GLsizei n, GLuint *fences)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGenFencesAPPLE),reinterpret_cast<void (*)()>(glGenFencesAPPLE),"glGenFencesAPPLE");
    _driver.call(&_driver.glGenFencesAPPLE)(n, fences);
  }

  static GLboolean REGAL_CALL glIsFenceAPPLE(GLuint fence)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIsFenceAPPLE),reinterpret_cast<void (*)()>(glIsFenceAPPLE),"glIsFenceAPPLE");
    return _driver.call(&_driver.glIsFenceAPPLE)(fence);
  }

  static void REGAL_CALL glSetFenceAPPLE(GLuint fence)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSetFenceAPPLE),reinterpret_cast<void (*)()>(glSetFenceAPPLE),"glSetFenceAPPLE");
    _driver.call(&_driver.glSetFenceAPPLE)(fence);
  }

  static GLboolean REGAL_CALL glTestFenceAPPLE(GLuint fence)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTestFenceAPPLE),reinterpret_cast<void (*)()>(glTestFenceAPPLE),"glTestFenceAPPLE");
    return _driver.call(&_driver.glTestFenceAPPLE)(fence);
  }

  static GLboolean REGAL_CALL glTestObjectAPPLE(GLenum object, GLuint name)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTestObjectAPPLE),reinterpret_cast<void (*)()>(glTestObjectAPPLE),"glTestObjectAPPLE");
    return _driver.call(&_driver.glTestObjectAPPLE)(object, name);
  }

// GL_APPLE_flush_buffer_range

  static void REGAL_CALL glBufferParameteriAPPLE(GLenum target, GLenum pname, GLint param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBufferParameteriAPPLE),reinterpret_cast<void (*)()>(glBufferParameteriAPPLE),"glBufferParameteriAPPLE");
    _driver.call(&_driver.glBufferParameteriAPPLE)(target, pname, param);
  }

  static void REGAL_CALL glFlushMappedBufferRangeAPPLE(GLenum target, GLintptr offset, GLsizeiptr size)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFlushMappedBufferRangeAPPLE),reinterpret_cast<void (*)()>(glFlushMappedBufferRangeAPPLE),"glFlushMappedBufferRangeAPPLE");
    _driver.call(&_driver.glFlushMappedBufferRangeAPPLE)(target, offset, size);
  }

// GL_APPLE_flush_render

  static void REGAL_CALL glFinishRenderAPPLE(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFinishRenderAPPLE),reinterpret_cast<void (*)()>(glFinishRenderAPPLE),"glFinishRenderAPPLE");
    _driver.call(&_driver.glFinishRenderAPPLE)();
  }

  static void REGAL_CALL glFlushRenderAPPLE(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFlushRenderAPPLE),reinterpret_cast<void (*)()>(glFlushRenderAPPLE),"glFlushRenderAPPLE");
    _driver.call(&_driver.glFlushRenderAPPLE)();
  }

  static void REGAL_CALL glSwapAPPLE(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSwapAPPLE),reinterpret_cast<void (*)()>(glSwapAPPLE),"glSwapAPPLE");
    _driver.call(&_driver.glSwapAPPLE)();
  }

// GL_APPLE_framebuffer_multisample

  static void REGAL_CALL glRenderbufferStorageMultisampleAPPLE(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glRenderbufferStorageMultisampleAPPLE),reinterpret_cast<void (*)()>(glRenderbufferStorageMultisampleAPPLE),"glRenderbufferStorageMultisampleAPPLE");
    _driver.call(&_driver.glRenderbufferStorageMultisampleAPPLE)(target, samples, internalformat, width, height);
  }

  static void REGAL_CALL glResolveMultisampleFramebufferAPPLE(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glResolveMultisampleFramebufferAPPLE),reinterpret_cast<void (*)()>(glResolveMultisampleFramebufferAPPLE),"glResolveMultisampleFramebufferAPPLE");
    _driver.call(&_driver.glResolveMultisampleFramebufferAPPLE)();
  }

// GL_APPLE_object_purgeable

  static void REGAL_CALL glGetObjectParameterivAPPLE(GLenum objectType, GLuint name, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetObjectParameterivAPPLE),reinterpret_cast<void (*)()>(glGetObjectParameterivAPPLE),"glGetObjectParameterivAPPLE");
    _driver.call(&_driver.glGetObjectParameterivAPPLE)(objectType, name, pname, params);
  }

  static GLenum REGAL_CALL glObjectPurgeableAPPLE(GLenum objectType, GLuint name, GLenum option)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glObjectPurgeableAPPLE),reinterpret_cast<void (*)()>(glObjectPurgeableAPPLE),"glObjectPurgeableAPPLE");
    return _driver.call(&_driver.glObjectPurgeableAPPLE)(objectType, name, option);
  }

  static GLenum REGAL_CALL glObjectUnpurgeableAPPLE(GLenum objectType, GLuint name, GLenum option)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glObjectUnpurgeableAPPLE),reinterpret_cast<void (*)()>(glObjectUnpurgeableAPPLE),"glObjectUnpurgeableAPPLE");
    return _driver.call(&_driver.glObjectUnpurgeableAPPLE)(objectType, name, option);
  }

// GL_APPLE_sync

  static GLenum REGAL_CALL glClientWaitSyncAPPLE(GLsync sync, GLbitfield flags, GLuint64 timeout)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glClientWaitSyncAPPLE),reinterpret_cast<void (*)()>(glClientWaitSyncAPPLE),"glClientWaitSyncAPPLE");
    return _driver.call(&_driver.glClientWaitSyncAPPLE)(sync, flags, timeout);
  }

  static void REGAL_CALL glDeleteSyncAPPLE(GLsync sync)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDeleteSyncAPPLE),reinterpret_cast<void (*)()>(glDeleteSyncAPPLE),"glDeleteSyncAPPLE");
    _driver.call(&_driver.glDeleteSyncAPPLE)(sync);
  }

  static GLsync REGAL_CALL glFenceSyncAPPLE(GLenum condition, GLbitfield flags)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFenceSyncAPPLE),reinterpret_cast<void (*)()>(glFenceSyncAPPLE),"glFenceSyncAPPLE");
    return _driver.call(&_driver.glFenceSyncAPPLE)(condition, flags);
  }

  static void REGAL_CALL glGetInteger64vAPPLE(GLenum pname, GLint64 *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetInteger64vAPPLE),reinterpret_cast<void (*)()>(glGetInteger64vAPPLE),"glGetInteger64vAPPLE");
    _driver.call(&_driver.glGetInteger64vAPPLE)(pname, params);
  }

  static void REGAL_CALL glGetSyncivAPPLE(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetSyncivAPPLE),reinterpret_cast<void (*)()>(glGetSyncivAPPLE),"glGetSyncivAPPLE");
    _driver.call(&_driver.glGetSyncivAPPLE)(sync, pname, bufSize, length, values);
  }

  static GLboolean REGAL_CALL glIsSyncAPPLE(GLsync sync)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIsSyncAPPLE),reinterpret_cast<void (*)()>(glIsSyncAPPLE),"glIsSyncAPPLE");
    return _driver.call(&_driver.glIsSyncAPPLE)(sync);
  }

  static void REGAL_CALL glWaitSyncAPPLE(GLsync sync, GLbitfield flags, GLuint64 timeout)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWaitSyncAPPLE),reinterpret_cast<void (*)()>(glWaitSyncAPPLE),"glWaitSyncAPPLE");
    _driver.call(&_driver.glWaitSyncAPPLE)(sync, flags, timeout);
  }

// GL_APPLE_texture_range

  static void REGAL_CALL glGetTexParameterPointervAPPLE(GLenum target, GLenum pname, GLvoid **params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetTexParameterPointervAPPLE),reinterpret_cast<void (*)()>(glGetTexParameterPointervAPPLE),"glGetTexParameterPointervAPPLE");
    _driver.call(&_driver.glGetTexParameterPointervAPPLE)(target, pname, params);
  }

  static void REGAL_CALL glTextureRangeAPPLE(GLenum target, GLsizei length, const GLvoid *pointer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTextureRangeAPPLE),reinterpret_cast<void (*)()>(glTextureRangeAPPLE),"glTextureRangeAPPLE");
    _driver.call(&_driver.glTextureRangeAPPLE)(target, length, pointer);
  }

// GL_APPLE_vertex_array_object

  static void REGAL_CALL glBindVertexArrayAPPLE(GLuint array)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBindVertexArrayAPPLE),reinterpret_cast<void (*)()>(glBindVertexArrayAPPLE),"glBindVertexArrayAPPLE");
    _driver.call(&_driver.glBindVertexArrayAPPLE)(array);
  }

  static void REGAL_CALL glDeleteVertexArraysAPPLE(GLsizei n, const GLuint *arrays)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDeleteVertexArraysAPPLE),reinterpret_cast<void (*)()>(glDeleteVertexArraysAPPLE),"glDeleteVertexArraysAPPLE");
    _driver.call(&_driver.glDeleteVertexArraysAPPLE)(n, arrays);
  }

  static void REGAL_CALL glGenVertexArraysAPPLE(GLsizei n, GLuint *arrays)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGenVertexArraysAPPLE),reinterpret_cast<void (*)()>(glGenVertexArraysAPPLE),"glGenVertexArraysAPPLE");
    _driver.call(&_driver.glGenVertexArraysAPPLE)(n, arrays);
  }

  static GLboolean REGAL_CALL glIsVertexArrayAPPLE(GLuint array)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIsVertexArrayAPPLE),reinterpret_cast<void (*)()>(glIsVertexArrayAPPLE),"glIsVertexArrayAPPLE");
    return _driver.call(&_driver.glIsVertexArrayAPPLE)(array);
  }

// GL_APPLE_vertex_array_range

  static void REGAL_CALL glFlushVertexArrayRangeAPPLE(GLsizei length, GLvoid *pointer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFlushVertexArrayRangeAPPLE),reinterpret_cast<void (*)()>(glFlushVertexArrayRangeAPPLE),"glFlushVertexArrayRangeAPPLE");
    _driver.call(&_driver.glFlushVertexArrayRangeAPPLE)(length, pointer);
  }

  static void REGAL_CALL glVertexArrayParameteriAPPLE(GLenum pname, GLint param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexArrayParameteriAPPLE),reinterpret_cast<void (*)()>(glVertexArrayParameteriAPPLE),"glVertexArrayParameteriAPPLE");
    _driver.call(&_driver.glVertexArrayParameteriAPPLE)(pname, param);
  }

  static void REGAL_CALL glVertexArrayRangeAPPLE(GLsizei length, GLvoid *pointer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexArrayRangeAPPLE),reinterpret_cast<void (*)()>(glVertexArrayRangeAPPLE),"glVertexArrayRangeAPPLE");
    _driver.call(&_driver.glVertexArrayRangeAPPLE)(length, pointer);
  }

// GL_APPLE_vertex_program_evaluators

  static void REGAL_CALL glDisableVertexAttribAPPLE(GLuint index, GLenum pname)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDisableVertexAttribAPPLE),reinterpret_cast<void (*)()>(glDisableVertexAttribAPPLE),"glDisableVertexAttribAPPLE");
    _driver.call(&_driver.glDisableVertexAttribAPPLE)(index, pname);
  }

  static void REGAL_CALL glEnableVertexAttribAPPLE(GLuint index, GLenum pname)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glEnableVertexAttribAPPLE),reinterpret_cast<void (*)()>(glEnableVertexAttribAPPLE),"glEnableVertexAttribAPPLE");
    _driver.call(&_driver.glEnableVertexAttribAPPLE)(index, pname);
  }

  static GLboolean REGAL_CALL glIsVertexAttribEnabledAPPLE(GLuint index, GLenum pname)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIsVertexAttribEnabledAPPLE),reinterpret_cast<void (*)()>(glIsVertexAttribEnabledAPPLE),"glIsVertexAttribEnabledAPPLE");
    return _driver.call(&_driver.glIsVertexAttribEnabledAPPLE)(index, pname);
  }

  static void REGAL_CALL glMapVertexAttrib1dAPPLE(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMapVertexAttrib1dAPPLE),reinterpret_cast<void (*)()>(glMapVertexAttrib1dAPPLE),"glMapVertexAttrib1dAPPLE");
    _driver.call(&_driver.glMapVertexAttrib1dAPPLE)(index, size, u1, u2, stride, order, points);
  }

  static void REGAL_CALL glMapVertexAttrib1fAPPLE(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMapVertexAttrib1fAPPLE),reinterpret_cast<void (*)()>(glMapVertexAttrib1fAPPLE),"glMapVertexAttrib1fAPPLE");
    _driver.call(&_driver.glMapVertexAttrib1fAPPLE)(index, size, u1, u2, stride, order, points);
  }

  static void REGAL_CALL glMapVertexAttrib2dAPPLE(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMapVertexAttrib2dAPPLE),reinterpret_cast<void (*)()>(glMapVertexAttrib2dAPPLE),"glMapVertexAttrib2dAPPLE");
    _driver.call(&_driver.glMapVertexAttrib2dAPPLE)(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
  }

  static void REGAL_CALL glMapVertexAttrib2fAPPLE(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMapVertexAttrib2fAPPLE),reinterpret_cast<void (*)()>(glMapVertexAttrib2fAPPLE),"glMapVertexAttrib2fAPPLE");
    _driver.call(&_driver.glMapVertexAttrib2fAPPLE)(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
  }

// GL_ARB_ES2_compatibility

  static void REGAL_CALL glClearDepthf(GLclampf d)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glClearDepthf),reinterpret_cast<void (*)()>(glClearDepthf),"glClearDepthf");
    _driver.call(&_driver.glClearDepthf)(d);
  }

  static void REGAL_CALL glDepthRangef(GLclampf n, GLclampf f)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDepthRangef),reinterpret_cast<void (*)()>(glDepthRangef),"glDepthRangef");
    _driver.call(&_driver.glDepthRangef)(n, f);
  }

  static void REGAL_CALL glGetShaderPrecisionFormat(GLenum shadertype, GLenum precisiontype, GLint *range, GLint *precision)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetShaderPrecisionFormat),reinterpret_cast<void (*)()>(glGetShaderPrecisionFormat),"glGetShaderPrecisionFormat");
    _driver.call(&_driver.glGetShaderPrecisionFormat)(shadertype, precisiontype, range, precision);
  }

  static void REGAL_CALL glReleaseShaderCompiler(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glReleaseShaderCompiler),reinterpret_cast<void (*)()>(glReleaseShaderCompiler),"glReleaseShaderCompiler");
    _driver.call(&_driver.glReleaseShaderCompiler)();
  }

  static void REGAL_CALL glShaderBinary(GLsizei count, const GLuint *shaders, GLenum binaryformat, const GLvoid *binary, GLsizei length)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glShaderBinary),reinterpret_cast<void (*)()>(glShaderBinary),"glShaderBinary");
    _driver.call(&_driver.glShaderBinary)(count, shaders, binaryformat, binary, length);
  }

// GL_ARB_base_instance

  static void REGAL_CALL glDrawArraysInstancedBaseInstance(GLenum mode, GLint first, GLsizei count, GLsizei primcount, GLuint baseinstance)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDrawArraysInstancedBaseInstance),reinterpret_cast<void (*)()>(glDrawArraysInstancedBaseInstance),"glDrawArraysInstancedBaseInstance");
    _driver.call(&_driver.glDrawArraysInstancedBaseInstance)(mode, first, count, primcount, baseinstance);
  }

  static void REGAL_CALL glDrawElementsInstancedBaseInstance(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount, GLuint baseinstance)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDrawElementsInstancedBaseInstance),reinterpret_cast<void (*)()>(glDrawElementsInstancedBaseInstance),"glDrawElementsInstancedBaseInstance");
    _driver.call(&_driver.glDrawElementsInstancedBaseInstance)(mode, count, type, indices, primcount, baseinstance);
  }

  static void REGAL_CALL glDrawElementsInstancedBaseVertexBaseInstance(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount, GLint basevertex, GLuint baseinstance)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDrawElementsInstancedBaseVertexBaseInstance),reinterpret_cast<void (*)()>(glDrawElementsInstancedBaseVertexBaseInstance),"glDrawElementsInstancedBaseVertexBaseInstance");
    _driver.call(&_driver.glDrawElementsInstancedBaseVertexBaseInstance)(mode, count, type, indices, primcount, basevertex, baseinstance);
  }

// GL_ARB_bindless_texture

  static GLuint64 REGAL_CALL glGetImageHandleARB(GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetImageHandleARB),reinterpret_cast<void (*)()>(glGetImageHandleARB),"glGetImageHandleARB");
    return _driver.call(&_driver.glGetImageHandleARB)(texture, level, layered, layer, format);
  }

  static GLuint64 REGAL_CALL glGetTextureHandleARB(GLuint texture)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetTextureHandleARB),reinterpret_cast<void (*)()>(glGetTextureHandleARB),"glGetTextureHandleARB");
    return _driver.call(&_driver.glGetTextureHandleARB)(texture);
  }

  static GLuint64 REGAL_CALL glGetTextureSamplerHandleARB(GLuint texture, GLuint sampler)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetTextureSamplerHandleARB),reinterpret_cast<void (*)()>(glGetTextureSamplerHandleARB),"glGetTextureSamplerHandleARB");
    return _driver.call(&_driver.glGetTextureSamplerHandleARB)(texture, sampler);
  }

  static void REGAL_CALL glGetVertexAttribLui64vARB(GLuint index, GLenum pname, GLuint64EXT *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetVertexAttribLui64vARB),reinterpret_cast<void (*)()>(glGetVertexAttribLui64vARB),"glGetVertexAttribLui64vARB");
    _driver.call(&_driver.glGetVertexAttribLui64vARB)(index, pname, params);
  }

  static GLboolean REGAL_CALL glIsImageHandleResidentARB(GLuint64 handle)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIsImageHandleResidentARB),reinterpret_cast<void (*)()>(glIsImageHandleResidentARB),"glIsImageHandleResidentARB");
    return _driver.call(&_driver.glIsImageHandleResidentARB)(handle);
  }

  static GLboolean REGAL_CALL glIsTextureHandleResidentARB(GLuint64 handle)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIsTextureHandleResidentARB),reinterpret_cast<void (*)()>(glIsTextureHandleResidentARB),"glIsTextureHandleResidentARB");
    return _driver.call(&_driver.glIsTextureHandleResidentARB)(handle);
  }

  static void REGAL_CALL glMakeImageHandleNonResidentARB(GLuint64 handle)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMakeImageHandleNonResidentARB),reinterpret_cast<void (*)()>(glMakeImageHandleNonResidentARB),"glMakeImageHandleNonResidentARB");
    _driver.call(&_driver.glMakeImageHandleNonResidentARB)(handle);
  }

  static void REGAL_CALL glMakeImageHandleResidentARB(GLuint64 handle, GLenum access)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMakeImageHandleResidentARB),reinterpret_cast<void (*)()>(glMakeImageHandleResidentARB),"glMakeImageHandleResidentARB");
    _driver.call(&_driver.glMakeImageHandleResidentARB)(handle, access);
  }

  static void REGAL_CALL glMakeTextureHandleNonResidentARB(GLuint64 handle)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMakeTextureHandleNonResidentARB),reinterpret_cast<void (*)()>(glMakeTextureHandleNonResidentARB),"glMakeTextureHandleNonResidentARB");
    _driver.call(&_driver.glMakeTextureHandleNonResidentARB)(handle);
  }

  static void REGAL_CALL glMakeTextureHandleResidentARB(GLuint64 handle)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMakeTextureHandleResidentARB),reinterpret_cast<void (*)()>(glMakeTextureHandleResidentARB),"glMakeTextureHandleResidentARB");
    _driver.call(&_driver.glMakeTextureHandleResidentARB)(handle);
  }

  static void REGAL_CALL glProgramUniformHandleui64ARB(GLuint program, GLint location, GLuint64 value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniformHandleui64ARB),reinterpret_cast<void (*)()>(glProgramUniformHandleui64ARB),"glProgramUniformHandleui64ARB");
    _driver.call(&_driver.glProgramUniformHandleui64ARB)(program, location, value);
  }

  static void REGAL_CALL glProgramUniformHandleui64vARB(GLuint program, GLint location, GLsizei count, const GLuint64 *values)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniformHandleui64vARB),reinterpret_cast<void (*)()>(glProgramUniformHandleui64vARB),"glProgramUniformHandleui64vARB");
    _driver.call(&_driver.glProgramUniformHandleui64vARB)(program, location, count, values);
  }

  static void REGAL_CALL glUniformHandleui64ARB(GLint location, GLuint64 value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniformHandleui64ARB),reinterpret_cast<void (*)()>(glUniformHandleui64ARB),"glUniformHandleui64ARB");
    _driver.call(&_driver.glUniformHandleui64ARB)(location, value);
  }

  static void REGAL_CALL glUniformHandleui64vARB(GLint location, GLsizei count, const GLuint64 *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniformHandleui64vARB),reinterpret_cast<void (*)()>(glUniformHandleui64vARB),"glUniformHandleui64vARB");
    _driver.call(&_driver.glUniformHandleui64vARB)(location, count, value);
  }

  static void REGAL_CALL glVertexAttribL1ui64ARB(GLuint index, GLuint64EXT x)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribL1ui64ARB),reinterpret_cast<void (*)()>(glVertexAttribL1ui64ARB),"glVertexAttribL1ui64ARB");
    _driver.call(&_driver.glVertexAttribL1ui64ARB)(index, x);
  }

  static void REGAL_CALL glVertexAttribL1ui64vARB(GLuint index, const GLuint64EXT *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribL1ui64vARB),reinterpret_cast<void (*)()>(glVertexAttribL1ui64vARB),"glVertexAttribL1ui64vARB");
    _driver.call(&_driver.glVertexAttribL1ui64vARB)(index, v);
  }

// GL_ARB_blend_func_extended

  static void REGAL_CALL glBindFragDataLocationIndexed(GLuint program, GLuint colorNumber, GLuint index, const GLchar *name)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBindFragDataLocationIndexed),reinterpret_cast<void (*)()>(glBindFragDataLocationIndexed),"glBindFragDataLocationIndexed");
    _driver.call(&_driver.glBindFragDataLocationIndexed)(program, colorNumber, index, name);
  }

  static GLint REGAL_CALL glGetFragDataIndex(GLuint program, const GLchar *name)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetFragDataIndex),reinterpret_cast<void (*)()>(glGetFragDataIndex),"glGetFragDataIndex");
    return _driver.call(&_driver.glGetFragDataIndex)(program, name);
  }

// GL_ARB_buffer_storage

  static void REGAL_CALL glBufferStorage(GLenum target, GLsizeiptr size, const GLvoid *data, GLbitfield flags)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBufferStorage),reinterpret_cast<void (*)()>(glBufferStorage),"glBufferStorage");
    _driver.call(&_driver.glBufferStorage)(target, size, data, flags);
  }

  static void REGAL_CALL glNamedBufferStorageEXT(GLuint buffer, GLsizeiptr size, const GLvoid *data, GLbitfield flags)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNamedBufferStorageEXT),reinterpret_cast<void (*)()>(glNamedBufferStorageEXT),"glNamedBufferStorageEXT");
    _driver.call(&_driver.glNamedBufferStorageEXT)(buffer, size, data, flags);
  }

// GL_ARB_cl_event

  static GLsync REGAL_CALL glCreateSyncFromCLeventARB(cl_context context, cl_event event, GLbitfield flags)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCreateSyncFromCLeventARB),reinterpret_cast<void (*)()>(glCreateSyncFromCLeventARB),"glCreateSyncFromCLeventARB");
    return _driver.call(&_driver.glCreateSyncFromCLeventARB)(context, event, flags);
  }

// GL_ARB_clear_buffer_object

  static void REGAL_CALL glClearBufferData(GLenum target, GLenum internalformat, GLenum format, GLenum type, const GLvoid *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glClearBufferData),reinterpret_cast<void (*)()>(glClearBufferData),"glClearBufferData");
    _driver.call(&_driver.glClearBufferData)(target, internalformat, format, type, data);
  }

  static void REGAL_CALL glClearBufferSubData(GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const GLvoid *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glClearBufferSubData),reinterpret_cast<void (*)()>(glClearBufferSubData),"glClearBufferSubData");
    _driver.call(&_driver.glClearBufferSubData)(target, internalformat, offset, size, format, type, data);
  }

  static void REGAL_CALL glClearNamedBufferDataEXT(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const GLvoid *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glClearNamedBufferDataEXT),reinterpret_cast<void (*)()>(glClearNamedBufferDataEXT),"glClearNamedBufferDataEXT");
    _driver.call(&_driver.glClearNamedBufferDataEXT)(buffer, internalformat, format, type, data);
  }

  static void REGAL_CALL glClearNamedBufferSubDataEXT(GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const GLvoid *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glClearNamedBufferSubDataEXT),reinterpret_cast<void (*)()>(glClearNamedBufferSubDataEXT),"glClearNamedBufferSubDataEXT");
    _driver.call(&_driver.glClearNamedBufferSubDataEXT)(buffer, internalformat, offset, size, format, type, data);
  }

// GL_ARB_clear_texture

  static void REGAL_CALL glClearTexImage(GLuint texture, GLint level, GLenum format, GLenum type, const GLvoid *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glClearTexImage),reinterpret_cast<void (*)()>(glClearTexImage),"glClearTexImage");
    _driver.call(&_driver.glClearTexImage)(texture, level, format, type, data);
  }

  static void REGAL_CALL glClearTexSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glClearTexSubImage),reinterpret_cast<void (*)()>(glClearTexSubImage),"glClearTexSubImage");
    _driver.call(&_driver.glClearTexSubImage)(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data);
  }

// GL_ARB_color_buffer_float

  static void REGAL_CALL glClampColorARB(GLenum target, GLenum clamp)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glClampColorARB),reinterpret_cast<void (*)()>(glClampColorARB),"glClampColorARB");
    _driver.call(&_driver.glClampColorARB)(target, clamp);
  }

// GL_ARB_compute_shader

  static void REGAL_CALL glDispatchCompute(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDispatchCompute),reinterpret_cast<void (*)()>(glDispatchCompute),"glDispatchCompute");
    _driver.call(&_driver.glDispatchCompute)(num_groups_x, num_groups_y, num_groups_z);
  }

  static void REGAL_CALL glDispatchComputeIndirect(GLintptr indirect)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDispatchComputeIndirect),reinterpret_cast<void (*)()>(glDispatchComputeIndirect),"glDispatchComputeIndirect");
    _driver.call(&_driver.glDispatchComputeIndirect)(indirect);
  }

// GL_ARB_compute_variable_group_size

  static void REGAL_CALL glDispatchComputeGroupSizeARB(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z, GLuint group_size_x, GLuint group_size_y, GLuint group_size_z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDispatchComputeGroupSizeARB),reinterpret_cast<void (*)()>(glDispatchComputeGroupSizeARB),"glDispatchComputeGroupSizeARB");
    _driver.call(&_driver.glDispatchComputeGroupSizeARB)(num_groups_x, num_groups_y, num_groups_z, group_size_x, group_size_y, group_size_z);
  }

// GL_ARB_copy_buffer

  static void REGAL_CALL glCopyBufferSubData(GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCopyBufferSubData),reinterpret_cast<void (*)()>(glCopyBufferSubData),"glCopyBufferSubData");
    _driver.call(&_driver.glCopyBufferSubData)(readtarget, writetarget, readoffset, writeoffset, size);
  }

// GL_ARB_copy_image

  static void REGAL_CALL glCopyImageSubData(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCopyImageSubData),reinterpret_cast<void (*)()>(glCopyImageSubData),"glCopyImageSubData");
    _driver.call(&_driver.glCopyImageSubData)(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
  }

// GL_ARB_debug_output

  static void REGAL_CALL glDebugMessageCallbackARB(GLDEBUGPROCARB callback, const GLvoid *userParam)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDebugMessageCallbackARB),reinterpret_cast<void (*)()>(glDebugMessageCallbackARB),"glDebugMessageCallbackARB");
    _driver.call(&_driver.glDebugMessageCallbackARB)(callback, userParam);
  }

  static void REGAL_CALL glDebugMessageControlARB(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDebugMessageControlARB),reinterpret_cast<void (*)()>(glDebugMessageControlARB),"glDebugMessageControlARB");
    _driver.call(&_driver.glDebugMessageControlARB)(source, type, severity, count, ids, enabled);
  }

  static void REGAL_CALL glDebugMessageInsertARB(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDebugMessageInsertARB),reinterpret_cast<void (*)()>(glDebugMessageInsertARB),"glDebugMessageInsertARB");
    _driver.call(&_driver.glDebugMessageInsertARB)(source, type, id, severity, length, buf);
  }

  static GLuint REGAL_CALL glGetDebugMessageLogARB(GLuint count, GLsizei bufsize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetDebugMessageLogARB),reinterpret_cast<void (*)()>(glGetDebugMessageLogARB),"glGetDebugMessageLogARB");
    return _driver.call(&_driver.glGetDebugMessageLogARB)(count, bufsize, sources, types, ids, severities, lengths, messageLog);
  }

// GL_ARB_draw_buffers

  static void REGAL_CALL glDrawBuffersARB(GLsizei n, const GLenum *bufs)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDrawBuffersARB),reinterpret_cast<void (*)()>(glDrawBuffersARB),"glDrawBuffersARB");
    _driver.call(&_driver.glDrawBuffersARB)(n, bufs);
  }

// GL_ARB_draw_buffers_blend

  static void REGAL_CALL glBlendEquationSeparateiARB(GLuint buf, GLenum modeRGB, GLenum modeAlpha)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBlendEquationSeparateiARB),reinterpret_cast<void (*)()>(glBlendEquationSeparateiARB),"glBlendEquationSeparateiARB");
    _driver.call(&_driver.glBlendEquationSeparateiARB)(buf, modeRGB, modeAlpha);
  }

  static void REGAL_CALL glBlendEquationiARB(GLuint buf, GLenum mode)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBlendEquationiARB),reinterpret_cast<void (*)()>(glBlendEquationiARB),"glBlendEquationiARB");
    _driver.call(&_driver.glBlendEquationiARB)(buf, mode);
  }

  static void REGAL_CALL glBlendFuncSeparateiARB(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBlendFuncSeparateiARB),reinterpret_cast<void (*)()>(glBlendFuncSeparateiARB),"glBlendFuncSeparateiARB");
    _driver.call(&_driver.glBlendFuncSeparateiARB)(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
  }

  static void REGAL_CALL glBlendFunciARB(GLuint buf, GLenum src, GLenum dst)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBlendFunciARB),reinterpret_cast<void (*)()>(glBlendFunciARB),"glBlendFunciARB");
    _driver.call(&_driver.glBlendFunciARB)(buf, src, dst);
  }

// GL_ARB_draw_elements_base_vertex

  static void REGAL_CALL glDrawElementsBaseVertex(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLint basevertex)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDrawElementsBaseVertex),reinterpret_cast<void (*)()>(glDrawElementsBaseVertex),"glDrawElementsBaseVertex");
    _driver.call(&_driver.glDrawElementsBaseVertex)(mode, count, type, indices, basevertex);
  }

  static void REGAL_CALL glDrawElementsInstancedBaseVertex(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount, GLint basevertex)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDrawElementsInstancedBaseVertex),reinterpret_cast<void (*)()>(glDrawElementsInstancedBaseVertex),"glDrawElementsInstancedBaseVertex");
    _driver.call(&_driver.glDrawElementsInstancedBaseVertex)(mode, count, type, indices, primcount, basevertex);
  }

  static void REGAL_CALL glDrawRangeElementsBaseVertex(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices, GLint basevertex)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDrawRangeElementsBaseVertex),reinterpret_cast<void (*)()>(glDrawRangeElementsBaseVertex),"glDrawRangeElementsBaseVertex");
    _driver.call(&_driver.glDrawRangeElementsBaseVertex)(mode, start, end, count, type, indices, basevertex);
  }

  static void REGAL_CALL glMultiDrawElementsBaseVertex(GLenum mode, const GLsizei *count, GLenum type, const GLvoid * const *indices, GLsizei primcount, const GLint *basevertex)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiDrawElementsBaseVertex),reinterpret_cast<void (*)()>(glMultiDrawElementsBaseVertex),"glMultiDrawElementsBaseVertex");
    _driver.call(&_driver.glMultiDrawElementsBaseVertex)(mode, count, type, indices, primcount, basevertex);
  }

// GL_ARB_draw_indirect

  static void REGAL_CALL glDrawArraysIndirect(GLenum mode, const GLvoid *indirect)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDrawArraysIndirect),reinterpret_cast<void (*)()>(glDrawArraysIndirect),"glDrawArraysIndirect");
    _driver.call(&_driver.glDrawArraysIndirect)(mode, indirect);
  }

  static void REGAL_CALL glDrawElementsIndirect(GLenum mode, GLenum type, const GLvoid *indirect)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDrawElementsIndirect),reinterpret_cast<void (*)()>(glDrawElementsIndirect),"glDrawElementsIndirect");
    _driver.call(&_driver.glDrawElementsIndirect)(mode, type, indirect);
  }

// GL_ARB_draw_instanced

  static void REGAL_CALL glDrawArraysInstancedARB(GLenum mode, GLint start, GLsizei count, GLsizei primcount)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDrawArraysInstancedARB),reinterpret_cast<void (*)()>(glDrawArraysInstancedARB),"glDrawArraysInstancedARB");
    _driver.call(&_driver.glDrawArraysInstancedARB)(mode, start, count, primcount);
  }

  static void REGAL_CALL glDrawElementsInstancedARB(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDrawElementsInstancedARB),reinterpret_cast<void (*)()>(glDrawElementsInstancedARB),"glDrawElementsInstancedARB");
    _driver.call(&_driver.glDrawElementsInstancedARB)(mode, count, type, indices, primcount);
  }

// GL_ARB_framebuffer_no_attachments

  static void REGAL_CALL glFramebufferParameteri(GLenum target, GLenum pname, GLint param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFramebufferParameteri),reinterpret_cast<void (*)()>(glFramebufferParameteri),"glFramebufferParameteri");
    _driver.call(&_driver.glFramebufferParameteri)(target, pname, param);
  }

  static void REGAL_CALL glGetFramebufferParameteriv(GLenum target, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetFramebufferParameteriv),reinterpret_cast<void (*)()>(glGetFramebufferParameteriv),"glGetFramebufferParameteriv");
    _driver.call(&_driver.glGetFramebufferParameteriv)(target, pname, params);
  }

  static void REGAL_CALL glGetNamedFramebufferParameterivEXT(GLuint framebuffer, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetNamedFramebufferParameterivEXT),reinterpret_cast<void (*)()>(glGetNamedFramebufferParameterivEXT),"glGetNamedFramebufferParameterivEXT");
    _driver.call(&_driver.glGetNamedFramebufferParameterivEXT)(framebuffer, pname, params);
  }

  static void REGAL_CALL glNamedFramebufferParameteriEXT(GLuint framebuffer, GLenum pname, GLint param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNamedFramebufferParameteriEXT),reinterpret_cast<void (*)()>(glNamedFramebufferParameteriEXT),"glNamedFramebufferParameteriEXT");
    _driver.call(&_driver.glNamedFramebufferParameteriEXT)(framebuffer, pname, param);
  }

// GL_ARB_framebuffer_object

  static void REGAL_CALL glBindFramebuffer(GLenum target, GLuint framebuffer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBindFramebuffer),reinterpret_cast<void (*)()>(glBindFramebuffer),"glBindFramebuffer");
    _driver.call(&_driver.glBindFramebuffer)(target, framebuffer);
  }

  static void REGAL_CALL glBindRenderbuffer(GLenum target, GLuint renderbuffer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBindRenderbuffer),reinterpret_cast<void (*)()>(glBindRenderbuffer),"glBindRenderbuffer");
    _driver.call(&_driver.glBindRenderbuffer)(target, renderbuffer);
  }

  static void REGAL_CALL glBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBlitFramebuffer),reinterpret_cast<void (*)()>(glBlitFramebuffer),"glBlitFramebuffer");
    _driver.call(&_driver.glBlitFramebuffer)(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
  }

  static GLenum REGAL_CALL glCheckFramebufferStatus(GLenum target)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCheckFramebufferStatus),reinterpret_cast<void (*)()>(glCheckFramebufferStatus),"glCheckFramebufferStatus");
    return _driver.call(&_driver.glCheckFramebufferStatus)(target);
  }

  static void REGAL_CALL glDeleteFramebuffers(GLsizei n, const GLuint *framebuffers)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDeleteFramebuffers),reinterpret_cast<void (*)()>(glDeleteFramebuffers),"glDeleteFramebuffers");
    _driver.call(&_driver.glDeleteFramebuffers)(n, framebuffers);
  }

  static void REGAL_CALL glDeleteRenderbuffers(GLsizei n, const GLuint *renderbuffers)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDeleteRenderbuffers),reinterpret_cast<void (*)()>(glDeleteRenderbuffers),"glDeleteRenderbuffers");
    _driver.call(&_driver.glDeleteRenderbuffers)(n, renderbuffers);
  }

  static void REGAL_CALL glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFramebufferRenderbuffer),reinterpret_cast<void (*)()>(glFramebufferRenderbuffer),"glFramebufferRenderbuffer");
    _driver.call(&_driver.glFramebufferRenderbuffer)(target, attachment, renderbuffertarget, renderbuffer);
  }

  static void REGAL_CALL glFramebufferTexture1D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFramebufferTexture1D),reinterpret_cast<void (*)()>(glFramebufferTexture1D),"glFramebufferTexture1D");
    _driver.call(&_driver.glFramebufferTexture1D)(target, attachment, textarget, texture, level);
  }

  static void REGAL_CALL glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFramebufferTexture2D),reinterpret_cast<void (*)()>(glFramebufferTexture2D),"glFramebufferTexture2D");
    _driver.call(&_driver.glFramebufferTexture2D)(target, attachment, textarget, texture, level);
  }

  static void REGAL_CALL glFramebufferTexture3D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint layer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFramebufferTexture3D),reinterpret_cast<void (*)()>(glFramebufferTexture3D),"glFramebufferTexture3D");
    _driver.call(&_driver.glFramebufferTexture3D)(target, attachment, textarget, texture, level, layer);
  }

  static void REGAL_CALL glFramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFramebufferTextureLayer),reinterpret_cast<void (*)()>(glFramebufferTextureLayer),"glFramebufferTextureLayer");
    _driver.call(&_driver.glFramebufferTextureLayer)(target, attachment, texture, level, layer);
  }

  static void REGAL_CALL glGenFramebuffers(GLsizei n, GLuint *framebuffers)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGenFramebuffers),reinterpret_cast<void (*)()>(glGenFramebuffers),"glGenFramebuffers");
    _driver.call(&_driver.glGenFramebuffers)(n, framebuffers);
  }

  static void REGAL_CALL glGenRenderbuffers(GLsizei n, GLuint *renderbuffers)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGenRenderbuffers),reinterpret_cast<void (*)()>(glGenRenderbuffers),"glGenRenderbuffers");
    _driver.call(&_driver.glGenRenderbuffers)(n, renderbuffers);
  }

  static void REGAL_CALL glGenerateMipmap(GLenum target)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGenerateMipmap),reinterpret_cast<void (*)()>(glGenerateMipmap),"glGenerateMipmap");
    _driver.call(&_driver.glGenerateMipmap)(target);
  }

  static void REGAL_CALL glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetFramebufferAttachmentParameteriv),reinterpret_cast<void (*)()>(glGetFramebufferAttachmentParameteriv),"glGetFramebufferAttachmentParameteriv");
    _driver.call(&_driver.glGetFramebufferAttachmentParameteriv)(target, attachment, pname, params);
  }

  static void REGAL_CALL glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetRenderbufferParameteriv),reinterpret_cast<void (*)()>(glGetRenderbufferParameteriv),"glGetRenderbufferParameteriv");
    _driver.call(&_driver.glGetRenderbufferParameteriv)(target, pname, params);
  }

  static GLboolean REGAL_CALL glIsFramebuffer(GLuint framebuffer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIsFramebuffer),reinterpret_cast<void (*)()>(glIsFramebuffer),"glIsFramebuffer");
    return _driver.call(&_driver.glIsFramebuffer)(framebuffer);
  }

  static GLboolean REGAL_CALL glIsRenderbuffer(GLuint renderbuffer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIsRenderbuffer),reinterpret_cast<void (*)()>(glIsRenderbuffer),"glIsRenderbuffer");
    return _driver.call(&_driver.glIsRenderbuffer)(renderbuffer);
  }

  static void REGAL_CALL glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glRenderbufferStorage),reinterpret_cast<void (*)()>(glRenderbufferStorage),"glRenderbufferStorage");
    _driver.call(&_driver.glRenderbufferStorage)(target, internalformat, width, height);
  }

  static void REGAL_CALL glRenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glRenderbufferStorageMultisample),reinterpret_cast<void (*)()>(glRenderbufferStorageMultisample),"glRenderbufferStorageMultisample");
    _driver.call(&_driver.glRenderbufferStorageMultisample)(target, samples, internalformat, width, height);
  }

// GL_ARB_geometry_shader4

  static void REGAL_CALL glFramebufferTextureARB(GLenum target, GLenum attachment, GLuint texture, GLint level)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFramebufferTextureARB),reinterpret_cast<void (*)()>(glFramebufferTextureARB),"glFramebufferTextureARB");
    _driver.call(&_driver.glFramebufferTextureARB)(target, attachment, texture, level);
  }

  static void REGAL_CALL glFramebufferTextureFaceARB(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFramebufferTextureFaceARB),reinterpret_cast<void (*)()>(glFramebufferTextureFaceARB),"glFramebufferTextureFaceARB");
    _driver.call(&_driver.glFramebufferTextureFaceARB)(target, attachment, texture, level, face);
  }

  static void REGAL_CALL glFramebufferTextureLayerARB(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFramebufferTextureLayerARB),reinterpret_cast<void (*)()>(glFramebufferTextureLayerARB),"glFramebufferTextureLayerARB");
    _driver.call(&_driver.glFramebufferTextureLayerARB)(target, attachment, texture, level, layer);
  }

  static void REGAL_CALL glProgramParameteriARB(GLuint program, GLenum pname, GLint value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramParameteriARB),reinterpret_cast<void (*)()>(glProgramParameteriARB),"glProgramParameteriARB");
    _driver.call(&_driver.glProgramParameteriARB)(program, pname, value);
  }

// GL_ARB_get_program_binary

  static void REGAL_CALL glGetProgramBinary(GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, GLvoid *binary)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetProgramBinary),reinterpret_cast<void (*)()>(glGetProgramBinary),"glGetProgramBinary");
    _driver.call(&_driver.glGetProgramBinary)(program, bufSize, length, binaryFormat, binary);
  }

  static void REGAL_CALL glProgramBinary(GLuint program, GLenum binaryFormat, const GLvoid *binary, GLsizei length)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramBinary),reinterpret_cast<void (*)()>(glProgramBinary),"glProgramBinary");
    _driver.call(&_driver.glProgramBinary)(program, binaryFormat, binary, length);
  }

  static void REGAL_CALL glProgramParameteri(GLuint program, GLenum pname, GLint value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramParameteri),reinterpret_cast<void (*)()>(glProgramParameteri),"glProgramParameteri");
    _driver.call(&_driver.glProgramParameteri)(program, pname, value);
  }

// GL_ARB_gpu_shader_fp64

  static void REGAL_CALL glGetUniformdv(GLuint program, GLint location, GLdouble *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetUniformdv),reinterpret_cast<void (*)()>(glGetUniformdv),"glGetUniformdv");
    _driver.call(&_driver.glGetUniformdv)(program, location, params);
  }

  static void REGAL_CALL glUniform1d(GLint location, GLdouble x)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform1d),reinterpret_cast<void (*)()>(glUniform1d),"glUniform1d");
    _driver.call(&_driver.glUniform1d)(location, x);
  }

  static void REGAL_CALL glUniform1dv(GLint location, GLsizei count, const GLdouble *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform1dv),reinterpret_cast<void (*)()>(glUniform1dv),"glUniform1dv");
    _driver.call(&_driver.glUniform1dv)(location, count, value);
  }

  static void REGAL_CALL glUniform2d(GLint location, GLdouble x, GLdouble y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform2d),reinterpret_cast<void (*)()>(glUniform2d),"glUniform2d");
    _driver.call(&_driver.glUniform2d)(location, x, y);
  }

  static void REGAL_CALL glUniform2dv(GLint location, GLsizei count, const GLdouble *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform2dv),reinterpret_cast<void (*)()>(glUniform2dv),"glUniform2dv");
    _driver.call(&_driver.glUniform2dv)(location, count, value);
  }

  static void REGAL_CALL glUniform3d(GLint location, GLdouble x, GLdouble y, GLdouble z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform3d),reinterpret_cast<void (*)()>(glUniform3d),"glUniform3d");
    _driver.call(&_driver.glUniform3d)(location, x, y, z);
  }

  static void REGAL_CALL glUniform3dv(GLint location, GLsizei count, const GLdouble *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform3dv),reinterpret_cast<void (*)()>(glUniform3dv),"glUniform3dv");
    _driver.call(&_driver.glUniform3dv)(location, count, value);
  }

  static void REGAL_CALL glUniform4d(GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform4d),reinterpret_cast<void (*)()>(glUniform4d),"glUniform4d");
    _driver.call(&_driver.glUniform4d)(location, x, y, z, w);
  }

  static void REGAL_CALL glUniform4dv(GLint location, GLsizei count, const GLdouble *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform4dv),reinterpret_cast<void (*)()>(glUniform4dv),"glUniform4dv");
    _driver.call(&_driver.glUniform4dv)(location, count, value);
  }

  static void REGAL_CALL glUniformMatrix2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniformMatrix2dv),reinterpret_cast<void (*)()>(glUniformMatrix2dv),"glUniformMatrix2dv");
    _driver.call(&_driver.glUniformMatrix2dv)(location, count, transpose, value);
  }

  static void REGAL_CALL glUniformMatrix2x3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniformMatrix2x3dv),reinterpret_cast<void (*)()>(glUniformMatrix2x3dv),"glUniformMatrix2x3dv");
    _driver.call(&_driver.glUniformMatrix2x3dv)(location, count, transpose, value);
  }

  static void REGAL_CALL glUniformMatrix2x4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniformMatrix2x4dv),reinterpret_cast<void (*)()>(glUniformMatrix2x4dv),"glUniformMatrix2x4dv");
    _driver.call(&_driver.glUniformMatrix2x4dv)(location, count, transpose, value);
  }

  static void REGAL_CALL glUniformMatrix3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniformMatrix3dv),reinterpret_cast<void (*)()>(glUniformMatrix3dv),"glUniformMatrix3dv");
    _driver.call(&_driver.glUniformMatrix3dv)(location, count, transpose, value);
  }

  static void REGAL_CALL glUniformMatrix3x2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniformMatrix3x2dv),reinterpret_cast<void (*)()>(glUniformMatrix3x2dv),"glUniformMatrix3x2dv");
    _driver.call(&_driver.glUniformMatrix3x2dv)(location, count, transpose, value);
  }

  static void REGAL_CALL glUniformMatrix3x4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniformMatrix3x4dv),reinterpret_cast<void (*)()>(glUniformMatrix3x4dv),"glUniformMatrix3x4dv");
    _driver.call(&_driver.glUniformMatrix3x4dv)(location, count, transpose, value);
  }

  static void REGAL_CALL glUniformMatrix4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniformMatrix4dv),reinterpret_cast<void (*)()>(glUniformMatrix4dv),"glUniformMatrix4dv");
    _driver.call(&_driver.glUniformMatrix4dv)(location, count, transpose, value);
  }

  static void REGAL_CALL glUniformMatrix4x2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniformMatrix4x2dv),reinterpret_cast<void (*)()>(glUniformMatrix4x2dv),"glUniformMatrix4x2dv");
    _driver.call(&_driver.glUniformMatrix4x2dv)(location, count, transpose, value);
  }

  static void REGAL_CALL glUniformMatrix4x3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniformMatrix4x3dv),reinterpret_cast<void (*)()>(glUniformMatrix4x3dv),"glUniformMatrix4x3dv");
    _driver.call(&_driver.glUniformMatrix4x3dv)(location, count, transpose, value);
  }

// GL_ARB_imaging

  static void REGAL_CALL glColorSubTable(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColorSubTable),reinterpret_cast<void (*)()>(glColorSubTable),"glColorSubTable");
    _driver.call(&_driver.glColorSubTable)(target, start, count, format, type, data);
  }

  static void REGAL_CALL glColorTable(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColorTable),reinterpret_cast<void (*)()>(glColorTable),"glColorTable");
    _driver.call(&_driver.glColorTable)(target, internalformat, width, format, type, table);
  }

  static void REGAL_CALL glColorTableParameterfv(GLenum target, GLenum pname, const GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColorTableParameterfv),reinterpret_cast<void (*)()>(glColorTableParameterfv),"glColorTableParameterfv");
    _driver.call(&_driver.glColorTableParameterfv)(target, pname, params);
  }

  static void REGAL_CALL glColorTableParameteriv(GLenum target, GLenum pname, const GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColorTableParameteriv),reinterpret_cast<void (*)()>(glColorTableParameteriv),"glColorTableParameteriv");
    _driver.call(&_driver.glColorTableParameteriv)(target, pname, params);
  }

  static void REGAL_CALL glConvolutionFilter1D(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glConvolutionFilter1D),reinterpret_cast<void (*)()>(glConvolutionFilter1D),"glConvolutionFilter1D");
    _driver.call(&_driver.glConvolutionFilter1D)(target, internalformat, width, format, type, image);
  }

  static void REGAL_CALL glConvolutionFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glConvolutionFilter2D),reinterpret_cast<void (*)()>(glConvolutionFilter2D),"glConvolutionFilter2D");
    _driver.call(&_driver.glConvolutionFilter2D)(target, internalformat, width, height, format, type, image);
  }

  static void REGAL_CALL glConvolutionParameterf(GLenum target, GLenum pname, GLfloat params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glConvolutionParameterf),reinterpret_cast<void (*)()>(glConvolutionParameterf),"glConvolutionParameterf");
    _driver.call(&_driver.glConvolutionParameterf)(target, pname, params);
  }

  static void REGAL_CALL glConvolutionParameterfv(GLenum target, GLenum pname, const GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glConvolutionParameterfv),reinterpret_cast<void (*)()>(glConvolutionParameterfv),"glConvolutionParameterfv");
    _driver.call(&_driver.glConvolutionParameterfv)(target, pname, params);
  }

  static void REGAL_CALL glConvolutionParameteri(GLenum target, GLenum pname, GLint params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glConvolutionParameteri),reinterpret_cast<void (*)()>(glConvolutionParameteri),"glConvolutionParameteri");
    _driver.call(&_driver.glConvolutionParameteri)(target, pname, params);
  }

  static void REGAL_CALL glConvolutionParameteriv(GLenum target, GLenum pname, const GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glConvolutionParameteriv),reinterpret_cast<void (*)()>(glConvolutionParameteriv),"glConvolutionParameteriv");
    _driver.call(&_driver.glConvolutionParameteriv)(target, pname, params);
  }

  static void REGAL_CALL glCopyColorSubTable(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCopyColorSubTable),reinterpret_cast<void (*)()>(glCopyColorSubTable),"glCopyColorSubTable");
    _driver.call(&_driver.glCopyColorSubTable)(target, start, x, y, width);
  }

  static void REGAL_CALL glCopyColorTable(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCopyColorTable),reinterpret_cast<void (*)()>(glCopyColorTable),"glCopyColorTable");
    _driver.call(&_driver.glCopyColorTable)(target, internalformat, x, y, width);
  }

  static void REGAL_CALL glCopyConvolutionFilter1D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCopyConvolutionFilter1D),reinterpret_cast<void (*)()>(glCopyConvolutionFilter1D),"glCopyConvolutionFilter1D");
    _driver.call(&_driver.glCopyConvolutionFilter1D)(target, internalformat, x, y, width);
  }

  static void REGAL_CALL glCopyConvolutionFilter2D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCopyConvolutionFilter2D),reinterpret_cast<void (*)()>(glCopyConvolutionFilter2D),"glCopyConvolutionFilter2D");
    _driver.call(&_driver.glCopyConvolutionFilter2D)(target, internalformat, x, y, width, height);
  }

  static void REGAL_CALL glGetColorTable(GLenum target, GLenum format, GLenum type, GLvoid *table)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetColorTable),reinterpret_cast<void (*)()>(glGetColorTable),"glGetColorTable");
    _driver.call(&_driver.glGetColorTable)(target, format, type, table);
  }

  static void REGAL_CALL glGetColorTableParameterfv(GLenum target, GLenum pname, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetColorTableParameterfv),reinterpret_cast<void (*)()>(glGetColorTableParameterfv),"glGetColorTableParameterfv");
    _driver.call(&_driver.glGetColorTableParameterfv)(target, pname, params);
  }

  static void REGAL_CALL glGetColorTableParameteriv(GLenum target, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetColorTableParameteriv),reinterpret_cast<void (*)()>(glGetColorTableParameteriv),"glGetColorTableParameteriv");
    _driver.call(&_driver.glGetColorTableParameteriv)(target, pname, params);
  }

  static void REGAL_CALL glGetConvolutionFilter(GLenum target, GLenum format, GLenum type, GLvoid *image)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetConvolutionFilter),reinterpret_cast<void (*)()>(glGetConvolutionFilter),"glGetConvolutionFilter");
    _driver.call(&_driver.glGetConvolutionFilter)(target, format, type, image);
  }

  static void REGAL_CALL glGetConvolutionParameterfv(GLenum target, GLenum pname, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetConvolutionParameterfv),reinterpret_cast<void (*)()>(glGetConvolutionParameterfv),"glGetConvolutionParameterfv");
    _driver.call(&_driver.glGetConvolutionParameterfv)(target, pname, params);
  }

  static void REGAL_CALL glGetConvolutionParameteriv(GLenum target, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetConvolutionParameteriv),reinterpret_cast<void (*)()>(glGetConvolutionParameteriv),"glGetConvolutionParameteriv");
    _driver.call(&_driver.glGetConvolutionParameteriv)(target, pname, params);
  }

  static void REGAL_CALL glGetHistogram(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetHistogram),reinterpret_cast<void (*)()>(glGetHistogram),"glGetHistogram");
    _driver.call(&_driver.glGetHistogram)(target, reset, format, type, values);
  }

  static void REGAL_CALL glGetHistogramParameterfv(GLenum target, GLenum pname, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetHistogramParameterfv),reinterpret_cast<void (*)()>(glGetHistogramParameterfv),"glGetHistogramParameterfv");
    _driver.call(&_driver.glGetHistogramParameterfv)(target, pname, params);
  }

  static void REGAL_CALL glGetHistogramParameteriv(GLenum target, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetHistogramParameteriv),reinterpret_cast<void (*)()>(glGetHistogramParameteriv),"glGetHistogramParameteriv");
    _driver.call(&_driver.glGetHistogramParameteriv)(target, pname, params);
  }

  static void REGAL_CALL glGetMinmax(GLenum target, GLboolean reset, GLenum format, GLenum types, GLvoid *values)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetMinmax),reinterpret_cast<void (*)()>(glGetMinmax),"glGetMinmax");
    _driver.call(&_driver.glGetMinmax)(target, reset, format, types, values);
  }

  static void REGAL_CALL glGetMinmaxParameterfv(GLenum target, GLenum pname, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetMinmaxParameterfv),reinterpret_cast<void (*)()>(glGetMinmaxParameterfv),"glGetMinmaxParameterfv");
    _driver.call(&_driver.glGetMinmaxParameterfv)(target, pname, params);
  }

  static void REGAL_CALL glGetMinmaxParameteriv(GLenum target, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetMinmaxParameteriv),reinterpret_cast<void (*)()>(glGetMinmaxParameteriv),"glGetMinmaxParameteriv");
    _driver.call(&_driver.glGetMinmaxParameteriv)(target, pname, params);
  }

  static void REGAL_CALL glGetSeparableFilter(GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetSeparableFilter),reinterpret_cast<void (*)()>(glGetSeparableFilter),"glGetSeparableFilter");
    _driver.call(&_driver.glGetSeparableFilter)(target, format, type, row, column, span);
  }

  static void REGAL_CALL glHistogram(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glHistogram),reinterpret_cast<void (*)()>(glHistogram),"glHistogram");
    _driver.call(&_driver.glHistogram)(target, width, internalformat, sink);
  }

  static void REGAL_CALL glMinmax(GLenum target, GLenum internalformat, GLboolean sink)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMinmax),reinterpret_cast<void (*)()>(glMinmax),"glMinmax");
    _driver.call(&_driver.glMinmax)(target, internalformat, sink);
  }

  static void REGAL_CALL glResetHistogram(GLenum target)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glResetHistogram),reinterpret_cast<void (*)()>(glResetHistogram),"glResetHistogram");
    _driver.call(&_driver.glResetHistogram)(target);
  }

  static void REGAL_CALL glResetMinmax(GLenum target)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glResetMinmax),reinterpret_cast<void (*)()>(glResetMinmax),"glResetMinmax");
    _driver.call(&_driver.glResetMinmax)(target);
  }

  static void REGAL_CALL glSeparableFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSeparableFilter2D),reinterpret_cast<void (*)()>(glSeparableFilter2D),"glSeparableFilter2D");
    _driver.call(&_driver.glSeparableFilter2D)(target, internalformat, width, height, format, type, row, column);
  }

// GL_ARB_indirect_parameters

  static void REGAL_CALL glMultiDrawArraysIndirectCountARB(GLenum mode, const GLvoid *indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiDrawArraysIndirectCountARB),reinterpret_cast<void (*)()>(glMultiDrawArraysIndirectCountARB),"glMultiDrawArraysIndirectCountARB");
    _driver.call(&_driver.glMultiDrawArraysIndirectCountARB)(mode, indirect, drawcount, maxdrawcount, stride);
  }

  static void REGAL_CALL glMultiDrawElementsIndirectCountARB(GLenum mode, GLenum type, const GLvoid *indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiDrawElementsIndirectCountARB),reinterpret_cast<void (*)()>(glMultiDrawElementsIndirectCountARB),"glMultiDrawElementsIndirectCountARB");
    _driver.call(&_driver.glMultiDrawElementsIndirectCountARB)(mode, type, indirect, drawcount, maxdrawcount, stride);
  }

// GL_ARB_instanced_arrays

  static void REGAL_CALL glVertexAttribDivisorARB(GLuint index, GLuint divisor)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribDivisorARB),reinterpret_cast<void (*)()>(glVertexAttribDivisorARB),"glVertexAttribDivisorARB");
    _driver.call(&_driver.glVertexAttribDivisorARB)(index, divisor);
  }

// GL_ARB_internalformat_query

  static void REGAL_CALL glGetInternalformativ(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetInternalformativ),reinterpret_cast<void (*)()>(glGetInternalformativ),"glGetInternalformativ");
    _driver.call(&_driver.glGetInternalformativ)(target, internalformat, pname, bufSize, params);
  }

// GL_ARB_internalformat_query2

  static void REGAL_CALL glGetInternalformati64v(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint64 *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetInternalformati64v),reinterpret_cast<void (*)()>(glGetInternalformati64v),"glGetInternalformati64v");
    _driver.call(&_driver.glGetInternalformati64v)(target, internalformat, pname, bufSize, params);
  }

// GL_ARB_invalidate_subdata

  static void REGAL_CALL glInvalidateBufferData(GLuint buffer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glInvalidateBufferData),reinterpret_cast<void (*)()>(glInvalidateBufferData),"glInvalidateBufferData");
    _driver.call(&_driver.glInvalidateBufferData)(buffer);
  }

  static void REGAL_CALL glInvalidateBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr length)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glInvalidateBufferSubData),reinterpret_cast<void (*)()>(glInvalidateBufferSubData),"glInvalidateBufferSubData");
    _driver.call(&_driver.glInvalidateBufferSubData)(buffer, offset, length);
  }

  static void REGAL_CALL glInvalidateFramebuffer(GLenum target, GLsizei numAttachments, const GLenum *attachments)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glInvalidateFramebuffer),reinterpret_cast<void (*)()>(glInvalidateFramebuffer),"glInvalidateFramebuffer");
    _driver.call(&_driver.glInvalidateFramebuffer)(target, numAttachments, attachments);
  }

  static void REGAL_CALL glInvalidateSubFramebuffer(GLenum target, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glInvalidateSubFramebuffer),reinterpret_cast<void (*)()>(glInvalidateSubFramebuffer),"glInvalidateSubFramebuffer");
    _driver.call(&_driver.glInvalidateSubFramebuffer)(target, numAttachments, attachments, x, y, width, height);
  }

  static void REGAL_CALL glInvalidateTexImage(GLuint texture, GLint level)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glInvalidateTexImage),reinterpret_cast<void (*)()>(glInvalidateTexImage),"glInvalidateTexImage");
    _driver.call(&_driver.glInvalidateTexImage)(texture, level);
  }

  static void REGAL_CALL glInvalidateTexSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glInvalidateTexSubImage),reinterpret_cast<void (*)()>(glInvalidateTexSubImage),"glInvalidateTexSubImage");
    _driver.call(&_driver.glInvalidateTexSubImage)(texture, level, xoffset, yoffset, zoffset, width, height, depth);
  }

// GL_ARB_map_buffer_range

  static void REGAL_CALL glFlushMappedBufferRange(GLenum target, GLintptr offset, GLsizeiptr length)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFlushMappedBufferRange),reinterpret_cast<void (*)()>(glFlushMappedBufferRange),"glFlushMappedBufferRange");
    _driver.call(&_driver.glFlushMappedBufferRange)(target, offset, length);
  }

  static GLvoid *REGAL_CALL glMapBufferRange(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMapBufferRange),reinterpret_cast<void (*)()>(glMapBufferRange),"glMapBufferRange");
    return _driver.call(&_driver.glMapBufferRange)(target, offset, length, access);
  }

// GL_ARB_matrix_palette

  static void REGAL_CALL glCurrentPaletteMatrixARB(GLint index)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCurrentPaletteMatrixARB),reinterpret_cast<void (*)()>(glCurrentPaletteMatrixARB),"glCurrentPaletteMatrixARB");
    _driver.call(&_driver.glCurrentPaletteMatrixARB)(index);
  }

  static void REGAL_CALL glMatrixIndexPointerARB(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMatrixIndexPointerARB),reinterpret_cast<void (*)()>(glMatrixIndexPointerARB),"glMatrixIndexPointerARB");
    _driver.call(&_driver.glMatrixIndexPointerARB)(size, type, stride, pointer);
  }

  static void REGAL_CALL glMatrixIndexubvARB(GLint size, const GLubyte *indices)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMatrixIndexubvARB),reinterpret_cast<void (*)()>(glMatrixIndexubvARB),"glMatrixIndexubvARB");
    _driver.call(&_driver.glMatrixIndexubvARB)(size, indices);
  }

  static void REGAL_CALL glMatrixIndexuivARB(GLint size, const GLuint *indices)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMatrixIndexuivARB),reinterpret_cast<void (*)()>(glMatrixIndexuivARB),"glMatrixIndexuivARB");
    _driver.call(&_driver.glMatrixIndexuivARB)(size, indices);
  }

  static void REGAL_CALL glMatrixIndexusvARB(GLint size, const GLushort *indices)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMatrixIndexusvARB),reinterpret_cast<void (*)()>(glMatrixIndexusvARB),"glMatrixIndexusvARB");
    _driver.call(&_driver.glMatrixIndexusvARB)(size, indices);
  }

// GL_ARB_multi_bind

  static void REGAL_CALL glBindBuffersBase(GLenum target, GLuint first, GLsizei count, const GLuint *buffers)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBindBuffersBase),reinterpret_cast<void (*)()>(glBindBuffersBase),"glBindBuffersBase");
    _driver.call(&_driver.glBindBuffersBase)(target, first, count, buffers);
  }

  static void REGAL_CALL glBindBuffersRange(GLenum target, GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizeiptr *sizes)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBindBuffersRange),reinterpret_cast<void (*)()>(glBindBuffersRange),"glBindBuffersRange");
    _driver.call(&_driver.glBindBuffersRange)(target, first, count, buffers, offsets, sizes);
  }

  static void REGAL_CALL glBindImageTextures(GLuint first, GLsizei count, const GLuint *textures)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBindImageTextures),reinterpret_cast<void (*)()>(glBindImageTextures),"glBindImageTextures");
    _driver.call(&_driver.glBindImageTextures)(first, count, textures);
  }

  static void REGAL_CALL glBindSamplers(GLuint first, GLsizei count, const GLuint *samplers)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBindSamplers),reinterpret_cast<void (*)()>(glBindSamplers),"glBindSamplers");
    _driver.call(&_driver.glBindSamplers)(first, count, samplers);
  }

  static void REGAL_CALL glBindTextures(GLuint first, GLsizei count, const GLuint *textures)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBindTextures),reinterpret_cast<void (*)()>(glBindTextures),"glBindTextures");
    _driver.call(&_driver.glBindTextures)(first, count, textures);
  }

  static void REGAL_CALL glBindVertexBuffers(GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizei *strides)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBindVertexBuffers),reinterpret_cast<void (*)()>(glBindVertexBuffers),"glBindVertexBuffers");
    _driver.call(&_driver.glBindVertexBuffers)(first, count, buffers, offsets, strides);
  }

// GL_ARB_multi_draw_indirect

  static void REGAL_CALL glMultiDrawArraysIndirect(GLenum mode, const GLvoid *indirect, GLsizei primcount, GLsizei stride)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiDrawArraysIndirect),reinterpret_cast<void (*)()>(glMultiDrawArraysIndirect),"glMultiDrawArraysIndirect");
    _driver.call(&_driver.glMultiDrawArraysIndirect)(mode, indirect, primcount, stride);
  }

  static void REGAL_CALL glMultiDrawElementsIndirect(GLenum mode, GLenum type, const GLvoid *indirect, GLsizei primcount, GLsizei stride)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiDrawElementsIndirect),reinterpret_cast<void (*)()>(glMultiDrawElementsIndirect),"glMultiDrawElementsIndirect");
    _driver.call(&_driver.glMultiDrawElementsIndirect)(mode, type, indirect, primcount, stride);
  }

// GL_ARB_multisample

  static void REGAL_CALL glSampleCoverageARB(GLclampf value, GLboolean invert)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSampleCoverageARB),reinterpret_cast<void (*)()>(glSampleCoverageARB),"glSampleCoverageARB");
    _driver.call(&_driver.glSampleCoverageARB)(value, invert);
  }

// GL_ARB_multitexture

  static void REGAL_CALL glActiveTextureARB(GLenum texture)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glActiveTextureARB),reinterpret_cast<void (*)()>(glActiveTextureARB),"glActiveTextureARB");
    _driver.call(&_driver.glActiveTextureARB)(texture);
  }

  static void REGAL_CALL glClientActiveTextureARB(GLenum texture)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glClientActiveTextureARB),reinterpret_cast<void (*)()>(glClientActiveTextureARB),"glClientActiveTextureARB");
    _driver.call(&_driver.glClientActiveTextureARB)(texture);
  }

  static void REGAL_CALL glMultiTexCoord1dARB(GLenum target, GLdouble s)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord1dARB),reinterpret_cast<void (*)()>(glMultiTexCoord1dARB),"glMultiTexCoord1dARB");
    _driver.call(&_driver.glMultiTexCoord1dARB)(target, s);
  }

  static void REGAL_CALL glMultiTexCoord1dvARB(GLenum target, const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord1dvARB),reinterpret_cast<void (*)()>(glMultiTexCoord1dvARB),"glMultiTexCoord1dvARB");
    _driver.call(&_driver.glMultiTexCoord1dvARB)(target, v);
  }

  static void REGAL_CALL glMultiTexCoord1fARB(GLenum target, GLfloat s)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord1fARB),reinterpret_cast<void (*)()>(glMultiTexCoord1fARB),"glMultiTexCoord1fARB");
    _driver.call(&_driver.glMultiTexCoord1fARB)(target, s);
  }

  static void REGAL_CALL glMultiTexCoord1fvARB(GLenum target, const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord1fvARB),reinterpret_cast<void (*)()>(glMultiTexCoord1fvARB),"glMultiTexCoord1fvARB");
    _driver.call(&_driver.glMultiTexCoord1fvARB)(target, v);
  }

  static void REGAL_CALL glMultiTexCoord1iARB(GLenum target, GLint s)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord1iARB),reinterpret_cast<void (*)()>(glMultiTexCoord1iARB),"glMultiTexCoord1iARB");
    _driver.call(&_driver.glMultiTexCoord1iARB)(target, s);
  }

  static void REGAL_CALL glMultiTexCoord1ivARB(GLenum target, const GLint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord1ivARB),reinterpret_cast<void (*)()>(glMultiTexCoord1ivARB),"glMultiTexCoord1ivARB");
    _driver.call(&_driver.glMultiTexCoord1ivARB)(target, v);
  }

  static void REGAL_CALL glMultiTexCoord1sARB(GLenum target, GLshort s)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord1sARB),reinterpret_cast<void (*)()>(glMultiTexCoord1sARB),"glMultiTexCoord1sARB");
    _driver.call(&_driver.glMultiTexCoord1sARB)(target, s);
  }

  static void REGAL_CALL glMultiTexCoord1svARB(GLenum target, const GLshort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord1svARB),reinterpret_cast<void (*)()>(glMultiTexCoord1svARB),"glMultiTexCoord1svARB");
    _driver.call(&_driver.glMultiTexCoord1svARB)(target, v);
  }

  static void REGAL_CALL glMultiTexCoord2dARB(GLenum target, GLdouble s, GLdouble t)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord2dARB),reinterpret_cast<void (*)()>(glMultiTexCoord2dARB),"glMultiTexCoord2dARB");
    _driver.call(&_driver.glMultiTexCoord2dARB)(target, s, t);
  }

  static void REGAL_CALL glMultiTexCoord2dvARB(GLenum target, const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord2dvARB),reinterpret_cast<void (*)()>(glMultiTexCoord2dvARB),"glMultiTexCoord2dvARB");
    _driver.call(&_driver.glMultiTexCoord2dvARB)(target, v);
  }

  static void REGAL_CALL glMultiTexCoord2fARB(GLenum target, GLfloat s, GLfloat t)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord2fARB),reinterpret_cast<void (*)()>(glMultiTexCoord2fARB),"glMultiTexCoord2fARB");
    _driver.call(&_driver.glMultiTexCoord2fARB)(target, s, t);
  }

  static void REGAL_CALL glMultiTexCoord2fvARB(GLenum target, const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord2fvARB),reinterpret_cast<void (*)()>(glMultiTexCoord2fvARB),"glMultiTexCoord2fvARB");
    _driver.call(&_driver.glMultiTexCoord2fvARB)(target, v);
  }

  static void REGAL_CALL glMultiTexCoord2iARB(GLenum target, GLint s, GLint t)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord2iARB),reinterpret_cast<void (*)()>(glMultiTexCoord2iARB),"glMultiTexCoord2iARB");
    _driver.call(&_driver.glMultiTexCoord2iARB)(target, s, t);
  }

  static void REGAL_CALL glMultiTexCoord2ivARB(GLenum target, const GLint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord2ivARB),reinterpret_cast<void (*)()>(glMultiTexCoord2ivARB),"glMultiTexCoord2ivARB");
    _driver.call(&_driver.glMultiTexCoord2ivARB)(target, v);
  }

  static void REGAL_CALL glMultiTexCoord2sARB(GLenum target, GLshort s, GLshort t)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord2sARB),reinterpret_cast<void (*)()>(glMultiTexCoord2sARB),"glMultiTexCoord2sARB");
    _driver.call(&_driver.glMultiTexCoord2sARB)(target, s, t);
  }

  static void REGAL_CALL glMultiTexCoord2svARB(GLenum target, const GLshort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord2svARB),reinterpret_cast<void (*)()>(glMultiTexCoord2svARB),"glMultiTexCoord2svARB");
    _driver.call(&_driver.glMultiTexCoord2svARB)(target, v);
  }

  static void REGAL_CALL glMultiTexCoord3dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord3dARB),reinterpret_cast<void (*)()>(glMultiTexCoord3dARB),"glMultiTexCoord3dARB");
    _driver.call(&_driver.glMultiTexCoord3dARB)(target, s, t, r);
  }

  static void REGAL_CALL glMultiTexCoord3dvARB(GLenum target, const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord3dvARB),reinterpret_cast<void (*)()>(glMultiTexCoord3dvARB),"glMultiTexCoord3dvARB");
    _driver.call(&_driver.glMultiTexCoord3dvARB)(target, v);
  }

  static void REGAL_CALL glMultiTexCoord3fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord3fARB),reinterpret_cast<void (*)()>(glMultiTexCoord3fARB),"glMultiTexCoord3fARB");
    _driver.call(&_driver.glMultiTexCoord3fARB)(target, s, t, r);
  }

  static void REGAL_CALL glMultiTexCoord3fvARB(GLenum target, const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord3fvARB),reinterpret_cast<void (*)()>(glMultiTexCoord3fvARB),"glMultiTexCoord3fvARB");
    _driver.call(&_driver.glMultiTexCoord3fvARB)(target, v);
  }

  static void REGAL_CALL glMultiTexCoord3iARB(GLenum target, GLint s, GLint t, GLint r)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord3iARB),reinterpret_cast<void (*)()>(glMultiTexCoord3iARB),"glMultiTexCoord3iARB");
    _driver.call(&_driver.glMultiTexCoord3iARB)(target, s, t, r);
  }

  static void REGAL_CALL glMultiTexCoord3ivARB(GLenum target, const GLint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord3ivARB),reinterpret_cast<void (*)()>(glMultiTexCoord3ivARB),"glMultiTexCoord3ivARB");
    _driver.call(&_driver.glMultiTexCoord3ivARB)(target, v);
  }

  static void REGAL_CALL glMultiTexCoord3sARB(GLenum target, GLshort s, GLshort t, GLshort r)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord3sARB),reinterpret_cast<void (*)()>(glMultiTexCoord3sARB),"glMultiTexCoord3sARB");
    _driver.call(&_driver.glMultiTexCoord3sARB)(target, s, t, r);
  }

  static void REGAL_CALL glMultiTexCoord3svARB(GLenum target, const GLshort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord3svARB),reinterpret_cast<void (*)()>(glMultiTexCoord3svARB),"glMultiTexCoord3svARB");
    _driver.call(&_driver.glMultiTexCoord3svARB)(target, v);
  }

  static void REGAL_CALL glMultiTexCoord4dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord4dARB),reinterpret_cast<void (*)()>(glMultiTexCoord4dARB),"glMultiTexCoord4dARB");
    _driver.call(&_driver.glMultiTexCoord4dARB)(target, s, t, r, q);
  }

  static void REGAL_CALL glMultiTexCoord4dvARB(GLenum target, const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord4dvARB),reinterpret_cast<void (*)()>(glMultiTexCoord4dvARB),"glMultiTexCoord4dvARB");
    _driver.call(&_driver.glMultiTexCoord4dvARB)(target, v);
  }

  static void REGAL_CALL glMultiTexCoord4fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord4fARB),reinterpret_cast<void (*)()>(glMultiTexCoord4fARB),"glMultiTexCoord4fARB");
    _driver.call(&_driver.glMultiTexCoord4fARB)(target, s, t, r, q);
  }

  static void REGAL_CALL glMultiTexCoord4fvARB(GLenum target, const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord4fvARB),reinterpret_cast<void (*)()>(glMultiTexCoord4fvARB),"glMultiTexCoord4fvARB");
    _driver.call(&_driver.glMultiTexCoord4fvARB)(target, v);
  }

  static void REGAL_CALL glMultiTexCoord4iARB(GLenum target, GLint s, GLint t, GLint r, GLint q)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord4iARB),reinterpret_cast<void (*)()>(glMultiTexCoord4iARB),"glMultiTexCoord4iARB");
    _driver.call(&_driver.glMultiTexCoord4iARB)(target, s, t, r, q);
  }

  static void REGAL_CALL glMultiTexCoord4ivARB(GLenum target, const GLint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord4ivARB),reinterpret_cast<void (*)()>(glMultiTexCoord4ivARB),"glMultiTexCoord4ivARB");
    _driver.call(&_driver.glMultiTexCoord4ivARB)(target, v);
  }

  static void REGAL_CALL glMultiTexCoord4sARB(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord4sARB),reinterpret_cast<void (*)()>(glMultiTexCoord4sARB),"glMultiTexCoord4sARB");
    _driver.call(&_driver.glMultiTexCoord4sARB)(target, s, t, r, q);
  }

  static void REGAL_CALL glMultiTexCoord4svARB(GLenum target, const GLshort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord4svARB),reinterpret_cast<void (*)()>(glMultiTexCoord4svARB),"glMultiTexCoord4svARB");
    _driver.call(&_driver.glMultiTexCoord4svARB)(target, v);
  }

// GL_ARB_occlusion_query

  static void REGAL_CALL glBeginQueryARB(GLenum target, GLuint id)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBeginQueryARB),reinterpret_cast<void (*)()>(glBeginQueryARB),"glBeginQueryARB");
    _driver.call(&_driver.glBeginQueryARB)(target, id);
  }

  static void REGAL_CALL glDeleteQueriesARB(GLsizei n, const GLuint *ids)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDeleteQueriesARB),reinterpret_cast<void (*)()>(glDeleteQueriesARB),"glDeleteQueriesARB");
    _driver.call(&_driver.glDeleteQueriesARB)(n, ids);
  }

  static void REGAL_CALL glEndQueryARB(GLenum target)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glEndQueryARB),reinterpret_cast<void (*)()>(glEndQueryARB),"glEndQueryARB");
    _driver.call(&_driver.glEndQueryARB)(target);
  }

  static void REGAL_CALL glGenQueriesARB(GLsizei n, GLuint *ids)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGenQueriesARB),reinterpret_cast<void (*)()>(glGenQueriesARB),"glGenQueriesARB");
    _driver.call(&_driver.glGenQueriesARB)(n, ids);
  }

  static void REGAL_CALL glGetQueryObjectivARB(GLuint id, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetQueryObjectivARB),reinterpret_cast<void (*)()>(glGetQueryObjectivARB),"glGetQueryObjectivARB");
    _driver.call(&_driver.glGetQueryObjectivARB)(id, pname, params);
  }

  static void REGAL_CALL glGetQueryObjectuivARB(GLuint id, GLenum pname, GLuint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetQueryObjectuivARB),reinterpret_cast<void (*)()>(glGetQueryObjectuivARB),"glGetQueryObjectuivARB");
    _driver.call(&_driver.glGetQueryObjectuivARB)(id, pname, params);
  }

  static void REGAL_CALL glGetQueryivARB(GLenum target, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetQueryivARB),reinterpret_cast<void (*)()>(glGetQueryivARB),"glGetQueryivARB");
    _driver.call(&_driver.glGetQueryivARB)(target, pname, params);
  }

  static GLboolean REGAL_CALL glIsQueryARB(GLuint id)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIsQueryARB),reinterpret_cast<void (*)()>(glIsQueryARB),"glIsQueryARB");
    return _driver.call(&_driver.glIsQueryARB)(id);
  }

// GL_ARB_point_parameters

  static void REGAL_CALL glPointParameterfARB(GLenum pname, GLfloat param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPointParameterfARB),reinterpret_cast<void (*)()>(glPointParameterfARB),"glPointParameterfARB");
    _driver.call(&_driver.glPointParameterfARB)(pname, param);
  }

  static void REGAL_CALL glPointParameterfvARB(GLenum pname, const GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPointParameterfvARB),reinterpret_cast<void (*)()>(glPointParameterfvARB),"glPointParameterfvARB");
    _driver.call(&_driver.glPointParameterfvARB)(pname, params);
  }

// GL_ARB_program_interface_query

  static void REGAL_CALL glGetProgramInterfaceiv(GLuint program, GLenum programInterface, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetProgramInterfaceiv),reinterpret_cast<void (*)()>(glGetProgramInterfaceiv),"glGetProgramInterfaceiv");
    _driver.call(&_driver.glGetProgramInterfaceiv)(program, programInterface, pname, params);
  }

  static GLuint REGAL_CALL glGetProgramResourceIndex(GLuint program, GLenum programInterface, const GLchar *name)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetProgramResourceIndex),reinterpret_cast<void (*)()>(glGetProgramResourceIndex),"glGetProgramResourceIndex");
    return _driver.call(&_driver.glGetProgramResourceIndex)(program, programInterface, name);
  }

  static GLint REGAL_CALL glGetProgramResourceLocation(GLuint program, GLenum programInterface, const GLchar *name)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetProgramResourceLocation),reinterpret_cast<void (*)()>(glGetProgramResourceLocation),"glGetProgramResourceLocation");
    return _driver.call(&_driver.glGetProgramResourceLocation)(program, programInterface, name);
  }

  static GLint REGAL_CALL glGetProgramResourceLocationIndex(GLuint program, GLenum programInterface, const GLchar *name)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetProgramResourceLocationIndex),reinterpret_cast<void (*)()>(glGetProgramResourceLocationIndex),"glGetProgramResourceLocationIndex");
    return _driver.call(&_driver.glGetProgramResourceLocationIndex)(program, programInterface, name);
  }

  static void REGAL_CALL glGetProgramResourceName(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetProgramResourceName),reinterpret_cast<void (*)()>(glGetProgramResourceName),"glGetProgramResourceName");
    _driver.call(&_driver.glGetProgramResourceName)(program, programInterface, index, bufSize, length, name);
  }

  static void REGAL_CALL glGetProgramResourceiv(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum *props, GLsizei bufSize, GLsizei *length, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetProgramResourceiv),reinterpret_cast<void (*)()>(glGetProgramResourceiv),"glGetProgramResourceiv");
    _driver.call(&_driver.glGetProgramResourceiv)(program, programInterface, index, propCount, props, bufSize, length, params);
  }

// GL_ARB_provoking_vertex

  static void REGAL_CALL glProvokingVertex(GLenum mode)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProvokingVertex),reinterpret_cast<void (*)()>(glProvokingVertex),"glProvokingVertex");
    _driver.call(&_driver.glProvokingVertex)(mode);
  }

// GL_ARB_robustness

  static GLenum REGAL_CALL glGetGraphicsResetStatusARB(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetGraphicsResetStatusARB),reinterpret_cast<void (*)()>(glGetGraphicsResetStatusARB),"glGetGraphicsResetStatusARB");
    return _driver.call(&_driver.glGetGraphicsResetStatusARB)();
  }

  static void REGAL_CALL glGetnColorTableARB(GLenum target, GLenum format, GLenum type, GLsizei bufSize, GLvoid *table)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetnColorTableARB),reinterpret_cast<void (*)()>(glGetnColorTableARB),"glGetnColorTableARB");
    _driver.call(&_driver.glGetnColorTableARB)(target, format, type, bufSize, table);
  }

  static void REGAL_CALL glGetnCompressedTexImageARB(GLenum target, GLint lod, GLsizei bufSize, GLvoid *img)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetnCompressedTexImageARB),reinterpret_cast<void (*)()>(glGetnCompressedTexImageARB),"glGetnCompressedTexImageARB");
    _driver.call(&_driver.glGetnCompressedTexImageARB)(target, lod, bufSize, img);
  }

  static void REGAL_CALL glGetnConvolutionFilterARB(GLenum target, GLenum format, GLenum type, GLsizei bufSize, GLvoid *image)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetnConvolutionFilterARB),reinterpret_cast<void (*)()>(glGetnConvolutionFilterARB),"glGetnConvolutionFilterARB");
    _driver.call(&_driver.glGetnConvolutionFilterARB)(target, format, type, bufSize, image);
  }

  static void REGAL_CALL glGetnHistogramARB(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, GLvoid *values)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetnHistogramARB),reinterpret_cast<void (*)()>(glGetnHistogramARB),"glGetnHistogramARB");
    _driver.call(&_driver.glGetnHistogramARB)(target, reset, format, type, bufSize, values);
  }

  static void REGAL_CALL glGetnMapdvARB(GLenum target, GLenum query, GLsizei bufSize, GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetnMapdvARB),reinterpret_cast<void (*)()>(glGetnMapdvARB),"glGetnMapdvARB");
    _driver.call(&_driver.glGetnMapdvARB)(target, query, bufSize, v);
  }

  static void REGAL_CALL glGetnMapfvARB(GLenum target, GLenum query, GLsizei bufSize, GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetnMapfvARB),reinterpret_cast<void (*)()>(glGetnMapfvARB),"glGetnMapfvARB");
    _driver.call(&_driver.glGetnMapfvARB)(target, query, bufSize, v);
  }

  static void REGAL_CALL glGetnMapivARB(GLenum target, GLenum query, GLsizei bufSize, GLint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetnMapivARB),reinterpret_cast<void (*)()>(glGetnMapivARB),"glGetnMapivARB");
    _driver.call(&_driver.glGetnMapivARB)(target, query, bufSize, v);
  }

  static void REGAL_CALL glGetnMinmaxARB(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, GLvoid *values)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetnMinmaxARB),reinterpret_cast<void (*)()>(glGetnMinmaxARB),"glGetnMinmaxARB");
    _driver.call(&_driver.glGetnMinmaxARB)(target, reset, format, type, bufSize, values);
  }

  static void REGAL_CALL glGetnPixelMapfvARB(GLenum map, GLsizei bufSize, GLfloat *values)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetnPixelMapfvARB),reinterpret_cast<void (*)()>(glGetnPixelMapfvARB),"glGetnPixelMapfvARB");
    _driver.call(&_driver.glGetnPixelMapfvARB)(map, bufSize, values);
  }

  static void REGAL_CALL glGetnPixelMapuivARB(GLenum map, GLsizei bufSize, GLuint *values)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetnPixelMapuivARB),reinterpret_cast<void (*)()>(glGetnPixelMapuivARB),"glGetnPixelMapuivARB");
    _driver.call(&_driver.glGetnPixelMapuivARB)(map, bufSize, values);
  }

  static void REGAL_CALL glGetnPixelMapusvARB(GLenum map, GLsizei bufSize, GLushort *values)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetnPixelMapusvARB),reinterpret_cast<void (*)()>(glGetnPixelMapusvARB),"glGetnPixelMapusvARB");
    _driver.call(&_driver.glGetnPixelMapusvARB)(map, bufSize, values);
  }

  static void REGAL_CALL glGetnPolygonStippleARB(GLsizei bufSize, GLubyte *pattern)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetnPolygonStippleARB),reinterpret_cast<void (*)()>(glGetnPolygonStippleARB),"glGetnPolygonStippleARB");
    _driver.call(&_driver.glGetnPolygonStippleARB)(bufSize, pattern);
  }

  static void REGAL_CALL glGetnSeparableFilterARB(GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, GLvoid *row, GLsizei columnBufSize, GLvoid *column, GLvoid *span)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetnSeparableFilterARB),reinterpret_cast<void (*)()>(glGetnSeparableFilterARB),"glGetnSeparableFilterARB");
    _driver.call(&_driver.glGetnSeparableFilterARB)(target, format, type, rowBufSize, row, columnBufSize, column, span);
  }

  static void REGAL_CALL glGetnTexImageARB(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, GLvoid *img)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetnTexImageARB),reinterpret_cast<void (*)()>(glGetnTexImageARB),"glGetnTexImageARB");
    _driver.call(&_driver.glGetnTexImageARB)(target, level, format, type, bufSize, img);
  }

  static void REGAL_CALL glGetnUniformdvARB(GLuint program, GLint location, GLsizei bufSize, GLdouble *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetnUniformdvARB),reinterpret_cast<void (*)()>(glGetnUniformdvARB),"glGetnUniformdvARB");
    _driver.call(&_driver.glGetnUniformdvARB)(program, location, bufSize, params);
  }

  static void REGAL_CALL glGetnUniformfvARB(GLuint program, GLint location, GLsizei bufSize, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetnUniformfvARB),reinterpret_cast<void (*)()>(glGetnUniformfvARB),"glGetnUniformfvARB");
    _driver.call(&_driver.glGetnUniformfvARB)(program, location, bufSize, params);
  }

  static void REGAL_CALL glGetnUniformivARB(GLuint program, GLint location, GLsizei bufSize, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetnUniformivARB),reinterpret_cast<void (*)()>(glGetnUniformivARB),"glGetnUniformivARB");
    _driver.call(&_driver.glGetnUniformivARB)(program, location, bufSize, params);
  }

  static void REGAL_CALL glGetnUniformuivARB(GLuint program, GLint location, GLsizei bufSize, GLuint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetnUniformuivARB),reinterpret_cast<void (*)()>(glGetnUniformuivARB),"glGetnUniformuivARB");
    _driver.call(&_driver.glGetnUniformuivARB)(program, location, bufSize, params);
  }

  static void REGAL_CALL glReadnPixelsARB(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, GLvoid *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glReadnPixelsARB),reinterpret_cast<void (*)()>(glReadnPixelsARB),"glReadnPixelsARB");
    _driver.call(&_driver.glReadnPixelsARB)(x, y, width, height, format, type, bufSize, data);
  }

// GL_ARB_sample_shading

  static void REGAL_CALL glMinSampleShading(GLclampf value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMinSampleShading),reinterpret_cast<void (*)()>(glMinSampleShading),"glMinSampleShading");
    _driver.call(&_driver.glMinSampleShading)(value);
  }

  static void REGAL_CALL glMinSampleShadingARB(GLclampf value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMinSampleShadingARB),reinterpret_cast<void (*)()>(glMinSampleShadingARB),"glMinSampleShadingARB");
    _driver.call(&_driver.glMinSampleShadingARB)(value);
  }

// GL_ARB_sampler_objects

  static void REGAL_CALL glBindSampler(GLuint unit, GLuint sampler)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBindSampler),reinterpret_cast<void (*)()>(glBindSampler),"glBindSampler");
    _driver.call(&_driver.glBindSampler)(unit, sampler);
  }

  static void REGAL_CALL glDeleteSamplers(GLsizei count, const GLuint *samplers)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDeleteSamplers),reinterpret_cast<void (*)()>(glDeleteSamplers),"glDeleteSamplers");
    _driver.call(&_driver.glDeleteSamplers)(count, samplers);
  }

  static void REGAL_CALL glGenSamplers(GLsizei count, GLuint *samplers)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGenSamplers),reinterpret_cast<void (*)()>(glGenSamplers),"glGenSamplers");
    _driver.call(&_driver.glGenSamplers)(count, samplers);
  }

  static void REGAL_CALL glGetSamplerParameterIiv(GLuint sampler, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetSamplerParameterIiv),reinterpret_cast<void (*)()>(glGetSamplerParameterIiv),"glGetSamplerParameterIiv");
    _driver.call(&_driver.glGetSamplerParameterIiv)(sampler, pname, params);
  }

  static void REGAL_CALL glGetSamplerParameterIuiv(GLuint sampler, GLenum pname, GLuint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetSamplerParameterIuiv),reinterpret_cast<void (*)()>(glGetSamplerParameterIuiv),"glGetSamplerParameterIuiv");
    _driver.call(&_driver.glGetSamplerParameterIuiv)(sampler, pname, params);
  }

  static void REGAL_CALL glGetSamplerParameterfv(GLuint sampler, GLenum pname, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetSamplerParameterfv),reinterpret_cast<void (*)()>(glGetSamplerParameterfv),"glGetSamplerParameterfv");
    _driver.call(&_driver.glGetSamplerParameterfv)(sampler, pname, params);
  }

  static void REGAL_CALL glGetSamplerParameteriv(GLuint sampler, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetSamplerParameteriv),reinterpret_cast<void (*)()>(glGetSamplerParameteriv),"glGetSamplerParameteriv");
    _driver.call(&_driver.glGetSamplerParameteriv)(sampler, pname, params);
  }

  static GLboolean REGAL_CALL glIsSampler(GLuint sampler)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIsSampler),reinterpret_cast<void (*)()>(glIsSampler),"glIsSampler");
    return _driver.call(&_driver.glIsSampler)(sampler);
  }

  static void REGAL_CALL glSamplerParameterIiv(GLuint sampler, GLenum pname, const GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSamplerParameterIiv),reinterpret_cast<void (*)()>(glSamplerParameterIiv),"glSamplerParameterIiv");
    _driver.call(&_driver.glSamplerParameterIiv)(sampler, pname, params);
  }

  static void REGAL_CALL glSamplerParameterIuiv(GLuint sampler, GLenum pname, const GLuint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSamplerParameterIuiv),reinterpret_cast<void (*)()>(glSamplerParameterIuiv),"glSamplerParameterIuiv");
    _driver.call(&_driver.glSamplerParameterIuiv)(sampler, pname, params);
  }

  static void REGAL_CALL glSamplerParameterf(GLuint sampler, GLenum pname, GLfloat param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSamplerParameterf),reinterpret_cast<void (*)()>(glSamplerParameterf),"glSamplerParameterf");
    _driver.call(&_driver.glSamplerParameterf)(sampler, pname, param);
  }

  static void REGAL_CALL glSamplerParameterfv(GLuint sampler, GLenum pname, const GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSamplerParameterfv),reinterpret_cast<void (*)()>(glSamplerParameterfv),"glSamplerParameterfv");
    _driver.call(&_driver.glSamplerParameterfv)(sampler, pname, params);
  }

  static void REGAL_CALL glSamplerParameteri(GLuint sampler, GLenum pname, GLint param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSamplerParameteri),reinterpret_cast<void (*)()>(glSamplerParameteri),"glSamplerParameteri");
    _driver.call(&_driver.glSamplerParameteri)(sampler, pname, param);
  }

  static void REGAL_CALL glSamplerParameteriv(GLuint sampler, GLenum pname, const GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSamplerParameteriv),reinterpret_cast<void (*)()>(glSamplerParameteriv),"glSamplerParameteriv");
    _driver.call(&_driver.glSamplerParameteriv)(sampler, pname, params);
  }

// GL_ARB_separate_shader_objects

  static void REGAL_CALL glActiveShaderProgram(GLuint pipeline, GLuint program)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glActiveShaderProgram),reinterpret_cast<void (*)()>(glActiveShaderProgram),"glActiveShaderProgram");
    _driver.call(&_driver.glActiveShaderProgram)(pipeline, program);
  }

  static void REGAL_CALL glBindProgramPipeline(GLuint pipeline)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBindProgramPipeline),reinterpret_cast<void (*)()>(glBindProgramPipeline),"glBindProgramPipeline");
    _driver.call(&_driver.glBindProgramPipeline)(pipeline);
  }

  static GLuint REGAL_CALL glCreateShaderProgramv(GLenum type, GLsizei count, const GLchar * const *strings)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCreateShaderProgramv),reinterpret_cast<void (*)()>(glCreateShaderProgramv),"glCreateShaderProgramv");
    return _driver.call(&_driver.glCreateShaderProgramv)(type, count, strings);
  }

  static void REGAL_CALL glDeleteProgramPipelines(GLsizei n, const GLuint *pipelines)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDeleteProgramPipelines),reinterpret_cast<void (*)()>(glDeleteProgramPipelines),"glDeleteProgramPipelines");
    _driver.call(&_driver.glDeleteProgramPipelines)(n, pipelines);
  }

  static void REGAL_CALL glGenProgramPipelines(GLsizei n, GLuint *pipelines)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGenProgramPipelines),reinterpret_cast<void (*)()>(glGenProgramPipelines),"glGenProgramPipelines");
    _driver.call(&_driver.glGenProgramPipelines)(n, pipelines);
  }

  static void REGAL_CALL glGetProgramPipelineInfoLog(GLuint pipeline, GLsizei bufSize, GLsizei *length, GLchar *infoLog)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetProgramPipelineInfoLog),reinterpret_cast<void (*)()>(glGetProgramPipelineInfoLog),"glGetProgramPipelineInfoLog");
    _driver.call(&_driver.glGetProgramPipelineInfoLog)(pipeline, bufSize, length, infoLog);
  }

  static void REGAL_CALL glGetProgramPipelineiv(GLuint pipeline, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetProgramPipelineiv),reinterpret_cast<void (*)()>(glGetProgramPipelineiv),"glGetProgramPipelineiv");
    _driver.call(&_driver.glGetProgramPipelineiv)(pipeline, pname, params);
  }

  static GLboolean REGAL_CALL glIsProgramPipeline(GLuint pipeline)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIsProgramPipeline),reinterpret_cast<void (*)()>(glIsProgramPipeline),"glIsProgramPipeline");
    return _driver.call(&_driver.glIsProgramPipeline)(pipeline);
  }

  static void REGAL_CALL glProgramUniform1d(GLuint program, GLint location, GLdouble x)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform1d),reinterpret_cast<void (*)()>(glProgramUniform1d),"glProgramUniform1d");
    _driver.call(&_driver.glProgramUniform1d)(program, location, x);
  }

  static void REGAL_CALL glProgramUniform1dv(GLuint program, GLint location, GLsizei count, const GLdouble *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform1dv),reinterpret_cast<void (*)()>(glProgramUniform1dv),"glProgramUniform1dv");
    _driver.call(&_driver.glProgramUniform1dv)(program, location, count, value);
  }

  static void REGAL_CALL glProgramUniform1f(GLuint program, GLint location, GLfloat x)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform1f),reinterpret_cast<void (*)()>(glProgramUniform1f),"glProgramUniform1f");
    _driver.call(&_driver.glProgramUniform1f)(program, location, x);
  }

  static void REGAL_CALL glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform1fv),reinterpret_cast<void (*)()>(glProgramUniform1fv),"glProgramUniform1fv");
    _driver.call(&_driver.glProgramUniform1fv)(program, location, count, value);
  }

  static void REGAL_CALL glProgramUniform1i(GLuint program, GLint location, GLint x)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform1i),reinterpret_cast<void (*)()>(glProgramUniform1i),"glProgramUniform1i");
    _driver.call(&_driver.glProgramUniform1i)(program, location, x);
  }

  static void REGAL_CALL glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform1iv),reinterpret_cast<void (*)()>(glProgramUniform1iv),"glProgramUniform1iv");
    _driver.call(&_driver.glProgramUniform1iv)(program, location, count, value);
  }

  static void REGAL_CALL glProgramUniform1ui(GLuint program, GLint location, GLuint v0)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform1ui),reinterpret_cast<void (*)()>(glProgramUniform1ui),"glProgramUniform1ui");
    _driver.call(&_driver.glProgramUniform1ui)(program, location, v0);
  }

  static void REGAL_CALL glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform1uiv),reinterpret_cast<void (*)()>(glProgramUniform1uiv),"glProgramUniform1uiv");
    _driver.call(&_driver.glProgramUniform1uiv)(program, location, count, value);
  }

  static void REGAL_CALL glProgramUniform2d(GLuint program, GLint location, GLdouble x, GLdouble y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform2d),reinterpret_cast<void (*)()>(glProgramUniform2d),"glProgramUniform2d");
    _driver.call(&_driver.glProgramUniform2d)(program, location, x, y);
  }

  static void REGAL_CALL glProgramUniform2dv(GLuint program, GLint location, GLsizei count, const GLdouble *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform2dv),reinterpret_cast<void (*)()>(glProgramUniform2dv),"glProgramUniform2dv");
    _driver.call(&_driver.glProgramUniform2dv)(program, location, count, value);
  }

  static void REGAL_CALL glProgramUniform2f(GLuint program, GLint location, GLfloat x, GLfloat y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform2f),reinterpret_cast<void (*)()>(glProgramUniform2f),"glProgramUniform2f");
    _driver.call(&_driver.glProgramUniform2f)(program, location, x, y);
  }

  static void REGAL_CALL glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform2fv),reinterpret_cast<void (*)()>(glProgramUniform2fv),"glProgramUniform2fv");
    _driver.call(&_driver.glProgramUniform2fv)(program, location, count, value);
  }

  static void REGAL_CALL glProgramUniform2i(GLuint program, GLint location, GLint x, GLint y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform2i),reinterpret_cast<void (*)()>(glProgramUniform2i),"glProgramUniform2i");
    _driver.call(&_driver.glProgramUniform2i)(program, location, x, y);
  }

  static void REGAL_CALL glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform2iv),reinterpret_cast<void (*)()>(glProgramUniform2iv),"glProgramUniform2iv");
    _driver.call(&_driver.glProgramUniform2iv)(program, location, count, value);
  }

  static void REGAL_CALL glProgramUniform2ui(GLuint program, GLint location, GLuint x, GLuint y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform2ui),reinterpret_cast<void (*)()>(glProgramUniform2ui),"glProgramUniform2ui");
    _driver.call(&_driver.glProgramUniform2ui)(program, location, x, y);
  }

  static void REGAL_CALL glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform2uiv),reinterpret_cast<void (*)()>(glProgramUniform2uiv),"glProgramUniform2uiv");
    _driver.call(&_driver.glProgramUniform2uiv)(program, location, count, value);
  }

  static void REGAL_CALL glProgramUniform3d(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform3d),reinterpret_cast<void (*)()>(glProgramUniform3d),"glProgramUniform3d");
    _driver.call(&_driver.glProgramUniform3d)(program, location, x, y, z);
  }

  static void REGAL_CALL glProgramUniform3dv(GLuint program, GLint location, GLsizei count, const GLdouble *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform3dv),reinterpret_cast<void (*)()>(glProgramUniform3dv),"glProgramUniform3dv");
    _driver.call(&_driver.glProgramUniform3dv)(program, location, count, value);
  }

  static void REGAL_CALL glProgramUniform3f(GLuint program, GLint location, GLfloat x, GLfloat y, GLfloat z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform3f),reinterpret_cast<void (*)()>(glProgramUniform3f),"glProgramUniform3f");
    _driver.call(&_driver.glProgramUniform3f)(program, location, x, y, z);
  }

  static void REGAL_CALL glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform3fv),reinterpret_cast<void (*)()>(glProgramUniform3fv),"glProgramUniform3fv");
    _driver.call(&_driver.glProgramUniform3fv)(program, location, count, value);
  }

  static void REGAL_CALL glProgramUniform3i(GLuint program, GLint location, GLint x, GLint y, GLint z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform3i),reinterpret_cast<void (*)()>(glProgramUniform3i),"glProgramUniform3i");
    _driver.call(&_driver.glProgramUniform3i)(program, location, x, y, z);
  }

  static void REGAL_CALL glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform3iv),reinterpret_cast<void (*)()>(glProgramUniform3iv),"glProgramUniform3iv");
    _driver.call(&_driver.glProgramUniform3iv)(program, location, count, value);
  }

  static void REGAL_CALL glProgramUniform3ui(GLuint program, GLint location, GLuint x, GLuint y, GLuint z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform3ui),reinterpret_cast<void (*)()>(glProgramUniform3ui),"glProgramUniform3ui");
    _driver.call(&_driver.glProgramUniform3ui)(program, location, x, y, z);
  }

  static void REGAL_CALL glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform3uiv),reinterpret_cast<void (*)()>(glProgramUniform3uiv),"glProgramUniform3uiv");
    _driver.call(&_driver.glProgramUniform3uiv)(program, location, count, value);
  }

  static void REGAL_CALL glProgramUniform4d(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform4d),reinterpret_cast<void (*)()>(glProgramUniform4d),"glProgramUniform4d");
    _driver.call(&_driver.glProgramUniform4d)(program, location, x, y, z, w);
  }

  static void REGAL_CALL glProgramUniform4dv(GLuint program, GLint location, GLsizei count, const GLdouble *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform4dv),reinterpret_cast<void (*)()>(glProgramUniform4dv),"glProgramUniform4dv");
    _driver.call(&_driver.glProgramUniform4dv)(program, location, count, value);
  }

  static void REGAL_CALL glProgramUniform4f(GLuint program, GLint location, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform4f),reinterpret_cast<void (*)()>(glProgramUniform4f),"glProgramUniform4f");
    _driver.call(&_driver.glProgramUniform4f)(program, location, x, y, z, w);
  }

  static void REGAL_CALL glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform4fv),reinterpret_cast<void (*)()>(glProgramUniform4fv),"glProgramUniform4fv");
    _driver.call(&_driver.glProgramUniform4fv)(program, location, count, value);
  }

  static void REGAL_CALL glProgramUniform4i(GLuint program, GLint location, GLint x, GLint y, GLint z, GLint w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform4i),reinterpret_cast<void (*)()>(glProgramUniform4i),"glProgramUniform4i");
    _driver.call(&_driver.glProgramUniform4i)(program, location, x, y, z, w);
  }

  static void REGAL_CALL glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform4iv),reinterpret_cast<void (*)()>(glProgramUniform4iv),"glProgramUniform4iv");
    _driver.call(&_driver.glProgramUniform4iv)(program, location, count, value);
  }

  static void REGAL_CALL glProgramUniform4ui(GLuint program, GLint location, GLuint x, GLuint y, GLuint z, GLuint w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform4ui),reinterpret_cast<void (*)()>(glProgramUniform4ui),"glProgramUniform4ui");
    _driver.call(&_driver.glProgramUniform4ui)(program, location, x, y, z, w);
  }

  static void REGAL_CALL glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform4uiv),reinterpret_cast<void (*)()>(glProgramUniform4uiv),"glProgramUniform4uiv");
    _driver.call(&_driver.glProgramUniform4uiv)(program, location, count, value);
  }

  static void REGAL_CALL glProgramUniformMatrix2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniformMatrix2dv),reinterpret_cast<void (*)()>(glProgramUniformMatrix2dv),"glProgramUniformMatrix2dv");
    _driver.call(&_driver.glProgramUniformMatrix2dv)(program, location, count, transpose, value);
  }

  static void REGAL_CALL glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniformMatrix2fv),reinterpret_cast<void (*)()>(glProgramUniformMatrix2fv),"glProgramUniformMatrix2fv");
    _driver.call(&_driver.glProgramUniformMatrix2fv)(program, location, count, transpose, value);
  }

  static void REGAL_CALL glProgramUniformMatrix2x3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniformMatrix2x3dv),reinterpret_cast<void (*)()>(glProgramUniformMatrix2x3dv),"glProgramUniformMatrix2x3dv");
    _driver.call(&_driver.glProgramUniformMatrix2x3dv)(program, location, count, transpose, value);
  }

  static void REGAL_CALL glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniformMatrix2x3fv),reinterpret_cast<void (*)()>(glProgramUniformMatrix2x3fv),"glProgramUniformMatrix2x3fv");
    _driver.call(&_driver.glProgramUniformMatrix2x3fv)(program, location, count, transpose, value);
  }

  static void REGAL_CALL glProgramUniformMatrix2x4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniformMatrix2x4dv),reinterpret_cast<void (*)()>(glProgramUniformMatrix2x4dv),"glProgramUniformMatrix2x4dv");
    _driver.call(&_driver.glProgramUniformMatrix2x4dv)(program, location, count, transpose, value);
  }

  static void REGAL_CALL glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniformMatrix2x4fv),reinterpret_cast<void (*)()>(glProgramUniformMatrix2x4fv),"glProgramUniformMatrix2x4fv");
    _driver.call(&_driver.glProgramUniformMatrix2x4fv)(program, location, count, transpose, value);
  }

  static void REGAL_CALL glProgramUniformMatrix3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniformMatrix3dv),reinterpret_cast<void (*)()>(glProgramUniformMatrix3dv),"glProgramUniformMatrix3dv");
    _driver.call(&_driver.glProgramUniformMatrix3dv)(program, location, count, transpose, value);
  }

  static void REGAL_CALL glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniformMatrix3fv),reinterpret_cast<void (*)()>(glProgramUniformMatrix3fv),"glProgramUniformMatrix3fv");
    _driver.call(&_driver.glProgramUniformMatrix3fv)(program, location, count, transpose, value);
  }

  static void REGAL_CALL glProgramUniformMatrix3x2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniformMatrix3x2dv),reinterpret_cast<void (*)()>(glProgramUniformMatrix3x2dv),"glProgramUniformMatrix3x2dv");
    _driver.call(&_driver.glProgramUniformMatrix3x2dv)(program, location, count, transpose, value);
  }

  static void REGAL_CALL glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniformMatrix3x2fv),reinterpret_cast<void (*)()>(glProgramUniformMatrix3x2fv),"glProgramUniformMatrix3x2fv");
    _driver.call(&_driver.glProgramUniformMatrix3x2fv)(program, location, count, transpose, value);
  }

  static void REGAL_CALL glProgramUniformMatrix3x4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniformMatrix3x4dv),reinterpret_cast<void (*)()>(glProgramUniformMatrix3x4dv),"glProgramUniformMatrix3x4dv");
    _driver.call(&_driver.glProgramUniformMatrix3x4dv)(program, location, count, transpose, value);
  }

  static void REGAL_CALL glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniformMatrix3x4fv),reinterpret_cast<void (*)()>(glProgramUniformMatrix3x4fv),"glProgramUniformMatrix3x4fv");
    _driver.call(&_driver.glProgramUniformMatrix3x4fv)(program, location, count, transpose, value);
  }

  static void REGAL_CALL glProgramUniformMatrix4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniformMatrix4dv),reinterpret_cast<void (*)()>(glProgramUniformMatrix4dv),"glProgramUniformMatrix4dv");
    _driver.call(&_driver.glProgramUniformMatrix4dv)(program, location, count, transpose, value);
  }

  static void REGAL_CALL glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniformMatrix4fv),reinterpret_cast<void (*)()>(glProgramUniformMatrix4fv),"glProgramUniformMatrix4fv");
    _driver.call(&_driver.glProgramUniformMatrix4fv)(program, location, count, transpose, value);
  }

  static void REGAL_CALL glProgramUniformMatrix4x2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniformMatrix4x2dv),reinterpret_cast<void (*)()>(glProgramUniformMatrix4x2dv),"glProgramUniformMatrix4x2dv");
    _driver.call(&_driver.glProgramUniformMatrix4x2dv)(program, location, count, transpose, value);
  }

  static void REGAL_CALL glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniformMatrix4x2fv),reinterpret_cast<void (*)()>(glProgramUniformMatrix4x2fv),"glProgramUniformMatrix4x2fv");
    _driver.call(&_driver.glProgramUniformMatrix4x2fv)(program, location, count, transpose, value);
  }

  static void REGAL_CALL glProgramUniformMatrix4x3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniformMatrix4x3dv),reinterpret_cast<void (*)()>(glProgramUniformMatrix4x3dv),"glProgramUniformMatrix4x3dv");
    _driver.call(&_driver.glProgramUniformMatrix4x3dv)(program, location, count, transpose, value);
  }

  static void REGAL_CALL glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniformMatrix4x3fv),reinterpret_cast<void (*)()>(glProgramUniformMatrix4x3fv),"glProgramUniformMatrix4x3fv");
    _driver.call(&_driver.glProgramUniformMatrix4x3fv)(program, location, count, transpose, value);
  }

  static void REGAL_CALL glUseProgramStages(GLuint pipeline, GLbitfield stages, GLuint program)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUseProgramStages),reinterpret_cast<void (*)()>(glUseProgramStages),"glUseProgramStages");
    _driver.call(&_driver.glUseProgramStages)(pipeline, stages, program);
  }

  static void REGAL_CALL glValidateProgramPipeline(GLuint pipeline)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glValidateProgramPipeline),reinterpret_cast<void (*)()>(glValidateProgramPipeline),"glValidateProgramPipeline");
    _driver.call(&_driver.glValidateProgramPipeline)(pipeline);
  }

// GL_ARB_shader_atomic_counters

  static void REGAL_CALL glGetActiveAtomicCounterBufferiv(GLuint program, GLuint bufferIndex, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetActiveAtomicCounterBufferiv),reinterpret_cast<void (*)()>(glGetActiveAtomicCounterBufferiv),"glGetActiveAtomicCounterBufferiv");
    _driver.call(&_driver.glGetActiveAtomicCounterBufferiv)(program, bufferIndex, pname, params);
  }

// GL_ARB_shader_image_load_store

  static void REGAL_CALL glBindImageTexture(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBindImageTexture),reinterpret_cast<void (*)()>(glBindImageTexture),"glBindImageTexture");
    _driver.call(&_driver.glBindImageTexture)(unit, texture, level, layered, layer, access, format);
  }

  static void REGAL_CALL glMemoryBarrier(GLbitfield barriers)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMemoryBarrier),reinterpret_cast<void (*)()>(glMemoryBarrier),"glMemoryBarrier");
    _driver.call(&_driver.glMemoryBarrier)(barriers);
  }

// GL_ARB_shader_objects

  static void REGAL_CALL glAttachObjectARB(GLhandleARB containerObj, GLhandleARB obj)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glAttachObjectARB),reinterpret_cast<void (*)()>(glAttachObjectARB),"glAttachObjectARB");
    _driver.call(&_driver.glAttachObjectARB)(containerObj, obj);
  }

  static void REGAL_CALL glCompileShaderARB(GLhandleARB shaderObj)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCompileShaderARB),reinterpret_cast<void (*)()>(glCompileShaderARB),"glCompileShaderARB");
    _driver.call(&_driver.glCompileShaderARB)(shaderObj);
  }

  static GLhandleARB REGAL_CALL glCreateProgramObjectARB(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCreateProgramObjectARB),reinterpret_cast<void (*)()>(glCreateProgramObjectARB),"glCreateProgramObjectARB");
    return _driver.call(&_driver.glCreateProgramObjectARB)();
  }

  static GLhandleARB REGAL_CALL glCreateShaderObjectARB(GLenum shaderType)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCreateShaderObjectARB),reinterpret_cast<void (*)()>(glCreateShaderObjectARB),"glCreateShaderObjectARB");
    return _driver.call(&_driver.glCreateShaderObjectARB)(shaderType);
  }

  static void REGAL_CALL glDeleteObjectARB(GLhandleARB obj)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDeleteObjectARB),reinterpret_cast<void (*)()>(glDeleteObjectARB),"glDeleteObjectARB");
    _driver.call(&_driver.glDeleteObjectARB)(obj);
  }

  static void REGAL_CALL glDetachObjectARB(GLhandleARB containerObj, GLhandleARB attachedObj)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDetachObjectARB),reinterpret_cast<void (*)()>(glDetachObjectARB),"glDetachObjectARB");
    _driver.call(&_driver.glDetachObjectARB)(containerObj, attachedObj);
  }

  static void REGAL_CALL glGetActiveUniformARB(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetActiveUniformARB),reinterpret_cast<void (*)()>(glGetActiveUniformARB),"glGetActiveUniformARB");
    _driver.call(&_driver.glGetActiveUniformARB)(programObj, index, maxLength, length, size, type, name);
  }

  static void REGAL_CALL glGetAttachedObjectsARB(GLhandleARB containerObj, GLsizei maxCount, GLsizei *count, GLhandleARB *obj)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetAttachedObjectsARB),reinterpret_cast<void (*)()>(glGetAttachedObjectsARB),"glGetAttachedObjectsARB");
    _driver.call(&_driver.glGetAttachedObjectsARB)(containerObj, maxCount, count, obj);
  }

  static GLhandleARB REGAL_CALL glGetHandleARB(GLenum pname)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetHandleARB),reinterpret_cast<void (*)()>(glGetHandleARB),"glGetHandleARB");
    return _driver.call(&_driver.glGetHandleARB)(pname);
  }

  static void REGAL_CALL glGetInfoLogARB(GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *infoLog)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetInfoLogARB),reinterpret_cast<void (*)()>(glGetInfoLogARB),"glGetInfoLogARB");
    _driver.call(&_driver.glGetInfoLogARB)(obj, maxLength, length, infoLog);
  }

  static void REGAL_CALL glGetObjectParameterfvARB(GLhandleARB obj, GLenum pname, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetObjectParameterfvARB),reinterpret_cast<void (*)()>(glGetObjectParameterfvARB),"glGetObjectParameterfvARB");
    _driver.call(&_driver.glGetObjectParameterfvARB)(obj, pname, params);
  }

  static void REGAL_CALL glGetObjectParameterivARB(GLhandleARB obj, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetObjectParameterivARB),reinterpret_cast<void (*)()>(glGetObjectParameterivARB),"glGetObjectParameterivARB");
    _driver.call(&_driver.glGetObjectParameterivARB)(obj, pname, params);
  }

  static void REGAL_CALL glGetShaderSourceARB(GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *source)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetShaderSourceARB),reinterpret_cast<void (*)()>(glGetShaderSourceARB),"glGetShaderSourceARB");
    _driver.call(&_driver.glGetShaderSourceARB)(obj, maxLength, length, source);
  }

  static GLint REGAL_CALL glGetUniformLocationARB(GLhandleARB programObj, const GLcharARB *name)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetUniformLocationARB),reinterpret_cast<void (*)()>(glGetUniformLocationARB),"glGetUniformLocationARB");
    return _driver.call(&_driver.glGetUniformLocationARB)(programObj, name);
  }

  static void REGAL_CALL glGetUniformfvARB(GLhandleARB programObj, GLint location, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetUniformfvARB),reinterpret_cast<void (*)()>(glGetUniformfvARB),"glGetUniformfvARB");
    _driver.call(&_driver.glGetUniformfvARB)(programObj, location, params);
  }

  static void REGAL_CALL glGetUniformivARB(GLhandleARB programObj, GLint location, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetUniformivARB),reinterpret_cast<void (*)()>(glGetUniformivARB),"glGetUniformivARB");
    _driver.call(&_driver.glGetUniformivARB)(programObj, location, params);
  }

  static void REGAL_CALL glLinkProgramARB(GLhandleARB programObj)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glLinkProgramARB),reinterpret_cast<void (*)()>(glLinkProgramARB),"glLinkProgramARB");
    _driver.call(&_driver.glLinkProgramARB)(programObj);
  }

  static void REGAL_CALL glShaderSourceARB(GLhandleARB shaderObj, GLsizei count, const GLcharARB ** const string, const GLint *length)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glShaderSourceARB),reinterpret_cast<void (*)()>(glShaderSourceARB),"glShaderSourceARB");
    _driver.call(&_driver.glShaderSourceARB)(shaderObj, count, string, length);
  }

  static void REGAL_CALL glUniform1fARB(GLint location, GLfloat v0)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform1fARB),reinterpret_cast<void (*)()>(glUniform1fARB),"glUniform1fARB");
    _driver.call(&_driver.glUniform1fARB)(location, v0);
  }

  static void REGAL_CALL glUniform1fvARB(GLint location, GLsizei count, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform1fvARB),reinterpret_cast<void (*)()>(glUniform1fvARB),"glUniform1fvARB");
    _driver.call(&_driver.glUniform1fvARB)(location, count, value);
  }

  static void REGAL_CALL glUniform1iARB(GLint location, GLint v0)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform1iARB),reinterpret_cast<void (*)()>(glUniform1iARB),"glUniform1iARB");
    _driver.call(&_driver.glUniform1iARB)(location, v0);
  }

  static void REGAL_CALL glUniform1ivARB(GLint location, GLsizei count, const GLint *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform1ivARB),reinterpret_cast<void (*)()>(glUniform1ivARB),"glUniform1ivARB");
    _driver.call(&_driver.glUniform1ivARB)(location, count, value);
  }

  static void REGAL_CALL glUniform2fARB(GLint location, GLfloat v0, GLfloat v1)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform2fARB),reinterpret_cast<void (*)()>(glUniform2fARB),"glUniform2fARB");
    _driver.call(&_driver.glUniform2fARB)(location, v0, v1);
  }

  static void REGAL_CALL glUniform2fvARB(GLint location, GLsizei count, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform2fvARB),reinterpret_cast<void (*)()>(glUniform2fvARB),"glUniform2fvARB");
    _driver.call(&_driver.glUniform2fvARB)(location, count, value);
  }

  static void REGAL_CALL glUniform2iARB(GLint location, GLint v0, GLint v1)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform2iARB),reinterpret_cast<void (*)()>(glUniform2iARB),"glUniform2iARB");
    _driver.call(&_driver.glUniform2iARB)(location, v0, v1);
  }

  static void REGAL_CALL glUniform2ivARB(GLint location, GLsizei count, const GLint *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform2ivARB),reinterpret_cast<void (*)()>(glUniform2ivARB),"glUniform2ivARB");
    _driver.call(&_driver.glUniform2ivARB)(location, count, value);
  }

  static void REGAL_CALL glUniform3fARB(GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform3fARB),reinterpret_cast<void (*)()>(glUniform3fARB),"glUniform3fARB");
    _driver.call(&_driver.glUniform3fARB)(location, v0, v1, v2);
  }

  static void REGAL_CALL glUniform3fvARB(GLint location, GLsizei count, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform3fvARB),reinterpret_cast<void (*)()>(glUniform3fvARB),"glUniform3fvARB");
    _driver.call(&_driver.glUniform3fvARB)(location, count, value);
  }

  static void REGAL_CALL glUniform3iARB(GLint location, GLint v0, GLint v1, GLint v2)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform3iARB),reinterpret_cast<void (*)()>(glUniform3iARB),"glUniform3iARB");
    _driver.call(&_driver.glUniform3iARB)(location, v0, v1, v2);
  }

  static void REGAL_CALL glUniform3ivARB(GLint location, GLsizei count, const GLint *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform3ivARB),reinterpret_cast<void (*)()>(glUniform3ivARB),"glUniform3ivARB");
    _driver.call(&_driver.glUniform3ivARB)(location, count, value);
  }

  static void REGAL_CALL glUniform4fARB(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform4fARB),reinterpret_cast<void (*)()>(glUniform4fARB),"glUniform4fARB");
    _driver.call(&_driver.glUniform4fARB)(location, v0, v1, v2, v3);
  }

  static void REGAL_CALL glUniform4fvARB(GLint location, GLsizei count, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform4fvARB),reinterpret_cast<void (*)()>(glUniform4fvARB),"glUniform4fvARB");
    _driver.call(&_driver.glUniform4fvARB)(location, count, value);
  }

  static void REGAL_CALL glUniform4iARB(GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform4iARB),reinterpret_cast<void (*)()>(glUniform4iARB),"glUniform4iARB");
    _driver.call(&_driver.glUniform4iARB)(location, v0, v1, v2, v3);
  }

  static void REGAL_CALL glUniform4ivARB(GLint location, GLsizei count, const GLint *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform4ivARB),reinterpret_cast<void (*)()>(glUniform4ivARB),"glUniform4ivARB");
    _driver.call(&_driver.glUniform4ivARB)(location, count, value);
  }

  static void REGAL_CALL glUniformMatrix2fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniformMatrix2fvARB),reinterpret_cast<void (*)()>(glUniformMatrix2fvARB),"glUniformMatrix2fvARB");
    _driver.call(&_driver.glUniformMatrix2fvARB)(location, count, transpose, value);
  }

  static void REGAL_CALL glUniformMatrix3fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniformMatrix3fvARB),reinterpret_cast<void (*)()>(glUniformMatrix3fvARB),"glUniformMatrix3fvARB");
    _driver.call(&_driver.glUniformMatrix3fvARB)(location, count, transpose, value);
  }

  static void REGAL_CALL glUniformMatrix4fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniformMatrix4fvARB),reinterpret_cast<void (*)()>(glUniformMatrix4fvARB),"glUniformMatrix4fvARB");
    _driver.call(&_driver.glUniformMatrix4fvARB)(location, count, transpose, value);
  }

  static void REGAL_CALL glUseProgramObjectARB(GLhandleARB programObj)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUseProgramObjectARB),reinterpret_cast<void (*)()>(glUseProgramObjectARB),"glUseProgramObjectARB");
    _driver.call(&_driver.glUseProgramObjectARB)(programObj);
  }

  static void REGAL_CALL glValidateProgramARB(GLhandleARB programObj)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glValidateProgramARB),reinterpret_cast<void (*)()>(glValidateProgramARB),"glValidateProgramARB");
    _driver.call(&_driver.glValidateProgramARB)(programObj);
  }

// GL_ARB_shader_storage_buffer_object

  static void REGAL_CALL glShaderStorageBlockBinding(GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glShaderStorageBlockBinding),reinterpret_cast<void (*)()>(glShaderStorageBlockBinding),"glShaderStorageBlockBinding");
    _driver.call(&_driver.glShaderStorageBlockBinding)(program, storageBlockIndex, storageBlockBinding);
  }

// GL_ARB_shader_subroutine

  static void REGAL_CALL glGetActiveSubroutineName(GLuint program, GLenum shaderType, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetActiveSubroutineName),reinterpret_cast<void (*)()>(glGetActiveSubroutineName),"glGetActiveSubroutineName");
    _driver.call(&_driver.glGetActiveSubroutineName)(program, shaderType, index, bufSize, length, name);
  }

  static void REGAL_CALL glGetActiveSubroutineUniformName(GLuint program, GLenum shaderType, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetActiveSubroutineUniformName),reinterpret_cast<void (*)()>(glGetActiveSubroutineUniformName),"glGetActiveSubroutineUniformName");
    _driver.call(&_driver.glGetActiveSubroutineUniformName)(program, shaderType, index, bufSize, length, name);
  }

  static void REGAL_CALL glGetActiveSubroutineUniformiv(GLuint program, GLenum shaderType, GLuint index, GLenum pname, GLint *values)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetActiveSubroutineUniformiv),reinterpret_cast<void (*)()>(glGetActiveSubroutineUniformiv),"glGetActiveSubroutineUniformiv");
    _driver.call(&_driver.glGetActiveSubroutineUniformiv)(program, shaderType, index, pname, values);
  }

  static void REGAL_CALL glGetProgramStageiv(GLuint program, GLenum shaderType, GLenum pname, GLint *values)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetProgramStageiv),reinterpret_cast<void (*)()>(glGetProgramStageiv),"glGetProgramStageiv");
    _driver.call(&_driver.glGetProgramStageiv)(program, shaderType, pname, values);
  }

  static void REGAL_CALL glGetProgramSubroutineParameteruivNV(GLenum target, GLuint index, GLuint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetProgramSubroutineParameteruivNV),reinterpret_cast<void (*)()>(glGetProgramSubroutineParameteruivNV),"glGetProgramSubroutineParameteruivNV");
    _driver.call(&_driver.glGetProgramSubroutineParameteruivNV)(target, index, params);
  }

  static GLuint REGAL_CALL glGetSubroutineIndex(GLuint program, GLenum shaderType, const GLchar *name)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetSubroutineIndex),reinterpret_cast<void (*)()>(glGetSubroutineIndex),"glGetSubroutineIndex");
    return _driver.call(&_driver.glGetSubroutineIndex)(program, shaderType, name);
  }

  static GLint REGAL_CALL glGetSubroutineUniformLocation(GLuint program, GLenum shaderType, const GLchar *name)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetSubroutineUniformLocation),reinterpret_cast<void (*)()>(glGetSubroutineUniformLocation),"glGetSubroutineUniformLocation");
    return _driver.call(&_driver.glGetSubroutineUniformLocation)(program, shaderType, name);
  }

  static void REGAL_CALL glGetUniformSubroutineuiv(GLenum shaderType, GLint location, GLuint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetUniformSubroutineuiv),reinterpret_cast<void (*)()>(glGetUniformSubroutineuiv),"glGetUniformSubroutineuiv");
    _driver.call(&_driver.glGetUniformSubroutineuiv)(shaderType, location, params);
  }

  static void REGAL_CALL glProgramSubroutineParametersuivNV(GLenum target, GLsizei count, const GLuint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramSubroutineParametersuivNV),reinterpret_cast<void (*)()>(glProgramSubroutineParametersuivNV),"glProgramSubroutineParametersuivNV");
    _driver.call(&_driver.glProgramSubroutineParametersuivNV)(target, count, params);
  }

  static void REGAL_CALL glUniformSubroutinesuiv(GLenum shaderType, GLsizei count, const GLuint *indices)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniformSubroutinesuiv),reinterpret_cast<void (*)()>(glUniformSubroutinesuiv),"glUniformSubroutinesuiv");
    _driver.call(&_driver.glUniformSubroutinesuiv)(shaderType, count, indices);
  }

// GL_ARB_shading_language_include

  static void REGAL_CALL glCompileShaderIncludeARB(GLuint shader, GLsizei count, const GLchar **path, const GLint *length)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCompileShaderIncludeARB),reinterpret_cast<void (*)()>(glCompileShaderIncludeARB),"glCompileShaderIncludeARB");
    _driver.call(&_driver.glCompileShaderIncludeARB)(shader, count, path, length);
  }

  static void REGAL_CALL glDeleteNamedStringARB(GLint namelen, const GLchar *name)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDeleteNamedStringARB),reinterpret_cast<void (*)()>(glDeleteNamedStringARB),"glDeleteNamedStringARB");
    _driver.call(&_driver.glDeleteNamedStringARB)(namelen, name);
  }

  static void REGAL_CALL glGetNamedStringARB(GLint namelen, const GLchar *name, GLsizei bufSize, GLint *stringlen, GLchar *string)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetNamedStringARB),reinterpret_cast<void (*)()>(glGetNamedStringARB),"glGetNamedStringARB");
    _driver.call(&_driver.glGetNamedStringARB)(namelen, name, bufSize, stringlen, string);
  }

  static void REGAL_CALL glGetNamedStringivARB(GLint namelen, const GLchar *name, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetNamedStringivARB),reinterpret_cast<void (*)()>(glGetNamedStringivARB),"glGetNamedStringivARB");
    _driver.call(&_driver.glGetNamedStringivARB)(namelen, name, pname, params);
  }

  static GLboolean REGAL_CALL glIsNamedStringARB(GLint namelen, const GLchar *name)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIsNamedStringARB),reinterpret_cast<void (*)()>(glIsNamedStringARB),"glIsNamedStringARB");
    return _driver.call(&_driver.glIsNamedStringARB)(namelen, name);
  }

  static void REGAL_CALL glNamedStringARB(GLenum type, GLint namelen, const GLchar *name, GLint stringlen, const GLchar *string)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNamedStringARB),reinterpret_cast<void (*)()>(glNamedStringARB),"glNamedStringARB");
    _driver.call(&_driver.glNamedStringARB)(type, namelen, name, stringlen, string);
  }

// GL_ARB_sparse_texture

  static void REGAL_CALL glTexPageCommitmentARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexPageCommitmentARB),reinterpret_cast<void (*)()>(glTexPageCommitmentARB),"glTexPageCommitmentARB");
    _driver.call(&_driver.glTexPageCommitmentARB)(target, level, xoffset, yoffset, zoffset, width, height, depth, commit);
  }

  static void REGAL_CALL glTexturePageCommitmentEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexturePageCommitmentEXT),reinterpret_cast<void (*)()>(glTexturePageCommitmentEXT),"glTexturePageCommitmentEXT");
    _driver.call(&_driver.glTexturePageCommitmentEXT)(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, commit);
  }

// GL_ARB_sync

  static GLenum REGAL_CALL glClientWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glClientWaitSync),reinterpret_cast<void (*)()>(glClientWaitSync),"glClientWaitSync");
    return _driver.call(&_driver.glClientWaitSync)(sync, flags, timeout);
  }

  static void REGAL_CALL glDeleteSync(GLsync sync)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDeleteSync),reinterpret_cast<void (*)()>(glDeleteSync),"glDeleteSync");
    _driver.call(&_driver.glDeleteSync)(sync);
  }

  static GLsync REGAL_CALL glFenceSync(GLenum condition, GLbitfield flags)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFenceSync),reinterpret_cast<void (*)()>(glFenceSync),"glFenceSync");
    return _driver.call(&_driver.glFenceSync)(condition, flags);
  }

  static void REGAL_CALL glGetInteger64v(GLenum pname, GLint64 *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetInteger64v),reinterpret_cast<void (*)()>(glGetInteger64v),"glGetInteger64v");
    _driver.call(&_driver.glGetInteger64v)(pname, params);
  }

  static void REGAL_CALL glGetSynciv(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetSynciv),reinterpret_cast<void (*)()>(glGetSynciv),"glGetSynciv");
    _driver.call(&_driver.glGetSynciv)(sync, pname, bufSize, length, values);
  }

  static GLboolean REGAL_CALL glIsSync(GLsync sync)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIsSync),reinterpret_cast<void (*)()>(glIsSync),"glIsSync");
    return _driver.call(&_driver.glIsSync)(sync);
  }

  static void REGAL_CALL glWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWaitSync),reinterpret_cast<void (*)()>(glWaitSync),"glWaitSync");
    _driver.call(&_driver.glWaitSync)(sync, flags, timeout);
  }

// GL_ARB_tessellation_shader

  static void REGAL_CALL glPatchParameterfv(GLenum pname, const GLfloat *values)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPatchParameterfv),reinterpret_cast<void (*)()>(glPatchParameterfv),"glPatchParameterfv");
    _driver.call(&_driver.glPatchParameterfv)(pname, values);
  }

  static void REGAL_CALL glPatchParameteri(GLenum pname, GLint value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPatchParameteri),reinterpret_cast<void (*)()>(glPatchParameteri),"glPatchParameteri");
    _driver.call(&_driver.glPatchParameteri)(pname, value);
  }

// GL_ARB_texture_buffer_object

  static void REGAL_CALL glTexBufferARB(GLenum target, GLenum internalformat, GLuint buffer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexBufferARB),reinterpret_cast<void (*)()>(glTexBufferARB),"glTexBufferARB");
    _driver.call(&_driver.glTexBufferARB)(target, internalformat, buffer);
  }

// GL_ARB_texture_buffer_range

  static void REGAL_CALL glTexBufferRange(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexBufferRange),reinterpret_cast<void (*)()>(glTexBufferRange),"glTexBufferRange");
    _driver.call(&_driver.glTexBufferRange)(target, internalformat, buffer, offset, size);
  }

  static void REGAL_CALL glTextureBufferRangeEXT(GLuint texture, GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTextureBufferRangeEXT),reinterpret_cast<void (*)()>(glTextureBufferRangeEXT),"glTextureBufferRangeEXT");
    _driver.call(&_driver.glTextureBufferRangeEXT)(texture, target, internalformat, buffer, offset, size);
  }

// GL_ARB_texture_compression

  static void REGAL_CALL glCompressedTexImage1DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCompressedTexImage1DARB),reinterpret_cast<void (*)()>(glCompressedTexImage1DARB),"glCompressedTexImage1DARB");
    _driver.call(&_driver.glCompressedTexImage1DARB)(target, level, internalformat, width, border, imageSize, data);
  }

  static void REGAL_CALL glCompressedTexImage2DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCompressedTexImage2DARB),reinterpret_cast<void (*)()>(glCompressedTexImage2DARB),"glCompressedTexImage2DARB");
    _driver.call(&_driver.glCompressedTexImage2DARB)(target, level, internalformat, width, height, border, imageSize, data);
  }

  static void REGAL_CALL glCompressedTexImage3DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCompressedTexImage3DARB),reinterpret_cast<void (*)()>(glCompressedTexImage3DARB),"glCompressedTexImage3DARB");
    _driver.call(&_driver.glCompressedTexImage3DARB)(target, level, internalformat, width, height, depth, border, imageSize, data);
  }

  static void REGAL_CALL glCompressedTexSubImage1DARB(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCompressedTexSubImage1DARB),reinterpret_cast<void (*)()>(glCompressedTexSubImage1DARB),"glCompressedTexSubImage1DARB");
    _driver.call(&_driver.glCompressedTexSubImage1DARB)(target, level, xoffset, width, format, imageSize, data);
  }

  static void REGAL_CALL glCompressedTexSubImage2DARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCompressedTexSubImage2DARB),reinterpret_cast<void (*)()>(glCompressedTexSubImage2DARB),"glCompressedTexSubImage2DARB");
    _driver.call(&_driver.glCompressedTexSubImage2DARB)(target, level, xoffset, yoffset, width, height, format, imageSize, data);
  }

  static void REGAL_CALL glCompressedTexSubImage3DARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCompressedTexSubImage3DARB),reinterpret_cast<void (*)()>(glCompressedTexSubImage3DARB),"glCompressedTexSubImage3DARB");
    _driver.call(&_driver.glCompressedTexSubImage3DARB)(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
  }

  static void REGAL_CALL glGetCompressedTexImageARB(GLenum target, GLint lod, GLvoid *img)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetCompressedTexImageARB),reinterpret_cast<void (*)()>(glGetCompressedTexImageARB),"glGetCompressedTexImageARB");
    _driver.call(&_driver.glGetCompressedTexImageARB)(target, lod, img);
  }

// GL_ARB_texture_multisample

  static void REGAL_CALL glGetMultisamplefv(GLenum pname, GLuint index, GLfloat *val)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetMultisamplefv),reinterpret_cast<void (*)()>(glGetMultisamplefv),"glGetMultisamplefv");
    _driver.call(&_driver.glGetMultisamplefv)(pname, index, val);
  }

  static void REGAL_CALL glSampleMaski(GLuint index, GLbitfield mask)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSampleMaski),reinterpret_cast<void (*)()>(glSampleMaski),"glSampleMaski");
    _driver.call(&_driver.glSampleMaski)(index, mask);
  }

  static void REGAL_CALL glTexImage2DMultisample(GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexImage2DMultisample),reinterpret_cast<void (*)()>(glTexImage2DMultisample),"glTexImage2DMultisample");
    _driver.call(&_driver.glTexImage2DMultisample)(target, samples, internalformat, width, height, fixedsamplelocations);
  }

  static void REGAL_CALL glTexImage3DMultisample(GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexImage3DMultisample),reinterpret_cast<void (*)()>(glTexImage3DMultisample),"glTexImage3DMultisample");
    _driver.call(&_driver.glTexImage3DMultisample)(target, samples, internalformat, width, height, depth, fixedsamplelocations);
  }

// GL_ARB_texture_storage

  static void REGAL_CALL glTexStorage1D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexStorage1D),reinterpret_cast<void (*)()>(glTexStorage1D),"glTexStorage1D");
    _driver.call(&_driver.glTexStorage1D)(target, levels, internalformat, width);
  }

  static void REGAL_CALL glTexStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexStorage2D),reinterpret_cast<void (*)()>(glTexStorage2D),"glTexStorage2D");
    _driver.call(&_driver.glTexStorage2D)(target, levels, internalformat, width, height);
  }

  static void REGAL_CALL glTexStorage3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexStorage3D),reinterpret_cast<void (*)()>(glTexStorage3D),"glTexStorage3D");
    _driver.call(&_driver.glTexStorage3D)(target, levels, internalformat, width, height, depth);
  }

  static void REGAL_CALL glTextureStorage1DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTextureStorage1DEXT),reinterpret_cast<void (*)()>(glTextureStorage1DEXT),"glTextureStorage1DEXT");
    _driver.call(&_driver.glTextureStorage1DEXT)(texture, target, levels, internalformat, width);
  }

  static void REGAL_CALL glTextureStorage2DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTextureStorage2DEXT),reinterpret_cast<void (*)()>(glTextureStorage2DEXT),"glTextureStorage2DEXT");
    _driver.call(&_driver.glTextureStorage2DEXT)(texture, target, levels, internalformat, width, height);
  }

  static void REGAL_CALL glTextureStorage3DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTextureStorage3DEXT),reinterpret_cast<void (*)()>(glTextureStorage3DEXT),"glTextureStorage3DEXT");
    _driver.call(&_driver.glTextureStorage3DEXT)(texture, target, levels, internalformat, width, height, depth);
  }

// GL_ARB_texture_storage_multisample

  static void REGAL_CALL glTexStorage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexStorage2DMultisample),reinterpret_cast<void (*)()>(glTexStorage2DMultisample),"glTexStorage2DMultisample");
    _driver.call(&_driver.glTexStorage2DMultisample)(target, samples, internalformat, width, height, fixedsamplelocations);
  }

  static void REGAL_CALL glTexStorage3DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexStorage3DMultisample),reinterpret_cast<void (*)()>(glTexStorage3DMultisample),"glTexStorage3DMultisample");
    _driver.call(&_driver.glTexStorage3DMultisample)(target, samples, internalformat, width, height, depth, fixedsamplelocations);
  }

  static void REGAL_CALL glTextureStorage2DMultisampleEXT(GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTextureStorage2DMultisampleEXT),reinterpret_cast<void (*)()>(glTextureStorage2DMultisampleEXT),"glTextureStorage2DMultisampleEXT");
    _driver.call(&_driver.glTextureStorage2DMultisampleEXT)(texture, target, samples, internalformat, width, height, fixedsamplelocations);
  }

  static void REGAL_CALL glTextureStorage3DMultisampleEXT(GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTextureStorage3DMultisampleEXT),reinterpret_cast<void (*)()>(glTextureStorage3DMultisampleEXT),"glTextureStorage3DMultisampleEXT");
    _driver.call(&_driver.glTextureStorage3DMultisampleEXT)(texture, target, samples, internalformat, width, height, depth, fixedsamplelocations);
  }

// GL_ARB_texture_view

  static void REGAL_CALL glTextureView(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTextureView),reinterpret_cast<void (*)()>(glTextureView),"glTextureView");
    _driver.call(&_driver.glTextureView)(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
  }

// GL_ARB_timer_query

  static void REGAL_CALL glGetQueryObjecti64v(GLuint id, GLenum pname, GLint64 *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetQueryObjecti64v),reinterpret_cast<void (*)()>(glGetQueryObjecti64v),"glGetQueryObjecti64v");
    _driver.call(&_driver.glGetQueryObjecti64v)(id, pname, params);
  }

  static void REGAL_CALL glGetQueryObjectui64v(GLuint id, GLenum pname, GLuint64 *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetQueryObjectui64v),reinterpret_cast<void (*)()>(glGetQueryObjectui64v),"glGetQueryObjectui64v");
    _driver.call(&_driver.glGetQueryObjectui64v)(id, pname, params);
  }

  static void REGAL_CALL glQueryCounter(GLuint id, GLenum target)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glQueryCounter),reinterpret_cast<void (*)()>(glQueryCounter),"glQueryCounter");
    _driver.call(&_driver.glQueryCounter)(id, target);
  }

// GL_ARB_transform_feedback2

  static void REGAL_CALL glBindTransformFeedback(GLenum target, GLuint id)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBindTransformFeedback),reinterpret_cast<void (*)()>(glBindTransformFeedback),"glBindTransformFeedback");
    _driver.call(&_driver.glBindTransformFeedback)(target, id);
  }

  static void REGAL_CALL glDeleteTransformFeedbacks(GLsizei n, const GLuint *ids)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDeleteTransformFeedbacks),reinterpret_cast<void (*)()>(glDeleteTransformFeedbacks),"glDeleteTransformFeedbacks");
    _driver.call(&_driver.glDeleteTransformFeedbacks)(n, ids);
  }

  static void REGAL_CALL glDrawTransformFeedback(GLenum mode, GLuint name)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDrawTransformFeedback),reinterpret_cast<void (*)()>(glDrawTransformFeedback),"glDrawTransformFeedback");
    _driver.call(&_driver.glDrawTransformFeedback)(mode, name);
  }

  static void REGAL_CALL glGenTransformFeedbacks(GLsizei n, GLuint *ids)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGenTransformFeedbacks),reinterpret_cast<void (*)()>(glGenTransformFeedbacks),"glGenTransformFeedbacks");
    _driver.call(&_driver.glGenTransformFeedbacks)(n, ids);
  }

  static GLboolean REGAL_CALL glIsTransformFeedback(GLuint id)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIsTransformFeedback),reinterpret_cast<void (*)()>(glIsTransformFeedback),"glIsTransformFeedback");
    return _driver.call(&_driver.glIsTransformFeedback)(id);
  }

  static void REGAL_CALL glPauseTransformFeedback(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPauseTransformFeedback),reinterpret_cast<void (*)()>(glPauseTransformFeedback),"glPauseTransformFeedback");
    _driver.call(&_driver.glPauseTransformFeedback)();
  }

  static void REGAL_CALL glResumeTransformFeedback(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glResumeTransformFeedback),reinterpret_cast<void (*)()>(glResumeTransformFeedback),"glResumeTransformFeedback");
    _driver.call(&_driver.glResumeTransformFeedback)();
  }

// GL_ARB_transform_feedback3

  static void REGAL_CALL glBeginQueryIndexed(GLenum target, GLuint index, GLuint id)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBeginQueryIndexed),reinterpret_cast<void (*)()>(glBeginQueryIndexed),"glBeginQueryIndexed");
    _driver.call(&_driver.glBeginQueryIndexed)(target, index, id);
  }

  static void REGAL_CALL glDrawTransformFeedbackStream(GLenum mode, GLuint id, GLuint stream)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDrawTransformFeedbackStream),reinterpret_cast<void (*)()>(glDrawTransformFeedbackStream),"glDrawTransformFeedbackStream");
    _driver.call(&_driver.glDrawTransformFeedbackStream)(mode, id, stream);
  }

  static void REGAL_CALL glEndQueryIndexed(GLenum target, GLuint index)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glEndQueryIndexed),reinterpret_cast<void (*)()>(glEndQueryIndexed),"glEndQueryIndexed");
    _driver.call(&_driver.glEndQueryIndexed)(target, index);
  }

  static void REGAL_CALL glGetQueryIndexediv(GLenum target, GLuint index, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetQueryIndexediv),reinterpret_cast<void (*)()>(glGetQueryIndexediv),"glGetQueryIndexediv");
    _driver.call(&_driver.glGetQueryIndexediv)(target, index, pname, params);
  }

// GL_ARB_transform_feedback_instanced

  static void REGAL_CALL glDrawTransformFeedbackInstanced(GLenum mode, GLuint id, GLsizei primcount)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDrawTransformFeedbackInstanced),reinterpret_cast<void (*)()>(glDrawTransformFeedbackInstanced),"glDrawTransformFeedbackInstanced");
    _driver.call(&_driver.glDrawTransformFeedbackInstanced)(mode, id, primcount);
  }

  static void REGAL_CALL glDrawTransformFeedbackStreamInstanced(GLenum mode, GLuint id, GLuint stream, GLsizei primcount)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDrawTransformFeedbackStreamInstanced),reinterpret_cast<void (*)()>(glDrawTransformFeedbackStreamInstanced),"glDrawTransformFeedbackStreamInstanced");
    _driver.call(&_driver.glDrawTransformFeedbackStreamInstanced)(mode, id, stream, primcount);
  }

// GL_ARB_transpose_matrix

  static void REGAL_CALL glLoadTransposeMatrixdARB(const GLdouble *m)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glLoadTransposeMatrixdARB),reinterpret_cast<void (*)()>(glLoadTransposeMatrixdARB),"glLoadTransposeMatrixdARB");
    _driver.call(&_driver.glLoadTransposeMatrixdARB)(m);
  }

  static void REGAL_CALL glLoadTransposeMatrixfARB(const GLfloat *m)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glLoadTransposeMatrixfARB),reinterpret_cast<void (*)()>(glLoadTransposeMatrixfARB),"glLoadTransposeMatrixfARB");
    _driver.call(&_driver.glLoadTransposeMatrixfARB)(m);
  }

  static void REGAL_CALL glMultTransposeMatrixdARB(const GLdouble *m)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultTransposeMatrixdARB),reinterpret_cast<void (*)()>(glMultTransposeMatrixdARB),"glMultTransposeMatrixdARB");
    _driver.call(&_driver.glMultTransposeMatrixdARB)(m);
  }

  static void REGAL_CALL glMultTransposeMatrixfARB(const GLfloat *m)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultTransposeMatrixfARB),reinterpret_cast<void (*)()>(glMultTransposeMatrixfARB),"glMultTransposeMatrixfARB");
    _driver.call(&_driver.glMultTransposeMatrixfARB)(m);
  }

// GL_ARB_uniform_buffer_object

  static void REGAL_CALL glBindBufferBase(GLenum target, GLuint index, GLuint buffer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBindBufferBase),reinterpret_cast<void (*)()>(glBindBufferBase),"glBindBufferBase");
    _driver.call(&_driver.glBindBufferBase)(target, index, buffer);
  }

  static void REGAL_CALL glBindBufferRange(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBindBufferRange),reinterpret_cast<void (*)()>(glBindBufferRange),"glBindBufferRange");
    _driver.call(&_driver.glBindBufferRange)(target, index, buffer, offset, size);
  }

  static void REGAL_CALL glGetActiveUniformBlockName(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetActiveUniformBlockName),reinterpret_cast<void (*)()>(glGetActiveUniformBlockName),"glGetActiveUniformBlockName");
    _driver.call(&_driver.glGetActiveUniformBlockName)(program, uniformBlockIndex, bufSize, length, uniformBlockName);
  }

  static void REGAL_CALL glGetActiveUniformBlockiv(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetActiveUniformBlockiv),reinterpret_cast<void (*)()>(glGetActiveUniformBlockiv),"glGetActiveUniformBlockiv");
    _driver.call(&_driver.glGetActiveUniformBlockiv)(program, uniformBlockIndex, pname, params);
  }

  static void REGAL_CALL glGetActiveUniformName(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformName)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetActiveUniformName),reinterpret_cast<void (*)()>(glGetActiveUniformName),"glGetActiveUniformName");
    _driver.call(&_driver.glGetActiveUniformName)(program, uniformIndex, bufSize, length, uniformName);
  }

  static void REGAL_CALL glGetActiveUniformsiv(GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetActiveUniformsiv),reinterpret_cast<void (*)()>(glGetActiveUniformsiv),"glGetActiveUniformsiv");
    _driver.call(&_driver.glGetActiveUniformsiv)(program, uniformCount, uniformIndices, pname, params);
  }

  static void REGAL_CALL glGetIntegeri_v(GLenum target, GLuint index, GLint *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetIntegeri_v),reinterpret_cast<void (*)()>(glGetIntegeri_v),"glGetIntegeri_v");
    _driver.call(&_driver.glGetIntegeri_v)(target, index, data);
  }

  static GLuint REGAL_CALL glGetUniformBlockIndex(GLuint program, const GLchar *uniformBlockName)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetUniformBlockIndex),reinterpret_cast<void (*)()>(glGetUniformBlockIndex),"glGetUniformBlockIndex");
    return _driver.call(&_driver.glGetUniformBlockIndex)(program, uniformBlockName);
  }

  static void REGAL_CALL glGetUniformIndices(GLuint program, GLsizei uniformCount, const GLchar * const *uniformNames, GLuint *uniformIndices)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetUniformIndices),reinterpret_cast<void (*)()>(glGetUniformIndices),"glGetUniformIndices");
    _driver.call(&_driver.glGetUniformIndices)(program, uniformCount, uniformNames, uniformIndices);
  }

  static void REGAL_CALL glUniformBlockBinding(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniformBlockBinding),reinterpret_cast<void (*)()>(glUniformBlockBinding),"glUniformBlockBinding");
    _driver.call(&_driver.glUniformBlockBinding)(program, uniformBlockIndex, uniformBlockBinding);
  }

// GL_ARB_vertex_array_object

  static void REGAL_CALL glBindVertexArray(GLuint array)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBindVertexArray),reinterpret_cast<void (*)()>(glBindVertexArray),"glBindVertexArray");
    _driver.call(&_driver.glBindVertexArray)(array);
  }

  static void REGAL_CALL glDeleteVertexArrays(GLsizei n, const GLuint *arrays)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDeleteVertexArrays),reinterpret_cast<void (*)()>(glDeleteVertexArrays),"glDeleteVertexArrays");
    _driver.call(&_driver.glDeleteVertexArrays)(n, arrays);
  }

  static void REGAL_CALL glGenVertexArrays(GLsizei n, GLuint *arrays)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGenVertexArrays),reinterpret_cast<void (*)()>(glGenVertexArrays),"glGenVertexArrays");
    _driver.call(&_driver.glGenVertexArrays)(n, arrays);
  }

  static GLboolean REGAL_CALL glIsVertexArray(GLuint array)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIsVertexArray),reinterpret_cast<void (*)()>(glIsVertexArray),"glIsVertexArray");
    return _driver.call(&_driver.glIsVertexArray)(array);
  }

// GL_ARB_vertex_attrib_64bit

  static void REGAL_CALL glGetVertexAttribLdv(GLuint index, GLenum pname, GLdouble *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetVertexAttribLdv),reinterpret_cast<void (*)()>(glGetVertexAttribLdv),"glGetVertexAttribLdv");
    _driver.call(&_driver.glGetVertexAttribLdv)(index, pname, params);
  }

  static void REGAL_CALL glVertexAttribL1d(GLuint index, GLdouble x)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribL1d),reinterpret_cast<void (*)()>(glVertexAttribL1d),"glVertexAttribL1d");
    _driver.call(&_driver.glVertexAttribL1d)(index, x);
  }

  static void REGAL_CALL glVertexAttribL1dv(GLuint index, const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribL1dv),reinterpret_cast<void (*)()>(glVertexAttribL1dv),"glVertexAttribL1dv");
    _driver.call(&_driver.glVertexAttribL1dv)(index, v);
  }

  static void REGAL_CALL glVertexAttribL2d(GLuint index, GLdouble x, GLdouble y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribL2d),reinterpret_cast<void (*)()>(glVertexAttribL2d),"glVertexAttribL2d");
    _driver.call(&_driver.glVertexAttribL2d)(index, x, y);
  }

  static void REGAL_CALL glVertexAttribL2dv(GLuint index, const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribL2dv),reinterpret_cast<void (*)()>(glVertexAttribL2dv),"glVertexAttribL2dv");
    _driver.call(&_driver.glVertexAttribL2dv)(index, v);
  }

  static void REGAL_CALL glVertexAttribL3d(GLuint index, GLdouble x, GLdouble y, GLdouble z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribL3d),reinterpret_cast<void (*)()>(glVertexAttribL3d),"glVertexAttribL3d");
    _driver.call(&_driver.glVertexAttribL3d)(index, x, y, z);
  }

  static void REGAL_CALL glVertexAttribL3dv(GLuint index, const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribL3dv),reinterpret_cast<void (*)()>(glVertexAttribL3dv),"glVertexAttribL3dv");
    _driver.call(&_driver.glVertexAttribL3dv)(index, v);
  }

  static void REGAL_CALL glVertexAttribL4d(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribL4d),reinterpret_cast<void (*)()>(glVertexAttribL4d),"glVertexAttribL4d");
    _driver.call(&_driver.glVertexAttribL4d)(index, x, y, z, w);
  }

  static void REGAL_CALL glVertexAttribL4dv(GLuint index, const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribL4dv),reinterpret_cast<void (*)()>(glVertexAttribL4dv),"glVertexAttribL4dv");
    _driver.call(&_driver.glVertexAttribL4dv)(index, v);
  }

  static void REGAL_CALL glVertexAttribLPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribLPointer),reinterpret_cast<void (*)()>(glVertexAttribLPointer),"glVertexAttribLPointer");
    _driver.call(&_driver.glVertexAttribLPointer)(index, size, type, stride, pointer);
  }

// GL_ARB_vertex_attrib_binding

  static void REGAL_CALL glBindVertexBuffer(GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBindVertexBuffer),reinterpret_cast<void (*)()>(glBindVertexBuffer),"glBindVertexBuffer");
    _driver.call(&_driver.glBindVertexBuffer)(bindingindex, buffer, offset, stride);
  }

  static void REGAL_CALL glVertexArrayBindVertexBufferEXT(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexArrayBindVertexBufferEXT),reinterpret_cast<void (*)()>(glVertexArrayBindVertexBufferEXT),"glVertexArrayBindVertexBufferEXT");
    _driver.call(&_driver.glVertexArrayBindVertexBufferEXT)(vaobj, bindingindex, buffer, offset, stride);
  }

  static void REGAL_CALL glVertexArrayVertexAttribBindingEXT(GLuint vaobj, GLuint attribindex, GLuint bindingindex)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexArrayVertexAttribBindingEXT),reinterpret_cast<void (*)()>(glVertexArrayVertexAttribBindingEXT),"glVertexArrayVertexAttribBindingEXT");
    _driver.call(&_driver.glVertexArrayVertexAttribBindingEXT)(vaobj, attribindex, bindingindex);
  }

  static void REGAL_CALL glVertexArrayVertexAttribFormatEXT(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexArrayVertexAttribFormatEXT),reinterpret_cast<void (*)()>(glVertexArrayVertexAttribFormatEXT),"glVertexArrayVertexAttribFormatEXT");
    _driver.call(&_driver.glVertexArrayVertexAttribFormatEXT)(vaobj, attribindex, size, type, normalized, relativeoffset);
  }

  static void REGAL_CALL glVertexArrayVertexAttribIFormatEXT(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexArrayVertexAttribIFormatEXT),reinterpret_cast<void (*)()>(glVertexArrayVertexAttribIFormatEXT),"glVertexArrayVertexAttribIFormatEXT");
    _driver.call(&_driver.glVertexArrayVertexAttribIFormatEXT)(vaobj, attribindex, size, type, relativeoffset);
  }

  static void REGAL_CALL glVertexArrayVertexAttribLFormatEXT(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexArrayVertexAttribLFormatEXT),reinterpret_cast<void (*)()>(glVertexArrayVertexAttribLFormatEXT),"glVertexArrayVertexAttribLFormatEXT");
    _driver.call(&_driver.glVertexArrayVertexAttribLFormatEXT)(vaobj, attribindex, size, type, relativeoffset);
  }

  static void REGAL_CALL glVertexArrayVertexBindingDivisorEXT(GLuint vaobj, GLuint bindingindex, GLuint divisor)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexArrayVertexBindingDivisorEXT),reinterpret_cast<void (*)()>(glVertexArrayVertexBindingDivisorEXT),"glVertexArrayVertexBindingDivisorEXT");
    _driver.call(&_driver.glVertexArrayVertexBindingDivisorEXT)(vaobj, bindingindex, divisor);
  }

  static void REGAL_CALL glVertexAttribBinding(GLuint attribindex, GLuint bindingindex)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribBinding),reinterpret_cast<void (*)()>(glVertexAttribBinding),"glVertexAttribBinding");
    _driver.call(&_driver.glVertexAttribBinding)(attribindex, bindingindex);
  }

  static void REGAL_CALL glVertexAttribFormat(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribFormat),reinterpret_cast<void (*)()>(glVertexAttribFormat),"glVertexAttribFormat");
    _driver.call(&_driver.glVertexAttribFormat)(attribindex, size, type, normalized, relativeoffset);
  }

  static void REGAL_CALL glVertexAttribIFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribIFormat),reinterpret_cast<void (*)()>(glVertexAttribIFormat),"glVertexAttribIFormat");
    _driver.call(&_driver.glVertexAttribIFormat)(attribindex, size, type, relativeoffset);
  }

  static void REGAL_CALL glVertexAttribLFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribLFormat),reinterpret_cast<void (*)()>(glVertexAttribLFormat),"glVertexAttribLFormat");
    _driver.call(&_driver.glVertexAttribLFormat)(attribindex, size, type, relativeoffset);
  }

  static void REGAL_CALL glVertexBindingDivisor(GLuint bindingindex, GLuint divisor)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexBindingDivisor),reinterpret_cast<void (*)()>(glVertexBindingDivisor),"glVertexBindingDivisor");
    _driver.call(&_driver.glVertexBindingDivisor)(bindingindex, divisor);
  }

// GL_ARB_vertex_blend

  static void REGAL_CALL glVertexBlendARB(GLint count)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexBlendARB),reinterpret_cast<void (*)()>(glVertexBlendARB),"glVertexBlendARB");
    _driver.call(&_driver.glVertexBlendARB)(count);
  }

  static void REGAL_CALL glWeightPointerARB(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWeightPointerARB),reinterpret_cast<void (*)()>(glWeightPointerARB),"glWeightPointerARB");
    _driver.call(&_driver.glWeightPointerARB)(size, type, stride, pointer);
  }

  static void REGAL_CALL glWeightbvARB(GLint size, const GLbyte *weights)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWeightbvARB),reinterpret_cast<void (*)()>(glWeightbvARB),"glWeightbvARB");
    _driver.call(&_driver.glWeightbvARB)(size, weights);
  }

  static void REGAL_CALL glWeightdvARB(GLint size, const GLdouble *weights)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWeightdvARB),reinterpret_cast<void (*)()>(glWeightdvARB),"glWeightdvARB");
    _driver.call(&_driver.glWeightdvARB)(size, weights);
  }

  static void REGAL_CALL glWeightfvARB(GLint size, const GLfloat *weights)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWeightfvARB),reinterpret_cast<void (*)()>(glWeightfvARB),"glWeightfvARB");
    _driver.call(&_driver.glWeightfvARB)(size, weights);
  }

  static void REGAL_CALL glWeightivARB(GLint size, const GLint *weights)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWeightivARB),reinterpret_cast<void (*)()>(glWeightivARB),"glWeightivARB");
    _driver.call(&_driver.glWeightivARB)(size, weights);
  }

  static void REGAL_CALL glWeightsvARB(GLint size, const GLshort *weights)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWeightsvARB),reinterpret_cast<void (*)()>(glWeightsvARB),"glWeightsvARB");
    _driver.call(&_driver.glWeightsvARB)(size, weights);
  }

  static void REGAL_CALL glWeightubvARB(GLint size, const GLubyte *weights)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWeightubvARB),reinterpret_cast<void (*)()>(glWeightubvARB),"glWeightubvARB");
    _driver.call(&_driver.glWeightubvARB)(size, weights);
  }

  static void REGAL_CALL glWeightuivARB(GLint size, const GLuint *weights)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWeightuivARB),reinterpret_cast<void (*)()>(glWeightuivARB),"glWeightuivARB");
    _driver.call(&_driver.glWeightuivARB)(size, weights);
  }

  static void REGAL_CALL glWeightusvARB(GLint size, const GLushort *weights)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWeightusvARB),reinterpret_cast<void (*)()>(glWeightusvARB),"glWeightusvARB");
    _driver.call(&_driver.glWeightusvARB)(size, weights);
  }

// GL_ARB_vertex_buffer_object

  static void REGAL_CALL glBindBufferARB(GLenum target, GLuint buffer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBindBufferARB),reinterpret_cast<void (*)()>(glBindBufferARB),"glBindBufferARB");
    _driver.call(&_driver.glBindBufferARB)(target, buffer);
  }

  static void REGAL_CALL glBufferDataARB(GLenum target, GLsizeiptrARB size, const GLvoid *data, GLenum usage)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBufferDataARB),reinterpret_cast<void (*)()>(glBufferDataARB),"glBufferDataARB");
    _driver.call(&_driver.glBufferDataARB)(target, size, data, usage);
  }

  static void REGAL_CALL glBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBufferSubDataARB),reinterpret_cast<void (*)()>(glBufferSubDataARB),"glBufferSubDataARB");
    _driver.call(&_driver.glBufferSubDataARB)(target, offset, size, data);
  }

  static void REGAL_CALL glDeleteBuffersARB(GLsizei n, const GLuint *buffers)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDeleteBuffersARB),reinterpret_cast<void (*)()>(glDeleteBuffersARB),"glDeleteBuffersARB");
    _driver.call(&_driver.glDeleteBuffersARB)(n, buffers);
  }

  static void REGAL_CALL glGenBuffersARB(GLsizei n, GLuint *buffers)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGenBuffersARB),reinterpret_cast<void (*)()>(glGenBuffersARB),"glGenBuffersARB");
    _driver.call(&_driver.glGenBuffersARB)(n, buffers);
  }

  static void REGAL_CALL glGetBufferParameterivARB(GLenum target, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetBufferParameterivARB),reinterpret_cast<void (*)()>(glGetBufferParameterivARB),"glGetBufferParameterivARB");
    _driver.call(&_driver.glGetBufferParameterivARB)(target, pname, params);
  }

  static void REGAL_CALL glGetBufferPointervARB(GLenum target, GLenum pname, GLvoid **params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetBufferPointervARB),reinterpret_cast<void (*)()>(glGetBufferPointervARB),"glGetBufferPointervARB");
    _driver.call(&_driver.glGetBufferPointervARB)(target, pname, params);
  }

  static void REGAL_CALL glGetBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, GLvoid *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetBufferSubDataARB),reinterpret_cast<void (*)()>(glGetBufferSubDataARB),"glGetBufferSubDataARB");
    _driver.call(&_driver.glGetBufferSubDataARB)(target, offset, size, data);
  }

  static GLboolean REGAL_CALL glIsBufferARB(GLuint buffer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIsBufferARB),reinterpret_cast<void (*)()>(glIsBufferARB),"glIsBufferARB");
    return _driver.call(&_driver.glIsBufferARB)(buffer);
  }

  static GLvoid *REGAL_CALL glMapBufferARB(GLenum target, GLenum access)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMapBufferARB),reinterpret_cast<void (*)()>(glMapBufferARB),"glMapBufferARB");
    return _driver.call(&_driver.glMapBufferARB)(target, access);
  }

  static GLboolean REGAL_CALL glUnmapBufferARB(GLenum target)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUnmapBufferARB),reinterpret_cast<void (*)()>(glUnmapBufferARB),"glUnmapBufferARB");
    return _driver.call(&_driver.glUnmapBufferARB)(target);
  }

// GL_ARB_vertex_program

  static void REGAL_CALL glBindProgramARB(GLenum target, GLuint program)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBindProgramARB),reinterpret_cast<void (*)()>(glBindProgramARB),"glBindProgramARB");
    _driver.call(&_driver.glBindProgramARB)(target, program);
  }

  static void REGAL_CALL glDeleteProgramsARB(GLsizei n, const GLuint *programs)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDeleteProgramsARB),reinterpret_cast<void (*)()>(glDeleteProgramsARB),"glDeleteProgramsARB");
    _driver.call(&_driver.glDeleteProgramsARB)(n, programs);
  }

  static void REGAL_CALL glDisableVertexAttribArrayARB(GLuint index)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDisableVertexAttribArrayARB),reinterpret_cast<void (*)()>(glDisableVertexAttribArrayARB),"glDisableVertexAttribArrayARB");
    _driver.call(&_driver.glDisableVertexAttribArrayARB)(index);
  }

  static void REGAL_CALL glEnableVertexAttribArrayARB(GLuint index)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glEnableVertexAttribArrayARB),reinterpret_cast<void (*)()>(glEnableVertexAttribArrayARB),"glEnableVertexAttribArrayARB");
    _driver.call(&_driver.glEnableVertexAttribArrayARB)(index);
  }

  static void REGAL_CALL glGenProgramsARB(GLsizei n, GLuint *programs)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGenProgramsARB),reinterpret_cast<void (*)()>(glGenProgramsARB),"glGenProgramsARB");
    _driver.call(&_driver.glGenProgramsARB)(n, programs);
  }

  static void REGAL_CALL glGetProgramEnvParameterdvARB(GLenum target, GLuint index, GLdouble *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetProgramEnvParameterdvARB),reinterpret_cast<void (*)()>(glGetProgramEnvParameterdvARB),"glGetProgramEnvParameterdvARB");
    _driver.call(&_driver.glGetProgramEnvParameterdvARB)(target, index, params);
  }

  static void REGAL_CALL glGetProgramEnvParameterfvARB(GLenum target, GLuint index, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetProgramEnvParameterfvARB),reinterpret_cast<void (*)()>(glGetProgramEnvParameterfvARB),"glGetProgramEnvParameterfvARB");
    _driver.call(&_driver.glGetProgramEnvParameterfvARB)(target, index, params);
  }

  static void REGAL_CALL glGetProgramLocalParameterdvARB(GLenum target, GLuint index, GLdouble *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetProgramLocalParameterdvARB),reinterpret_cast<void (*)()>(glGetProgramLocalParameterdvARB),"glGetProgramLocalParameterdvARB");
    _driver.call(&_driver.glGetProgramLocalParameterdvARB)(target, index, params);
  }

  static void REGAL_CALL glGetProgramLocalParameterfvARB(GLenum target, GLuint index, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetProgramLocalParameterfvARB),reinterpret_cast<void (*)()>(glGetProgramLocalParameterfvARB),"glGetProgramLocalParameterfvARB");
    _driver.call(&_driver.glGetProgramLocalParameterfvARB)(target, index, params);
  }

  static void REGAL_CALL glGetProgramStringARB(GLenum target, GLenum pname, GLvoid *string)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetProgramStringARB),reinterpret_cast<void (*)()>(glGetProgramStringARB),"glGetProgramStringARB");
    _driver.call(&_driver.glGetProgramStringARB)(target, pname, string);
  }

  static void REGAL_CALL glGetProgramivARB(GLenum target, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetProgramivARB),reinterpret_cast<void (*)()>(glGetProgramivARB),"glGetProgramivARB");
    _driver.call(&_driver.glGetProgramivARB)(target, pname, params);
  }

  static void REGAL_CALL glGetVertexAttribPointervARB(GLuint index, GLenum pname, GLvoid **pointer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetVertexAttribPointervARB),reinterpret_cast<void (*)()>(glGetVertexAttribPointervARB),"glGetVertexAttribPointervARB");
    _driver.call(&_driver.glGetVertexAttribPointervARB)(index, pname, pointer);
  }

  static void REGAL_CALL glGetVertexAttribdvARB(GLuint index, GLenum pname, GLdouble *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetVertexAttribdvARB),reinterpret_cast<void (*)()>(glGetVertexAttribdvARB),"glGetVertexAttribdvARB");
    _driver.call(&_driver.glGetVertexAttribdvARB)(index, pname, params);
  }

  static void REGAL_CALL glGetVertexAttribfvARB(GLuint index, GLenum pname, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetVertexAttribfvARB),reinterpret_cast<void (*)()>(glGetVertexAttribfvARB),"glGetVertexAttribfvARB");
    _driver.call(&_driver.glGetVertexAttribfvARB)(index, pname, params);
  }

  static void REGAL_CALL glGetVertexAttribivARB(GLuint index, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetVertexAttribivARB),reinterpret_cast<void (*)()>(glGetVertexAttribivARB),"glGetVertexAttribivARB");
    _driver.call(&_driver.glGetVertexAttribivARB)(index, pname, params);
  }

  static GLboolean REGAL_CALL glIsProgramARB(GLuint program)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIsProgramARB),reinterpret_cast<void (*)()>(glIsProgramARB),"glIsProgramARB");
    return _driver.call(&_driver.glIsProgramARB)(program);
  }

  static void REGAL_CALL glProgramEnvParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramEnvParameter4dARB),reinterpret_cast<void (*)()>(glProgramEnvParameter4dARB),"glProgramEnvParameter4dARB");
    _driver.call(&_driver.glProgramEnvParameter4dARB)(target, index, x, y, z, w);
  }

  static void REGAL_CALL glProgramEnvParameter4dvARB(GLenum target, GLuint index, const GLdouble *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramEnvParameter4dvARB),reinterpret_cast<void (*)()>(glProgramEnvParameter4dvARB),"glProgramEnvParameter4dvARB");
    _driver.call(&_driver.glProgramEnvParameter4dvARB)(target, index, params);
  }

  static void REGAL_CALL glProgramEnvParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramEnvParameter4fARB),reinterpret_cast<void (*)()>(glProgramEnvParameter4fARB),"glProgramEnvParameter4fARB");
    _driver.call(&_driver.glProgramEnvParameter4fARB)(target, index, x, y, z, w);
  }

  static void REGAL_CALL glProgramEnvParameter4fvARB(GLenum target, GLuint index, const GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramEnvParameter4fvARB),reinterpret_cast<void (*)()>(glProgramEnvParameter4fvARB),"glProgramEnvParameter4fvARB");
    _driver.call(&_driver.glProgramEnvParameter4fvARB)(target, index, params);
  }

  static void REGAL_CALL glProgramLocalParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramLocalParameter4dARB),reinterpret_cast<void (*)()>(glProgramLocalParameter4dARB),"glProgramLocalParameter4dARB");
    _driver.call(&_driver.glProgramLocalParameter4dARB)(target, index, x, y, z, w);
  }

  static void REGAL_CALL glProgramLocalParameter4dvARB(GLenum target, GLuint index, const GLdouble *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramLocalParameter4dvARB),reinterpret_cast<void (*)()>(glProgramLocalParameter4dvARB),"glProgramLocalParameter4dvARB");
    _driver.call(&_driver.glProgramLocalParameter4dvARB)(target, index, params);
  }

  static void REGAL_CALL glProgramLocalParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramLocalParameter4fARB),reinterpret_cast<void (*)()>(glProgramLocalParameter4fARB),"glProgramLocalParameter4fARB");
    _driver.call(&_driver.glProgramLocalParameter4fARB)(target, index, x, y, z, w);
  }

  static void REGAL_CALL glProgramLocalParameter4fvARB(GLenum target, GLuint index, const GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramLocalParameter4fvARB),reinterpret_cast<void (*)()>(glProgramLocalParameter4fvARB),"glProgramLocalParameter4fvARB");
    _driver.call(&_driver.glProgramLocalParameter4fvARB)(target, index, params);
  }

  static void REGAL_CALL glProgramStringARB(GLenum target, GLenum format, GLsizei len, const GLvoid *string)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramStringARB),reinterpret_cast<void (*)()>(glProgramStringARB),"glProgramStringARB");
    _driver.call(&_driver.glProgramStringARB)(target, format, len, string);
  }

  static void REGAL_CALL glVertexAttrib1dARB(GLuint index, GLdouble x)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib1dARB),reinterpret_cast<void (*)()>(glVertexAttrib1dARB),"glVertexAttrib1dARB");
    _driver.call(&_driver.glVertexAttrib1dARB)(index, x);
  }

  static void REGAL_CALL glVertexAttrib1dvARB(GLuint index, const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib1dvARB),reinterpret_cast<void (*)()>(glVertexAttrib1dvARB),"glVertexAttrib1dvARB");
    _driver.call(&_driver.glVertexAttrib1dvARB)(index, v);
  }

  static void REGAL_CALL glVertexAttrib1fARB(GLuint index, GLfloat x)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib1fARB),reinterpret_cast<void (*)()>(glVertexAttrib1fARB),"glVertexAttrib1fARB");
    _driver.call(&_driver.glVertexAttrib1fARB)(index, x);
  }

  static void REGAL_CALL glVertexAttrib1fvARB(GLuint index, const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib1fvARB),reinterpret_cast<void (*)()>(glVertexAttrib1fvARB),"glVertexAttrib1fvARB");
    _driver.call(&_driver.glVertexAttrib1fvARB)(index, v);
  }

  static void REGAL_CALL glVertexAttrib1sARB(GLuint index, GLshort x)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib1sARB),reinterpret_cast<void (*)()>(glVertexAttrib1sARB),"glVertexAttrib1sARB");
    _driver.call(&_driver.glVertexAttrib1sARB)(index, x);
  }

  static void REGAL_CALL glVertexAttrib1svARB(GLuint index, const GLshort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib1svARB),reinterpret_cast<void (*)()>(glVertexAttrib1svARB),"glVertexAttrib1svARB");
    _driver.call(&_driver.glVertexAttrib1svARB)(index, v);
  }

  static void REGAL_CALL glVertexAttrib2dARB(GLuint index, GLdouble x, GLdouble y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib2dARB),reinterpret_cast<void (*)()>(glVertexAttrib2dARB),"glVertexAttrib2dARB");
    _driver.call(&_driver.glVertexAttrib2dARB)(index, x, y);
  }

  static void REGAL_CALL glVertexAttrib2dvARB(GLuint index, const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib2dvARB),reinterpret_cast<void (*)()>(glVertexAttrib2dvARB),"glVertexAttrib2dvARB");
    _driver.call(&_driver.glVertexAttrib2dvARB)(index, v);
  }

  static void REGAL_CALL glVertexAttrib2fARB(GLuint index, GLfloat x, GLfloat y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib2fARB),reinterpret_cast<void (*)()>(glVertexAttrib2fARB),"glVertexAttrib2fARB");
    _driver.call(&_driver.glVertexAttrib2fARB)(index, x, y);
  }

  static void REGAL_CALL glVertexAttrib2fvARB(GLuint index, const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib2fvARB),reinterpret_cast<void (*)()>(glVertexAttrib2fvARB),"glVertexAttrib2fvARB");
    _driver.call(&_driver.glVertexAttrib2fvARB)(index, v);
  }

  static void REGAL_CALL glVertexAttrib2sARB(GLuint index, GLshort x, GLshort y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib2sARB),reinterpret_cast<void (*)()>(glVertexAttrib2sARB),"glVertexAttrib2sARB");
    _driver.call(&_driver.glVertexAttrib2sARB)(index, x, y);
  }

  static void REGAL_CALL glVertexAttrib2svARB(GLuint index, const GLshort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib2svARB),reinterpret_cast<void (*)()>(glVertexAttrib2svARB),"glVertexAttrib2svARB");
    _driver.call(&_driver.glVertexAttrib2svARB)(index, v);
  }

  static void REGAL_CALL glVertexAttrib3dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib3dARB),reinterpret_cast<void (*)()>(glVertexAttrib3dARB),"glVertexAttrib3dARB");
    _driver.call(&_driver.glVertexAttrib3dARB)(index, x, y, z);
  }

  static void REGAL_CALL glVertexAttrib3dvARB(GLuint index, const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib3dvARB),reinterpret_cast<void (*)()>(glVertexAttrib3dvARB),"glVertexAttrib3dvARB");
    _driver.call(&_driver.glVertexAttrib3dvARB)(index, v);
  }

  static void REGAL_CALL glVertexAttrib3fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib3fARB),reinterpret_cast<void (*)()>(glVertexAttrib3fARB),"glVertexAttrib3fARB");
    _driver.call(&_driver.glVertexAttrib3fARB)(index, x, y, z);
  }

  static void REGAL_CALL glVertexAttrib3fvARB(GLuint index, const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib3fvARB),reinterpret_cast<void (*)()>(glVertexAttrib3fvARB),"glVertexAttrib3fvARB");
    _driver.call(&_driver.glVertexAttrib3fvARB)(index, v);
  }

  static void REGAL_CALL glVertexAttrib3sARB(GLuint index, GLshort x, GLshort y, GLshort z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib3sARB),reinterpret_cast<void (*)()>(glVertexAttrib3sARB),"glVertexAttrib3sARB");
    _driver.call(&_driver.glVertexAttrib3sARB)(index, x, y, z);
  }

  static void REGAL_CALL glVertexAttrib3svARB(GLuint index, const GLshort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib3svARB),reinterpret_cast<void (*)()>(glVertexAttrib3svARB),"glVertexAttrib3svARB");
    _driver.call(&_driver.glVertexAttrib3svARB)(index, v);
  }

  static void REGAL_CALL glVertexAttrib4NbvARB(GLuint index, const GLbyte *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib4NbvARB),reinterpret_cast<void (*)()>(glVertexAttrib4NbvARB),"glVertexAttrib4NbvARB");
    _driver.call(&_driver.glVertexAttrib4NbvARB)(index, v);
  }

  static void REGAL_CALL glVertexAttrib4NivARB(GLuint index, const GLint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib4NivARB),reinterpret_cast<void (*)()>(glVertexAttrib4NivARB),"glVertexAttrib4NivARB");
    _driver.call(&_driver.glVertexAttrib4NivARB)(index, v);
  }

  static void REGAL_CALL glVertexAttrib4NsvARB(GLuint index, const GLshort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib4NsvARB),reinterpret_cast<void (*)()>(glVertexAttrib4NsvARB),"glVertexAttrib4NsvARB");
    _driver.call(&_driver.glVertexAttrib4NsvARB)(index, v);
  }

  static void REGAL_CALL glVertexAttrib4NubARB(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib4NubARB),reinterpret_cast<void (*)()>(glVertexAttrib4NubARB),"glVertexAttrib4NubARB");
    _driver.call(&_driver.glVertexAttrib4NubARB)(index, x, y, z, w);
  }

  static void REGAL_CALL glVertexAttrib4NubvARB(GLuint index, const GLubyte *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib4NubvARB),reinterpret_cast<void (*)()>(glVertexAttrib4NubvARB),"glVertexAttrib4NubvARB");
    _driver.call(&_driver.glVertexAttrib4NubvARB)(index, v);
  }

  static void REGAL_CALL glVertexAttrib4NuivARB(GLuint index, const GLuint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib4NuivARB),reinterpret_cast<void (*)()>(glVertexAttrib4NuivARB),"glVertexAttrib4NuivARB");
    _driver.call(&_driver.glVertexAttrib4NuivARB)(index, v);
  }

  static void REGAL_CALL glVertexAttrib4NusvARB(GLuint index, const GLushort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib4NusvARB),reinterpret_cast<void (*)()>(glVertexAttrib4NusvARB),"glVertexAttrib4NusvARB");
    _driver.call(&_driver.glVertexAttrib4NusvARB)(index, v);
  }

  static void REGAL_CALL glVertexAttrib4bvARB(GLuint index, const GLbyte *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib4bvARB),reinterpret_cast<void (*)()>(glVertexAttrib4bvARB),"glVertexAttrib4bvARB");
    _driver.call(&_driver.glVertexAttrib4bvARB)(index, v);
  }

  static void REGAL_CALL glVertexAttrib4dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib4dARB),reinterpret_cast<void (*)()>(glVertexAttrib4dARB),"glVertexAttrib4dARB");
    _driver.call(&_driver.glVertexAttrib4dARB)(index, x, y, z, w);
  }

  static void REGAL_CALL glVertexAttrib4dvARB(GLuint index, const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib4dvARB),reinterpret_cast<void (*)()>(glVertexAttrib4dvARB),"glVertexAttrib4dvARB");
    _driver.call(&_driver.glVertexAttrib4dvARB)(index, v);
  }

  static void REGAL_CALL glVertexAttrib4fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib4fARB),reinterpret_cast<void (*)()>(glVertexAttrib4fARB),"glVertexAttrib4fARB");
    _driver.call(&_driver.glVertexAttrib4fARB)(index, x, y, z, w);
  }

  static void REGAL_CALL glVertexAttrib4fvARB(GLuint index, const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib4fvARB),reinterpret_cast<void (*)()>(glVertexAttrib4fvARB),"glVertexAttrib4fvARB");
    _driver.call(&_driver.glVertexAttrib4fvARB)(index, v);
  }

  static void REGAL_CALL glVertexAttrib4ivARB(GLuint index, const GLint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib4ivARB),reinterpret_cast<void (*)()>(glVertexAttrib4ivARB),"glVertexAttrib4ivARB");
    _driver.call(&_driver.glVertexAttrib4ivARB)(index, v);
  }

  static void REGAL_CALL glVertexAttrib4sARB(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib4sARB),reinterpret_cast<void (*)()>(glVertexAttrib4sARB),"glVertexAttrib4sARB");
    _driver.call(&_driver.glVertexAttrib4sARB)(index, x, y, z, w);
  }

  static void REGAL_CALL glVertexAttrib4svARB(GLuint index, const GLshort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib4svARB),reinterpret_cast<void (*)()>(glVertexAttrib4svARB),"glVertexAttrib4svARB");
    _driver.call(&_driver.glVertexAttrib4svARB)(index, v);
  }

  static void REGAL_CALL glVertexAttrib4ubvARB(GLuint index, const GLubyte *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib4ubvARB),reinterpret_cast<void (*)()>(glVertexAttrib4ubvARB),"glVertexAttrib4ubvARB");
    _driver.call(&_driver.glVertexAttrib4ubvARB)(index, v);
  }

  static void REGAL_CALL glVertexAttrib4uivARB(GLuint index, const GLuint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib4uivARB),reinterpret_cast<void (*)()>(glVertexAttrib4uivARB),"glVertexAttrib4uivARB");
    _driver.call(&_driver.glVertexAttrib4uivARB)(index, v);
  }

  static void REGAL_CALL glVertexAttrib4usvARB(GLuint index, const GLushort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib4usvARB),reinterpret_cast<void (*)()>(glVertexAttrib4usvARB),"glVertexAttrib4usvARB");
    _driver.call(&_driver.glVertexAttrib4usvARB)(index, v);
  }

  static void REGAL_CALL glVertexAttribPointerARB(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribPointerARB),reinterpret_cast<void (*)()>(glVertexAttribPointerARB),"glVertexAttribPointerARB");
    _driver.call(&_driver.glVertexAttribPointerARB)(index, size, type, normalized, stride, pointer);
  }

// GL_ARB_vertex_shader

  static void REGAL_CALL glBindAttribLocationARB(GLhandleARB programObj, GLuint index, const GLcharARB *name)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBindAttribLocationARB),reinterpret_cast<void (*)()>(glBindAttribLocationARB),"glBindAttribLocationARB");
    _driver.call(&_driver.glBindAttribLocationARB)(programObj, index, name);
  }

  static void REGAL_CALL glGetActiveAttribARB(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetActiveAttribARB),reinterpret_cast<void (*)()>(glGetActiveAttribARB),"glGetActiveAttribARB");
    _driver.call(&_driver.glGetActiveAttribARB)(programObj, index, maxLength, length, size, type, name);
  }

  static GLint REGAL_CALL glGetAttribLocationARB(GLhandleARB programObj, const GLcharARB *name)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetAttribLocationARB),reinterpret_cast<void (*)()>(glGetAttribLocationARB),"glGetAttribLocationARB");
    return _driver.call(&_driver.glGetAttribLocationARB)(programObj, name);
  }

// GL_ARB_vertex_type_2_10_10_10_rev

  static void REGAL_CALL glColorP3ui(GLenum type, GLuint color)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColorP3ui),reinterpret_cast<void (*)()>(glColorP3ui),"glColorP3ui");
    _driver.call(&_driver.glColorP3ui)(type, color);
  }

  static void REGAL_CALL glColorP3uiv(GLenum type, const GLuint *color)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColorP3uiv),reinterpret_cast<void (*)()>(glColorP3uiv),"glColorP3uiv");
    _driver.call(&_driver.glColorP3uiv)(type, color);
  }

  static void REGAL_CALL glColorP4ui(GLenum type, GLuint color)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColorP4ui),reinterpret_cast<void (*)()>(glColorP4ui),"glColorP4ui");
    _driver.call(&_driver.glColorP4ui)(type, color);
  }

  static void REGAL_CALL glColorP4uiv(GLenum type, const GLuint *color)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColorP4uiv),reinterpret_cast<void (*)()>(glColorP4uiv),"glColorP4uiv");
    _driver.call(&_driver.glColorP4uiv)(type, color);
  }

  static void REGAL_CALL glMultiTexCoordP1ui(GLenum texture, GLenum type, GLuint coords)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoordP1ui),reinterpret_cast<void (*)()>(glMultiTexCoordP1ui),"glMultiTexCoordP1ui");
    _driver.call(&_driver.glMultiTexCoordP1ui)(texture, type, coords);
  }

  static void REGAL_CALL glMultiTexCoordP1uiv(GLenum texture, GLenum type, const GLuint *coords)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoordP1uiv),reinterpret_cast<void (*)()>(glMultiTexCoordP1uiv),"glMultiTexCoordP1uiv");
    _driver.call(&_driver.glMultiTexCoordP1uiv)(texture, type, coords);
  }

  static void REGAL_CALL glMultiTexCoordP2ui(GLenum texture, GLenum type, GLuint coords)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoordP2ui),reinterpret_cast<void (*)()>(glMultiTexCoordP2ui),"glMultiTexCoordP2ui");
    _driver.call(&_driver.glMultiTexCoordP2ui)(texture, type, coords);
  }

  static void REGAL_CALL glMultiTexCoordP2uiv(GLenum texture, GLenum type, const GLuint *coords)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoordP2uiv),reinterpret_cast<void (*)()>(glMultiTexCoordP2uiv),"glMultiTexCoordP2uiv");
    _driver.call(&_driver.glMultiTexCoordP2uiv)(texture, type, coords);
  }

  static void REGAL_CALL glMultiTexCoordP3ui(GLenum texture, GLenum type, GLuint coords)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoordP3ui),reinterpret_cast<void (*)()>(glMultiTexCoordP3ui),"glMultiTexCoordP3ui");
    _driver.call(&_driver.glMultiTexCoordP3ui)(texture, type, coords);
  }

  static void REGAL_CALL glMultiTexCoordP3uiv(GLenum texture, GLenum type, const GLuint *coords)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoordP3uiv),reinterpret_cast<void (*)()>(glMultiTexCoordP3uiv),"glMultiTexCoordP3uiv");
    _driver.call(&_driver.glMultiTexCoordP3uiv)(texture, type, coords);
  }

  static void REGAL_CALL glMultiTexCoordP4ui(GLenum texture, GLenum type, GLuint coords)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoordP4ui),reinterpret_cast<void (*)()>(glMultiTexCoordP4ui),"glMultiTexCoordP4ui");
    _driver.call(&_driver.glMultiTexCoordP4ui)(texture, type, coords);
  }

  static void REGAL_CALL glMultiTexCoordP4uiv(GLenum texture, GLenum type, const GLuint *coords)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoordP4uiv),reinterpret_cast<void (*)()>(glMultiTexCoordP4uiv),"glMultiTexCoordP4uiv");
    _driver.call(&_driver.glMultiTexCoordP4uiv)(texture, type, coords);
  }

  static void REGAL_CALL glNormalP3ui(GLenum type, GLuint coords)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNormalP3ui),reinterpret_cast<void (*)()>(glNormalP3ui),"glNormalP3ui");
    _driver.call(&_driver.glNormalP3ui)(type, coords);
  }

  static void REGAL_CALL glNormalP3uiv(GLenum type, const GLuint *coords)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNormalP3uiv),reinterpret_cast<void (*)()>(glNormalP3uiv),"glNormalP3uiv");
    _driver.call(&_driver.glNormalP3uiv)(type, coords);
  }

  static void REGAL_CALL glSecondaryColorP3ui(GLenum type, GLuint color)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSecondaryColorP3ui),reinterpret_cast<void (*)()>(glSecondaryColorP3ui),"glSecondaryColorP3ui");
    _driver.call(&_driver.glSecondaryColorP3ui)(type, color);
  }

  static void REGAL_CALL glSecondaryColorP3uiv(GLenum type, const GLuint *color)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSecondaryColorP3uiv),reinterpret_cast<void (*)()>(glSecondaryColorP3uiv),"glSecondaryColorP3uiv");
    _driver.call(&_driver.glSecondaryColorP3uiv)(type, color);
  }

  static void REGAL_CALL glTexCoordP1ui(GLenum type, GLuint coords)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoordP1ui),reinterpret_cast<void (*)()>(glTexCoordP1ui),"glTexCoordP1ui");
    _driver.call(&_driver.glTexCoordP1ui)(type, coords);
  }

  static void REGAL_CALL glTexCoordP1uiv(GLenum type, const GLuint *coords)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoordP1uiv),reinterpret_cast<void (*)()>(glTexCoordP1uiv),"glTexCoordP1uiv");
    _driver.call(&_driver.glTexCoordP1uiv)(type, coords);
  }

  static void REGAL_CALL glTexCoordP2ui(GLenum type, GLuint coords)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoordP2ui),reinterpret_cast<void (*)()>(glTexCoordP2ui),"glTexCoordP2ui");
    _driver.call(&_driver.glTexCoordP2ui)(type, coords);
  }

  static void REGAL_CALL glTexCoordP2uiv(GLenum type, const GLuint *coords)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoordP2uiv),reinterpret_cast<void (*)()>(glTexCoordP2uiv),"glTexCoordP2uiv");
    _driver.call(&_driver.glTexCoordP2uiv)(type, coords);
  }

  static void REGAL_CALL glTexCoordP3ui(GLenum type, GLuint coords)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoordP3ui),reinterpret_cast<void (*)()>(glTexCoordP3ui),"glTexCoordP3ui");
    _driver.call(&_driver.glTexCoordP3ui)(type, coords);
  }

  static void REGAL_CALL glTexCoordP3uiv(GLenum type, const GLuint *coords)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoordP3uiv),reinterpret_cast<void (*)()>(glTexCoordP3uiv),"glTexCoordP3uiv");
    _driver.call(&_driver.glTexCoordP3uiv)(type, coords);
  }

  static void REGAL_CALL glTexCoordP4ui(GLenum type, GLuint coords)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoordP4ui),reinterpret_cast<void (*)()>(glTexCoordP4ui),"glTexCoordP4ui");
    _driver.call(&_driver.glTexCoordP4ui)(type, coords);
  }

  static void REGAL_CALL glTexCoordP4uiv(GLenum type, const GLuint *coords)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoordP4uiv),reinterpret_cast<void (*)()>(glTexCoordP4uiv),"glTexCoordP4uiv");
    _driver.call(&_driver.glTexCoordP4uiv)(type, coords);
  }

  static void REGAL_CALL glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribP1ui),reinterpret_cast<void (*)()>(glVertexAttribP1ui),"glVertexAttribP1ui");
    _driver.call(&_driver.glVertexAttribP1ui)(index, type, normalized, value);
  }

  static void REGAL_CALL glVertexAttribP1uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribP1uiv),reinterpret_cast<void (*)()>(glVertexAttribP1uiv),"glVertexAttribP1uiv");
    _driver.call(&_driver.glVertexAttribP1uiv)(index, type, normalized, value);
  }

  static void REGAL_CALL glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribP2ui),reinterpret_cast<void (*)()>(glVertexAttribP2ui),"glVertexAttribP2ui");
    _driver.call(&_driver.glVertexAttribP2ui)(index, type, normalized, value);
  }

  static void REGAL_CALL glVertexAttribP2uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribP2uiv),reinterpret_cast<void (*)()>(glVertexAttribP2uiv),"glVertexAttribP2uiv");
    _driver.call(&_driver.glVertexAttribP2uiv)(index, type, normalized, value);
  }

  static void REGAL_CALL glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribP3ui),reinterpret_cast<void (*)()>(glVertexAttribP3ui),"glVertexAttribP3ui");
    _driver.call(&_driver.glVertexAttribP3ui)(index, type, normalized, value);
  }

  static void REGAL_CALL glVertexAttribP3uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribP3uiv),reinterpret_cast<void (*)()>(glVertexAttribP3uiv),"glVertexAttribP3uiv");
    _driver.call(&_driver.glVertexAttribP3uiv)(index, type, normalized, value);
  }

  static void REGAL_CALL glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribP4ui),reinterpret_cast<void (*)()>(glVertexAttribP4ui),"glVertexAttribP4ui");
    _driver.call(&_driver.glVertexAttribP4ui)(index, type, normalized, value);
  }

  static void REGAL_CALL glVertexAttribP4uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribP4uiv),reinterpret_cast<void (*)()>(glVertexAttribP4uiv),"glVertexAttribP4uiv");
    _driver.call(&_driver.glVertexAttribP4uiv)(index, type, normalized, value);
  }

  static void REGAL_CALL glVertexP2ui(GLenum type, GLuint coords)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexP2ui),reinterpret_cast<void (*)()>(glVertexP2ui),"glVertexP2ui");
    _driver.call(&_driver.glVertexP2ui)(type, coords);
  }

  static void REGAL_CALL glVertexP2uiv(GLenum type, const GLuint *coords)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexP2uiv),reinterpret_cast<void (*)()>(glVertexP2uiv),"glVertexP2uiv");
    _driver.call(&_driver.glVertexP2uiv)(type, coords);
  }

  static void REGAL_CALL glVertexP3ui(GLenum type, GLuint coords)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexP3ui),reinterpret_cast<void (*)()>(glVertexP3ui),"glVertexP3ui");
    _driver.call(&_driver.glVertexP3ui)(type, coords);
  }

  static void REGAL_CALL glVertexP3uiv(GLenum type, const GLuint *coords)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexP3uiv),reinterpret_cast<void (*)()>(glVertexP3uiv),"glVertexP3uiv");
    _driver.call(&_driver.glVertexP3uiv)(type, coords);
  }

  static void REGAL_CALL glVertexP4ui(GLenum type, GLuint coords)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexP4ui),reinterpret_cast<void (*)()>(glVertexP4ui),"glVertexP4ui");
    _driver.call(&_driver.glVertexP4ui)(type, coords);
  }

  static void REGAL_CALL glVertexP4uiv(GLenum type, const GLuint *coords)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexP4uiv),reinterpret_cast<void (*)()>(glVertexP4uiv),"glVertexP4uiv");
    _driver.call(&_driver.glVertexP4uiv)(type, coords);
  }

// GL_ARB_viewport_array

  static void REGAL_CALL glDepthRangeArrayv(GLuint first, GLsizei count, const GLclampd *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDepthRangeArrayv),reinterpret_cast<void (*)()>(glDepthRangeArrayv),"glDepthRangeArrayv");
    _driver.call(&_driver.glDepthRangeArrayv)(first, count, v);
  }

  static void REGAL_CALL glDepthRangeIndexed(GLuint index, GLclampd n, GLclampd f)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDepthRangeIndexed),reinterpret_cast<void (*)()>(glDepthRangeIndexed),"glDepthRangeIndexed");
    _driver.call(&_driver.glDepthRangeIndexed)(index, n, f);
  }

  static void REGAL_CALL glGetDoublei_v(GLenum target, GLuint index, GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetDoublei_v),reinterpret_cast<void (*)()>(glGetDoublei_v),"glGetDoublei_v");
    _driver.call(&_driver.glGetDoublei_v)(target, index, v);
  }

  static void REGAL_CALL glGetFloati_v(GLenum target, GLuint index, GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetFloati_v),reinterpret_cast<void (*)()>(glGetFloati_v),"glGetFloati_v");
    _driver.call(&_driver.glGetFloati_v)(target, index, v);
  }

  static void REGAL_CALL glScissorArrayv(GLuint first, GLsizei count, const GLint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glScissorArrayv),reinterpret_cast<void (*)()>(glScissorArrayv),"glScissorArrayv");
    _driver.call(&_driver.glScissorArrayv)(first, count, v);
  }

  static void REGAL_CALL glScissorIndexed(GLuint index, GLint left, GLint bottom, GLint width, GLint height)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glScissorIndexed),reinterpret_cast<void (*)()>(glScissorIndexed),"glScissorIndexed");
    _driver.call(&_driver.glScissorIndexed)(index, left, bottom, width, height);
  }

  static void REGAL_CALL glScissorIndexedv(GLuint index, const GLint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glScissorIndexedv),reinterpret_cast<void (*)()>(glScissorIndexedv),"glScissorIndexedv");
    _driver.call(&_driver.glScissorIndexedv)(index, v);
  }

  static void REGAL_CALL glViewportArrayv(GLuint first, GLsizei count, const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glViewportArrayv),reinterpret_cast<void (*)()>(glViewportArrayv),"glViewportArrayv");
    _driver.call(&_driver.glViewportArrayv)(first, count, v);
  }

  static void REGAL_CALL glViewportIndexedf(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glViewportIndexedf),reinterpret_cast<void (*)()>(glViewportIndexedf),"glViewportIndexedf");
    _driver.call(&_driver.glViewportIndexedf)(index, x, y, w, h);
  }

  static void REGAL_CALL glViewportIndexedfv(GLuint index, const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glViewportIndexedfv),reinterpret_cast<void (*)()>(glViewportIndexedfv),"glViewportIndexedfv");
    _driver.call(&_driver.glViewportIndexedfv)(index, v);
  }

// GL_ARB_window_pos

  static void REGAL_CALL glWindowPos2dARB(GLdouble x, GLdouble y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos2dARB),reinterpret_cast<void (*)()>(glWindowPos2dARB),"glWindowPos2dARB");
    _driver.call(&_driver.glWindowPos2dARB)(x, y);
  }

  static void REGAL_CALL glWindowPos2dvARB(const GLdouble *p)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos2dvARB),reinterpret_cast<void (*)()>(glWindowPos2dvARB),"glWindowPos2dvARB");
    _driver.call(&_driver.glWindowPos2dvARB)(p);
  }

  static void REGAL_CALL glWindowPos2fARB(GLfloat x, GLfloat y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos2fARB),reinterpret_cast<void (*)()>(glWindowPos2fARB),"glWindowPos2fARB");
    _driver.call(&_driver.glWindowPos2fARB)(x, y);
  }

  static void REGAL_CALL glWindowPos2fvARB(const GLfloat *p)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos2fvARB),reinterpret_cast<void (*)()>(glWindowPos2fvARB),"glWindowPos2fvARB");
    _driver.call(&_driver.glWindowPos2fvARB)(p);
  }

  static void REGAL_CALL glWindowPos2iARB(GLint x, GLint y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos2iARB),reinterpret_cast<void (*)()>(glWindowPos2iARB),"glWindowPos2iARB");
    _driver.call(&_driver.glWindowPos2iARB)(x, y);
  }

  static void REGAL_CALL glWindowPos2ivARB(const GLint *p)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos2ivARB),reinterpret_cast<void (*)()>(glWindowPos2ivARB),"glWindowPos2ivARB");
    _driver.call(&_driver.glWindowPos2ivARB)(p);
  }

  static void REGAL_CALL glWindowPos2sARB(GLshort x, GLshort y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos2sARB),reinterpret_cast<void (*)()>(glWindowPos2sARB),"glWindowPos2sARB");
    _driver.call(&_driver.glWindowPos2sARB)(x, y);
  }

  static void REGAL_CALL glWindowPos2svARB(const GLshort *p)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos2svARB),reinterpret_cast<void (*)()>(glWindowPos2svARB),"glWindowPos2svARB");
    _driver.call(&_driver.glWindowPos2svARB)(p);
  }

  static void REGAL_CALL glWindowPos3dARB(GLdouble x, GLdouble y, GLdouble z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos3dARB),reinterpret_cast<void (*)()>(glWindowPos3dARB),"glWindowPos3dARB");
    _driver.call(&_driver.glWindowPos3dARB)(x, y, z);
  }

  static void REGAL_CALL glWindowPos3dvARB(const GLdouble *p)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos3dvARB),reinterpret_cast<void (*)()>(glWindowPos3dvARB),"glWindowPos3dvARB");
    _driver.call(&_driver.glWindowPos3dvARB)(p);
  }

  static void REGAL_CALL glWindowPos3fARB(GLfloat x, GLfloat y, GLfloat z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos3fARB),reinterpret_cast<void (*)()>(glWindowPos3fARB),"glWindowPos3fARB");
    _driver.call(&_driver.glWindowPos3fARB)(x, y, z);
  }

  static void REGAL_CALL glWindowPos3fvARB(const GLfloat *p)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos3fvARB),reinterpret_cast<void (*)()>(glWindowPos3fvARB),"glWindowPos3fvARB");
    _driver.call(&_driver.glWindowPos3fvARB)(p);
  }

  static void REGAL_CALL glWindowPos3iARB(GLint x, GLint y, GLint z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos3iARB),reinterpret_cast<void (*)()>(glWindowPos3iARB),"glWindowPos3iARB");
    _driver.call(&_driver.glWindowPos3iARB)(x, y, z);
  }

  static void REGAL_CALL glWindowPos3ivARB(const GLint *p)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos3ivARB),reinterpret_cast<void (*)()>(glWindowPos3ivARB),"glWindowPos3ivARB");
    _driver.call(&_driver.glWindowPos3ivARB)(p);
  }

  static void REGAL_CALL glWindowPos3sARB(GLshort x, GLshort y, GLshort z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos3sARB),reinterpret_cast<void (*)()>(glWindowPos3sARB),"glWindowPos3sARB");
    _driver.call(&_driver.glWindowPos3sARB)(x, y, z);
  }

  static void REGAL_CALL glWindowPos3svARB(const GLshort *p)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos3svARB),reinterpret_cast<void (*)()>(glWindowPos3svARB),"glWindowPos3svARB");
    _driver.call(&_driver.glWindowPos3svARB)(p);
  }

// GL_ATI_draw_buffers

  static void REGAL_CALL glDrawBuffersATI(GLsizei n, const GLenum *bufs)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDrawBuffersATI),reinterpret_cast<void (*)()>(glDrawBuffersATI),"glDrawBuffersATI");
    _driver.call(&_driver.glDrawBuffersATI)(n, bufs);
  }

// GL_ATI_element_array

  static void REGAL_CALL glDrawElementArrayATI(GLenum mode, GLsizei count)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDrawElementArrayATI),reinterpret_cast<void (*)()>(glDrawElementArrayATI),"glDrawElementArrayATI");
    _driver.call(&_driver.glDrawElementArrayATI)(mode, count);
  }

  static void REGAL_CALL glDrawRangeElementArrayATI(GLenum mode, GLuint start, GLuint end, GLsizei count)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDrawRangeElementArrayATI),reinterpret_cast<void (*)()>(glDrawRangeElementArrayATI),"glDrawRangeElementArrayATI");
    _driver.call(&_driver.glDrawRangeElementArrayATI)(mode, start, end, count);
  }

  static void REGAL_CALL glElementPointerATI(GLenum type, const GLvoid *pointer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glElementPointerATI),reinterpret_cast<void (*)()>(glElementPointerATI),"glElementPointerATI");
    _driver.call(&_driver.glElementPointerATI)(type, pointer);
  }

// GL_ATI_envmap_bumpmap

  static void REGAL_CALL glGetTexBumpParameterfvATI(GLenum pname, GLfloat *param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetTexBumpParameterfvATI),reinterpret_cast<void (*)()>(glGetTexBumpParameterfvATI),"glGetTexBumpParameterfvATI");
    _driver.call(&_driver.glGetTexBumpParameterfvATI)(pname, param);
  }

  static void REGAL_CALL glGetTexBumpParameterivATI(GLenum pname, GLint *param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetTexBumpParameterivATI),reinterpret_cast<void (*)()>(glGetTexBumpParameterivATI),"glGetTexBumpParameterivATI");
    _driver.call(&_driver.glGetTexBumpParameterivATI)(pname, param);
  }

  static void REGAL_CALL glTexBumpParameterfvATI(GLenum pname, const GLfloat *param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexBumpParameterfvATI),reinterpret_cast<void (*)()>(glTexBumpParameterfvATI),"glTexBumpParameterfvATI");
    _driver.call(&_driver.glTexBumpParameterfvATI)(pname, param);
  }

  static void REGAL_CALL glTexBumpParameterivATI(GLenum pname, const GLint *param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexBumpParameterivATI),reinterpret_cast<void (*)()>(glTexBumpParameterivATI),"glTexBumpParameterivATI");
    _driver.call(&_driver.glTexBumpParameterivATI)(pname, param);
  }

// GL_ATI_fragment_shader

  static void REGAL_CALL glAlphaFragmentOp1ATI(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glAlphaFragmentOp1ATI),reinterpret_cast<void (*)()>(glAlphaFragmentOp1ATI),"glAlphaFragmentOp1ATI");
    _driver.call(&_driver.glAlphaFragmentOp1ATI)(op, dst, dstMod, arg1, arg1Rep, arg1Mod);
  }

  static void REGAL_CALL glAlphaFragmentOp2ATI(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glAlphaFragmentOp2ATI),reinterpret_cast<void (*)()>(glAlphaFragmentOp2ATI),"glAlphaFragmentOp2ATI");
    _driver.call(&_driver.glAlphaFragmentOp2ATI)(op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);
  }

  static void REGAL_CALL glAlphaFragmentOp3ATI(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glAlphaFragmentOp3ATI),reinterpret_cast<void (*)()>(glAlphaFragmentOp3ATI),"glAlphaFragmentOp3ATI");
    _driver.call(&_driver.glAlphaFragmentOp3ATI)(op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);
  }

  static void REGAL_CALL glBeginFragmentShaderATI(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBeginFragmentShaderATI),reinterpret_cast<void (*)()>(glBeginFragmentShaderATI),"glBeginFragmentShaderATI");
    _driver.call(&_driver.glBeginFragmentShaderATI)();
  }

  static void REGAL_CALL glBindFragmentShaderATI(GLuint id)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBindFragmentShaderATI),reinterpret_cast<void (*)()>(glBindFragmentShaderATI),"glBindFragmentShaderATI");
    _driver.call(&_driver.glBindFragmentShaderATI)(id);
  }

  static void REGAL_CALL glColorFragmentOp1ATI(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColorFragmentOp1ATI),reinterpret_cast<void (*)()>(glColorFragmentOp1ATI),"glColorFragmentOp1ATI");
    _driver.call(&_driver.glColorFragmentOp1ATI)(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod);
  }

  static void REGAL_CALL glColorFragmentOp2ATI(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColorFragmentOp2ATI),reinterpret_cast<void (*)()>(glColorFragmentOp2ATI),"glColorFragmentOp2ATI");
    _driver.call(&_driver.glColorFragmentOp2ATI)(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);
  }

  static void REGAL_CALL glColorFragmentOp3ATI(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColorFragmentOp3ATI),reinterpret_cast<void (*)()>(glColorFragmentOp3ATI),"glColorFragmentOp3ATI");
    _driver.call(&_driver.glColorFragmentOp3ATI)(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);
  }

  static void REGAL_CALL glDeleteFragmentShaderATI(GLuint id)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDeleteFragmentShaderATI),reinterpret_cast<void (*)()>(glDeleteFragmentShaderATI),"glDeleteFragmentShaderATI");
    _driver.call(&_driver.glDeleteFragmentShaderATI)(id);
  }

  static void REGAL_CALL glEndFragmentShaderATI(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glEndFragmentShaderATI),reinterpret_cast<void (*)()>(glEndFragmentShaderATI),"glEndFragmentShaderATI");
    _driver.call(&_driver.glEndFragmentShaderATI)();
  }

  static GLuint REGAL_CALL glGenFragmentShadersATI(GLuint range)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGenFragmentShadersATI),reinterpret_cast<void (*)()>(glGenFragmentShadersATI),"glGenFragmentShadersATI");
    return _driver.call(&_driver.glGenFragmentShadersATI)(range);
  }

  static void REGAL_CALL glPassTexCoordATI(GLuint dst, GLuint coord, GLenum swizzle)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPassTexCoordATI),reinterpret_cast<void (*)()>(glPassTexCoordATI),"glPassTexCoordATI");
    _driver.call(&_driver.glPassTexCoordATI)(dst, coord, swizzle);
  }

  static void REGAL_CALL glSampleMapATI(GLuint dst, GLuint interp, GLenum swizzle)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSampleMapATI),reinterpret_cast<void (*)()>(glSampleMapATI),"glSampleMapATI");
    _driver.call(&_driver.glSampleMapATI)(dst, interp, swizzle);
  }

  static void REGAL_CALL glSetFragmentShaderConstantATI(GLuint dst, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSetFragmentShaderConstantATI),reinterpret_cast<void (*)()>(glSetFragmentShaderConstantATI),"glSetFragmentShaderConstantATI");
    _driver.call(&_driver.glSetFragmentShaderConstantATI)(dst, value);
  }

// GL_ATI_map_object_buffer

  static GLvoid *REGAL_CALL glMapObjectBufferATI(GLuint buffer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMapObjectBufferATI),reinterpret_cast<void (*)()>(glMapObjectBufferATI),"glMapObjectBufferATI");
    return _driver.call(&_driver.glMapObjectBufferATI)(buffer);
  }

  static void REGAL_CALL glUnmapObjectBufferATI(GLuint buffer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUnmapObjectBufferATI),reinterpret_cast<void (*)()>(glUnmapObjectBufferATI),"glUnmapObjectBufferATI");
    _driver.call(&_driver.glUnmapObjectBufferATI)(buffer);
  }

// GL_ATI_pn_triangles

  static void REGAL_CALL glPNTrianglesfATI(GLenum pname, GLfloat param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPNTrianglesfATI),reinterpret_cast<void (*)()>(glPNTrianglesfATI),"glPNTrianglesfATI");
    _driver.call(&_driver.glPNTrianglesfATI)(pname, param);
  }

  static void REGAL_CALL glPNTrianglesiATI(GLenum pname, GLint param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPNTrianglesiATI),reinterpret_cast<void (*)()>(glPNTrianglesiATI),"glPNTrianglesiATI");
    _driver.call(&_driver.glPNTrianglesiATI)(pname, param);
  }

// GL_ATI_separate_stencil

  static void REGAL_CALL glStencilFuncSeparateATI(GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glStencilFuncSeparateATI),reinterpret_cast<void (*)()>(glStencilFuncSeparateATI),"glStencilFuncSeparateATI");
    _driver.call(&_driver.glStencilFuncSeparateATI)(frontfunc, backfunc, ref, mask);
  }

  static void REGAL_CALL glStencilOpSeparateATI(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glStencilOpSeparateATI),reinterpret_cast<void (*)()>(glStencilOpSeparateATI),"glStencilOpSeparateATI");
    _driver.call(&_driver.glStencilOpSeparateATI)(face, sfail, dpfail, dppass);
  }

// GL_ATI_vertex_array_object

  static void REGAL_CALL glArrayObjectATI(GLenum array, GLint size, GLenum type, GLsizei stride, GLuint buffer, GLuint offset)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glArrayObjectATI),reinterpret_cast<void (*)()>(glArrayObjectATI),"glArrayObjectATI");
    _driver.call(&_driver.glArrayObjectATI)(array, size, type, stride, buffer, offset);
  }

  static void REGAL_CALL glFreeObjectBufferATI(GLuint buffer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFreeObjectBufferATI),reinterpret_cast<void (*)()>(glFreeObjectBufferATI),"glFreeObjectBufferATI");
    _driver.call(&_driver.glFreeObjectBufferATI)(buffer);
  }

  static void REGAL_CALL glGetArrayObjectfvATI(GLenum array, GLenum pname, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetArrayObjectfvATI),reinterpret_cast<void (*)()>(glGetArrayObjectfvATI),"glGetArrayObjectfvATI");
    _driver.call(&_driver.glGetArrayObjectfvATI)(array, pname, params);
  }

  static void REGAL_CALL glGetArrayObjectivATI(GLenum array, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetArrayObjectivATI),reinterpret_cast<void (*)()>(glGetArrayObjectivATI),"glGetArrayObjectivATI");
    _driver.call(&_driver.glGetArrayObjectivATI)(array, pname, params);
  }

  static void REGAL_CALL glGetObjectBufferfvATI(GLuint buffer, GLenum pname, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetObjectBufferfvATI),reinterpret_cast<void (*)()>(glGetObjectBufferfvATI),"glGetObjectBufferfvATI");
    _driver.call(&_driver.glGetObjectBufferfvATI)(buffer, pname, params);
  }

  static void REGAL_CALL glGetObjectBufferivATI(GLuint buffer, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetObjectBufferivATI),reinterpret_cast<void (*)()>(glGetObjectBufferivATI),"glGetObjectBufferivATI");
    _driver.call(&_driver.glGetObjectBufferivATI)(buffer, pname, params);
  }

  static void REGAL_CALL glGetVariantArrayObjectfvATI(GLuint id, GLenum pname, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetVariantArrayObjectfvATI),reinterpret_cast<void (*)()>(glGetVariantArrayObjectfvATI),"glGetVariantArrayObjectfvATI");
    _driver.call(&_driver.glGetVariantArrayObjectfvATI)(id, pname, params);
  }

  static void REGAL_CALL glGetVariantArrayObjectivATI(GLuint id, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetVariantArrayObjectivATI),reinterpret_cast<void (*)()>(glGetVariantArrayObjectivATI),"glGetVariantArrayObjectivATI");
    _driver.call(&_driver.glGetVariantArrayObjectivATI)(id, pname, params);
  }

  static GLboolean REGAL_CALL glIsObjectBufferATI(GLuint buffer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIsObjectBufferATI),reinterpret_cast<void (*)()>(glIsObjectBufferATI),"glIsObjectBufferATI");
    return _driver.call(&_driver.glIsObjectBufferATI)(buffer);
  }

  static GLuint REGAL_CALL glNewObjectBufferATI(GLsizei size, const GLvoid *pointer, GLenum usage)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNewObjectBufferATI),reinterpret_cast<void (*)()>(glNewObjectBufferATI),"glNewObjectBufferATI");
    return _driver.call(&_driver.glNewObjectBufferATI)(size, pointer, usage);
  }

  static void REGAL_CALL glUpdateObjectBufferATI(GLuint buffer, GLuint offset, GLsizei size, const GLvoid *pointer, GLenum preserve)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUpdateObjectBufferATI),reinterpret_cast<void (*)()>(glUpdateObjectBufferATI),"glUpdateObjectBufferATI");
    _driver.call(&_driver.glUpdateObjectBufferATI)(buffer, offset, size, pointer, preserve);
  }

  static void REGAL_CALL glVariantArrayObjectATI(GLuint id, GLenum type, GLsizei stride, GLuint buffer, GLuint offset)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVariantArrayObjectATI),reinterpret_cast<void (*)()>(glVariantArrayObjectATI),"glVariantArrayObjectATI");
    _driver.call(&_driver.glVariantArrayObjectATI)(id, type, stride, buffer, offset);
  }

// GL_ATI_vertex_attrib_array_object

  static void REGAL_CALL glGetVertexAttribArrayObjectfvATI(GLuint index, GLenum pname, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetVertexAttribArrayObjectfvATI),reinterpret_cast<void (*)()>(glGetVertexAttribArrayObjectfvATI),"glGetVertexAttribArrayObjectfvATI");
    _driver.call(&_driver.glGetVertexAttribArrayObjectfvATI)(index, pname, params);
  }

  static void REGAL_CALL glGetVertexAttribArrayObjectivATI(GLuint index, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetVertexAttribArrayObjectivATI),reinterpret_cast<void (*)()>(glGetVertexAttribArrayObjectivATI),"glGetVertexAttribArrayObjectivATI");
    _driver.call(&_driver.glGetVertexAttribArrayObjectivATI)(index, pname, params);
  }

  static void REGAL_CALL glVertexAttribArrayObjectATI(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLuint buffer, GLuint offset)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribArrayObjectATI),reinterpret_cast<void (*)()>(glVertexAttribArrayObjectATI),"glVertexAttribArrayObjectATI");
    _driver.call(&_driver.glVertexAttribArrayObjectATI)(index, size, type, normalized, stride, buffer, offset);
  }

// GL_ATI_vertex_streams

  static void REGAL_CALL glClientActiveVertexStreamATI(GLenum stream)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glClientActiveVertexStreamATI),reinterpret_cast<void (*)()>(glClientActiveVertexStreamATI),"glClientActiveVertexStreamATI");
    _driver.call(&_driver.glClientActiveVertexStreamATI)(stream);
  }

  static void REGAL_CALL glNormalStream3bATI(GLenum stream, GLbyte x, GLbyte y, GLbyte z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNormalStream3bATI),reinterpret_cast<void (*)()>(glNormalStream3bATI),"glNormalStream3bATI");
    _driver.call(&_driver.glNormalStream3bATI)(stream, x, y, z);
  }

  static void REGAL_CALL glNormalStream3bvATI(GLenum stream, const GLbyte *coords)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNormalStream3bvATI),reinterpret_cast<void (*)()>(glNormalStream3bvATI),"glNormalStream3bvATI");
    _driver.call(&_driver.glNormalStream3bvATI)(stream, coords);
  }

  static void REGAL_CALL glNormalStream3dATI(GLenum stream, GLdouble x, GLdouble y, GLdouble z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNormalStream3dATI),reinterpret_cast<void (*)()>(glNormalStream3dATI),"glNormalStream3dATI");
    _driver.call(&_driver.glNormalStream3dATI)(stream, x, y, z);
  }

  static void REGAL_CALL glNormalStream3dvATI(GLenum stream, const GLdouble *coords)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNormalStream3dvATI),reinterpret_cast<void (*)()>(glNormalStream3dvATI),"glNormalStream3dvATI");
    _driver.call(&_driver.glNormalStream3dvATI)(stream, coords);
  }

  static void REGAL_CALL glNormalStream3fATI(GLenum stream, GLfloat x, GLfloat y, GLfloat z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNormalStream3fATI),reinterpret_cast<void (*)()>(glNormalStream3fATI),"glNormalStream3fATI");
    _driver.call(&_driver.glNormalStream3fATI)(stream, x, y, z);
  }

  static void REGAL_CALL glNormalStream3fvATI(GLenum stream, const GLfloat *coords)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNormalStream3fvATI),reinterpret_cast<void (*)()>(glNormalStream3fvATI),"glNormalStream3fvATI");
    _driver.call(&_driver.glNormalStream3fvATI)(stream, coords);
  }

  static void REGAL_CALL glNormalStream3iATI(GLenum stream, GLint x, GLint y, GLint z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNormalStream3iATI),reinterpret_cast<void (*)()>(glNormalStream3iATI),"glNormalStream3iATI");
    _driver.call(&_driver.glNormalStream3iATI)(stream, x, y, z);
  }

  static void REGAL_CALL glNormalStream3ivATI(GLenum stream, const GLint *coords)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNormalStream3ivATI),reinterpret_cast<void (*)()>(glNormalStream3ivATI),"glNormalStream3ivATI");
    _driver.call(&_driver.glNormalStream3ivATI)(stream, coords);
  }

  static void REGAL_CALL glNormalStream3sATI(GLenum stream, GLshort x, GLshort y, GLshort z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNormalStream3sATI),reinterpret_cast<void (*)()>(glNormalStream3sATI),"glNormalStream3sATI");
    _driver.call(&_driver.glNormalStream3sATI)(stream, x, y, z);
  }

  static void REGAL_CALL glNormalStream3svATI(GLenum stream, const GLshort *coords)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNormalStream3svATI),reinterpret_cast<void (*)()>(glNormalStream3svATI),"glNormalStream3svATI");
    _driver.call(&_driver.glNormalStream3svATI)(stream, coords);
  }

  static void REGAL_CALL glVertexBlendEnvfATI(GLenum pname, GLfloat param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexBlendEnvfATI),reinterpret_cast<void (*)()>(glVertexBlendEnvfATI),"glVertexBlendEnvfATI");
    _driver.call(&_driver.glVertexBlendEnvfATI)(pname, param);
  }

  static void REGAL_CALL glVertexBlendEnviATI(GLenum pname, GLint param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexBlendEnviATI),reinterpret_cast<void (*)()>(glVertexBlendEnviATI),"glVertexBlendEnviATI");
    _driver.call(&_driver.glVertexBlendEnviATI)(pname, param);
  }

  static void REGAL_CALL glVertexStream1dATI(GLenum stream, GLdouble x)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexStream1dATI),reinterpret_cast<void (*)()>(glVertexStream1dATI),"glVertexStream1dATI");
    _driver.call(&_driver.glVertexStream1dATI)(stream, x);
  }

  static void REGAL_CALL glVertexStream1dvATI(GLenum stream, const GLdouble *coords)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexStream1dvATI),reinterpret_cast<void (*)()>(glVertexStream1dvATI),"glVertexStream1dvATI");
    _driver.call(&_driver.glVertexStream1dvATI)(stream, coords);
  }

  static void REGAL_CALL glVertexStream1fATI(GLenum stream, GLfloat x)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexStream1fATI),reinterpret_cast<void (*)()>(glVertexStream1fATI),"glVertexStream1fATI");
    _driver.call(&_driver.glVertexStream1fATI)(stream, x);
  }

  static void REGAL_CALL glVertexStream1fvATI(GLenum stream, const GLfloat *coords)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexStream1fvATI),reinterpret_cast<void (*)()>(glVertexStream1fvATI),"glVertexStream1fvATI");
    _driver.call(&_driver.glVertexStream1fvATI)(stream, coords);
  }

  static void REGAL_CALL glVertexStream1iATI(GLenum stream, GLint x)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexStream1iATI),reinterpret_cast<void (*)()>(glVertexStream1iATI),"glVertexStream1iATI");
    _driver.call(&_driver.glVertexStream1iATI)(stream, x);
  }

  static void REGAL_CALL glVertexStream1ivATI(GLenum stream, const GLint *coords)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexStream1ivATI),reinterpret_cast<void (*)()>(glVertexStream1ivATI),"glVertexStream1ivATI");
    _driver.call(&_driver.glVertexStream1ivATI)(stream, coords);
  }

  static void REGAL_CALL glVertexStream1sATI(GLenum stream, GLshort x)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexStream1sATI),reinterpret_cast<void (*)()>(glVertexStream1sATI),"glVertexStream1sATI");
    _driver.call(&_driver.glVertexStream1sATI)(stream, x);
  }

  static void REGAL_CALL glVertexStream1svATI(GLenum stream, const GLshort *coords)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexStream1svATI),reinterpret_cast<void (*)()>(glVertexStream1svATI),"glVertexStream1svATI");
    _driver.call(&_driver.glVertexStream1svATI)(stream, coords);
  }

  static void REGAL_CALL glVertexStream2dATI(GLenum stream, GLdouble x, GLdouble y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexStream2dATI),reinterpret_cast<void (*)()>(glVertexStream2dATI),"glVertexStream2dATI");
    _driver.call(&_driver.glVertexStream2dATI)(stream, x, y);
  }

  static void REGAL_CALL glVertexStream2dvATI(GLenum stream, const GLdouble *coords)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexStream2dvATI),reinterpret_cast<void (*)()>(glVertexStream2dvATI),"glVertexStream2dvATI");
    _driver.call(&_driver.glVertexStream2dvATI)(stream, coords);
  }

  static void REGAL_CALL glVertexStream2fATI(GLenum stream, GLfloat x, GLfloat y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexStream2fATI),reinterpret_cast<void (*)()>(glVertexStream2fATI),"glVertexStream2fATI");
    _driver.call(&_driver.glVertexStream2fATI)(stream, x, y);
  }

  static void REGAL_CALL glVertexStream2fvATI(GLenum stream, const GLfloat *coords)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexStream2fvATI),reinterpret_cast<void (*)()>(glVertexStream2fvATI),"glVertexStream2fvATI");
    _driver.call(&_driver.glVertexStream2fvATI)(stream, coords);
  }

  static void REGAL_CALL glVertexStream2iATI(GLenum stream, GLint x, GLint y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexStream2iATI),reinterpret_cast<void (*)()>(glVertexStream2iATI),"glVertexStream2iATI");
    _driver.call(&_driver.glVertexStream2iATI)(stream, x, y);
  }

  static void REGAL_CALL glVertexStream2ivATI(GLenum stream, const GLint *coords)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexStream2ivATI),reinterpret_cast<void (*)()>(glVertexStream2ivATI),"glVertexStream2ivATI");
    _driver.call(&_driver.glVertexStream2ivATI)(stream, coords);
  }

  static void REGAL_CALL glVertexStream2sATI(GLenum stream, GLshort x, GLshort y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexStream2sATI),reinterpret_cast<void (*)()>(glVertexStream2sATI),"glVertexStream2sATI");
    _driver.call(&_driver.glVertexStream2sATI)(stream, x, y);
  }

  static void REGAL_CALL glVertexStream2svATI(GLenum stream, const GLshort *coords)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexStream2svATI),reinterpret_cast<void (*)()>(glVertexStream2svATI),"glVertexStream2svATI");
    _driver.call(&_driver.glVertexStream2svATI)(stream, coords);
  }

  static void REGAL_CALL glVertexStream3dATI(GLenum stream, GLdouble x, GLdouble y, GLdouble z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexStream3dATI),reinterpret_cast<void (*)()>(glVertexStream3dATI),"glVertexStream3dATI");
    _driver.call(&_driver.glVertexStream3dATI)(stream, x, y, z);
  }

  static void REGAL_CALL glVertexStream3dvATI(GLenum stream, const GLdouble *coords)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexStream3dvATI),reinterpret_cast<void (*)()>(glVertexStream3dvATI),"glVertexStream3dvATI");
    _driver.call(&_driver.glVertexStream3dvATI)(stream, coords);
  }

  static void REGAL_CALL glVertexStream3fATI(GLenum stream, GLfloat x, GLfloat y, GLfloat z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexStream3fATI),reinterpret_cast<void (*)()>(glVertexStream3fATI),"glVertexStream3fATI");
    _driver.call(&_driver.glVertexStream3fATI)(stream, x, y, z);
  }

  static void REGAL_CALL glVertexStream3fvATI(GLenum stream, const GLfloat *coords)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexStream3fvATI),reinterpret_cast<void (*)()>(glVertexStream3fvATI),"glVertexStream3fvATI");
    _driver.call(&_driver.glVertexStream3fvATI)(stream, coords);
  }

  static void REGAL_CALL glVertexStream3iATI(GLenum stream, GLint x, GLint y, GLint z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexStream3iATI),reinterpret_cast<void (*)()>(glVertexStream3iATI),"glVertexStream3iATI");
    _driver.call(&_driver.glVertexStream3iATI)(stream, x, y, z);
  }

  static void REGAL_CALL glVertexStream3ivATI(GLenum stream, const GLint *coords)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexStream3ivATI),reinterpret_cast<void (*)()>(glVertexStream3ivATI),"glVertexStream3ivATI");
    _driver.call(&_driver.glVertexStream3ivATI)(stream, coords);
  }

  static void REGAL_CALL glVertexStream3sATI(GLenum stream, GLshort x, GLshort y, GLshort z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexStream3sATI),reinterpret_cast<void (*)()>(glVertexStream3sATI),"glVertexStream3sATI");
    _driver.call(&_driver.glVertexStream3sATI)(stream, x, y, z);
  }

  static void REGAL_CALL glVertexStream3svATI(GLenum stream, const GLshort *coords)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexStream3svATI),reinterpret_cast<void (*)()>(glVertexStream3svATI),"glVertexStream3svATI");
    _driver.call(&_driver.glVertexStream3svATI)(stream, coords);
  }

  static void REGAL_CALL glVertexStream4dATI(GLenum stream, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexStream4dATI),reinterpret_cast<void (*)()>(glVertexStream4dATI),"glVertexStream4dATI");
    _driver.call(&_driver.glVertexStream4dATI)(stream, x, y, z, w);
  }

  static void REGAL_CALL glVertexStream4dvATI(GLenum stream, const GLdouble *coords)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexStream4dvATI),reinterpret_cast<void (*)()>(glVertexStream4dvATI),"glVertexStream4dvATI");
    _driver.call(&_driver.glVertexStream4dvATI)(stream, coords);
  }

  static void REGAL_CALL glVertexStream4fATI(GLenum stream, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexStream4fATI),reinterpret_cast<void (*)()>(glVertexStream4fATI),"glVertexStream4fATI");
    _driver.call(&_driver.glVertexStream4fATI)(stream, x, y, z, w);
  }

  static void REGAL_CALL glVertexStream4fvATI(GLenum stream, const GLfloat *coords)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexStream4fvATI),reinterpret_cast<void (*)()>(glVertexStream4fvATI),"glVertexStream4fvATI");
    _driver.call(&_driver.glVertexStream4fvATI)(stream, coords);
  }

  static void REGAL_CALL glVertexStream4iATI(GLenum stream, GLint x, GLint y, GLint z, GLint w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexStream4iATI),reinterpret_cast<void (*)()>(glVertexStream4iATI),"glVertexStream4iATI");
    _driver.call(&_driver.glVertexStream4iATI)(stream, x, y, z, w);
  }

  static void REGAL_CALL glVertexStream4ivATI(GLenum stream, const GLint *coords)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexStream4ivATI),reinterpret_cast<void (*)()>(glVertexStream4ivATI),"glVertexStream4ivATI");
    _driver.call(&_driver.glVertexStream4ivATI)(stream, coords);
  }

  static void REGAL_CALL glVertexStream4sATI(GLenum stream, GLshort x, GLshort y, GLshort z, GLshort w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexStream4sATI),reinterpret_cast<void (*)()>(glVertexStream4sATI),"glVertexStream4sATI");
    _driver.call(&_driver.glVertexStream4sATI)(stream, x, y, z, w);
  }

  static void REGAL_CALL glVertexStream4svATI(GLenum stream, const GLshort *coords)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexStream4svATI),reinterpret_cast<void (*)()>(glVertexStream4svATI),"glVertexStream4svATI");
    _driver.call(&_driver.glVertexStream4svATI)(stream, coords);
  }

// GL_EXT_bindable_uniform

  static GLint REGAL_CALL glGetUniformBufferSizeEXT(GLuint program, GLint location)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetUniformBufferSizeEXT),reinterpret_cast<void (*)()>(glGetUniformBufferSizeEXT),"glGetUniformBufferSizeEXT");
    return _driver.call(&_driver.glGetUniformBufferSizeEXT)(program, location);
  }

  static GLintptr REGAL_CALL glGetUniformOffsetEXT(GLuint program, GLint location)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetUniformOffsetEXT),reinterpret_cast<void (*)()>(glGetUniformOffsetEXT),"glGetUniformOffsetEXT");
    return _driver.call(&_driver.glGetUniformOffsetEXT)(program, location);
  }

  static void REGAL_CALL glUniformBufferEXT(GLuint program, GLint location, GLuint buffer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniformBufferEXT),reinterpret_cast<void (*)()>(glUniformBufferEXT),"glUniformBufferEXT");
    _driver.call(&_driver.glUniformBufferEXT)(program, location, buffer);
  }

// GL_EXT_blend_color

  static void REGAL_CALL glBlendColorEXT(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBlendColorEXT),reinterpret_cast<void (*)()>(glBlendColorEXT),"glBlendColorEXT");
    _driver.call(&_driver.glBlendColorEXT)(red, green, blue, alpha);
  }

// GL_EXT_blend_equation_separate

  static void REGAL_CALL glBlendEquationSeparateEXT(GLenum modeRGB, GLenum modeAlpha)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBlendEquationSeparateEXT),reinterpret_cast<void (*)()>(glBlendEquationSeparateEXT),"glBlendEquationSeparateEXT");
    _driver.call(&_driver.glBlendEquationSeparateEXT)(modeRGB, modeAlpha);
  }

// GL_EXT_blend_func_separate

  static void REGAL_CALL glBlendFuncSeparateEXT(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBlendFuncSeparateEXT),reinterpret_cast<void (*)()>(glBlendFuncSeparateEXT),"glBlendFuncSeparateEXT");
    _driver.call(&_driver.glBlendFuncSeparateEXT)(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
  }

// GL_EXT_blend_minmax

  static void REGAL_CALL glBlendEquationEXT(GLenum mode)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBlendEquationEXT),reinterpret_cast<void (*)()>(glBlendEquationEXT),"glBlendEquationEXT");
    _driver.call(&_driver.glBlendEquationEXT)(mode);
  }

// GL_EXT_color_subtable

  static void REGAL_CALL glColorSubTableEXT(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *table)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColorSubTableEXT),reinterpret_cast<void (*)()>(glColorSubTableEXT),"glColorSubTableEXT");
    _driver.call(&_driver.glColorSubTableEXT)(target, start, count, format, type, table);
  }

  static void REGAL_CALL glCopyColorSubTableEXT(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCopyColorSubTableEXT),reinterpret_cast<void (*)()>(glCopyColorSubTableEXT),"glCopyColorSubTableEXT");
    _driver.call(&_driver.glCopyColorSubTableEXT)(target, start, x, y, width);
  }

// GL_EXT_compiled_vertex_array

  static void REGAL_CALL glLockArraysEXT(GLint first, GLsizei count)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glLockArraysEXT),reinterpret_cast<void (*)()>(glLockArraysEXT),"glLockArraysEXT");
    _driver.call(&_driver.glLockArraysEXT)(first, count);
  }

  static void REGAL_CALL glUnlockArraysEXT(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUnlockArraysEXT),reinterpret_cast<void (*)()>(glUnlockArraysEXT),"glUnlockArraysEXT");
    _driver.call(&_driver.glUnlockArraysEXT)();
  }

// GL_EXT_convolution

  static void REGAL_CALL glConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glConvolutionFilter1DEXT),reinterpret_cast<void (*)()>(glConvolutionFilter1DEXT),"glConvolutionFilter1DEXT");
    _driver.call(&_driver.glConvolutionFilter1DEXT)(target, internalformat, width, format, type, image);
  }

  static void REGAL_CALL glConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glConvolutionFilter2DEXT),reinterpret_cast<void (*)()>(glConvolutionFilter2DEXT),"glConvolutionFilter2DEXT");
    _driver.call(&_driver.glConvolutionFilter2DEXT)(target, internalformat, width, height, format, type, image);
  }

  static void REGAL_CALL glConvolutionParameterfEXT(GLenum target, GLenum pname, GLfloat param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glConvolutionParameterfEXT),reinterpret_cast<void (*)()>(glConvolutionParameterfEXT),"glConvolutionParameterfEXT");
    _driver.call(&_driver.glConvolutionParameterfEXT)(target, pname, param);
  }

  static void REGAL_CALL glConvolutionParameterfvEXT(GLenum target, GLenum pname, const GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glConvolutionParameterfvEXT),reinterpret_cast<void (*)()>(glConvolutionParameterfvEXT),"glConvolutionParameterfvEXT");
    _driver.call(&_driver.glConvolutionParameterfvEXT)(target, pname, params);
  }

  static void REGAL_CALL glConvolutionParameteriEXT(GLenum target, GLenum pname, GLint param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glConvolutionParameteriEXT),reinterpret_cast<void (*)()>(glConvolutionParameteriEXT),"glConvolutionParameteriEXT");
    _driver.call(&_driver.glConvolutionParameteriEXT)(target, pname, param);
  }

  static void REGAL_CALL glConvolutionParameterivEXT(GLenum target, GLenum pname, const GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glConvolutionParameterivEXT),reinterpret_cast<void (*)()>(glConvolutionParameterivEXT),"glConvolutionParameterivEXT");
    _driver.call(&_driver.glConvolutionParameterivEXT)(target, pname, params);
  }

  static void REGAL_CALL glCopyConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCopyConvolutionFilter1DEXT),reinterpret_cast<void (*)()>(glCopyConvolutionFilter1DEXT),"glCopyConvolutionFilter1DEXT");
    _driver.call(&_driver.glCopyConvolutionFilter1DEXT)(target, internalformat, x, y, width);
  }

  static void REGAL_CALL glCopyConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCopyConvolutionFilter2DEXT),reinterpret_cast<void (*)()>(glCopyConvolutionFilter2DEXT),"glCopyConvolutionFilter2DEXT");
    _driver.call(&_driver.glCopyConvolutionFilter2DEXT)(target, internalformat, x, y, width, height);
  }

  static void REGAL_CALL glGetConvolutionFilterEXT(GLenum target, GLenum format, GLenum type, GLvoid *image)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetConvolutionFilterEXT),reinterpret_cast<void (*)()>(glGetConvolutionFilterEXT),"glGetConvolutionFilterEXT");
    _driver.call(&_driver.glGetConvolutionFilterEXT)(target, format, type, image);
  }

  static void REGAL_CALL glGetConvolutionParameterfvEXT(GLenum target, GLenum pname, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetConvolutionParameterfvEXT),reinterpret_cast<void (*)()>(glGetConvolutionParameterfvEXT),"glGetConvolutionParameterfvEXT");
    _driver.call(&_driver.glGetConvolutionParameterfvEXT)(target, pname, params);
  }

  static void REGAL_CALL glGetConvolutionParameterivEXT(GLenum target, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetConvolutionParameterivEXT),reinterpret_cast<void (*)()>(glGetConvolutionParameterivEXT),"glGetConvolutionParameterivEXT");
    _driver.call(&_driver.glGetConvolutionParameterivEXT)(target, pname, params);
  }

  static void REGAL_CALL glGetSeparableFilterEXT(GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetSeparableFilterEXT),reinterpret_cast<void (*)()>(glGetSeparableFilterEXT),"glGetSeparableFilterEXT");
    _driver.call(&_driver.glGetSeparableFilterEXT)(target, format, type, row, column, span);
  }

  static void REGAL_CALL glSeparableFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSeparableFilter2DEXT),reinterpret_cast<void (*)()>(glSeparableFilter2DEXT),"glSeparableFilter2DEXT");
    _driver.call(&_driver.glSeparableFilter2DEXT)(target, internalformat, width, height, format, type, row, column);
  }

// GL_EXT_coordinate_frame

  static void REGAL_CALL glBinormal3bEXT(GLbyte bx, GLbyte by, GLbyte bz)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBinormal3bEXT),reinterpret_cast<void (*)()>(glBinormal3bEXT),"glBinormal3bEXT");
    _driver.call(&_driver.glBinormal3bEXT)(bx, by, bz);
  }

  static void REGAL_CALL glBinormal3bvEXT(const GLbyte *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBinormal3bvEXT),reinterpret_cast<void (*)()>(glBinormal3bvEXT),"glBinormal3bvEXT");
    _driver.call(&_driver.glBinormal3bvEXT)(v);
  }

  static void REGAL_CALL glBinormal3dEXT(GLdouble bx, GLdouble by, GLdouble bz)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBinormal3dEXT),reinterpret_cast<void (*)()>(glBinormal3dEXT),"glBinormal3dEXT");
    _driver.call(&_driver.glBinormal3dEXT)(bx, by, bz);
  }

  static void REGAL_CALL glBinormal3dvEXT(const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBinormal3dvEXT),reinterpret_cast<void (*)()>(glBinormal3dvEXT),"glBinormal3dvEXT");
    _driver.call(&_driver.glBinormal3dvEXT)(v);
  }

  static void REGAL_CALL glBinormal3fEXT(GLfloat bx, GLfloat by, GLfloat bz)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBinormal3fEXT),reinterpret_cast<void (*)()>(glBinormal3fEXT),"glBinormal3fEXT");
    _driver.call(&_driver.glBinormal3fEXT)(bx, by, bz);
  }

  static void REGAL_CALL glBinormal3fvEXT(const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBinormal3fvEXT),reinterpret_cast<void (*)()>(glBinormal3fvEXT),"glBinormal3fvEXT");
    _driver.call(&_driver.glBinormal3fvEXT)(v);
  }

  static void REGAL_CALL glBinormal3iEXT(GLint bx, GLint by, GLint bz)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBinormal3iEXT),reinterpret_cast<void (*)()>(glBinormal3iEXT),"glBinormal3iEXT");
    _driver.call(&_driver.glBinormal3iEXT)(bx, by, bz);
  }

  static void REGAL_CALL glBinormal3ivEXT(const GLint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBinormal3ivEXT),reinterpret_cast<void (*)()>(glBinormal3ivEXT),"glBinormal3ivEXT");
    _driver.call(&_driver.glBinormal3ivEXT)(v);
  }

  static void REGAL_CALL glBinormal3sEXT(GLshort bx, GLshort by, GLshort bz)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBinormal3sEXT),reinterpret_cast<void (*)()>(glBinormal3sEXT),"glBinormal3sEXT");
    _driver.call(&_driver.glBinormal3sEXT)(bx, by, bz);
  }

  static void REGAL_CALL glBinormal3svEXT(const GLshort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBinormal3svEXT),reinterpret_cast<void (*)()>(glBinormal3svEXT),"glBinormal3svEXT");
    _driver.call(&_driver.glBinormal3svEXT)(v);
  }

  static void REGAL_CALL glBinormalPointerEXT(GLenum type, GLsizei stride, const GLvoid *pointer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBinormalPointerEXT),reinterpret_cast<void (*)()>(glBinormalPointerEXT),"glBinormalPointerEXT");
    _driver.call(&_driver.glBinormalPointerEXT)(type, stride, pointer);
  }

  static void REGAL_CALL glTangent3bEXT(GLbyte tx, GLbyte ty, GLbyte tz)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTangent3bEXT),reinterpret_cast<void (*)()>(glTangent3bEXT),"glTangent3bEXT");
    _driver.call(&_driver.glTangent3bEXT)(tx, ty, tz);
  }

  static void REGAL_CALL glTangent3bvEXT(const GLbyte *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTangent3bvEXT),reinterpret_cast<void (*)()>(glTangent3bvEXT),"glTangent3bvEXT");
    _driver.call(&_driver.glTangent3bvEXT)(v);
  }

  static void REGAL_CALL glTangent3dEXT(GLdouble tx, GLdouble ty, GLdouble tz)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTangent3dEXT),reinterpret_cast<void (*)()>(glTangent3dEXT),"glTangent3dEXT");
    _driver.call(&_driver.glTangent3dEXT)(tx, ty, tz);
  }

  static void REGAL_CALL glTangent3dvEXT(const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTangent3dvEXT),reinterpret_cast<void (*)()>(glTangent3dvEXT),"glTangent3dvEXT");
    _driver.call(&_driver.glTangent3dvEXT)(v);
  }

  static void REGAL_CALL glTangent3fEXT(GLfloat tx, GLfloat ty, GLfloat tz)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTangent3fEXT),reinterpret_cast<void (*)()>(glTangent3fEXT),"glTangent3fEXT");
    _driver.call(&_driver.glTangent3fEXT)(tx, ty, tz);
  }

  static void REGAL_CALL glTangent3fvEXT(const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTangent3fvEXT),reinterpret_cast<void (*)()>(glTangent3fvEXT),"glTangent3fvEXT");
    _driver.call(&_driver.glTangent3fvEXT)(v);
  }

  static void REGAL_CALL glTangent3iEXT(GLint tx, GLint ty, GLint tz)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTangent3iEXT),reinterpret_cast<void (*)()>(glTangent3iEXT),"glTangent3iEXT");
    _driver.call(&_driver.glTangent3iEXT)(tx, ty, tz);
  }

  static void REGAL_CALL glTangent3ivEXT(const GLint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTangent3ivEXT),reinterpret_cast<void (*)()>(glTangent3ivEXT),"glTangent3ivEXT");
    _driver.call(&_driver.glTangent3ivEXT)(v);
  }

  static void REGAL_CALL glTangent3sEXT(GLshort tx, GLshort ty, GLshort tz)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTangent3sEXT),reinterpret_cast<void (*)()>(glTangent3sEXT),"glTangent3sEXT");
    _driver.call(&_driver.glTangent3sEXT)(tx, ty, tz);
  }

  static void REGAL_CALL glTangent3svEXT(const GLshort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTangent3svEXT),reinterpret_cast<void (*)()>(glTangent3svEXT),"glTangent3svEXT");
    _driver.call(&_driver.glTangent3svEXT)(v);
  }

  static void REGAL_CALL glTangentPointerEXT(GLenum type, GLsizei stride, const GLvoid *pointer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTangentPointerEXT),reinterpret_cast<void (*)()>(glTangentPointerEXT),"glTangentPointerEXT");
    _driver.call(&_driver.glTangentPointerEXT)(type, stride, pointer);
  }

// GL_EXT_copy_texture

  static void REGAL_CALL glCopyTexImage1DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCopyTexImage1DEXT),reinterpret_cast<void (*)()>(glCopyTexImage1DEXT),"glCopyTexImage1DEXT");
    _driver.call(&_driver.glCopyTexImage1DEXT)(target, level, internalformat, x, y, width, border);
  }

  static void REGAL_CALL glCopyTexImage2DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCopyTexImage2DEXT),reinterpret_cast<void (*)()>(glCopyTexImage2DEXT),"glCopyTexImage2DEXT");
    _driver.call(&_driver.glCopyTexImage2DEXT)(target, level, internalformat, x, y, width, height, border);
  }

  static void REGAL_CALL glCopyTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCopyTexSubImage1DEXT),reinterpret_cast<void (*)()>(glCopyTexSubImage1DEXT),"glCopyTexSubImage1DEXT");
    _driver.call(&_driver.glCopyTexSubImage1DEXT)(target, level, xoffset, x, y, width);
  }

  static void REGAL_CALL glCopyTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCopyTexSubImage2DEXT),reinterpret_cast<void (*)()>(glCopyTexSubImage2DEXT),"glCopyTexSubImage2DEXT");
    _driver.call(&_driver.glCopyTexSubImage2DEXT)(target, level, xoffset, yoffset, x, y, width, height);
  }

  static void REGAL_CALL glCopyTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCopyTexSubImage3DEXT),reinterpret_cast<void (*)()>(glCopyTexSubImage3DEXT),"glCopyTexSubImage3DEXT");
    _driver.call(&_driver.glCopyTexSubImage3DEXT)(target, level, xoffset, yoffset, zoffset, x, y, width, height);
  }

// GL_EXT_cull_vertex

  static void REGAL_CALL glCullParameterdvEXT(GLenum pname, GLdouble *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCullParameterdvEXT),reinterpret_cast<void (*)()>(glCullParameterdvEXT),"glCullParameterdvEXT");
    _driver.call(&_driver.glCullParameterdvEXT)(pname, params);
  }

  static void REGAL_CALL glCullParameterfvEXT(GLenum pname, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCullParameterfvEXT),reinterpret_cast<void (*)()>(glCullParameterfvEXT),"glCullParameterfvEXT");
    _driver.call(&_driver.glCullParameterfvEXT)(pname, params);
  }

// GL_EXT_debug_label

  static void REGAL_CALL glGetObjectLabelEXT(GLenum type, GLuint object, GLsizei bufSize, GLsizei *length, GLchar *label)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetObjectLabelEXT),reinterpret_cast<void (*)()>(glGetObjectLabelEXT),"glGetObjectLabelEXT");
    _driver.call(&_driver.glGetObjectLabelEXT)(type, object, bufSize, length, label);
  }

  static void REGAL_CALL glLabelObjectEXT(GLenum type, GLuint object, GLsizei length, const GLchar *label)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glLabelObjectEXT),reinterpret_cast<void (*)()>(glLabelObjectEXT),"glLabelObjectEXT");
    _driver.call(&_driver.glLabelObjectEXT)(type, object, length, label);
  }

// GL_EXT_debug_marker

  static void REGAL_CALL glInsertEventMarkerEXT(GLsizei length, const GLchar *marker)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glInsertEventMarkerEXT),reinterpret_cast<void (*)()>(glInsertEventMarkerEXT),"glInsertEventMarkerEXT");
    _driver.call(&_driver.glInsertEventMarkerEXT)(length, marker);
  }

  static void REGAL_CALL glPopGroupMarkerEXT(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPopGroupMarkerEXT),reinterpret_cast<void (*)()>(glPopGroupMarkerEXT),"glPopGroupMarkerEXT");
    _driver.call(&_driver.glPopGroupMarkerEXT)();
  }

  static void REGAL_CALL glPushGroupMarkerEXT(GLsizei length, const GLchar *marker)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPushGroupMarkerEXT),reinterpret_cast<void (*)()>(glPushGroupMarkerEXT),"glPushGroupMarkerEXT");
    _driver.call(&_driver.glPushGroupMarkerEXT)(length, marker);
  }

// GL_EXT_depth_bounds_test

  static void REGAL_CALL glDepthBoundsEXT(GLclampd zmin, GLclampd zmax)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDepthBoundsEXT),reinterpret_cast<void (*)()>(glDepthBoundsEXT),"glDepthBoundsEXT");
    _driver.call(&_driver.glDepthBoundsEXT)(zmin, zmax);
  }

// GL_EXT_direct_state_access

  static void REGAL_CALL glBindMultiTextureEXT(GLenum texunit, GLenum target, GLuint texture)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBindMultiTextureEXT),reinterpret_cast<void (*)()>(glBindMultiTextureEXT),"glBindMultiTextureEXT");
    _driver.call(&_driver.glBindMultiTextureEXT)(texunit, target, texture);
  }

  static GLenum REGAL_CALL glCheckNamedFramebufferStatusEXT(GLuint framebuffer, GLenum target)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCheckNamedFramebufferStatusEXT),reinterpret_cast<void (*)()>(glCheckNamedFramebufferStatusEXT),"glCheckNamedFramebufferStatusEXT");
    return _driver.call(&_driver.glCheckNamedFramebufferStatusEXT)(framebuffer, target);
  }

  static void REGAL_CALL glClientAttribDefaultEXT(GLbitfield mask)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glClientAttribDefaultEXT),reinterpret_cast<void (*)()>(glClientAttribDefaultEXT),"glClientAttribDefaultEXT");
    _driver.call(&_driver.glClientAttribDefaultEXT)(mask);
  }

  static void REGAL_CALL glCompressedMultiTexImage1DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCompressedMultiTexImage1DEXT),reinterpret_cast<void (*)()>(glCompressedMultiTexImage1DEXT),"glCompressedMultiTexImage1DEXT");
    _driver.call(&_driver.glCompressedMultiTexImage1DEXT)(texunit, target, level, internalformat, width, border, imageSize, data);
  }

  static void REGAL_CALL glCompressedMultiTexImage2DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *bits)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCompressedMultiTexImage2DEXT),reinterpret_cast<void (*)()>(glCompressedMultiTexImage2DEXT),"glCompressedMultiTexImage2DEXT");
    _driver.call(&_driver.glCompressedMultiTexImage2DEXT)(texunit, target, level, internalformat, width, height, border, imageSize, bits);
  }

  static void REGAL_CALL glCompressedMultiTexImage3DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *bits)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCompressedMultiTexImage3DEXT),reinterpret_cast<void (*)()>(glCompressedMultiTexImage3DEXT),"glCompressedMultiTexImage3DEXT");
    _driver.call(&_driver.glCompressedMultiTexImage3DEXT)(texunit, target, level, internalformat, width, height, depth, border, imageSize, bits);
  }

  static void REGAL_CALL glCompressedMultiTexSubImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCompressedMultiTexSubImage1DEXT),reinterpret_cast<void (*)()>(glCompressedMultiTexSubImage1DEXT),"glCompressedMultiTexSubImage1DEXT");
    _driver.call(&_driver.glCompressedMultiTexSubImage1DEXT)(texunit, target, level, xoffset, width, format, imageSize, data);
  }

  static void REGAL_CALL glCompressedMultiTexSubImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCompressedMultiTexSubImage2DEXT),reinterpret_cast<void (*)()>(glCompressedMultiTexSubImage2DEXT),"glCompressedMultiTexSubImage2DEXT");
    _driver.call(&_driver.glCompressedMultiTexSubImage2DEXT)(texunit, target, level, xoffset, yoffset, width, height, format, imageSize, data);
  }

  static void REGAL_CALL glCompressedMultiTexSubImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCompressedMultiTexSubImage3DEXT),reinterpret_cast<void (*)()>(glCompressedMultiTexSubImage3DEXT),"glCompressedMultiTexSubImage3DEXT");
    _driver.call(&_driver.glCompressedMultiTexSubImage3DEXT)(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
  }

  static void REGAL_CALL glCompressedTextureImage1DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *bits)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCompressedTextureImage1DEXT),reinterpret_cast<void (*)()>(glCompressedTextureImage1DEXT),"glCompressedTextureImage1DEXT");
    _driver.call(&_driver.glCompressedTextureImage1DEXT)(texture, target, level, internalformat, width, border, imageSize, bits);
  }

  static void REGAL_CALL glCompressedTextureImage2DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *bits)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCompressedTextureImage2DEXT),reinterpret_cast<void (*)()>(glCompressedTextureImage2DEXT),"glCompressedTextureImage2DEXT");
    _driver.call(&_driver.glCompressedTextureImage2DEXT)(texture, target, level, internalformat, width, height, border, imageSize, bits);
  }

  static void REGAL_CALL glCompressedTextureImage3DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *bits)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCompressedTextureImage3DEXT),reinterpret_cast<void (*)()>(glCompressedTextureImage3DEXT),"glCompressedTextureImage3DEXT");
    _driver.call(&_driver.glCompressedTextureImage3DEXT)(texture, target, level, internalformat, width, height, depth, border, imageSize, bits);
  }

  static void REGAL_CALL glCompressedTextureSubImage1DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *bits)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCompressedTextureSubImage1DEXT),reinterpret_cast<void (*)()>(glCompressedTextureSubImage1DEXT),"glCompressedTextureSubImage1DEXT");
    _driver.call(&_driver.glCompressedTextureSubImage1DEXT)(texture, target, level, xoffset, width, format, imageSize, bits);
  }

  static void REGAL_CALL glCompressedTextureSubImage2DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *bits)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCompressedTextureSubImage2DEXT),reinterpret_cast<void (*)()>(glCompressedTextureSubImage2DEXT),"glCompressedTextureSubImage2DEXT");
    _driver.call(&_driver.glCompressedTextureSubImage2DEXT)(texture, target, level, xoffset, yoffset, width, height, format, imageSize, bits);
  }

  static void REGAL_CALL glCompressedTextureSubImage3DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *bits)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCompressedTextureSubImage3DEXT),reinterpret_cast<void (*)()>(glCompressedTextureSubImage3DEXT),"glCompressedTextureSubImage3DEXT");
    _driver.call(&_driver.glCompressedTextureSubImage3DEXT)(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits);
  }

  static void REGAL_CALL glCopyMultiTexImage1DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCopyMultiTexImage1DEXT),reinterpret_cast<void (*)()>(glCopyMultiTexImage1DEXT),"glCopyMultiTexImage1DEXT");
    _driver.call(&_driver.glCopyMultiTexImage1DEXT)(texunit, target, level, internalformat, x, y, width, border);
  }

  static void REGAL_CALL glCopyMultiTexImage2DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCopyMultiTexImage2DEXT),reinterpret_cast<void (*)()>(glCopyMultiTexImage2DEXT),"glCopyMultiTexImage2DEXT");
    _driver.call(&_driver.glCopyMultiTexImage2DEXT)(texunit, target, level, internalformat, x, y, width, height, border);
  }

  static void REGAL_CALL glCopyMultiTexSubImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCopyMultiTexSubImage1DEXT),reinterpret_cast<void (*)()>(glCopyMultiTexSubImage1DEXT),"glCopyMultiTexSubImage1DEXT");
    _driver.call(&_driver.glCopyMultiTexSubImage1DEXT)(texunit, target, level, xoffset, x, y, width);
  }

  static void REGAL_CALL glCopyMultiTexSubImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCopyMultiTexSubImage2DEXT),reinterpret_cast<void (*)()>(glCopyMultiTexSubImage2DEXT),"glCopyMultiTexSubImage2DEXT");
    _driver.call(&_driver.glCopyMultiTexSubImage2DEXT)(texunit, target, level, xoffset, yoffset, x, y, width, height);
  }

  static void REGAL_CALL glCopyMultiTexSubImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCopyMultiTexSubImage3DEXT),reinterpret_cast<void (*)()>(glCopyMultiTexSubImage3DEXT),"glCopyMultiTexSubImage3DEXT");
    _driver.call(&_driver.glCopyMultiTexSubImage3DEXT)(texunit, target, level, xoffset, yoffset, zoffset, x, y, width, height);
  }

  static void REGAL_CALL glCopyTextureImage1DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCopyTextureImage1DEXT),reinterpret_cast<void (*)()>(glCopyTextureImage1DEXT),"glCopyTextureImage1DEXT");
    _driver.call(&_driver.glCopyTextureImage1DEXT)(texture, target, level, internalformat, x, y, width, border);
  }

  static void REGAL_CALL glCopyTextureImage2DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCopyTextureImage2DEXT),reinterpret_cast<void (*)()>(glCopyTextureImage2DEXT),"glCopyTextureImage2DEXT");
    _driver.call(&_driver.glCopyTextureImage2DEXT)(texture, target, level, internalformat, x, y, width, height, border);
  }

  static void REGAL_CALL glCopyTextureSubImage1DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCopyTextureSubImage1DEXT),reinterpret_cast<void (*)()>(glCopyTextureSubImage1DEXT),"glCopyTextureSubImage1DEXT");
    _driver.call(&_driver.glCopyTextureSubImage1DEXT)(texture, target, level, xoffset, x, y, width);
  }

  static void REGAL_CALL glCopyTextureSubImage2DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCopyTextureSubImage2DEXT),reinterpret_cast<void (*)()>(glCopyTextureSubImage2DEXT),"glCopyTextureSubImage2DEXT");
    _driver.call(&_driver.glCopyTextureSubImage2DEXT)(texture, target, level, xoffset, yoffset, x, y, width, height);
  }

  static void REGAL_CALL glCopyTextureSubImage3DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCopyTextureSubImage3DEXT),reinterpret_cast<void (*)()>(glCopyTextureSubImage3DEXT),"glCopyTextureSubImage3DEXT");
    _driver.call(&_driver.glCopyTextureSubImage3DEXT)(texture, target, level, xoffset, yoffset, zoffset, x, y, width, height);
  }

  static void REGAL_CALL glDisableClientStateIndexedEXT(GLenum array, GLuint index)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDisableClientStateIndexedEXT),reinterpret_cast<void (*)()>(glDisableClientStateIndexedEXT),"glDisableClientStateIndexedEXT");
    _driver.call(&_driver.glDisableClientStateIndexedEXT)(array, index);
  }

  static void REGAL_CALL glDisableClientStateiEXT(GLenum array, GLuint index)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDisableClientStateiEXT),reinterpret_cast<void (*)()>(glDisableClientStateiEXT),"glDisableClientStateiEXT");
    _driver.call(&_driver.glDisableClientStateiEXT)(array, index);
  }

  static void REGAL_CALL glDisableVertexArrayAttribEXT(GLuint vaobj, GLenum array)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDisableVertexArrayAttribEXT),reinterpret_cast<void (*)()>(glDisableVertexArrayAttribEXT),"glDisableVertexArrayAttribEXT");
    _driver.call(&_driver.glDisableVertexArrayAttribEXT)(vaobj, array);
  }

  static void REGAL_CALL glDisableVertexArrayEXT(GLuint vaobj, GLenum array)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDisableVertexArrayEXT),reinterpret_cast<void (*)()>(glDisableVertexArrayEXT),"glDisableVertexArrayEXT");
    _driver.call(&_driver.glDisableVertexArrayEXT)(vaobj, array);
  }

  static void REGAL_CALL glEnableClientStateIndexedEXT(GLenum array, GLuint index)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glEnableClientStateIndexedEXT),reinterpret_cast<void (*)()>(glEnableClientStateIndexedEXT),"glEnableClientStateIndexedEXT");
    _driver.call(&_driver.glEnableClientStateIndexedEXT)(array, index);
  }

  static void REGAL_CALL glEnableClientStateiEXT(GLenum array, GLuint index)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glEnableClientStateiEXT),reinterpret_cast<void (*)()>(glEnableClientStateiEXT),"glEnableClientStateiEXT");
    _driver.call(&_driver.glEnableClientStateiEXT)(array, index);
  }

  static void REGAL_CALL glEnableVertexArrayAttribEXT(GLuint vaobj, GLenum array)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glEnableVertexArrayAttribEXT),reinterpret_cast<void (*)()>(glEnableVertexArrayAttribEXT),"glEnableVertexArrayAttribEXT");
    _driver.call(&_driver.glEnableVertexArrayAttribEXT)(vaobj, array);
  }

  static void REGAL_CALL glEnableVertexArrayEXT(GLuint vaobj, GLenum array)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glEnableVertexArrayEXT),reinterpret_cast<void (*)()>(glEnableVertexArrayEXT),"glEnableVertexArrayEXT");
    _driver.call(&_driver.glEnableVertexArrayEXT)(vaobj, array);
  }

  static void REGAL_CALL glFlushMappedNamedBufferRangeEXT(GLuint buffer, GLintptr offset, GLsizeiptr length)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFlushMappedNamedBufferRangeEXT),reinterpret_cast<void (*)()>(glFlushMappedNamedBufferRangeEXT),"glFlushMappedNamedBufferRangeEXT");
    _driver.call(&_driver.glFlushMappedNamedBufferRangeEXT)(buffer, offset, length);
  }

  static void REGAL_CALL glFramebufferDrawBufferEXT(GLuint framebuffer, GLenum mode)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFramebufferDrawBufferEXT),reinterpret_cast<void (*)()>(glFramebufferDrawBufferEXT),"glFramebufferDrawBufferEXT");
    _driver.call(&_driver.glFramebufferDrawBufferEXT)(framebuffer, mode);
  }

  static void REGAL_CALL glFramebufferDrawBuffersEXT(GLuint framebuffer, GLsizei n, const GLenum *bufs)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFramebufferDrawBuffersEXT),reinterpret_cast<void (*)()>(glFramebufferDrawBuffersEXT),"glFramebufferDrawBuffersEXT");
    _driver.call(&_driver.glFramebufferDrawBuffersEXT)(framebuffer, n, bufs);
  }

  static void REGAL_CALL glFramebufferReadBufferEXT(GLuint framebuffer, GLenum mode)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFramebufferReadBufferEXT),reinterpret_cast<void (*)()>(glFramebufferReadBufferEXT),"glFramebufferReadBufferEXT");
    _driver.call(&_driver.glFramebufferReadBufferEXT)(framebuffer, mode);
  }

  static void REGAL_CALL glGenerateMultiTexMipmapEXT(GLenum texunit, GLenum target)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGenerateMultiTexMipmapEXT),reinterpret_cast<void (*)()>(glGenerateMultiTexMipmapEXT),"glGenerateMultiTexMipmapEXT");
    _driver.call(&_driver.glGenerateMultiTexMipmapEXT)(texunit, target);
  }

  static void REGAL_CALL glGenerateTextureMipmapEXT(GLuint texture, GLenum target)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGenerateTextureMipmapEXT),reinterpret_cast<void (*)()>(glGenerateTextureMipmapEXT),"glGenerateTextureMipmapEXT");
    _driver.call(&_driver.glGenerateTextureMipmapEXT)(texture, target);
  }

  static void REGAL_CALL glGetCompressedMultiTexImageEXT(GLenum texunit, GLenum target, GLint lod, GLvoid *img)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetCompressedMultiTexImageEXT),reinterpret_cast<void (*)()>(glGetCompressedMultiTexImageEXT),"glGetCompressedMultiTexImageEXT");
    _driver.call(&_driver.glGetCompressedMultiTexImageEXT)(texunit, target, lod, img);
  }

  static void REGAL_CALL glGetCompressedTextureImageEXT(GLuint texture, GLenum target, GLint lod, GLvoid *img)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetCompressedTextureImageEXT),reinterpret_cast<void (*)()>(glGetCompressedTextureImageEXT),"glGetCompressedTextureImageEXT");
    _driver.call(&_driver.glGetCompressedTextureImageEXT)(texture, target, lod, img);
  }

  static void REGAL_CALL glGetDoubleIndexedvEXT(GLenum target, GLuint index, GLdouble *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetDoubleIndexedvEXT),reinterpret_cast<void (*)()>(glGetDoubleIndexedvEXT),"glGetDoubleIndexedvEXT");
    _driver.call(&_driver.glGetDoubleIndexedvEXT)(target, index, data);
  }

  static void REGAL_CALL glGetDoublei_vEXT(GLenum target, GLuint index, GLdouble *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetDoublei_vEXT),reinterpret_cast<void (*)()>(glGetDoublei_vEXT),"glGetDoublei_vEXT");
    _driver.call(&_driver.glGetDoublei_vEXT)(target, index, data);
  }

  static void REGAL_CALL glGetFloatIndexedvEXT(GLenum target, GLuint index, GLfloat *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetFloatIndexedvEXT),reinterpret_cast<void (*)()>(glGetFloatIndexedvEXT),"glGetFloatIndexedvEXT");
    _driver.call(&_driver.glGetFloatIndexedvEXT)(target, index, data);
  }

  static void REGAL_CALL glGetFloati_vEXT(GLenum target, GLuint index, GLfloat *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetFloati_vEXT),reinterpret_cast<void (*)()>(glGetFloati_vEXT),"glGetFloati_vEXT");
    _driver.call(&_driver.glGetFloati_vEXT)(target, index, data);
  }

  static void REGAL_CALL glGetFramebufferParameterivEXT(GLuint framebuffer, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetFramebufferParameterivEXT),reinterpret_cast<void (*)()>(glGetFramebufferParameterivEXT),"glGetFramebufferParameterivEXT");
    _driver.call(&_driver.glGetFramebufferParameterivEXT)(framebuffer, pname, params);
  }

  static void REGAL_CALL glGetMultiTexEnvfvEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetMultiTexEnvfvEXT),reinterpret_cast<void (*)()>(glGetMultiTexEnvfvEXT),"glGetMultiTexEnvfvEXT");
    _driver.call(&_driver.glGetMultiTexEnvfvEXT)(texunit, target, pname, params);
  }

  static void REGAL_CALL glGetMultiTexEnvivEXT(GLenum texunit, GLenum target, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetMultiTexEnvivEXT),reinterpret_cast<void (*)()>(glGetMultiTexEnvivEXT),"glGetMultiTexEnvivEXT");
    _driver.call(&_driver.glGetMultiTexEnvivEXT)(texunit, target, pname, params);
  }

  static void REGAL_CALL glGetMultiTexGendvEXT(GLenum texunit, GLenum coord, GLenum pname, GLdouble *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetMultiTexGendvEXT),reinterpret_cast<void (*)()>(glGetMultiTexGendvEXT),"glGetMultiTexGendvEXT");
    _driver.call(&_driver.glGetMultiTexGendvEXT)(texunit, coord, pname, params);
  }

  static void REGAL_CALL glGetMultiTexGenfvEXT(GLenum texunit, GLenum coord, GLenum pname, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetMultiTexGenfvEXT),reinterpret_cast<void (*)()>(glGetMultiTexGenfvEXT),"glGetMultiTexGenfvEXT");
    _driver.call(&_driver.glGetMultiTexGenfvEXT)(texunit, coord, pname, params);
  }

  static void REGAL_CALL glGetMultiTexGenivEXT(GLenum texunit, GLenum coord, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetMultiTexGenivEXT),reinterpret_cast<void (*)()>(glGetMultiTexGenivEXT),"glGetMultiTexGenivEXT");
    _driver.call(&_driver.glGetMultiTexGenivEXT)(texunit, coord, pname, params);
  }

  static void REGAL_CALL glGetMultiTexImageEXT(GLenum texunit, GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetMultiTexImageEXT),reinterpret_cast<void (*)()>(glGetMultiTexImageEXT),"glGetMultiTexImageEXT");
    _driver.call(&_driver.glGetMultiTexImageEXT)(texunit, target, level, format, type, pixels);
  }

  static void REGAL_CALL glGetMultiTexLevelParameterfvEXT(GLenum texunit, GLenum target, GLint level, GLenum pname, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetMultiTexLevelParameterfvEXT),reinterpret_cast<void (*)()>(glGetMultiTexLevelParameterfvEXT),"glGetMultiTexLevelParameterfvEXT");
    _driver.call(&_driver.glGetMultiTexLevelParameterfvEXT)(texunit, target, level, pname, params);
  }

  static void REGAL_CALL glGetMultiTexLevelParameterivEXT(GLenum texunit, GLenum target, GLint level, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetMultiTexLevelParameterivEXT),reinterpret_cast<void (*)()>(glGetMultiTexLevelParameterivEXT),"glGetMultiTexLevelParameterivEXT");
    _driver.call(&_driver.glGetMultiTexLevelParameterivEXT)(texunit, target, level, pname, params);
  }

  static void REGAL_CALL glGetMultiTexParameterIivEXT(GLenum texunit, GLenum target, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetMultiTexParameterIivEXT),reinterpret_cast<void (*)()>(glGetMultiTexParameterIivEXT),"glGetMultiTexParameterIivEXT");
    _driver.call(&_driver.glGetMultiTexParameterIivEXT)(texunit, target, pname, params);
  }

  static void REGAL_CALL glGetMultiTexParameterIuivEXT(GLenum texunit, GLenum target, GLenum pname, GLuint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetMultiTexParameterIuivEXT),reinterpret_cast<void (*)()>(glGetMultiTexParameterIuivEXT),"glGetMultiTexParameterIuivEXT");
    _driver.call(&_driver.glGetMultiTexParameterIuivEXT)(texunit, target, pname, params);
  }

  static void REGAL_CALL glGetMultiTexParameterfvEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetMultiTexParameterfvEXT),reinterpret_cast<void (*)()>(glGetMultiTexParameterfvEXT),"glGetMultiTexParameterfvEXT");
    _driver.call(&_driver.glGetMultiTexParameterfvEXT)(texunit, target, pname, params);
  }

  static void REGAL_CALL glGetMultiTexParameterivEXT(GLenum texunit, GLenum target, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetMultiTexParameterivEXT),reinterpret_cast<void (*)()>(glGetMultiTexParameterivEXT),"glGetMultiTexParameterivEXT");
    _driver.call(&_driver.glGetMultiTexParameterivEXT)(texunit, target, pname, params);
  }

  static void REGAL_CALL glGetNamedBufferParameterivEXT(GLuint buffer, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetNamedBufferParameterivEXT),reinterpret_cast<void (*)()>(glGetNamedBufferParameterivEXT),"glGetNamedBufferParameterivEXT");
    _driver.call(&_driver.glGetNamedBufferParameterivEXT)(buffer, pname, params);
  }

  static void REGAL_CALL glGetNamedBufferPointervEXT(GLuint buffer, GLenum pname, GLvoid **params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetNamedBufferPointervEXT),reinterpret_cast<void (*)()>(glGetNamedBufferPointervEXT),"glGetNamedBufferPointervEXT");
    _driver.call(&_driver.glGetNamedBufferPointervEXT)(buffer, pname, params);
  }

  static void REGAL_CALL glGetNamedBufferSubDataEXT(GLuint buffer, GLintptr offset, GLsizeiptr size, GLvoid *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetNamedBufferSubDataEXT),reinterpret_cast<void (*)()>(glGetNamedBufferSubDataEXT),"glGetNamedBufferSubDataEXT");
    _driver.call(&_driver.glGetNamedBufferSubDataEXT)(buffer, offset, size, data);
  }

  static void REGAL_CALL glGetNamedFramebufferAttachmentParameterivEXT(GLuint framebuffer, GLenum attachment, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetNamedFramebufferAttachmentParameterivEXT),reinterpret_cast<void (*)()>(glGetNamedFramebufferAttachmentParameterivEXT),"glGetNamedFramebufferAttachmentParameterivEXT");
    _driver.call(&_driver.glGetNamedFramebufferAttachmentParameterivEXT)(framebuffer, attachment, pname, params);
  }

  static void REGAL_CALL glGetNamedProgramLocalParameterIivEXT(GLuint program, GLenum target, GLuint index, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetNamedProgramLocalParameterIivEXT),reinterpret_cast<void (*)()>(glGetNamedProgramLocalParameterIivEXT),"glGetNamedProgramLocalParameterIivEXT");
    _driver.call(&_driver.glGetNamedProgramLocalParameterIivEXT)(program, target, index, params);
  }

  static void REGAL_CALL glGetNamedProgramLocalParameterIuivEXT(GLuint program, GLenum target, GLuint index, GLuint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetNamedProgramLocalParameterIuivEXT),reinterpret_cast<void (*)()>(glGetNamedProgramLocalParameterIuivEXT),"glGetNamedProgramLocalParameterIuivEXT");
    _driver.call(&_driver.glGetNamedProgramLocalParameterIuivEXT)(program, target, index, params);
  }

  static void REGAL_CALL glGetNamedProgramLocalParameterdvEXT(GLuint program, GLenum target, GLuint index, GLdouble *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetNamedProgramLocalParameterdvEXT),reinterpret_cast<void (*)()>(glGetNamedProgramLocalParameterdvEXT),"glGetNamedProgramLocalParameterdvEXT");
    _driver.call(&_driver.glGetNamedProgramLocalParameterdvEXT)(program, target, index, params);
  }

  static void REGAL_CALL glGetNamedProgramLocalParameterfvEXT(GLuint program, GLenum target, GLuint index, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetNamedProgramLocalParameterfvEXT),reinterpret_cast<void (*)()>(glGetNamedProgramLocalParameterfvEXT),"glGetNamedProgramLocalParameterfvEXT");
    _driver.call(&_driver.glGetNamedProgramLocalParameterfvEXT)(program, target, index, params);
  }

  static void REGAL_CALL glGetNamedProgramStringEXT(GLuint program, GLenum target, GLenum pname, GLvoid *string)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetNamedProgramStringEXT),reinterpret_cast<void (*)()>(glGetNamedProgramStringEXT),"glGetNamedProgramStringEXT");
    _driver.call(&_driver.glGetNamedProgramStringEXT)(program, target, pname, string);
  }

  static void REGAL_CALL glGetNamedProgramivEXT(GLuint program, GLenum target, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetNamedProgramivEXT),reinterpret_cast<void (*)()>(glGetNamedProgramivEXT),"glGetNamedProgramivEXT");
    _driver.call(&_driver.glGetNamedProgramivEXT)(program, target, pname, params);
  }

  static void REGAL_CALL glGetNamedRenderbufferParameterivEXT(GLuint renderbuffer, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetNamedRenderbufferParameterivEXT),reinterpret_cast<void (*)()>(glGetNamedRenderbufferParameterivEXT),"glGetNamedRenderbufferParameterivEXT");
    _driver.call(&_driver.glGetNamedRenderbufferParameterivEXT)(renderbuffer, pname, params);
  }

  static void REGAL_CALL glGetPointerIndexedvEXT(GLenum target, GLuint index, GLvoid **data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetPointerIndexedvEXT),reinterpret_cast<void (*)()>(glGetPointerIndexedvEXT),"glGetPointerIndexedvEXT");
    _driver.call(&_driver.glGetPointerIndexedvEXT)(target, index, data);
  }

  static void REGAL_CALL glGetPointeri_vEXT(GLenum pname, GLuint index, GLvoid **params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetPointeri_vEXT),reinterpret_cast<void (*)()>(glGetPointeri_vEXT),"glGetPointeri_vEXT");
    _driver.call(&_driver.glGetPointeri_vEXT)(pname, index, params);
  }

  static void REGAL_CALL glGetTextureImageEXT(GLuint texture, GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetTextureImageEXT),reinterpret_cast<void (*)()>(glGetTextureImageEXT),"glGetTextureImageEXT");
    _driver.call(&_driver.glGetTextureImageEXT)(texture, target, level, format, type, pixels);
  }

  static void REGAL_CALL glGetTextureLevelParameterfvEXT(GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetTextureLevelParameterfvEXT),reinterpret_cast<void (*)()>(glGetTextureLevelParameterfvEXT),"glGetTextureLevelParameterfvEXT");
    _driver.call(&_driver.glGetTextureLevelParameterfvEXT)(texture, target, level, pname, params);
  }

  static void REGAL_CALL glGetTextureLevelParameterivEXT(GLuint texture, GLenum target, GLint level, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetTextureLevelParameterivEXT),reinterpret_cast<void (*)()>(glGetTextureLevelParameterivEXT),"glGetTextureLevelParameterivEXT");
    _driver.call(&_driver.glGetTextureLevelParameterivEXT)(texture, target, level, pname, params);
  }

  static void REGAL_CALL glGetTextureParameterIivEXT(GLuint texture, GLenum target, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetTextureParameterIivEXT),reinterpret_cast<void (*)()>(glGetTextureParameterIivEXT),"glGetTextureParameterIivEXT");
    _driver.call(&_driver.glGetTextureParameterIivEXT)(texture, target, pname, params);
  }

  static void REGAL_CALL glGetTextureParameterIuivEXT(GLuint texture, GLenum target, GLenum pname, GLuint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetTextureParameterIuivEXT),reinterpret_cast<void (*)()>(glGetTextureParameterIuivEXT),"glGetTextureParameterIuivEXT");
    _driver.call(&_driver.glGetTextureParameterIuivEXT)(texture, target, pname, params);
  }

  static void REGAL_CALL glGetTextureParameterfvEXT(GLuint texture, GLenum target, GLenum pname, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetTextureParameterfvEXT),reinterpret_cast<void (*)()>(glGetTextureParameterfvEXT),"glGetTextureParameterfvEXT");
    _driver.call(&_driver.glGetTextureParameterfvEXT)(texture, target, pname, params);
  }

  static void REGAL_CALL glGetTextureParameterivEXT(GLuint texture, GLenum target, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetTextureParameterivEXT),reinterpret_cast<void (*)()>(glGetTextureParameterivEXT),"glGetTextureParameterivEXT");
    _driver.call(&_driver.glGetTextureParameterivEXT)(texture, target, pname, params);
  }

  static void REGAL_CALL glGetVertexArrayIntegeri_vEXT(GLuint vaobj, GLuint index, GLenum pname, GLint *param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetVertexArrayIntegeri_vEXT),reinterpret_cast<void (*)()>(glGetVertexArrayIntegeri_vEXT),"glGetVertexArrayIntegeri_vEXT");
    _driver.call(&_driver.glGetVertexArrayIntegeri_vEXT)(vaobj, index, pname, param);
  }

  static void REGAL_CALL glGetVertexArrayIntegervEXT(GLuint vaobj, GLenum pname, GLint *param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetVertexArrayIntegervEXT),reinterpret_cast<void (*)()>(glGetVertexArrayIntegervEXT),"glGetVertexArrayIntegervEXT");
    _driver.call(&_driver.glGetVertexArrayIntegervEXT)(vaobj, pname, param);
  }

  static void REGAL_CALL glGetVertexArrayPointeri_vEXT(GLuint vaobj, GLuint index, GLenum pname, GLvoid **param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetVertexArrayPointeri_vEXT),reinterpret_cast<void (*)()>(glGetVertexArrayPointeri_vEXT),"glGetVertexArrayPointeri_vEXT");
    _driver.call(&_driver.glGetVertexArrayPointeri_vEXT)(vaobj, index, pname, param);
  }

  static void REGAL_CALL glGetVertexArrayPointervEXT(GLuint vaobj, GLenum pname, GLvoid **param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetVertexArrayPointervEXT),reinterpret_cast<void (*)()>(glGetVertexArrayPointervEXT),"glGetVertexArrayPointervEXT");
    _driver.call(&_driver.glGetVertexArrayPointervEXT)(vaobj, pname, param);
  }

  static GLvoid *REGAL_CALL glMapNamedBufferEXT(GLuint buffer, GLenum access)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMapNamedBufferEXT),reinterpret_cast<void (*)()>(glMapNamedBufferEXT),"glMapNamedBufferEXT");
    return _driver.call(&_driver.glMapNamedBufferEXT)(buffer, access);
  }

  static GLvoid *REGAL_CALL glMapNamedBufferRangeEXT(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMapNamedBufferRangeEXT),reinterpret_cast<void (*)()>(glMapNamedBufferRangeEXT),"glMapNamedBufferRangeEXT");
    return _driver.call(&_driver.glMapNamedBufferRangeEXT)(buffer, offset, length, access);
  }

  static void REGAL_CALL glMatrixFrustumEXT(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMatrixFrustumEXT),reinterpret_cast<void (*)()>(glMatrixFrustumEXT),"glMatrixFrustumEXT");
    _driver.call(&_driver.glMatrixFrustumEXT)(mode, left, right, bottom, top, zNear, zFar);
  }

  static void REGAL_CALL glMatrixLoadIdentityEXT(GLenum mode)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMatrixLoadIdentityEXT),reinterpret_cast<void (*)()>(glMatrixLoadIdentityEXT),"glMatrixLoadIdentityEXT");
    _driver.call(&_driver.glMatrixLoadIdentityEXT)(mode);
  }

  static void REGAL_CALL glMatrixLoadTransposedEXT(GLenum mode, const GLdouble *m)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMatrixLoadTransposedEXT),reinterpret_cast<void (*)()>(glMatrixLoadTransposedEXT),"glMatrixLoadTransposedEXT");
    _driver.call(&_driver.glMatrixLoadTransposedEXT)(mode, m);
  }

  static void REGAL_CALL glMatrixLoadTransposefEXT(GLenum mode, const GLfloat *m)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMatrixLoadTransposefEXT),reinterpret_cast<void (*)()>(glMatrixLoadTransposefEXT),"glMatrixLoadTransposefEXT");
    _driver.call(&_driver.glMatrixLoadTransposefEXT)(mode, m);
  }

  static void REGAL_CALL glMatrixLoaddEXT(GLenum mode, const GLdouble *m)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMatrixLoaddEXT),reinterpret_cast<void (*)()>(glMatrixLoaddEXT),"glMatrixLoaddEXT");
    _driver.call(&_driver.glMatrixLoaddEXT)(mode, m);
  }

  static void REGAL_CALL glMatrixLoadfEXT(GLenum mode, const GLfloat *m)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMatrixLoadfEXT),reinterpret_cast<void (*)()>(glMatrixLoadfEXT),"glMatrixLoadfEXT");
    _driver.call(&_driver.glMatrixLoadfEXT)(mode, m);
  }

  static void REGAL_CALL glMatrixMultTransposedEXT(GLenum mode, const GLdouble *m)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMatrixMultTransposedEXT),reinterpret_cast<void (*)()>(glMatrixMultTransposedEXT),"glMatrixMultTransposedEXT");
    _driver.call(&_driver.glMatrixMultTransposedEXT)(mode, m);
  }

  static void REGAL_CALL glMatrixMultTransposefEXT(GLenum mode, const GLfloat *m)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMatrixMultTransposefEXT),reinterpret_cast<void (*)()>(glMatrixMultTransposefEXT),"glMatrixMultTransposefEXT");
    _driver.call(&_driver.glMatrixMultTransposefEXT)(mode, m);
  }

  static void REGAL_CALL glMatrixMultdEXT(GLenum mode, const GLdouble *m)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMatrixMultdEXT),reinterpret_cast<void (*)()>(glMatrixMultdEXT),"glMatrixMultdEXT");
    _driver.call(&_driver.glMatrixMultdEXT)(mode, m);
  }

  static void REGAL_CALL glMatrixMultfEXT(GLenum mode, const GLfloat *m)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMatrixMultfEXT),reinterpret_cast<void (*)()>(glMatrixMultfEXT),"glMatrixMultfEXT");
    _driver.call(&_driver.glMatrixMultfEXT)(mode, m);
  }

  static void REGAL_CALL glMatrixOrthoEXT(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMatrixOrthoEXT),reinterpret_cast<void (*)()>(glMatrixOrthoEXT),"glMatrixOrthoEXT");
    _driver.call(&_driver.glMatrixOrthoEXT)(mode, left, right, bottom, top, zNear, zFar);
  }

  static void REGAL_CALL glMatrixPopEXT(GLenum mode)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMatrixPopEXT),reinterpret_cast<void (*)()>(glMatrixPopEXT),"glMatrixPopEXT");
    _driver.call(&_driver.glMatrixPopEXT)(mode);
  }

  static void REGAL_CALL glMatrixPushEXT(GLenum mode)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMatrixPushEXT),reinterpret_cast<void (*)()>(glMatrixPushEXT),"glMatrixPushEXT");
    _driver.call(&_driver.glMatrixPushEXT)(mode);
  }

  static void REGAL_CALL glMatrixRotatedEXT(GLenum mode, GLdouble angle, GLdouble x, GLdouble y, GLdouble z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMatrixRotatedEXT),reinterpret_cast<void (*)()>(glMatrixRotatedEXT),"glMatrixRotatedEXT");
    _driver.call(&_driver.glMatrixRotatedEXT)(mode, angle, x, y, z);
  }

  static void REGAL_CALL glMatrixRotatefEXT(GLenum mode, GLfloat angle, GLfloat x, GLfloat y, GLfloat z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMatrixRotatefEXT),reinterpret_cast<void (*)()>(glMatrixRotatefEXT),"glMatrixRotatefEXT");
    _driver.call(&_driver.glMatrixRotatefEXT)(mode, angle, x, y, z);
  }

  static void REGAL_CALL glMatrixScaledEXT(GLenum mode, GLdouble x, GLdouble y, GLdouble z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMatrixScaledEXT),reinterpret_cast<void (*)()>(glMatrixScaledEXT),"glMatrixScaledEXT");
    _driver.call(&_driver.glMatrixScaledEXT)(mode, x, y, z);
  }

  static void REGAL_CALL glMatrixScalefEXT(GLenum mode, GLfloat x, GLfloat y, GLfloat z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMatrixScalefEXT),reinterpret_cast<void (*)()>(glMatrixScalefEXT),"glMatrixScalefEXT");
    _driver.call(&_driver.glMatrixScalefEXT)(mode, x, y, z);
  }

  static void REGAL_CALL glMatrixTranslatedEXT(GLenum mode, GLdouble x, GLdouble y, GLdouble z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMatrixTranslatedEXT),reinterpret_cast<void (*)()>(glMatrixTranslatedEXT),"glMatrixTranslatedEXT");
    _driver.call(&_driver.glMatrixTranslatedEXT)(mode, x, y, z);
  }

  static void REGAL_CALL glMatrixTranslatefEXT(GLenum mode, GLfloat x, GLfloat y, GLfloat z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMatrixTranslatefEXT),reinterpret_cast<void (*)()>(glMatrixTranslatefEXT),"glMatrixTranslatefEXT");
    _driver.call(&_driver.glMatrixTranslatefEXT)(mode, x, y, z);
  }

  static void REGAL_CALL glMultiTexBufferEXT(GLenum texunit, GLenum target, GLenum internalformat, GLuint buffer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexBufferEXT),reinterpret_cast<void (*)()>(glMultiTexBufferEXT),"glMultiTexBufferEXT");
    _driver.call(&_driver.glMultiTexBufferEXT)(texunit, target, internalformat, buffer);
  }

  static void REGAL_CALL glMultiTexCoordPointerEXT(GLenum texunit, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoordPointerEXT),reinterpret_cast<void (*)()>(glMultiTexCoordPointerEXT),"glMultiTexCoordPointerEXT");
    _driver.call(&_driver.glMultiTexCoordPointerEXT)(texunit, size, type, stride, pointer);
  }

  static void REGAL_CALL glMultiTexEnvfEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexEnvfEXT),reinterpret_cast<void (*)()>(glMultiTexEnvfEXT),"glMultiTexEnvfEXT");
    _driver.call(&_driver.glMultiTexEnvfEXT)(texunit, target, pname, param);
  }

  static void REGAL_CALL glMultiTexEnvfvEXT(GLenum texunit, GLenum target, GLenum pname, const GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexEnvfvEXT),reinterpret_cast<void (*)()>(glMultiTexEnvfvEXT),"glMultiTexEnvfvEXT");
    _driver.call(&_driver.glMultiTexEnvfvEXT)(texunit, target, pname, params);
  }

  static void REGAL_CALL glMultiTexEnviEXT(GLenum texunit, GLenum target, GLenum pname, GLint param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexEnviEXT),reinterpret_cast<void (*)()>(glMultiTexEnviEXT),"glMultiTexEnviEXT");
    _driver.call(&_driver.glMultiTexEnviEXT)(texunit, target, pname, param);
  }

  static void REGAL_CALL glMultiTexEnvivEXT(GLenum texunit, GLenum target, GLenum pname, const GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexEnvivEXT),reinterpret_cast<void (*)()>(glMultiTexEnvivEXT),"glMultiTexEnvivEXT");
    _driver.call(&_driver.glMultiTexEnvivEXT)(texunit, target, pname, params);
  }

  static void REGAL_CALL glMultiTexGendEXT(GLenum texunit, GLenum coord, GLenum pname, GLdouble param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexGendEXT),reinterpret_cast<void (*)()>(glMultiTexGendEXT),"glMultiTexGendEXT");
    _driver.call(&_driver.glMultiTexGendEXT)(texunit, coord, pname, param);
  }

  static void REGAL_CALL glMultiTexGendvEXT(GLenum texunit, GLenum coord, GLenum pname, const GLdouble *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexGendvEXT),reinterpret_cast<void (*)()>(glMultiTexGendvEXT),"glMultiTexGendvEXT");
    _driver.call(&_driver.glMultiTexGendvEXT)(texunit, coord, pname, params);
  }

  static void REGAL_CALL glMultiTexGenfEXT(GLenum texunit, GLenum coord, GLenum pname, GLfloat param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexGenfEXT),reinterpret_cast<void (*)()>(glMultiTexGenfEXT),"glMultiTexGenfEXT");
    _driver.call(&_driver.glMultiTexGenfEXT)(texunit, coord, pname, param);
  }

  static void REGAL_CALL glMultiTexGenfvEXT(GLenum texunit, GLenum coord, GLenum pname, const GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexGenfvEXT),reinterpret_cast<void (*)()>(glMultiTexGenfvEXT),"glMultiTexGenfvEXT");
    _driver.call(&_driver.glMultiTexGenfvEXT)(texunit, coord, pname, params);
  }

  static void REGAL_CALL glMultiTexGeniEXT(GLenum texunit, GLenum coord, GLenum pname, GLint param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexGeniEXT),reinterpret_cast<void (*)()>(glMultiTexGeniEXT),"glMultiTexGeniEXT");
    _driver.call(&_driver.glMultiTexGeniEXT)(texunit, coord, pname, param);
  }

  static void REGAL_CALL glMultiTexGenivEXT(GLenum texunit, GLenum coord, GLenum pname, const GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexGenivEXT),reinterpret_cast<void (*)()>(glMultiTexGenivEXT),"glMultiTexGenivEXT");
    _driver.call(&_driver.glMultiTexGenivEXT)(texunit, coord, pname, params);
  }

  static void REGAL_CALL glMultiTexImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexImage1DEXT),reinterpret_cast<void (*)()>(glMultiTexImage1DEXT),"glMultiTexImage1DEXT");
    _driver.call(&_driver.glMultiTexImage1DEXT)(texunit, target, level, internalformat, width, border, format, type, pixels);
  }

  static void REGAL_CALL glMultiTexImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexImage2DEXT),reinterpret_cast<void (*)()>(glMultiTexImage2DEXT),"glMultiTexImage2DEXT");
    _driver.call(&_driver.glMultiTexImage2DEXT)(texunit, target, level, internalformat, width, height, border, format, type, pixels);
  }

  static void REGAL_CALL glMultiTexImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexImage3DEXT),reinterpret_cast<void (*)()>(glMultiTexImage3DEXT),"glMultiTexImage3DEXT");
    _driver.call(&_driver.glMultiTexImage3DEXT)(texunit, target, level, internalformat, width, height, depth, border, format, type, pixels);
  }

  static void REGAL_CALL glMultiTexParameterIivEXT(GLenum texunit, GLenum target, GLenum pname, const GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexParameterIivEXT),reinterpret_cast<void (*)()>(glMultiTexParameterIivEXT),"glMultiTexParameterIivEXT");
    _driver.call(&_driver.glMultiTexParameterIivEXT)(texunit, target, pname, params);
  }

  static void REGAL_CALL glMultiTexParameterIuivEXT(GLenum texunit, GLenum target, GLenum pname, const GLuint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexParameterIuivEXT),reinterpret_cast<void (*)()>(glMultiTexParameterIuivEXT),"glMultiTexParameterIuivEXT");
    _driver.call(&_driver.glMultiTexParameterIuivEXT)(texunit, target, pname, params);
  }

  static void REGAL_CALL glMultiTexParameterfEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexParameterfEXT),reinterpret_cast<void (*)()>(glMultiTexParameterfEXT),"glMultiTexParameterfEXT");
    _driver.call(&_driver.glMultiTexParameterfEXT)(texunit, target, pname, param);
  }

  static void REGAL_CALL glMultiTexParameterfvEXT(GLenum texunit, GLenum target, GLenum pname, const GLfloat *param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexParameterfvEXT),reinterpret_cast<void (*)()>(glMultiTexParameterfvEXT),"glMultiTexParameterfvEXT");
    _driver.call(&_driver.glMultiTexParameterfvEXT)(texunit, target, pname, param);
  }

  static void REGAL_CALL glMultiTexParameteriEXT(GLenum texunit, GLenum target, GLenum pname, GLint param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexParameteriEXT),reinterpret_cast<void (*)()>(glMultiTexParameteriEXT),"glMultiTexParameteriEXT");
    _driver.call(&_driver.glMultiTexParameteriEXT)(texunit, target, pname, param);
  }

  static void REGAL_CALL glMultiTexParameterivEXT(GLenum texunit, GLenum target, GLenum pname, const GLint *param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexParameterivEXT),reinterpret_cast<void (*)()>(glMultiTexParameterivEXT),"glMultiTexParameterivEXT");
    _driver.call(&_driver.glMultiTexParameterivEXT)(texunit, target, pname, param);
  }

  static void REGAL_CALL glMultiTexRenderbufferEXT(GLenum texunit, GLenum target, GLuint renderbuffer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexRenderbufferEXT),reinterpret_cast<void (*)()>(glMultiTexRenderbufferEXT),"glMultiTexRenderbufferEXT");
    _driver.call(&_driver.glMultiTexRenderbufferEXT)(texunit, target, renderbuffer);
  }

  static void REGAL_CALL glMultiTexSubImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexSubImage1DEXT),reinterpret_cast<void (*)()>(glMultiTexSubImage1DEXT),"glMultiTexSubImage1DEXT");
    _driver.call(&_driver.glMultiTexSubImage1DEXT)(texunit, target, level, xoffset, width, format, type, pixels);
  }

  static void REGAL_CALL glMultiTexSubImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexSubImage2DEXT),reinterpret_cast<void (*)()>(glMultiTexSubImage2DEXT),"glMultiTexSubImage2DEXT");
    _driver.call(&_driver.glMultiTexSubImage2DEXT)(texunit, target, level, xoffset, yoffset, width, height, format, type, pixels);
  }

  static void REGAL_CALL glMultiTexSubImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexSubImage3DEXT),reinterpret_cast<void (*)()>(glMultiTexSubImage3DEXT),"glMultiTexSubImage3DEXT");
    _driver.call(&_driver.glMultiTexSubImage3DEXT)(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
  }

  static void REGAL_CALL glNamedBufferDataEXT(GLuint buffer, GLsizeiptr size, const GLvoid *data, GLenum usage)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNamedBufferDataEXT),reinterpret_cast<void (*)()>(glNamedBufferDataEXT),"glNamedBufferDataEXT");
    _driver.call(&_driver.glNamedBufferDataEXT)(buffer, size, data, usage);
  }

  static void REGAL_CALL glNamedBufferSubDataEXT(GLuint buffer, GLintptr offset, GLsizeiptr size, const GLvoid *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNamedBufferSubDataEXT),reinterpret_cast<void (*)()>(glNamedBufferSubDataEXT),"glNamedBufferSubDataEXT");
    _driver.call(&_driver.glNamedBufferSubDataEXT)(buffer, offset, size, data);
  }

  static void REGAL_CALL glNamedCopyBufferSubDataEXT(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNamedCopyBufferSubDataEXT),reinterpret_cast<void (*)()>(glNamedCopyBufferSubDataEXT),"glNamedCopyBufferSubDataEXT");
    _driver.call(&_driver.glNamedCopyBufferSubDataEXT)(readBuffer, writeBuffer, readOffset, writeOffset, size);
  }

  static void REGAL_CALL glNamedFramebufferRenderbufferEXT(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNamedFramebufferRenderbufferEXT),reinterpret_cast<void (*)()>(glNamedFramebufferRenderbufferEXT),"glNamedFramebufferRenderbufferEXT");
    _driver.call(&_driver.glNamedFramebufferRenderbufferEXT)(framebuffer, attachment, renderbuffertarget, renderbuffer);
  }

  static void REGAL_CALL glNamedFramebufferTexture1DEXT(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNamedFramebufferTexture1DEXT),reinterpret_cast<void (*)()>(glNamedFramebufferTexture1DEXT),"glNamedFramebufferTexture1DEXT");
    _driver.call(&_driver.glNamedFramebufferTexture1DEXT)(framebuffer, attachment, textarget, texture, level);
  }

  static void REGAL_CALL glNamedFramebufferTexture2DEXT(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNamedFramebufferTexture2DEXT),reinterpret_cast<void (*)()>(glNamedFramebufferTexture2DEXT),"glNamedFramebufferTexture2DEXT");
    _driver.call(&_driver.glNamedFramebufferTexture2DEXT)(framebuffer, attachment, textarget, texture, level);
  }

  static void REGAL_CALL glNamedFramebufferTexture3DEXT(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNamedFramebufferTexture3DEXT),reinterpret_cast<void (*)()>(glNamedFramebufferTexture3DEXT),"glNamedFramebufferTexture3DEXT");
    _driver.call(&_driver.glNamedFramebufferTexture3DEXT)(framebuffer, attachment, textarget, texture, level, zoffset);
  }

  static void REGAL_CALL glNamedFramebufferTextureEXT(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNamedFramebufferTextureEXT),reinterpret_cast<void (*)()>(glNamedFramebufferTextureEXT),"glNamedFramebufferTextureEXT");
    _driver.call(&_driver.glNamedFramebufferTextureEXT)(framebuffer, attachment, texture, level);
  }

  static void REGAL_CALL glNamedFramebufferTextureFaceEXT(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLenum face)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNamedFramebufferTextureFaceEXT),reinterpret_cast<void (*)()>(glNamedFramebufferTextureFaceEXT),"glNamedFramebufferTextureFaceEXT");
    _driver.call(&_driver.glNamedFramebufferTextureFaceEXT)(framebuffer, attachment, texture, level, face);
  }

  static void REGAL_CALL glNamedFramebufferTextureLayerEXT(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNamedFramebufferTextureLayerEXT),reinterpret_cast<void (*)()>(glNamedFramebufferTextureLayerEXT),"glNamedFramebufferTextureLayerEXT");
    _driver.call(&_driver.glNamedFramebufferTextureLayerEXT)(framebuffer, attachment, texture, level, layer);
  }

  static void REGAL_CALL glNamedProgramLocalParameter4dEXT(GLuint program, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNamedProgramLocalParameter4dEXT),reinterpret_cast<void (*)()>(glNamedProgramLocalParameter4dEXT),"glNamedProgramLocalParameter4dEXT");
    _driver.call(&_driver.glNamedProgramLocalParameter4dEXT)(program, target, index, x, y, z, w);
  }

  static void REGAL_CALL glNamedProgramLocalParameter4dvEXT(GLuint program, GLenum target, GLuint index, const GLdouble *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNamedProgramLocalParameter4dvEXT),reinterpret_cast<void (*)()>(glNamedProgramLocalParameter4dvEXT),"glNamedProgramLocalParameter4dvEXT");
    _driver.call(&_driver.glNamedProgramLocalParameter4dvEXT)(program, target, index, params);
  }

  static void REGAL_CALL glNamedProgramLocalParameter4fEXT(GLuint program, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNamedProgramLocalParameter4fEXT),reinterpret_cast<void (*)()>(glNamedProgramLocalParameter4fEXT),"glNamedProgramLocalParameter4fEXT");
    _driver.call(&_driver.glNamedProgramLocalParameter4fEXT)(program, target, index, x, y, z, w);
  }

  static void REGAL_CALL glNamedProgramLocalParameter4fvEXT(GLuint program, GLenum target, GLuint index, const GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNamedProgramLocalParameter4fvEXT),reinterpret_cast<void (*)()>(glNamedProgramLocalParameter4fvEXT),"glNamedProgramLocalParameter4fvEXT");
    _driver.call(&_driver.glNamedProgramLocalParameter4fvEXT)(program, target, index, params);
  }

  static void REGAL_CALL glNamedProgramLocalParameterI4iEXT(GLuint program, GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNamedProgramLocalParameterI4iEXT),reinterpret_cast<void (*)()>(glNamedProgramLocalParameterI4iEXT),"glNamedProgramLocalParameterI4iEXT");
    _driver.call(&_driver.glNamedProgramLocalParameterI4iEXT)(program, target, index, x, y, z, w);
  }

  static void REGAL_CALL glNamedProgramLocalParameterI4ivEXT(GLuint program, GLenum target, GLuint index, const GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNamedProgramLocalParameterI4ivEXT),reinterpret_cast<void (*)()>(glNamedProgramLocalParameterI4ivEXT),"glNamedProgramLocalParameterI4ivEXT");
    _driver.call(&_driver.glNamedProgramLocalParameterI4ivEXT)(program, target, index, params);
  }

  static void REGAL_CALL glNamedProgramLocalParameterI4uiEXT(GLuint program, GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNamedProgramLocalParameterI4uiEXT),reinterpret_cast<void (*)()>(glNamedProgramLocalParameterI4uiEXT),"glNamedProgramLocalParameterI4uiEXT");
    _driver.call(&_driver.glNamedProgramLocalParameterI4uiEXT)(program, target, index, x, y, z, w);
  }

  static void REGAL_CALL glNamedProgramLocalParameterI4uivEXT(GLuint program, GLenum target, GLuint index, const GLuint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNamedProgramLocalParameterI4uivEXT),reinterpret_cast<void (*)()>(glNamedProgramLocalParameterI4uivEXT),"glNamedProgramLocalParameterI4uivEXT");
    _driver.call(&_driver.glNamedProgramLocalParameterI4uivEXT)(program, target, index, params);
  }

  static void REGAL_CALL glNamedProgramLocalParameters4fvEXT(GLuint program, GLenum target, GLuint index, GLsizei count, const GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNamedProgramLocalParameters4fvEXT),reinterpret_cast<void (*)()>(glNamedProgramLocalParameters4fvEXT),"glNamedProgramLocalParameters4fvEXT");
    _driver.call(&_driver.glNamedProgramLocalParameters4fvEXT)(program, target, index, count, params);
  }

  static void REGAL_CALL glNamedProgramLocalParametersI4ivEXT(GLuint program, GLenum target, GLuint index, GLsizei count, const GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNamedProgramLocalParametersI4ivEXT),reinterpret_cast<void (*)()>(glNamedProgramLocalParametersI4ivEXT),"glNamedProgramLocalParametersI4ivEXT");
    _driver.call(&_driver.glNamedProgramLocalParametersI4ivEXT)(program, target, index, count, params);
  }

  static void REGAL_CALL glNamedProgramLocalParametersI4uivEXT(GLuint program, GLenum target, GLuint index, GLsizei count, const GLuint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNamedProgramLocalParametersI4uivEXT),reinterpret_cast<void (*)()>(glNamedProgramLocalParametersI4uivEXT),"glNamedProgramLocalParametersI4uivEXT");
    _driver.call(&_driver.glNamedProgramLocalParametersI4uivEXT)(program, target, index, count, params);
  }

  static void REGAL_CALL glNamedProgramStringEXT(GLuint program, GLenum target, GLenum format, GLsizei len, const GLvoid *string)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNamedProgramStringEXT),reinterpret_cast<void (*)()>(glNamedProgramStringEXT),"glNamedProgramStringEXT");
    _driver.call(&_driver.glNamedProgramStringEXT)(program, target, format, len, string);
  }

  static void REGAL_CALL glNamedRenderbufferStorageEXT(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNamedRenderbufferStorageEXT),reinterpret_cast<void (*)()>(glNamedRenderbufferStorageEXT),"glNamedRenderbufferStorageEXT");
    _driver.call(&_driver.glNamedRenderbufferStorageEXT)(renderbuffer, internalformat, width, height);
  }

  static void REGAL_CALL glNamedRenderbufferStorageMultisampleCoverageEXT(GLuint renderbuffer, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNamedRenderbufferStorageMultisampleCoverageEXT),reinterpret_cast<void (*)()>(glNamedRenderbufferStorageMultisampleCoverageEXT),"glNamedRenderbufferStorageMultisampleCoverageEXT");
    _driver.call(&_driver.glNamedRenderbufferStorageMultisampleCoverageEXT)(renderbuffer, coverageSamples, colorSamples, internalformat, width, height);
  }

  static void REGAL_CALL glNamedRenderbufferStorageMultisampleEXT(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNamedRenderbufferStorageMultisampleEXT),reinterpret_cast<void (*)()>(glNamedRenderbufferStorageMultisampleEXT),"glNamedRenderbufferStorageMultisampleEXT");
    _driver.call(&_driver.glNamedRenderbufferStorageMultisampleEXT)(renderbuffer, samples, internalformat, width, height);
  }

  static void REGAL_CALL glProgramUniform1dEXT(GLuint program, GLint location, GLdouble x)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform1dEXT),reinterpret_cast<void (*)()>(glProgramUniform1dEXT),"glProgramUniform1dEXT");
    _driver.call(&_driver.glProgramUniform1dEXT)(program, location, x);
  }

  static void REGAL_CALL glProgramUniform1dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform1dvEXT),reinterpret_cast<void (*)()>(glProgramUniform1dvEXT),"glProgramUniform1dvEXT");
    _driver.call(&_driver.glProgramUniform1dvEXT)(program, location, count, value);
  }

  static void REGAL_CALL glProgramUniform1fEXT(GLuint program, GLint location, GLfloat v0)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform1fEXT),reinterpret_cast<void (*)()>(glProgramUniform1fEXT),"glProgramUniform1fEXT");
    _driver.call(&_driver.glProgramUniform1fEXT)(program, location, v0);
  }

  static void REGAL_CALL glProgramUniform1fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform1fvEXT),reinterpret_cast<void (*)()>(glProgramUniform1fvEXT),"glProgramUniform1fvEXT");
    _driver.call(&_driver.glProgramUniform1fvEXT)(program, location, count, value);
  }

  static void REGAL_CALL glProgramUniform1iEXT(GLuint program, GLint location, GLint v0)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform1iEXT),reinterpret_cast<void (*)()>(glProgramUniform1iEXT),"glProgramUniform1iEXT");
    _driver.call(&_driver.glProgramUniform1iEXT)(program, location, v0);
  }

  static void REGAL_CALL glProgramUniform1ivEXT(GLuint program, GLint location, GLsizei count, const GLint *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform1ivEXT),reinterpret_cast<void (*)()>(glProgramUniform1ivEXT),"glProgramUniform1ivEXT");
    _driver.call(&_driver.glProgramUniform1ivEXT)(program, location, count, value);
  }

  static void REGAL_CALL glProgramUniform1uiEXT(GLuint program, GLint location, GLuint v0)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform1uiEXT),reinterpret_cast<void (*)()>(glProgramUniform1uiEXT),"glProgramUniform1uiEXT");
    _driver.call(&_driver.glProgramUniform1uiEXT)(program, location, v0);
  }

  static void REGAL_CALL glProgramUniform1uivEXT(GLuint program, GLint location, GLsizei count, const GLuint *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform1uivEXT),reinterpret_cast<void (*)()>(glProgramUniform1uivEXT),"glProgramUniform1uivEXT");
    _driver.call(&_driver.glProgramUniform1uivEXT)(program, location, count, value);
  }

  static void REGAL_CALL glProgramUniform2dEXT(GLuint program, GLint location, GLdouble x, GLdouble y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform2dEXT),reinterpret_cast<void (*)()>(glProgramUniform2dEXT),"glProgramUniform2dEXT");
    _driver.call(&_driver.glProgramUniform2dEXT)(program, location, x, y);
  }

  static void REGAL_CALL glProgramUniform2dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform2dvEXT),reinterpret_cast<void (*)()>(glProgramUniform2dvEXT),"glProgramUniform2dvEXT");
    _driver.call(&_driver.glProgramUniform2dvEXT)(program, location, count, value);
  }

  static void REGAL_CALL glProgramUniform2fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform2fEXT),reinterpret_cast<void (*)()>(glProgramUniform2fEXT),"glProgramUniform2fEXT");
    _driver.call(&_driver.glProgramUniform2fEXT)(program, location, v0, v1);
  }

  static void REGAL_CALL glProgramUniform2fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform2fvEXT),reinterpret_cast<void (*)()>(glProgramUniform2fvEXT),"glProgramUniform2fvEXT");
    _driver.call(&_driver.glProgramUniform2fvEXT)(program, location, count, value);
  }

  static void REGAL_CALL glProgramUniform2iEXT(GLuint program, GLint location, GLint v0, GLint v1)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform2iEXT),reinterpret_cast<void (*)()>(glProgramUniform2iEXT),"glProgramUniform2iEXT");
    _driver.call(&_driver.glProgramUniform2iEXT)(program, location, v0, v1);
  }

  static void REGAL_CALL glProgramUniform2ivEXT(GLuint program, GLint location, GLsizei count, const GLint *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform2ivEXT),reinterpret_cast<void (*)()>(glProgramUniform2ivEXT),"glProgramUniform2ivEXT");
    _driver.call(&_driver.glProgramUniform2ivEXT)(program, location, count, value);
  }

  static void REGAL_CALL glProgramUniform2uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform2uiEXT),reinterpret_cast<void (*)()>(glProgramUniform2uiEXT),"glProgramUniform2uiEXT");
    _driver.call(&_driver.glProgramUniform2uiEXT)(program, location, v0, v1);
  }

  static void REGAL_CALL glProgramUniform2uivEXT(GLuint program, GLint location, GLsizei count, const GLuint *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform2uivEXT),reinterpret_cast<void (*)()>(glProgramUniform2uivEXT),"glProgramUniform2uivEXT");
    _driver.call(&_driver.glProgramUniform2uivEXT)(program, location, count, value);
  }

  static void REGAL_CALL glProgramUniform3dEXT(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform3dEXT),reinterpret_cast<void (*)()>(glProgramUniform3dEXT),"glProgramUniform3dEXT");
    _driver.call(&_driver.glProgramUniform3dEXT)(program, location, x, y, z);
  }

  static void REGAL_CALL glProgramUniform3dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform3dvEXT),reinterpret_cast<void (*)()>(glProgramUniform3dvEXT),"glProgramUniform3dvEXT");
    _driver.call(&_driver.glProgramUniform3dvEXT)(program, location, count, value);
  }

  static void REGAL_CALL glProgramUniform3fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform3fEXT),reinterpret_cast<void (*)()>(glProgramUniform3fEXT),"glProgramUniform3fEXT");
    _driver.call(&_driver.glProgramUniform3fEXT)(program, location, v0, v1, v2);
  }

  static void REGAL_CALL glProgramUniform3fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform3fvEXT),reinterpret_cast<void (*)()>(glProgramUniform3fvEXT),"glProgramUniform3fvEXT");
    _driver.call(&_driver.glProgramUniform3fvEXT)(program, location, count, value);
  }

  static void REGAL_CALL glProgramUniform3iEXT(GLuint program, GLint location, GLint v0, GLint v1, GLint v2)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform3iEXT),reinterpret_cast<void (*)()>(glProgramUniform3iEXT),"glProgramUniform3iEXT");
    _driver.call(&_driver.glProgramUniform3iEXT)(program, location, v0, v1, v2);
  }

  static void REGAL_CALL glProgramUniform3ivEXT(GLuint program, GLint location, GLsizei count, const GLint *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform3ivEXT),reinterpret_cast<void (*)()>(glProgramUniform3ivEXT),"glProgramUniform3ivEXT");
    _driver.call(&_driver.glProgramUniform3ivEXT)(program, location, count, value);
  }

  static void REGAL_CALL glProgramUniform3uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform3uiEXT),reinterpret_cast<void (*)()>(glProgramUniform3uiEXT),"glProgramUniform3uiEXT");
    _driver.call(&_driver.glProgramUniform3uiEXT)(program, location, v0, v1, v2);
  }

  static void REGAL_CALL glProgramUniform3uivEXT(GLuint program, GLint location, GLsizei count, const GLuint *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform3uivEXT),reinterpret_cast<void (*)()>(glProgramUniform3uivEXT),"glProgramUniform3uivEXT");
    _driver.call(&_driver.glProgramUniform3uivEXT)(program, location, count, value);
  }

  static void REGAL_CALL glProgramUniform4dEXT(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform4dEXT),reinterpret_cast<void (*)()>(glProgramUniform4dEXT),"glProgramUniform4dEXT");
    _driver.call(&_driver.glProgramUniform4dEXT)(program, location, x, y, z, w);
  }

  static void REGAL_CALL glProgramUniform4dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform4dvEXT),reinterpret_cast<void (*)()>(glProgramUniform4dvEXT),"glProgramUniform4dvEXT");
    _driver.call(&_driver.glProgramUniform4dvEXT)(program, location, count, value);
  }

  static void REGAL_CALL glProgramUniform4fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform4fEXT),reinterpret_cast<void (*)()>(glProgramUniform4fEXT),"glProgramUniform4fEXT");
    _driver.call(&_driver.glProgramUniform4fEXT)(program, location, v0, v1, v2, v3);
  }

  static void REGAL_CALL glProgramUniform4fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform4fvEXT),reinterpret_cast<void (*)()>(glProgramUniform4fvEXT),"glProgramUniform4fvEXT");
    _driver.call(&_driver.glProgramUniform4fvEXT)(program, location, count, value);
  }

  static void REGAL_CALL glProgramUniform4iEXT(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform4iEXT),reinterpret_cast<void (*)()>(glProgramUniform4iEXT),"glProgramUniform4iEXT");
    _driver.call(&_driver.glProgramUniform4iEXT)(program, location, v0, v1, v2, v3);
  }

  static void REGAL_CALL glProgramUniform4ivEXT(GLuint program, GLint location, GLsizei count, const GLint *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform4ivEXT),reinterpret_cast<void (*)()>(glProgramUniform4ivEXT),"glProgramUniform4ivEXT");
    _driver.call(&_driver.glProgramUniform4ivEXT)(program, location, count, value);
  }

  static void REGAL_CALL glProgramUniform4uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform4uiEXT),reinterpret_cast<void (*)()>(glProgramUniform4uiEXT),"glProgramUniform4uiEXT");
    _driver.call(&_driver.glProgramUniform4uiEXT)(program, location, v0, v1, v2, v3);
  }

  static void REGAL_CALL glProgramUniform4uivEXT(GLuint program, GLint location, GLsizei count, const GLuint *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform4uivEXT),reinterpret_cast<void (*)()>(glProgramUniform4uivEXT),"glProgramUniform4uivEXT");
    _driver.call(&_driver.glProgramUniform4uivEXT)(program, location, count, value);
  }

  static void REGAL_CALL glProgramUniformMatrix2dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniformMatrix2dvEXT),reinterpret_cast<void (*)()>(glProgramUniformMatrix2dvEXT),"glProgramUniformMatrix2dvEXT");
    _driver.call(&_driver.glProgramUniformMatrix2dvEXT)(program, location, count, transpose, value);
  }

  static void REGAL_CALL glProgramUniformMatrix2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniformMatrix2fvEXT),reinterpret_cast<void (*)()>(glProgramUniformMatrix2fvEXT),"glProgramUniformMatrix2fvEXT");
    _driver.call(&_driver.glProgramUniformMatrix2fvEXT)(program, location, count, transpose, value);
  }

  static void REGAL_CALL glProgramUniformMatrix2x3dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniformMatrix2x3dvEXT),reinterpret_cast<void (*)()>(glProgramUniformMatrix2x3dvEXT),"glProgramUniformMatrix2x3dvEXT");
    _driver.call(&_driver.glProgramUniformMatrix2x3dvEXT)(program, location, count, transpose, value);
  }

  static void REGAL_CALL glProgramUniformMatrix2x3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniformMatrix2x3fvEXT),reinterpret_cast<void (*)()>(glProgramUniformMatrix2x3fvEXT),"glProgramUniformMatrix2x3fvEXT");
    _driver.call(&_driver.glProgramUniformMatrix2x3fvEXT)(program, location, count, transpose, value);
  }

  static void REGAL_CALL glProgramUniformMatrix2x4dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniformMatrix2x4dvEXT),reinterpret_cast<void (*)()>(glProgramUniformMatrix2x4dvEXT),"glProgramUniformMatrix2x4dvEXT");
    _driver.call(&_driver.glProgramUniformMatrix2x4dvEXT)(program, location, count, transpose, value);
  }

  static void REGAL_CALL glProgramUniformMatrix2x4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniformMatrix2x4fvEXT),reinterpret_cast<void (*)()>(glProgramUniformMatrix2x4fvEXT),"glProgramUniformMatrix2x4fvEXT");
    _driver.call(&_driver.glProgramUniformMatrix2x4fvEXT)(program, location, count, transpose, value);
  }

  static void REGAL_CALL glProgramUniformMatrix3dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniformMatrix3dvEXT),reinterpret_cast<void (*)()>(glProgramUniformMatrix3dvEXT),"glProgramUniformMatrix3dvEXT");
    _driver.call(&_driver.glProgramUniformMatrix3dvEXT)(program, location, count, transpose, value);
  }

  static void REGAL_CALL glProgramUniformMatrix3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniformMatrix3fvEXT),reinterpret_cast<void (*)()>(glProgramUniformMatrix3fvEXT),"glProgramUniformMatrix3fvEXT");
    _driver.call(&_driver.glProgramUniformMatrix3fvEXT)(program, location, count, transpose, value);
  }

  static void REGAL_CALL glProgramUniformMatrix3x2dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniformMatrix3x2dvEXT),reinterpret_cast<void (*)()>(glProgramUniformMatrix3x2dvEXT),"glProgramUniformMatrix3x2dvEXT");
    _driver.call(&_driver.glProgramUniformMatrix3x2dvEXT)(program, location, count, transpose, value);
  }

  static void REGAL_CALL glProgramUniformMatrix3x2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniformMatrix3x2fvEXT),reinterpret_cast<void (*)()>(glProgramUniformMatrix3x2fvEXT),"glProgramUniformMatrix3x2fvEXT");
    _driver.call(&_driver.glProgramUniformMatrix3x2fvEXT)(program, location, count, transpose, value);
  }

  static void REGAL_CALL glProgramUniformMatrix3x4dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniformMatrix3x4dvEXT),reinterpret_cast<void (*)()>(glProgramUniformMatrix3x4dvEXT),"glProgramUniformMatrix3x4dvEXT");
    _driver.call(&_driver.glProgramUniformMatrix3x4dvEXT)(program, location, count, transpose, value);
  }

  static void REGAL_CALL glProgramUniformMatrix3x4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniformMatrix3x4fvEXT),reinterpret_cast<void (*)()>(glProgramUniformMatrix3x4fvEXT),"glProgramUniformMatrix3x4fvEXT");
    _driver.call(&_driver.glProgramUniformMatrix3x4fvEXT)(program, location, count, transpose, value);
  }

  static void REGAL_CALL glProgramUniformMatrix4dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniformMatrix4dvEXT),reinterpret_cast<void (*)()>(glProgramUniformMatrix4dvEXT),"glProgramUniformMatrix4dvEXT");
    _driver.call(&_driver.glProgramUniformMatrix4dvEXT)(program, location, count, transpose, value);
  }

  static void REGAL_CALL glProgramUniformMatrix4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniformMatrix4fvEXT),reinterpret_cast<void (*)()>(glProgramUniformMatrix4fvEXT),"glProgramUniformMatrix4fvEXT");
    _driver.call(&_driver.glProgramUniformMatrix4fvEXT)(program, location, count, transpose, value);
  }

  static void REGAL_CALL glProgramUniformMatrix4x2dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniformMatrix4x2dvEXT),reinterpret_cast<void (*)()>(glProgramUniformMatrix4x2dvEXT),"glProgramUniformMatrix4x2dvEXT");
    _driver.call(&_driver.glProgramUniformMatrix4x2dvEXT)(program, location, count, transpose, value);
  }

  static void REGAL_CALL glProgramUniformMatrix4x2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniformMatrix4x2fvEXT),reinterpret_cast<void (*)()>(glProgramUniformMatrix4x2fvEXT),"glProgramUniformMatrix4x2fvEXT");
    _driver.call(&_driver.glProgramUniformMatrix4x2fvEXT)(program, location, count, transpose, value);
  }

  static void REGAL_CALL glProgramUniformMatrix4x3dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniformMatrix4x3dvEXT),reinterpret_cast<void (*)()>(glProgramUniformMatrix4x3dvEXT),"glProgramUniformMatrix4x3dvEXT");
    _driver.call(&_driver.glProgramUniformMatrix4x3dvEXT)(program, location, count, transpose, value);
  }

  static void REGAL_CALL glProgramUniformMatrix4x3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniformMatrix4x3fvEXT),reinterpret_cast<void (*)()>(glProgramUniformMatrix4x3fvEXT),"glProgramUniformMatrix4x3fvEXT");
    _driver.call(&_driver.glProgramUniformMatrix4x3fvEXT)(program, location, count, transpose, value);
  }

  static void REGAL_CALL glPushClientAttribDefaultEXT(GLbitfield mask)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPushClientAttribDefaultEXT),reinterpret_cast<void (*)()>(glPushClientAttribDefaultEXT),"glPushClientAttribDefaultEXT");
    _driver.call(&_driver.glPushClientAttribDefaultEXT)(mask);
  }

  static void REGAL_CALL glTextureBufferEXT(GLuint texture, GLenum target, GLenum internalformat, GLuint buffer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTextureBufferEXT),reinterpret_cast<void (*)()>(glTextureBufferEXT),"glTextureBufferEXT");
    _driver.call(&_driver.glTextureBufferEXT)(texture, target, internalformat, buffer);
  }

  static void REGAL_CALL glTextureImage1DEXT(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTextureImage1DEXT),reinterpret_cast<void (*)()>(glTextureImage1DEXT),"glTextureImage1DEXT");
    _driver.call(&_driver.glTextureImage1DEXT)(texture, target, level, internalformat, width, border, format, type, pixels);
  }

  static void REGAL_CALL glTextureImage2DEXT(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTextureImage2DEXT),reinterpret_cast<void (*)()>(glTextureImage2DEXT),"glTextureImage2DEXT");
    _driver.call(&_driver.glTextureImage2DEXT)(texture, target, level, internalformat, width, height, border, format, type, pixels);
  }

  static void REGAL_CALL glTextureImage3DEXT(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTextureImage3DEXT),reinterpret_cast<void (*)()>(glTextureImage3DEXT),"glTextureImage3DEXT");
    _driver.call(&_driver.glTextureImage3DEXT)(texture, target, level, internalformat, width, height, depth, border, format, type, pixels);
  }

  static void REGAL_CALL glTextureParameterIivEXT(GLuint texture, GLenum target, GLenum pname, const GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTextureParameterIivEXT),reinterpret_cast<void (*)()>(glTextureParameterIivEXT),"glTextureParameterIivEXT");
    _driver.call(&_driver.glTextureParameterIivEXT)(texture, target, pname, params);
  }

  static void REGAL_CALL glTextureParameterIuivEXT(GLuint texture, GLenum target, GLenum pname, const GLuint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTextureParameterIuivEXT),reinterpret_cast<void (*)()>(glTextureParameterIuivEXT),"glTextureParameterIuivEXT");
    _driver.call(&_driver.glTextureParameterIuivEXT)(texture, target, pname, params);
  }

  static void REGAL_CALL glTextureParameterfEXT(GLuint texture, GLenum target, GLenum pname, GLfloat param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTextureParameterfEXT),reinterpret_cast<void (*)()>(glTextureParameterfEXT),"glTextureParameterfEXT");
    _driver.call(&_driver.glTextureParameterfEXT)(texture, target, pname, param);
  }

  static void REGAL_CALL glTextureParameterfvEXT(GLuint texture, GLenum target, GLenum pname, const GLfloat *param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTextureParameterfvEXT),reinterpret_cast<void (*)()>(glTextureParameterfvEXT),"glTextureParameterfvEXT");
    _driver.call(&_driver.glTextureParameterfvEXT)(texture, target, pname, param);
  }

  static void REGAL_CALL glTextureParameteriEXT(GLuint texture, GLenum target, GLenum pname, GLint param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTextureParameteriEXT),reinterpret_cast<void (*)()>(glTextureParameteriEXT),"glTextureParameteriEXT");
    _driver.call(&_driver.glTextureParameteriEXT)(texture, target, pname, param);
  }

  static void REGAL_CALL glTextureParameterivEXT(GLuint texture, GLenum target, GLenum pname, const GLint *param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTextureParameterivEXT),reinterpret_cast<void (*)()>(glTextureParameterivEXT),"glTextureParameterivEXT");
    _driver.call(&_driver.glTextureParameterivEXT)(texture, target, pname, param);
  }

  static void REGAL_CALL glTextureRenderbufferEXT(GLuint texture, GLenum target, GLuint renderbuffer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTextureRenderbufferEXT),reinterpret_cast<void (*)()>(glTextureRenderbufferEXT),"glTextureRenderbufferEXT");
    _driver.call(&_driver.glTextureRenderbufferEXT)(texture, target, renderbuffer);
  }

  static void REGAL_CALL glTextureSubImage1DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTextureSubImage1DEXT),reinterpret_cast<void (*)()>(glTextureSubImage1DEXT),"glTextureSubImage1DEXT");
    _driver.call(&_driver.glTextureSubImage1DEXT)(texture, target, level, xoffset, width, format, type, pixels);
  }

  static void REGAL_CALL glTextureSubImage2DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTextureSubImage2DEXT),reinterpret_cast<void (*)()>(glTextureSubImage2DEXT),"glTextureSubImage2DEXT");
    _driver.call(&_driver.glTextureSubImage2DEXT)(texture, target, level, xoffset, yoffset, width, height, format, type, pixels);
  }

  static void REGAL_CALL glTextureSubImage3DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTextureSubImage3DEXT),reinterpret_cast<void (*)()>(glTextureSubImage3DEXT),"glTextureSubImage3DEXT");
    _driver.call(&_driver.glTextureSubImage3DEXT)(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
  }

  static GLboolean REGAL_CALL glUnmapNamedBufferEXT(GLuint buffer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUnmapNamedBufferEXT),reinterpret_cast<void (*)()>(glUnmapNamedBufferEXT),"glUnmapNamedBufferEXT");
    return _driver.call(&_driver.glUnmapNamedBufferEXT)(buffer);
  }

  static void REGAL_CALL glVertexArrayColorOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, const GLintptr offset)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexArrayColorOffsetEXT),reinterpret_cast<void (*)()>(glVertexArrayColorOffsetEXT),"glVertexArrayColorOffsetEXT");
    _driver.call(&_driver.glVertexArrayColorOffsetEXT)(vaobj, buffer, size, type, stride, offset);
  }

  static void REGAL_CALL glVertexArrayEdgeFlagOffsetEXT(GLuint vaobj, GLuint buffer, GLsizei stride, const GLintptr offset)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexArrayEdgeFlagOffsetEXT),reinterpret_cast<void (*)()>(glVertexArrayEdgeFlagOffsetEXT),"glVertexArrayEdgeFlagOffsetEXT");
    _driver.call(&_driver.glVertexArrayEdgeFlagOffsetEXT)(vaobj, buffer, stride, offset);
  }

  static void REGAL_CALL glVertexArrayFogCoordOffsetEXT(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, const GLintptr offset)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexArrayFogCoordOffsetEXT),reinterpret_cast<void (*)()>(glVertexArrayFogCoordOffsetEXT),"glVertexArrayFogCoordOffsetEXT");
    _driver.call(&_driver.glVertexArrayFogCoordOffsetEXT)(vaobj, buffer, type, stride, offset);
  }

  static void REGAL_CALL glVertexArrayIndexOffsetEXT(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, const GLintptr offset)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexArrayIndexOffsetEXT),reinterpret_cast<void (*)()>(glVertexArrayIndexOffsetEXT),"glVertexArrayIndexOffsetEXT");
    _driver.call(&_driver.glVertexArrayIndexOffsetEXT)(vaobj, buffer, type, stride, offset);
  }

  static void REGAL_CALL glVertexArrayMultiTexCoordOffsetEXT(GLuint vaobj, GLuint buffer, GLenum texunit, GLint size, GLenum type, GLsizei stride, const GLintptr offset)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexArrayMultiTexCoordOffsetEXT),reinterpret_cast<void (*)()>(glVertexArrayMultiTexCoordOffsetEXT),"glVertexArrayMultiTexCoordOffsetEXT");
    _driver.call(&_driver.glVertexArrayMultiTexCoordOffsetEXT)(vaobj, buffer, texunit, size, type, stride, offset);
  }

  static void REGAL_CALL glVertexArrayNormalOffsetEXT(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, const GLintptr offset)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexArrayNormalOffsetEXT),reinterpret_cast<void (*)()>(glVertexArrayNormalOffsetEXT),"glVertexArrayNormalOffsetEXT");
    _driver.call(&_driver.glVertexArrayNormalOffsetEXT)(vaobj, buffer, type, stride, offset);
  }

  static void REGAL_CALL glVertexArraySecondaryColorOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, const GLintptr offset)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexArraySecondaryColorOffsetEXT),reinterpret_cast<void (*)()>(glVertexArraySecondaryColorOffsetEXT),"glVertexArraySecondaryColorOffsetEXT");
    _driver.call(&_driver.glVertexArraySecondaryColorOffsetEXT)(vaobj, buffer, size, type, stride, offset);
  }

  static void REGAL_CALL glVertexArrayTexCoordOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, const GLintptr offset)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexArrayTexCoordOffsetEXT),reinterpret_cast<void (*)()>(glVertexArrayTexCoordOffsetEXT),"glVertexArrayTexCoordOffsetEXT");
    _driver.call(&_driver.glVertexArrayTexCoordOffsetEXT)(vaobj, buffer, size, type, stride, offset);
  }

  static void REGAL_CALL glVertexArrayVertexAttribIOffsetEXT(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, const GLintptr offset)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexArrayVertexAttribIOffsetEXT),reinterpret_cast<void (*)()>(glVertexArrayVertexAttribIOffsetEXT),"glVertexArrayVertexAttribIOffsetEXT");
    _driver.call(&_driver.glVertexArrayVertexAttribIOffsetEXT)(vaobj, buffer, index, size, type, stride, offset);
  }

  static void REGAL_CALL glVertexArrayVertexAttribOffsetEXT(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLintptr offset)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexArrayVertexAttribOffsetEXT),reinterpret_cast<void (*)()>(glVertexArrayVertexAttribOffsetEXT),"glVertexArrayVertexAttribOffsetEXT");
    _driver.call(&_driver.glVertexArrayVertexAttribOffsetEXT)(vaobj, buffer, index, size, type, normalized, stride, offset);
  }

  static void REGAL_CALL glVertexArrayVertexOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, const GLintptr offset)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexArrayVertexOffsetEXT),reinterpret_cast<void (*)()>(glVertexArrayVertexOffsetEXT),"glVertexArrayVertexOffsetEXT");
    _driver.call(&_driver.glVertexArrayVertexOffsetEXT)(vaobj, buffer, size, type, stride, offset);
  }

// GL_EXT_discard_framebuffer

  static void REGAL_CALL glDiscardFramebufferEXT(GLenum target, GLsizei numAttachments, const GLenum *attachments)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDiscardFramebufferEXT),reinterpret_cast<void (*)()>(glDiscardFramebufferEXT),"glDiscardFramebufferEXT");
    _driver.call(&_driver.glDiscardFramebufferEXT)(target, numAttachments, attachments);
  }

// GL_EXT_disjoint_timer_query

  static void REGAL_CALL glGetQueryObjectivEXT(GLuint id, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetQueryObjectivEXT),reinterpret_cast<void (*)()>(glGetQueryObjectivEXT),"glGetQueryObjectivEXT");
    _driver.call(&_driver.glGetQueryObjectivEXT)(id, pname, params);
  }

  static void REGAL_CALL glQueryCounterEXT(GLuint id, GLenum target)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glQueryCounterEXT),reinterpret_cast<void (*)()>(glQueryCounterEXT),"glQueryCounterEXT");
    _driver.call(&_driver.glQueryCounterEXT)(id, target);
  }

// GL_EXT_draw_buffers2

  static void REGAL_CALL glColorMaskIndexedEXT(GLuint buf, GLboolean r, GLboolean g, GLboolean b, GLboolean a)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColorMaskIndexedEXT),reinterpret_cast<void (*)()>(glColorMaskIndexedEXT),"glColorMaskIndexedEXT");
    _driver.call(&_driver.glColorMaskIndexedEXT)(buf, r, g, b, a);
  }

  static void REGAL_CALL glDisableIndexedEXT(GLenum target, GLuint index)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDisableIndexedEXT),reinterpret_cast<void (*)()>(glDisableIndexedEXT),"glDisableIndexedEXT");
    _driver.call(&_driver.glDisableIndexedEXT)(target, index);
  }

  static void REGAL_CALL glEnableIndexedEXT(GLenum target, GLuint index)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glEnableIndexedEXT),reinterpret_cast<void (*)()>(glEnableIndexedEXT),"glEnableIndexedEXT");
    _driver.call(&_driver.glEnableIndexedEXT)(target, index);
  }

  static void REGAL_CALL glGetBooleanIndexedvEXT(GLenum value, GLuint index, GLboolean *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetBooleanIndexedvEXT),reinterpret_cast<void (*)()>(glGetBooleanIndexedvEXT),"glGetBooleanIndexedvEXT");
    _driver.call(&_driver.glGetBooleanIndexedvEXT)(value, index, data);
  }

  static void REGAL_CALL glGetIntegerIndexedvEXT(GLenum value, GLuint index, GLint *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetIntegerIndexedvEXT),reinterpret_cast<void (*)()>(glGetIntegerIndexedvEXT),"glGetIntegerIndexedvEXT");
    _driver.call(&_driver.glGetIntegerIndexedvEXT)(value, index, data);
  }

  static GLboolean REGAL_CALL glIsEnabledIndexedEXT(GLenum target, GLuint index)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIsEnabledIndexedEXT),reinterpret_cast<void (*)()>(glIsEnabledIndexedEXT),"glIsEnabledIndexedEXT");
    return _driver.call(&_driver.glIsEnabledIndexedEXT)(target, index);
  }

// GL_EXT_draw_instanced

  static void REGAL_CALL glDrawArraysInstancedEXT(GLenum mode, GLint start, GLsizei count, GLsizei primcount)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDrawArraysInstancedEXT),reinterpret_cast<void (*)()>(glDrawArraysInstancedEXT),"glDrawArraysInstancedEXT");
    _driver.call(&_driver.glDrawArraysInstancedEXT)(mode, start, count, primcount);
  }

  static void REGAL_CALL glDrawElementsInstancedEXT(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDrawElementsInstancedEXT),reinterpret_cast<void (*)()>(glDrawElementsInstancedEXT),"glDrawElementsInstancedEXT");
    _driver.call(&_driver.glDrawElementsInstancedEXT)(mode, count, type, indices, primcount);
  }

// GL_EXT_draw_range_elements

  static void REGAL_CALL glDrawRangeElementsEXT(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDrawRangeElementsEXT),reinterpret_cast<void (*)()>(glDrawRangeElementsEXT),"glDrawRangeElementsEXT");
    _driver.call(&_driver.glDrawRangeElementsEXT)(mode, start, end, count, type, indices);
  }

// GL_EXT_fog_coord

  static void REGAL_CALL glFogCoordPointerEXT(GLenum type, GLsizei stride, const GLvoid *pointer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFogCoordPointerEXT),reinterpret_cast<void (*)()>(glFogCoordPointerEXT),"glFogCoordPointerEXT");
    _driver.call(&_driver.glFogCoordPointerEXT)(type, stride, pointer);
  }

  static void REGAL_CALL glFogCoorddEXT(GLdouble coord)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFogCoorddEXT),reinterpret_cast<void (*)()>(glFogCoorddEXT),"glFogCoorddEXT");
    _driver.call(&_driver.glFogCoorddEXT)(coord);
  }

  static void REGAL_CALL glFogCoorddvEXT(const GLdouble *coord)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFogCoorddvEXT),reinterpret_cast<void (*)()>(glFogCoorddvEXT),"glFogCoorddvEXT");
    _driver.call(&_driver.glFogCoorddvEXT)(coord);
  }

  static void REGAL_CALL glFogCoordfEXT(GLfloat coord)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFogCoordfEXT),reinterpret_cast<void (*)()>(glFogCoordfEXT),"glFogCoordfEXT");
    _driver.call(&_driver.glFogCoordfEXT)(coord);
  }

  static void REGAL_CALL glFogCoordfvEXT(const GLfloat *coord)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFogCoordfvEXT),reinterpret_cast<void (*)()>(glFogCoordfvEXT),"glFogCoordfvEXT");
    _driver.call(&_driver.glFogCoordfvEXT)(coord);
  }

// GL_EXT_fragment_lighting

  static void REGAL_CALL glFragmentColorMaterialEXT(GLenum face, GLenum mode)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFragmentColorMaterialEXT),reinterpret_cast<void (*)()>(glFragmentColorMaterialEXT),"glFragmentColorMaterialEXT");
    _driver.call(&_driver.glFragmentColorMaterialEXT)(face, mode);
  }

  static void REGAL_CALL glFragmentLightModelfEXT(GLenum pname, GLfloat param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFragmentLightModelfEXT),reinterpret_cast<void (*)()>(glFragmentLightModelfEXT),"glFragmentLightModelfEXT");
    _driver.call(&_driver.glFragmentLightModelfEXT)(pname, param);
  }

  static void REGAL_CALL glFragmentLightModelfvEXT(GLenum pname, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFragmentLightModelfvEXT),reinterpret_cast<void (*)()>(glFragmentLightModelfvEXT),"glFragmentLightModelfvEXT");
    _driver.call(&_driver.glFragmentLightModelfvEXT)(pname, params);
  }

  static void REGAL_CALL glFragmentLightModeliEXT(GLenum pname, GLint param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFragmentLightModeliEXT),reinterpret_cast<void (*)()>(glFragmentLightModeliEXT),"glFragmentLightModeliEXT");
    _driver.call(&_driver.glFragmentLightModeliEXT)(pname, param);
  }

  static void REGAL_CALL glFragmentLightModelivEXT(GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFragmentLightModelivEXT),reinterpret_cast<void (*)()>(glFragmentLightModelivEXT),"glFragmentLightModelivEXT");
    _driver.call(&_driver.glFragmentLightModelivEXT)(pname, params);
  }

  static void REGAL_CALL glFragmentLightfEXT(GLenum light, GLenum pname, GLfloat param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFragmentLightfEXT),reinterpret_cast<void (*)()>(glFragmentLightfEXT),"glFragmentLightfEXT");
    _driver.call(&_driver.glFragmentLightfEXT)(light, pname, param);
  }

  static void REGAL_CALL glFragmentLightfvEXT(GLenum light, GLenum pname, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFragmentLightfvEXT),reinterpret_cast<void (*)()>(glFragmentLightfvEXT),"glFragmentLightfvEXT");
    _driver.call(&_driver.glFragmentLightfvEXT)(light, pname, params);
  }

  static void REGAL_CALL glFragmentLightiEXT(GLenum light, GLenum pname, GLint param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFragmentLightiEXT),reinterpret_cast<void (*)()>(glFragmentLightiEXT),"glFragmentLightiEXT");
    _driver.call(&_driver.glFragmentLightiEXT)(light, pname, param);
  }

  static void REGAL_CALL glFragmentLightivEXT(GLenum light, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFragmentLightivEXT),reinterpret_cast<void (*)()>(glFragmentLightivEXT),"glFragmentLightivEXT");
    _driver.call(&_driver.glFragmentLightivEXT)(light, pname, params);
  }

  static void REGAL_CALL glFragmentMaterialfEXT(GLenum face, GLenum pname, const GLfloat param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFragmentMaterialfEXT),reinterpret_cast<void (*)()>(glFragmentMaterialfEXT),"glFragmentMaterialfEXT");
    _driver.call(&_driver.glFragmentMaterialfEXT)(face, pname, param);
  }

  static void REGAL_CALL glFragmentMaterialfvEXT(GLenum face, GLenum pname, const GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFragmentMaterialfvEXT),reinterpret_cast<void (*)()>(glFragmentMaterialfvEXT),"glFragmentMaterialfvEXT");
    _driver.call(&_driver.glFragmentMaterialfvEXT)(face, pname, params);
  }

  static void REGAL_CALL glFragmentMaterialiEXT(GLenum face, GLenum pname, const GLint param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFragmentMaterialiEXT),reinterpret_cast<void (*)()>(glFragmentMaterialiEXT),"glFragmentMaterialiEXT");
    _driver.call(&_driver.glFragmentMaterialiEXT)(face, pname, param);
  }

  static void REGAL_CALL glFragmentMaterialivEXT(GLenum face, GLenum pname, const GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFragmentMaterialivEXT),reinterpret_cast<void (*)()>(glFragmentMaterialivEXT),"glFragmentMaterialivEXT");
    _driver.call(&_driver.glFragmentMaterialivEXT)(face, pname, params);
  }

  static void REGAL_CALL glGetFragmentLightfvEXT(GLenum light, GLenum pname, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetFragmentLightfvEXT),reinterpret_cast<void (*)()>(glGetFragmentLightfvEXT),"glGetFragmentLightfvEXT");
    _driver.call(&_driver.glGetFragmentLightfvEXT)(light, pname, params);
  }

  static void REGAL_CALL glGetFragmentLightivEXT(GLenum light, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetFragmentLightivEXT),reinterpret_cast<void (*)()>(glGetFragmentLightivEXT),"glGetFragmentLightivEXT");
    _driver.call(&_driver.glGetFragmentLightivEXT)(light, pname, params);
  }

  static void REGAL_CALL glGetFragmentMaterialfvEXT(GLenum face, GLenum pname, const GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetFragmentMaterialfvEXT),reinterpret_cast<void (*)()>(glGetFragmentMaterialfvEXT),"glGetFragmentMaterialfvEXT");
    _driver.call(&_driver.glGetFragmentMaterialfvEXT)(face, pname, params);
  }

  static void REGAL_CALL glGetFragmentMaterialivEXT(GLenum face, GLenum pname, const GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetFragmentMaterialivEXT),reinterpret_cast<void (*)()>(glGetFragmentMaterialivEXT),"glGetFragmentMaterialivEXT");
    _driver.call(&_driver.glGetFragmentMaterialivEXT)(face, pname, params);
  }

  static void REGAL_CALL glLightEnviEXT(GLenum pname, GLint param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glLightEnviEXT),reinterpret_cast<void (*)()>(glLightEnviEXT),"glLightEnviEXT");
    _driver.call(&_driver.glLightEnviEXT)(pname, param);
  }

// GL_EXT_framebuffer_blit

  static void REGAL_CALL glBlitFramebufferEXT(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBlitFramebufferEXT),reinterpret_cast<void (*)()>(glBlitFramebufferEXT),"glBlitFramebufferEXT");
    _driver.call(&_driver.glBlitFramebufferEXT)(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
  }

// GL_EXT_framebuffer_multisample

  static void REGAL_CALL glRenderbufferStorageMultisampleEXT(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glRenderbufferStorageMultisampleEXT),reinterpret_cast<void (*)()>(glRenderbufferStorageMultisampleEXT),"glRenderbufferStorageMultisampleEXT");
    _driver.call(&_driver.glRenderbufferStorageMultisampleEXT)(target, samples, internalformat, width, height);
  }

// GL_EXT_framebuffer_object

  static void REGAL_CALL glBindFramebufferEXT(GLenum target, GLuint framebuffer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBindFramebufferEXT),reinterpret_cast<void (*)()>(glBindFramebufferEXT),"glBindFramebufferEXT");
    _driver.call(&_driver.glBindFramebufferEXT)(target, framebuffer);
  }

  static void REGAL_CALL glBindRenderbufferEXT(GLenum target, GLuint renderbuffer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBindRenderbufferEXT),reinterpret_cast<void (*)()>(glBindRenderbufferEXT),"glBindRenderbufferEXT");
    _driver.call(&_driver.glBindRenderbufferEXT)(target, renderbuffer);
  }

  static GLenum REGAL_CALL glCheckFramebufferStatusEXT(GLenum target)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCheckFramebufferStatusEXT),reinterpret_cast<void (*)()>(glCheckFramebufferStatusEXT),"glCheckFramebufferStatusEXT");
    return _driver.call(&_driver.glCheckFramebufferStatusEXT)(target);
  }

  static void REGAL_CALL glDeleteFramebuffersEXT(GLsizei n, const GLuint *framebuffers)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDeleteFramebuffersEXT),reinterpret_cast<void (*)()>(glDeleteFramebuffersEXT),"glDeleteFramebuffersEXT");
    _driver.call(&_driver.glDeleteFramebuffersEXT)(n, framebuffers);
  }

  static void REGAL_CALL glDeleteRenderbuffersEXT(GLsizei n, const GLuint *renderbuffers)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDeleteRenderbuffersEXT),reinterpret_cast<void (*)()>(glDeleteRenderbuffersEXT),"glDeleteRenderbuffersEXT");
    _driver.call(&_driver.glDeleteRenderbuffersEXT)(n, renderbuffers);
  }

  static void REGAL_CALL glFramebufferRenderbufferEXT(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFramebufferRenderbufferEXT),reinterpret_cast<void (*)()>(glFramebufferRenderbufferEXT),"glFramebufferRenderbufferEXT");
    _driver.call(&_driver.glFramebufferRenderbufferEXT)(target, attachment, renderbuffertarget, renderbuffer);
  }

  static void REGAL_CALL glFramebufferTexture1DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFramebufferTexture1DEXT),reinterpret_cast<void (*)()>(glFramebufferTexture1DEXT),"glFramebufferTexture1DEXT");
    _driver.call(&_driver.glFramebufferTexture1DEXT)(target, attachment, textarget, texture, level);
  }

  static void REGAL_CALL glFramebufferTexture2DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFramebufferTexture2DEXT),reinterpret_cast<void (*)()>(glFramebufferTexture2DEXT),"glFramebufferTexture2DEXT");
    _driver.call(&_driver.glFramebufferTexture2DEXT)(target, attachment, textarget, texture, level);
  }

  static void REGAL_CALL glFramebufferTexture3DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFramebufferTexture3DEXT),reinterpret_cast<void (*)()>(glFramebufferTexture3DEXT),"glFramebufferTexture3DEXT");
    _driver.call(&_driver.glFramebufferTexture3DEXT)(target, attachment, textarget, texture, level, zoffset);
  }

  static void REGAL_CALL glGenFramebuffersEXT(GLsizei n, GLuint *framebuffers)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGenFramebuffersEXT),reinterpret_cast<void (*)()>(glGenFramebuffersEXT),"glGenFramebuffersEXT");
    _driver.call(&_driver.glGenFramebuffersEXT)(n, framebuffers);
  }

  static void REGAL_CALL glGenRenderbuffersEXT(GLsizei n, GLuint *renderbuffers)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGenRenderbuffersEXT),reinterpret_cast<void (*)()>(glGenRenderbuffersEXT),"glGenRenderbuffersEXT");
    _driver.call(&_driver.glGenRenderbuffersEXT)(n, renderbuffers);
  }

  static void REGAL_CALL glGenerateMipmapEXT(GLenum target)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGenerateMipmapEXT),reinterpret_cast<void (*)()>(glGenerateMipmapEXT),"glGenerateMipmapEXT");
    _driver.call(&_driver.glGenerateMipmapEXT)(target);
  }

  static void REGAL_CALL glGetFramebufferAttachmentParameterivEXT(GLenum target, GLenum attachment, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetFramebufferAttachmentParameterivEXT),reinterpret_cast<void (*)()>(glGetFramebufferAttachmentParameterivEXT),"glGetFramebufferAttachmentParameterivEXT");
    _driver.call(&_driver.glGetFramebufferAttachmentParameterivEXT)(target, attachment, pname, params);
  }

  static void REGAL_CALL glGetRenderbufferParameterivEXT(GLenum target, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetRenderbufferParameterivEXT),reinterpret_cast<void (*)()>(glGetRenderbufferParameterivEXT),"glGetRenderbufferParameterivEXT");
    _driver.call(&_driver.glGetRenderbufferParameterivEXT)(target, pname, params);
  }

  static GLboolean REGAL_CALL glIsFramebufferEXT(GLuint framebuffer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIsFramebufferEXT),reinterpret_cast<void (*)()>(glIsFramebufferEXT),"glIsFramebufferEXT");
    return _driver.call(&_driver.glIsFramebufferEXT)(framebuffer);
  }

  static GLboolean REGAL_CALL glIsRenderbufferEXT(GLuint renderbuffer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIsRenderbufferEXT),reinterpret_cast<void (*)()>(glIsRenderbufferEXT),"glIsRenderbufferEXT");
    return _driver.call(&_driver.glIsRenderbufferEXT)(renderbuffer);
  }

  static void REGAL_CALL glRenderbufferStorageEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glRenderbufferStorageEXT),reinterpret_cast<void (*)()>(glRenderbufferStorageEXT),"glRenderbufferStorageEXT");
    _driver.call(&_driver.glRenderbufferStorageEXT)(target, internalformat, width, height);
  }

// GL_EXT_geometry_shader4

  static void REGAL_CALL glFramebufferTextureEXT(GLenum target, GLenum attachment, GLuint texture, GLint level)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFramebufferTextureEXT),reinterpret_cast<void (*)()>(glFramebufferTextureEXT),"glFramebufferTextureEXT");
    _driver.call(&_driver.glFramebufferTextureEXT)(target, attachment, texture, level);
  }

  static void REGAL_CALL glFramebufferTextureFaceEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFramebufferTextureFaceEXT),reinterpret_cast<void (*)()>(glFramebufferTextureFaceEXT),"glFramebufferTextureFaceEXT");
    _driver.call(&_driver.glFramebufferTextureFaceEXT)(target, attachment, texture, level, face);
  }

  static void REGAL_CALL glProgramParameteriEXT(GLuint program, GLenum pname, GLint value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramParameteriEXT),reinterpret_cast<void (*)()>(glProgramParameteriEXT),"glProgramParameteriEXT");
    _driver.call(&_driver.glProgramParameteriEXT)(program, pname, value);
  }

// GL_EXT_gpu_program_parameters

  static void REGAL_CALL glProgramEnvParameters4fvEXT(GLenum target, GLuint index, GLsizei count, const GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramEnvParameters4fvEXT),reinterpret_cast<void (*)()>(glProgramEnvParameters4fvEXT),"glProgramEnvParameters4fvEXT");
    _driver.call(&_driver.glProgramEnvParameters4fvEXT)(target, index, count, params);
  }

  static void REGAL_CALL glProgramLocalParameters4fvEXT(GLenum target, GLuint index, GLsizei count, const GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramLocalParameters4fvEXT),reinterpret_cast<void (*)()>(glProgramLocalParameters4fvEXT),"glProgramLocalParameters4fvEXT");
    _driver.call(&_driver.glProgramLocalParameters4fvEXT)(target, index, count, params);
  }

// GL_EXT_gpu_shader4

  static void REGAL_CALL glBindFragDataLocationEXT(GLuint program, GLuint color, const GLchar *name)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBindFragDataLocationEXT),reinterpret_cast<void (*)()>(glBindFragDataLocationEXT),"glBindFragDataLocationEXT");
    _driver.call(&_driver.glBindFragDataLocationEXT)(program, color, name);
  }

  static GLint REGAL_CALL glGetFragDataLocationEXT(GLuint program, const GLchar *name)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetFragDataLocationEXT),reinterpret_cast<void (*)()>(glGetFragDataLocationEXT),"glGetFragDataLocationEXT");
    return _driver.call(&_driver.glGetFragDataLocationEXT)(program, name);
  }

  static void REGAL_CALL glGetUniformuivEXT(GLuint program, GLint location, GLuint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetUniformuivEXT),reinterpret_cast<void (*)()>(glGetUniformuivEXT),"glGetUniformuivEXT");
    _driver.call(&_driver.glGetUniformuivEXT)(program, location, params);
  }

  static void REGAL_CALL glGetVertexAttribIivEXT(GLuint index, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetVertexAttribIivEXT),reinterpret_cast<void (*)()>(glGetVertexAttribIivEXT),"glGetVertexAttribIivEXT");
    _driver.call(&_driver.glGetVertexAttribIivEXT)(index, pname, params);
  }

  static void REGAL_CALL glGetVertexAttribIuivEXT(GLuint index, GLenum pname, GLuint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetVertexAttribIuivEXT),reinterpret_cast<void (*)()>(glGetVertexAttribIuivEXT),"glGetVertexAttribIuivEXT");
    _driver.call(&_driver.glGetVertexAttribIuivEXT)(index, pname, params);
  }

  static void REGAL_CALL glUniform1uiEXT(GLint location, GLuint v0)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform1uiEXT),reinterpret_cast<void (*)()>(glUniform1uiEXT),"glUniform1uiEXT");
    _driver.call(&_driver.glUniform1uiEXT)(location, v0);
  }

  static void REGAL_CALL glUniform1uivEXT(GLint location, GLsizei count, const GLuint *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform1uivEXT),reinterpret_cast<void (*)()>(glUniform1uivEXT),"glUniform1uivEXT");
    _driver.call(&_driver.glUniform1uivEXT)(location, count, value);
  }

  static void REGAL_CALL glUniform2uiEXT(GLint location, GLuint v0, GLuint v1)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform2uiEXT),reinterpret_cast<void (*)()>(glUniform2uiEXT),"glUniform2uiEXT");
    _driver.call(&_driver.glUniform2uiEXT)(location, v0, v1);
  }

  static void REGAL_CALL glUniform2uivEXT(GLint location, GLsizei count, const GLuint *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform2uivEXT),reinterpret_cast<void (*)()>(glUniform2uivEXT),"glUniform2uivEXT");
    _driver.call(&_driver.glUniform2uivEXT)(location, count, value);
  }

  static void REGAL_CALL glUniform3uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform3uiEXT),reinterpret_cast<void (*)()>(glUniform3uiEXT),"glUniform3uiEXT");
    _driver.call(&_driver.glUniform3uiEXT)(location, v0, v1, v2);
  }

  static void REGAL_CALL glUniform3uivEXT(GLint location, GLsizei count, const GLuint *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform3uivEXT),reinterpret_cast<void (*)()>(glUniform3uivEXT),"glUniform3uivEXT");
    _driver.call(&_driver.glUniform3uivEXT)(location, count, value);
  }

  static void REGAL_CALL glUniform4uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform4uiEXT),reinterpret_cast<void (*)()>(glUniform4uiEXT),"glUniform4uiEXT");
    _driver.call(&_driver.glUniform4uiEXT)(location, v0, v1, v2, v3);
  }

  static void REGAL_CALL glUniform4uivEXT(GLint location, GLsizei count, const GLuint *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform4uivEXT),reinterpret_cast<void (*)()>(glUniform4uivEXT),"glUniform4uivEXT");
    _driver.call(&_driver.glUniform4uivEXT)(location, count, value);
  }

  static void REGAL_CALL glVertexAttribI1iEXT(GLuint index, GLint x)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribI1iEXT),reinterpret_cast<void (*)()>(glVertexAttribI1iEXT),"glVertexAttribI1iEXT");
    _driver.call(&_driver.glVertexAttribI1iEXT)(index, x);
  }

  static void REGAL_CALL glVertexAttribI1ivEXT(GLuint index, const GLint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribI1ivEXT),reinterpret_cast<void (*)()>(glVertexAttribI1ivEXT),"glVertexAttribI1ivEXT");
    _driver.call(&_driver.glVertexAttribI1ivEXT)(index, v);
  }

  static void REGAL_CALL glVertexAttribI1uiEXT(GLuint index, GLuint x)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribI1uiEXT),reinterpret_cast<void (*)()>(glVertexAttribI1uiEXT),"glVertexAttribI1uiEXT");
    _driver.call(&_driver.glVertexAttribI1uiEXT)(index, x);
  }

  static void REGAL_CALL glVertexAttribI1uivEXT(GLuint index, const GLuint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribI1uivEXT),reinterpret_cast<void (*)()>(glVertexAttribI1uivEXT),"glVertexAttribI1uivEXT");
    _driver.call(&_driver.glVertexAttribI1uivEXT)(index, v);
  }

  static void REGAL_CALL glVertexAttribI2iEXT(GLuint index, GLint x, GLint y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribI2iEXT),reinterpret_cast<void (*)()>(glVertexAttribI2iEXT),"glVertexAttribI2iEXT");
    _driver.call(&_driver.glVertexAttribI2iEXT)(index, x, y);
  }

  static void REGAL_CALL glVertexAttribI2ivEXT(GLuint index, const GLint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribI2ivEXT),reinterpret_cast<void (*)()>(glVertexAttribI2ivEXT),"glVertexAttribI2ivEXT");
    _driver.call(&_driver.glVertexAttribI2ivEXT)(index, v);
  }

  static void REGAL_CALL glVertexAttribI2uiEXT(GLuint index, GLuint x, GLuint y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribI2uiEXT),reinterpret_cast<void (*)()>(glVertexAttribI2uiEXT),"glVertexAttribI2uiEXT");
    _driver.call(&_driver.glVertexAttribI2uiEXT)(index, x, y);
  }

  static void REGAL_CALL glVertexAttribI2uivEXT(GLuint index, const GLuint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribI2uivEXT),reinterpret_cast<void (*)()>(glVertexAttribI2uivEXT),"glVertexAttribI2uivEXT");
    _driver.call(&_driver.glVertexAttribI2uivEXT)(index, v);
  }

  static void REGAL_CALL glVertexAttribI3iEXT(GLuint index, GLint x, GLint y, GLint z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribI3iEXT),reinterpret_cast<void (*)()>(glVertexAttribI3iEXT),"glVertexAttribI3iEXT");
    _driver.call(&_driver.glVertexAttribI3iEXT)(index, x, y, z);
  }

  static void REGAL_CALL glVertexAttribI3ivEXT(GLuint index, const GLint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribI3ivEXT),reinterpret_cast<void (*)()>(glVertexAttribI3ivEXT),"glVertexAttribI3ivEXT");
    _driver.call(&_driver.glVertexAttribI3ivEXT)(index, v);
  }

  static void REGAL_CALL glVertexAttribI3uiEXT(GLuint index, GLuint x, GLuint y, GLuint z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribI3uiEXT),reinterpret_cast<void (*)()>(glVertexAttribI3uiEXT),"glVertexAttribI3uiEXT");
    _driver.call(&_driver.glVertexAttribI3uiEXT)(index, x, y, z);
  }

  static void REGAL_CALL glVertexAttribI3uivEXT(GLuint index, const GLuint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribI3uivEXT),reinterpret_cast<void (*)()>(glVertexAttribI3uivEXT),"glVertexAttribI3uivEXT");
    _driver.call(&_driver.glVertexAttribI3uivEXT)(index, v);
  }

  static void REGAL_CALL glVertexAttribI4bvEXT(GLuint index, const GLbyte *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribI4bvEXT),reinterpret_cast<void (*)()>(glVertexAttribI4bvEXT),"glVertexAttribI4bvEXT");
    _driver.call(&_driver.glVertexAttribI4bvEXT)(index, v);
  }

  static void REGAL_CALL glVertexAttribI4iEXT(GLuint index, GLint x, GLint y, GLint z, GLint w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribI4iEXT),reinterpret_cast<void (*)()>(glVertexAttribI4iEXT),"glVertexAttribI4iEXT");
    _driver.call(&_driver.glVertexAttribI4iEXT)(index, x, y, z, w);
  }

  static void REGAL_CALL glVertexAttribI4ivEXT(GLuint index, const GLint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribI4ivEXT),reinterpret_cast<void (*)()>(glVertexAttribI4ivEXT),"glVertexAttribI4ivEXT");
    _driver.call(&_driver.glVertexAttribI4ivEXT)(index, v);
  }

  static void REGAL_CALL glVertexAttribI4svEXT(GLuint index, const GLshort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribI4svEXT),reinterpret_cast<void (*)()>(glVertexAttribI4svEXT),"glVertexAttribI4svEXT");
    _driver.call(&_driver.glVertexAttribI4svEXT)(index, v);
  }

  static void REGAL_CALL glVertexAttribI4ubvEXT(GLuint index, const GLubyte *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribI4ubvEXT),reinterpret_cast<void (*)()>(glVertexAttribI4ubvEXT),"glVertexAttribI4ubvEXT");
    _driver.call(&_driver.glVertexAttribI4ubvEXT)(index, v);
  }

  static void REGAL_CALL glVertexAttribI4uiEXT(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribI4uiEXT),reinterpret_cast<void (*)()>(glVertexAttribI4uiEXT),"glVertexAttribI4uiEXT");
    _driver.call(&_driver.glVertexAttribI4uiEXT)(index, x, y, z, w);
  }

  static void REGAL_CALL glVertexAttribI4uivEXT(GLuint index, const GLuint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribI4uivEXT),reinterpret_cast<void (*)()>(glVertexAttribI4uivEXT),"glVertexAttribI4uivEXT");
    _driver.call(&_driver.glVertexAttribI4uivEXT)(index, v);
  }

  static void REGAL_CALL glVertexAttribI4usvEXT(GLuint index, const GLushort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribI4usvEXT),reinterpret_cast<void (*)()>(glVertexAttribI4usvEXT),"glVertexAttribI4usvEXT");
    _driver.call(&_driver.glVertexAttribI4usvEXT)(index, v);
  }

  static void REGAL_CALL glVertexAttribIPointerEXT(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribIPointerEXT),reinterpret_cast<void (*)()>(glVertexAttribIPointerEXT),"glVertexAttribIPointerEXT");
    _driver.call(&_driver.glVertexAttribIPointerEXT)(index, size, type, stride, pointer);
  }

// GL_EXT_histogram

  static void REGAL_CALL glGetHistogramEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetHistogramEXT),reinterpret_cast<void (*)()>(glGetHistogramEXT),"glGetHistogramEXT");
    _driver.call(&_driver.glGetHistogramEXT)(target, reset, format, type, values);
  }

  static void REGAL_CALL glGetHistogramParameterfvEXT(GLenum target, GLenum pname, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetHistogramParameterfvEXT),reinterpret_cast<void (*)()>(glGetHistogramParameterfvEXT),"glGetHistogramParameterfvEXT");
    _driver.call(&_driver.glGetHistogramParameterfvEXT)(target, pname, params);
  }

  static void REGAL_CALL glGetHistogramParameterivEXT(GLenum target, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetHistogramParameterivEXT),reinterpret_cast<void (*)()>(glGetHistogramParameterivEXT),"glGetHistogramParameterivEXT");
    _driver.call(&_driver.glGetHistogramParameterivEXT)(target, pname, params);
  }

  static void REGAL_CALL glGetMinmaxEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetMinmaxEXT),reinterpret_cast<void (*)()>(glGetMinmaxEXT),"glGetMinmaxEXT");
    _driver.call(&_driver.glGetMinmaxEXT)(target, reset, format, type, values);
  }

  static void REGAL_CALL glGetMinmaxParameterfvEXT(GLenum target, GLenum pname, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetMinmaxParameterfvEXT),reinterpret_cast<void (*)()>(glGetMinmaxParameterfvEXT),"glGetMinmaxParameterfvEXT");
    _driver.call(&_driver.glGetMinmaxParameterfvEXT)(target, pname, params);
  }

  static void REGAL_CALL glGetMinmaxParameterivEXT(GLenum target, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetMinmaxParameterivEXT),reinterpret_cast<void (*)()>(glGetMinmaxParameterivEXT),"glGetMinmaxParameterivEXT");
    _driver.call(&_driver.glGetMinmaxParameterivEXT)(target, pname, params);
  }

  static void REGAL_CALL glHistogramEXT(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glHistogramEXT),reinterpret_cast<void (*)()>(glHistogramEXT),"glHistogramEXT");
    _driver.call(&_driver.glHistogramEXT)(target, width, internalformat, sink);
  }

  static void REGAL_CALL glMinmaxEXT(GLenum target, GLenum internalformat, GLboolean sink)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMinmaxEXT),reinterpret_cast<void (*)()>(glMinmaxEXT),"glMinmaxEXT");
    _driver.call(&_driver.glMinmaxEXT)(target, internalformat, sink);
  }

  static void REGAL_CALL glResetHistogramEXT(GLenum target)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glResetHistogramEXT),reinterpret_cast<void (*)()>(glResetHistogramEXT),"glResetHistogramEXT");
    _driver.call(&_driver.glResetHistogramEXT)(target);
  }

  static void REGAL_CALL glResetMinmaxEXT(GLenum target)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glResetMinmaxEXT),reinterpret_cast<void (*)()>(glResetMinmaxEXT),"glResetMinmaxEXT");
    _driver.call(&_driver.glResetMinmaxEXT)(target);
  }

// GL_EXT_index_func

  static void REGAL_CALL glIndexFuncEXT(GLenum func, GLfloat ref)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIndexFuncEXT),reinterpret_cast<void (*)()>(glIndexFuncEXT),"glIndexFuncEXT");
    _driver.call(&_driver.glIndexFuncEXT)(func, ref);
  }

// GL_EXT_index_material

  static void REGAL_CALL glIndexMaterialEXT(GLenum face, GLenum mode)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIndexMaterialEXT),reinterpret_cast<void (*)()>(glIndexMaterialEXT),"glIndexMaterialEXT");
    _driver.call(&_driver.glIndexMaterialEXT)(face, mode);
  }

// GL_EXT_light_texture

  static void REGAL_CALL glApplyTextureEXT(GLenum mode)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glApplyTextureEXT),reinterpret_cast<void (*)()>(glApplyTextureEXT),"glApplyTextureEXT");
    _driver.call(&_driver.glApplyTextureEXT)(mode);
  }

  static void REGAL_CALL glTextureLightEXT(GLenum pname)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTextureLightEXT),reinterpret_cast<void (*)()>(glTextureLightEXT),"glTextureLightEXT");
    _driver.call(&_driver.glTextureLightEXT)(pname);
  }

  static void REGAL_CALL glTextureMaterialEXT(GLenum face, GLenum mode)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTextureMaterialEXT),reinterpret_cast<void (*)()>(glTextureMaterialEXT),"glTextureMaterialEXT");
    _driver.call(&_driver.glTextureMaterialEXT)(face, mode);
  }

// GL_EXT_map_buffer_range

  static void REGAL_CALL glFlushMappedBufferRangeEXT(GLenum target, GLintptr offset, GLsizeiptr length)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFlushMappedBufferRangeEXT),reinterpret_cast<void (*)()>(glFlushMappedBufferRangeEXT),"glFlushMappedBufferRangeEXT");
    _driver.call(&_driver.glFlushMappedBufferRangeEXT)(target, offset, length);
  }

  static GLvoid *REGAL_CALL glMapBufferRangeEXT(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMapBufferRangeEXT),reinterpret_cast<void (*)()>(glMapBufferRangeEXT),"glMapBufferRangeEXT");
    return _driver.call(&_driver.glMapBufferRangeEXT)(target, offset, length, access);
  }

// GL_EXT_multi_draw_arrays

  static void REGAL_CALL glMultiDrawArraysEXT(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiDrawArraysEXT),reinterpret_cast<void (*)()>(glMultiDrawArraysEXT),"glMultiDrawArraysEXT");
    _driver.call(&_driver.glMultiDrawArraysEXT)(mode, first, count, primcount);
  }

  static void REGAL_CALL glMultiDrawElementsEXT(GLenum mode, const GLsizei *count, GLenum type, const GLvoid **indices, GLsizei primcount)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiDrawElementsEXT),reinterpret_cast<void (*)()>(glMultiDrawElementsEXT),"glMultiDrawElementsEXT");
    _driver.call(&_driver.glMultiDrawElementsEXT)(mode, count, type, indices, primcount);
  }

// GL_EXT_multisample

  static void REGAL_CALL glSampleMaskEXT(GLclampf value, GLboolean invert)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSampleMaskEXT),reinterpret_cast<void (*)()>(glSampleMaskEXT),"glSampleMaskEXT");
    _driver.call(&_driver.glSampleMaskEXT)(value, invert);
  }

  static void REGAL_CALL glSamplePatternEXT(GLenum pattern)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSamplePatternEXT),reinterpret_cast<void (*)()>(glSamplePatternEXT),"glSamplePatternEXT");
    _driver.call(&_driver.glSamplePatternEXT)(pattern);
  }

// GL_EXT_multisampled_render_to_texture

  static void REGAL_CALL glFramebufferTexture2DMultisampleEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFramebufferTexture2DMultisampleEXT),reinterpret_cast<void (*)()>(glFramebufferTexture2DMultisampleEXT),"glFramebufferTexture2DMultisampleEXT");
    _driver.call(&_driver.glFramebufferTexture2DMultisampleEXT)(target, attachment, textarget, texture, level, samples);
  }

// GL_EXT_multiview_draw_buffers

  static void REGAL_CALL glDrawBuffersIndexedEXT(GLint n, const GLenum *location, const GLint *indices)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDrawBuffersIndexedEXT),reinterpret_cast<void (*)()>(glDrawBuffersIndexedEXT),"glDrawBuffersIndexedEXT");
    _driver.call(&_driver.glDrawBuffersIndexedEXT)(n, location, indices);
  }

  static void REGAL_CALL glGetIntegeri_vEXT(GLenum target, GLuint index, GLint *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetIntegeri_vEXT),reinterpret_cast<void (*)()>(glGetIntegeri_vEXT),"glGetIntegeri_vEXT");
    _driver.call(&_driver.glGetIntegeri_vEXT)(target, index, data);
  }

  static void REGAL_CALL glReadBufferIndexedEXT(GLenum src, GLint index)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glReadBufferIndexedEXT),reinterpret_cast<void (*)()>(glReadBufferIndexedEXT),"glReadBufferIndexedEXT");
    _driver.call(&_driver.glReadBufferIndexedEXT)(src, index);
  }

// GL_EXT_occlusion_query_boolean

  static void REGAL_CALL glBeginQueryEXT(GLenum target, GLuint id)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBeginQueryEXT),reinterpret_cast<void (*)()>(glBeginQueryEXT),"glBeginQueryEXT");
    _driver.call(&_driver.glBeginQueryEXT)(target, id);
  }

  static void REGAL_CALL glDeleteQueriesEXT(GLsizei n, const GLuint *ids)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDeleteQueriesEXT),reinterpret_cast<void (*)()>(glDeleteQueriesEXT),"glDeleteQueriesEXT");
    _driver.call(&_driver.glDeleteQueriesEXT)(n, ids);
  }

  static void REGAL_CALL glEndQueryEXT(GLenum target)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glEndQueryEXT),reinterpret_cast<void (*)()>(glEndQueryEXT),"glEndQueryEXT");
    _driver.call(&_driver.glEndQueryEXT)(target);
  }

  static void REGAL_CALL glGenQueriesEXT(GLsizei n, GLuint *ids)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGenQueriesEXT),reinterpret_cast<void (*)()>(glGenQueriesEXT),"glGenQueriesEXT");
    _driver.call(&_driver.glGenQueriesEXT)(n, ids);
  }

  static void REGAL_CALL glGetQueryObjectuivEXT(GLuint id, GLenum pname, GLuint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetQueryObjectuivEXT),reinterpret_cast<void (*)()>(glGetQueryObjectuivEXT),"glGetQueryObjectuivEXT");
    _driver.call(&_driver.glGetQueryObjectuivEXT)(id, pname, params);
  }

  static void REGAL_CALL glGetQueryivEXT(GLenum target, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetQueryivEXT),reinterpret_cast<void (*)()>(glGetQueryivEXT),"glGetQueryivEXT");
    _driver.call(&_driver.glGetQueryivEXT)(target, pname, params);
  }

  static GLboolean REGAL_CALL glIsQueryEXT(GLuint id)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIsQueryEXT),reinterpret_cast<void (*)()>(glIsQueryEXT),"glIsQueryEXT");
    return _driver.call(&_driver.glIsQueryEXT)(id);
  }

// GL_EXT_paletted_texture

  static void REGAL_CALL glColorTableEXT(GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const GLvoid *table)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColorTableEXT),reinterpret_cast<void (*)()>(glColorTableEXT),"glColorTableEXT");
    _driver.call(&_driver.glColorTableEXT)(target, internalFormat, width, format, type, table);
  }

  static void REGAL_CALL glGetColorTableEXT(GLenum target, GLenum format, GLenum type, GLvoid *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetColorTableEXT),reinterpret_cast<void (*)()>(glGetColorTableEXT),"glGetColorTableEXT");
    _driver.call(&_driver.glGetColorTableEXT)(target, format, type, data);
  }

  static void REGAL_CALL glGetColorTableParameterfvEXT(GLenum target, GLenum pname, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetColorTableParameterfvEXT),reinterpret_cast<void (*)()>(glGetColorTableParameterfvEXT),"glGetColorTableParameterfvEXT");
    _driver.call(&_driver.glGetColorTableParameterfvEXT)(target, pname, params);
  }

  static void REGAL_CALL glGetColorTableParameterivEXT(GLenum target, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetColorTableParameterivEXT),reinterpret_cast<void (*)()>(glGetColorTableParameterivEXT),"glGetColorTableParameterivEXT");
    _driver.call(&_driver.glGetColorTableParameterivEXT)(target, pname, params);
  }

// GL_EXT_pixel_transform

  static void REGAL_CALL glGetPixelTransformParameterfvEXT(GLenum target, GLenum pname, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetPixelTransformParameterfvEXT),reinterpret_cast<void (*)()>(glGetPixelTransformParameterfvEXT),"glGetPixelTransformParameterfvEXT");
    _driver.call(&_driver.glGetPixelTransformParameterfvEXT)(target, pname, params);
  }

  static void REGAL_CALL glGetPixelTransformParameterivEXT(GLenum target, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetPixelTransformParameterivEXT),reinterpret_cast<void (*)()>(glGetPixelTransformParameterivEXT),"glGetPixelTransformParameterivEXT");
    _driver.call(&_driver.glGetPixelTransformParameterivEXT)(target, pname, params);
  }

  static void REGAL_CALL glPixelTransformParameterfEXT(GLenum target, GLenum pname, const GLfloat param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPixelTransformParameterfEXT),reinterpret_cast<void (*)()>(glPixelTransformParameterfEXT),"glPixelTransformParameterfEXT");
    _driver.call(&_driver.glPixelTransformParameterfEXT)(target, pname, param);
  }

  static void REGAL_CALL glPixelTransformParameterfvEXT(GLenum target, GLenum pname, const GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPixelTransformParameterfvEXT),reinterpret_cast<void (*)()>(glPixelTransformParameterfvEXT),"glPixelTransformParameterfvEXT");
    _driver.call(&_driver.glPixelTransformParameterfvEXT)(target, pname, params);
  }

  static void REGAL_CALL glPixelTransformParameteriEXT(GLenum target, GLenum pname, const GLint param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPixelTransformParameteriEXT),reinterpret_cast<void (*)()>(glPixelTransformParameteriEXT),"glPixelTransformParameteriEXT");
    _driver.call(&_driver.glPixelTransformParameteriEXT)(target, pname, param);
  }

  static void REGAL_CALL glPixelTransformParameterivEXT(GLenum target, GLenum pname, const GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPixelTransformParameterivEXT),reinterpret_cast<void (*)()>(glPixelTransformParameterivEXT),"glPixelTransformParameterivEXT");
    _driver.call(&_driver.glPixelTransformParameterivEXT)(target, pname, params);
  }

// GL_EXT_point_parameters

  static void REGAL_CALL glPointParameterfEXT(GLenum pname, GLfloat param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPointParameterfEXT),reinterpret_cast<void (*)()>(glPointParameterfEXT),"glPointParameterfEXT");
    _driver.call(&_driver.glPointParameterfEXT)(pname, param);
  }

  static void REGAL_CALL glPointParameterfvEXT(GLenum pname, const GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPointParameterfvEXT),reinterpret_cast<void (*)()>(glPointParameterfvEXT),"glPointParameterfvEXT");
    _driver.call(&_driver.glPointParameterfvEXT)(pname, params);
  }

// GL_EXT_polygon_offset

  static void REGAL_CALL glPolygonOffsetEXT(GLfloat factor, GLfloat bias)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPolygonOffsetEXT),reinterpret_cast<void (*)()>(glPolygonOffsetEXT),"glPolygonOffsetEXT");
    _driver.call(&_driver.glPolygonOffsetEXT)(factor, bias);
  }

// GL_EXT_provoking_vertex

  static void REGAL_CALL glProvokingVertexEXT(GLenum mode)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProvokingVertexEXT),reinterpret_cast<void (*)()>(glProvokingVertexEXT),"glProvokingVertexEXT");
    _driver.call(&_driver.glProvokingVertexEXT)(mode);
  }

// GL_EXT_robustness

  static void REGAL_CALL glGetnUniformfvEXT(GLuint program, GLint location, GLsizei bufSize, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetnUniformfvEXT),reinterpret_cast<void (*)()>(glGetnUniformfvEXT),"glGetnUniformfvEXT");
    _driver.call(&_driver.glGetnUniformfvEXT)(program, location, bufSize, params);
  }

  static void REGAL_CALL glGetnUniformivEXT(GLuint program, GLint location, GLsizei bufSize, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetnUniformivEXT),reinterpret_cast<void (*)()>(glGetnUniformivEXT),"glGetnUniformivEXT");
    _driver.call(&_driver.glGetnUniformivEXT)(program, location, bufSize, params);
  }

  static void REGAL_CALL glReadnPixelsEXT(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, GLvoid *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glReadnPixelsEXT),reinterpret_cast<void (*)()>(glReadnPixelsEXT),"glReadnPixelsEXT");
    _driver.call(&_driver.glReadnPixelsEXT)(x, y, width, height, format, type, bufSize, data);
  }

// GL_EXT_scene_marker

  static void REGAL_CALL glBeginSceneEXT(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBeginSceneEXT),reinterpret_cast<void (*)()>(glBeginSceneEXT),"glBeginSceneEXT");
    _driver.call(&_driver.glBeginSceneEXT)();
  }

  static void REGAL_CALL glEndSceneEXT(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glEndSceneEXT),reinterpret_cast<void (*)()>(glEndSceneEXT),"glEndSceneEXT");
    _driver.call(&_driver.glEndSceneEXT)();
  }

// GL_EXT_secondary_color

  static void REGAL_CALL glSecondaryColor3bEXT(GLbyte red, GLbyte green, GLbyte blue)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSecondaryColor3bEXT),reinterpret_cast<void (*)()>(glSecondaryColor3bEXT),"glSecondaryColor3bEXT");
    _driver.call(&_driver.glSecondaryColor3bEXT)(red, green, blue);
  }

  static void REGAL_CALL glSecondaryColor3bvEXT(const GLbyte *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSecondaryColor3bvEXT),reinterpret_cast<void (*)()>(glSecondaryColor3bvEXT),"glSecondaryColor3bvEXT");
    _driver.call(&_driver.glSecondaryColor3bvEXT)(v);
  }

  static void REGAL_CALL glSecondaryColor3dEXT(GLdouble red, GLdouble green, GLdouble blue)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSecondaryColor3dEXT),reinterpret_cast<void (*)()>(glSecondaryColor3dEXT),"glSecondaryColor3dEXT");
    _driver.call(&_driver.glSecondaryColor3dEXT)(red, green, blue);
  }

  static void REGAL_CALL glSecondaryColor3dvEXT(const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSecondaryColor3dvEXT),reinterpret_cast<void (*)()>(glSecondaryColor3dvEXT),"glSecondaryColor3dvEXT");
    _driver.call(&_driver.glSecondaryColor3dvEXT)(v);
  }

  static void REGAL_CALL glSecondaryColor3fEXT(GLfloat red, GLfloat green, GLfloat blue)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSecondaryColor3fEXT),reinterpret_cast<void (*)()>(glSecondaryColor3fEXT),"glSecondaryColor3fEXT");
    _driver.call(&_driver.glSecondaryColor3fEXT)(red, green, blue);
  }

  static void REGAL_CALL glSecondaryColor3fvEXT(const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSecondaryColor3fvEXT),reinterpret_cast<void (*)()>(glSecondaryColor3fvEXT),"glSecondaryColor3fvEXT");
    _driver.call(&_driver.glSecondaryColor3fvEXT)(v);
  }

  static void REGAL_CALL glSecondaryColor3iEXT(GLint red, GLint green, GLint blue)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSecondaryColor3iEXT),reinterpret_cast<void (*)()>(glSecondaryColor3iEXT),"glSecondaryColor3iEXT");
    _driver.call(&_driver.glSecondaryColor3iEXT)(red, green, blue);
  }

  static void REGAL_CALL glSecondaryColor3ivEXT(const GLint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSecondaryColor3ivEXT),reinterpret_cast<void (*)()>(glSecondaryColor3ivEXT),"glSecondaryColor3ivEXT");
    _driver.call(&_driver.glSecondaryColor3ivEXT)(v);
  }

  static void REGAL_CALL glSecondaryColor3sEXT(GLshort red, GLshort green, GLshort blue)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSecondaryColor3sEXT),reinterpret_cast<void (*)()>(glSecondaryColor3sEXT),"glSecondaryColor3sEXT");
    _driver.call(&_driver.glSecondaryColor3sEXT)(red, green, blue);
  }

  static void REGAL_CALL glSecondaryColor3svEXT(const GLshort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSecondaryColor3svEXT),reinterpret_cast<void (*)()>(glSecondaryColor3svEXT),"glSecondaryColor3svEXT");
    _driver.call(&_driver.glSecondaryColor3svEXT)(v);
  }

  static void REGAL_CALL glSecondaryColor3ubEXT(GLubyte red, GLubyte green, GLubyte blue)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSecondaryColor3ubEXT),reinterpret_cast<void (*)()>(glSecondaryColor3ubEXT),"glSecondaryColor3ubEXT");
    _driver.call(&_driver.glSecondaryColor3ubEXT)(red, green, blue);
  }

  static void REGAL_CALL glSecondaryColor3ubvEXT(const GLubyte *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSecondaryColor3ubvEXT),reinterpret_cast<void (*)()>(glSecondaryColor3ubvEXT),"glSecondaryColor3ubvEXT");
    _driver.call(&_driver.glSecondaryColor3ubvEXT)(v);
  }

  static void REGAL_CALL glSecondaryColor3uiEXT(GLuint red, GLuint green, GLuint blue)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSecondaryColor3uiEXT),reinterpret_cast<void (*)()>(glSecondaryColor3uiEXT),"glSecondaryColor3uiEXT");
    _driver.call(&_driver.glSecondaryColor3uiEXT)(red, green, blue);
  }

  static void REGAL_CALL glSecondaryColor3uivEXT(const GLuint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSecondaryColor3uivEXT),reinterpret_cast<void (*)()>(glSecondaryColor3uivEXT),"glSecondaryColor3uivEXT");
    _driver.call(&_driver.glSecondaryColor3uivEXT)(v);
  }

  static void REGAL_CALL glSecondaryColor3usEXT(GLushort red, GLushort green, GLushort blue)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSecondaryColor3usEXT),reinterpret_cast<void (*)()>(glSecondaryColor3usEXT),"glSecondaryColor3usEXT");
    _driver.call(&_driver.glSecondaryColor3usEXT)(red, green, blue);
  }

  static void REGAL_CALL glSecondaryColor3usvEXT(const GLushort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSecondaryColor3usvEXT),reinterpret_cast<void (*)()>(glSecondaryColor3usvEXT),"glSecondaryColor3usvEXT");
    _driver.call(&_driver.glSecondaryColor3usvEXT)(v);
  }

  static void REGAL_CALL glSecondaryColorPointerEXT(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSecondaryColorPointerEXT),reinterpret_cast<void (*)()>(glSecondaryColorPointerEXT),"glSecondaryColorPointerEXT");
    _driver.call(&_driver.glSecondaryColorPointerEXT)(size, type, stride, pointer);
  }

// GL_EXT_separate_shader_objects

  static void REGAL_CALL glActiveProgramEXT(GLuint program)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glActiveProgramEXT),reinterpret_cast<void (*)()>(glActiveProgramEXT),"glActiveProgramEXT");
    _driver.call(&_driver.glActiveProgramEXT)(program);
  }

  static GLuint REGAL_CALL glCreateShaderProgramEXT(GLenum type, const GLchar *string)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCreateShaderProgramEXT),reinterpret_cast<void (*)()>(glCreateShaderProgramEXT),"glCreateShaderProgramEXT");
    return _driver.call(&_driver.glCreateShaderProgramEXT)(type, string);
  }

  static void REGAL_CALL glUseShaderProgramEXT(GLenum type, GLuint program)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUseShaderProgramEXT),reinterpret_cast<void (*)()>(glUseShaderProgramEXT),"glUseShaderProgramEXT");
    _driver.call(&_driver.glUseShaderProgramEXT)(type, program);
  }

// GL_EXT_shader_image_load_store

  static void REGAL_CALL glBindImageTextureEXT(GLuint index, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLint format)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBindImageTextureEXT),reinterpret_cast<void (*)()>(glBindImageTextureEXT),"glBindImageTextureEXT");
    _driver.call(&_driver.glBindImageTextureEXT)(index, texture, level, layered, layer, access, format);
  }

  static void REGAL_CALL glMemoryBarrierEXT(GLbitfield barriers)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMemoryBarrierEXT),reinterpret_cast<void (*)()>(glMemoryBarrierEXT),"glMemoryBarrierEXT");
    _driver.call(&_driver.glMemoryBarrierEXT)(barriers);
  }

// GL_EXT_stencil_clear_tag

  static void REGAL_CALL glStencilClearTagEXT(GLsizei stencilTagBits, GLuint stencilClearTag)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glStencilClearTagEXT),reinterpret_cast<void (*)()>(glStencilClearTagEXT),"glStencilClearTagEXT");
    _driver.call(&_driver.glStencilClearTagEXT)(stencilTagBits, stencilClearTag);
  }

// GL_EXT_stencil_two_side

  static void REGAL_CALL glActiveStencilFaceEXT(GLenum face)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glActiveStencilFaceEXT),reinterpret_cast<void (*)()>(glActiveStencilFaceEXT),"glActiveStencilFaceEXT");
    _driver.call(&_driver.glActiveStencilFaceEXT)(face);
  }

// GL_EXT_subtexture

  static void REGAL_CALL glTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexSubImage1DEXT),reinterpret_cast<void (*)()>(glTexSubImage1DEXT),"glTexSubImage1DEXT");
    _driver.call(&_driver.glTexSubImage1DEXT)(target, level, xoffset, width, format, type, pixels);
  }

  static void REGAL_CALL glTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexSubImage2DEXT),reinterpret_cast<void (*)()>(glTexSubImage2DEXT),"glTexSubImage2DEXT");
    _driver.call(&_driver.glTexSubImage2DEXT)(target, level, xoffset, yoffset, width, height, format, type, pixels);
  }

  static void REGAL_CALL glTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexSubImage3DEXT),reinterpret_cast<void (*)()>(glTexSubImage3DEXT),"glTexSubImage3DEXT");
    _driver.call(&_driver.glTexSubImage3DEXT)(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
  }

// GL_EXT_texture3D

  static void REGAL_CALL glTexImage3DEXT(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexImage3DEXT),reinterpret_cast<void (*)()>(glTexImage3DEXT),"glTexImage3DEXT");
    _driver.call(&_driver.glTexImage3DEXT)(target, level, internalformat, width, height, depth, border, format, type, pixels);
  }

// GL_EXT_texture_array

  static void REGAL_CALL glFramebufferTextureLayerEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFramebufferTextureLayerEXT),reinterpret_cast<void (*)()>(glFramebufferTextureLayerEXT),"glFramebufferTextureLayerEXT");
    _driver.call(&_driver.glFramebufferTextureLayerEXT)(target, attachment, texture, level, layer);
  }

// GL_EXT_texture_buffer_object

  static void REGAL_CALL glTexBufferEXT(GLenum target, GLenum internalformat, GLuint buffer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexBufferEXT),reinterpret_cast<void (*)()>(glTexBufferEXT),"glTexBufferEXT");
    _driver.call(&_driver.glTexBufferEXT)(target, internalformat, buffer);
  }

// GL_EXT_texture_integer

  static void REGAL_CALL glClearColorIiEXT(GLint red, GLint green, GLint blue, GLint alpha)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glClearColorIiEXT),reinterpret_cast<void (*)()>(glClearColorIiEXT),"glClearColorIiEXT");
    _driver.call(&_driver.glClearColorIiEXT)(red, green, blue, alpha);
  }

  static void REGAL_CALL glClearColorIuiEXT(GLuint red, GLuint green, GLuint blue, GLuint alpha)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glClearColorIuiEXT),reinterpret_cast<void (*)()>(glClearColorIuiEXT),"glClearColorIuiEXT");
    _driver.call(&_driver.glClearColorIuiEXT)(red, green, blue, alpha);
  }

  static void REGAL_CALL glGetTexParameterIivEXT(GLenum target, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetTexParameterIivEXT),reinterpret_cast<void (*)()>(glGetTexParameterIivEXT),"glGetTexParameterIivEXT");
    _driver.call(&_driver.glGetTexParameterIivEXT)(target, pname, params);
  }

  static void REGAL_CALL glGetTexParameterIuivEXT(GLenum target, GLenum pname, GLuint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetTexParameterIuivEXT),reinterpret_cast<void (*)()>(glGetTexParameterIuivEXT),"glGetTexParameterIuivEXT");
    _driver.call(&_driver.glGetTexParameterIuivEXT)(target, pname, params);
  }

  static void REGAL_CALL glTexParameterIivEXT(GLenum target, GLenum pname, const GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexParameterIivEXT),reinterpret_cast<void (*)()>(glTexParameterIivEXT),"glTexParameterIivEXT");
    _driver.call(&_driver.glTexParameterIivEXT)(target, pname, params);
  }

  static void REGAL_CALL glTexParameterIuivEXT(GLenum target, GLenum pname, const GLuint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexParameterIuivEXT),reinterpret_cast<void (*)()>(glTexParameterIuivEXT),"glTexParameterIuivEXT");
    _driver.call(&_driver.glTexParameterIuivEXT)(target, pname, params);
  }

// GL_EXT_texture_object

  static GLboolean REGAL_CALL glAreTexturesResidentEXT(GLsizei n, const GLuint *textures, GLboolean *residences)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glAreTexturesResidentEXT),reinterpret_cast<void (*)()>(glAreTexturesResidentEXT),"glAreTexturesResidentEXT");
    return _driver.call(&_driver.glAreTexturesResidentEXT)(n, textures, residences);
  }

  static void REGAL_CALL glBindTextureEXT(GLenum target, GLuint texture)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBindTextureEXT),reinterpret_cast<void (*)()>(glBindTextureEXT),"glBindTextureEXT");
    _driver.call(&_driver.glBindTextureEXT)(target, texture);
  }

  static void REGAL_CALL glDeleteTexturesEXT(GLsizei n, const GLuint *textures)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDeleteTexturesEXT),reinterpret_cast<void (*)()>(glDeleteTexturesEXT),"glDeleteTexturesEXT");
    _driver.call(&_driver.glDeleteTexturesEXT)(n, textures);
  }

  static void REGAL_CALL glGenTexturesEXT(GLsizei n, GLuint *textures)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGenTexturesEXT),reinterpret_cast<void (*)()>(glGenTexturesEXT),"glGenTexturesEXT");
    _driver.call(&_driver.glGenTexturesEXT)(n, textures);
  }

  static GLboolean REGAL_CALL glIsTextureEXT(GLuint texture)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIsTextureEXT),reinterpret_cast<void (*)()>(glIsTextureEXT),"glIsTextureEXT");
    return _driver.call(&_driver.glIsTextureEXT)(texture);
  }

  static void REGAL_CALL glPrioritizeTexturesEXT(GLsizei n, const GLuint *textures, const GLclampf *priorities)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPrioritizeTexturesEXT),reinterpret_cast<void (*)()>(glPrioritizeTexturesEXT),"glPrioritizeTexturesEXT");
    _driver.call(&_driver.glPrioritizeTexturesEXT)(n, textures, priorities);
  }

// GL_EXT_texture_perturb_normal

  static void REGAL_CALL glTextureNormalEXT(GLenum mode)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTextureNormalEXT),reinterpret_cast<void (*)()>(glTextureNormalEXT),"glTextureNormalEXT");
    _driver.call(&_driver.glTextureNormalEXT)(mode);
  }

// GL_EXT_texture_storage

  static void REGAL_CALL glTexStorage1DEXT(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexStorage1DEXT),reinterpret_cast<void (*)()>(glTexStorage1DEXT),"glTexStorage1DEXT");
    _driver.call(&_driver.glTexStorage1DEXT)(target, levels, internalformat, width);
  }

  static void REGAL_CALL glTexStorage2DEXT(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexStorage2DEXT),reinterpret_cast<void (*)()>(glTexStorage2DEXT),"glTexStorage2DEXT");
    _driver.call(&_driver.glTexStorage2DEXT)(target, levels, internalformat, width, height);
  }

  static void REGAL_CALL glTexStorage3DEXT(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexStorage3DEXT),reinterpret_cast<void (*)()>(glTexStorage3DEXT),"glTexStorage3DEXT");
    _driver.call(&_driver.glTexStorage3DEXT)(target, levels, internalformat, width, height, depth);
  }

// GL_EXT_timer_query

  static void REGAL_CALL glGetQueryObjecti64vEXT(GLuint id, GLenum pname, GLint64EXT *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetQueryObjecti64vEXT),reinterpret_cast<void (*)()>(glGetQueryObjecti64vEXT),"glGetQueryObjecti64vEXT");
    _driver.call(&_driver.glGetQueryObjecti64vEXT)(id, pname, params);
  }

  static void REGAL_CALL glGetQueryObjectui64vEXT(GLuint id, GLenum pname, GLuint64EXT *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetQueryObjectui64vEXT),reinterpret_cast<void (*)()>(glGetQueryObjectui64vEXT),"glGetQueryObjectui64vEXT");
    _driver.call(&_driver.glGetQueryObjectui64vEXT)(id, pname, params);
  }

// GL_EXT_transform_feedback

  static void REGAL_CALL glBeginTransformFeedbackEXT(GLenum primitiveMode)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBeginTransformFeedbackEXT),reinterpret_cast<void (*)()>(glBeginTransformFeedbackEXT),"glBeginTransformFeedbackEXT");
    _driver.call(&_driver.glBeginTransformFeedbackEXT)(primitiveMode);
  }

  static void REGAL_CALL glBindBufferBaseEXT(GLenum target, GLuint index, GLuint buffer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBindBufferBaseEXT),reinterpret_cast<void (*)()>(glBindBufferBaseEXT),"glBindBufferBaseEXT");
    _driver.call(&_driver.glBindBufferBaseEXT)(target, index, buffer);
  }

  static void REGAL_CALL glBindBufferOffsetEXT(GLenum target, GLuint index, GLuint buffer, GLintptr offset)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBindBufferOffsetEXT),reinterpret_cast<void (*)()>(glBindBufferOffsetEXT),"glBindBufferOffsetEXT");
    _driver.call(&_driver.glBindBufferOffsetEXT)(target, index, buffer, offset);
  }

  static void REGAL_CALL glBindBufferRangeEXT(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBindBufferRangeEXT),reinterpret_cast<void (*)()>(glBindBufferRangeEXT),"glBindBufferRangeEXT");
    _driver.call(&_driver.glBindBufferRangeEXT)(target, index, buffer, offset, size);
  }

  static void REGAL_CALL glEndTransformFeedbackEXT(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glEndTransformFeedbackEXT),reinterpret_cast<void (*)()>(glEndTransformFeedbackEXT),"glEndTransformFeedbackEXT");
    _driver.call(&_driver.glEndTransformFeedbackEXT)();
  }

  static void REGAL_CALL glGetTransformFeedbackVaryingEXT(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetTransformFeedbackVaryingEXT),reinterpret_cast<void (*)()>(glGetTransformFeedbackVaryingEXT),"glGetTransformFeedbackVaryingEXT");
    _driver.call(&_driver.glGetTransformFeedbackVaryingEXT)(program, index, bufSize, length, size, type, name);
  }

  static void REGAL_CALL glTransformFeedbackVaryingsEXT(GLuint program, GLsizei count, const GLchar ** const varyings, GLenum bufferMode)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTransformFeedbackVaryingsEXT),reinterpret_cast<void (*)()>(glTransformFeedbackVaryingsEXT),"glTransformFeedbackVaryingsEXT");
    _driver.call(&_driver.glTransformFeedbackVaryingsEXT)(program, count, varyings, bufferMode);
  }

// GL_EXT_vertex_array

  static void REGAL_CALL glArrayElementEXT(GLint i)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glArrayElementEXT),reinterpret_cast<void (*)()>(glArrayElementEXT),"glArrayElementEXT");
    _driver.call(&_driver.glArrayElementEXT)(i);
  }

  static void REGAL_CALL glColorPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColorPointerEXT),reinterpret_cast<void (*)()>(glColorPointerEXT),"glColorPointerEXT");
    _driver.call(&_driver.glColorPointerEXT)(size, type, stride, count, pointer);
  }

  static void REGAL_CALL glDrawArraysEXT(GLenum mode, GLint first, GLsizei count)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDrawArraysEXT),reinterpret_cast<void (*)()>(glDrawArraysEXT),"glDrawArraysEXT");
    _driver.call(&_driver.glDrawArraysEXT)(mode, first, count);
  }

  static void REGAL_CALL glEdgeFlagPointerEXT(GLsizei stride, GLsizei count, const GLboolean *pointer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glEdgeFlagPointerEXT),reinterpret_cast<void (*)()>(glEdgeFlagPointerEXT),"glEdgeFlagPointerEXT");
    _driver.call(&_driver.glEdgeFlagPointerEXT)(stride, count, pointer);
  }

  static void REGAL_CALL glGetPointervEXT(GLenum pname, GLvoid **params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetPointervEXT),reinterpret_cast<void (*)()>(glGetPointervEXT),"glGetPointervEXT");
    _driver.call(&_driver.glGetPointervEXT)(pname, params);
  }

  static void REGAL_CALL glIndexPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIndexPointerEXT),reinterpret_cast<void (*)()>(glIndexPointerEXT),"glIndexPointerEXT");
    _driver.call(&_driver.glIndexPointerEXT)(type, stride, count, pointer);
  }

  static void REGAL_CALL glNormalPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNormalPointerEXT),reinterpret_cast<void (*)()>(glNormalPointerEXT),"glNormalPointerEXT");
    _driver.call(&_driver.glNormalPointerEXT)(type, stride, count, pointer);
  }

  static void REGAL_CALL glTexCoordPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoordPointerEXT),reinterpret_cast<void (*)()>(glTexCoordPointerEXT),"glTexCoordPointerEXT");
    _driver.call(&_driver.glTexCoordPointerEXT)(size, type, stride, count, pointer);
  }

  static void REGAL_CALL glVertexPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexPointerEXT),reinterpret_cast<void (*)()>(glVertexPointerEXT),"glVertexPointerEXT");
    _driver.call(&_driver.glVertexPointerEXT)(size, type, stride, count, pointer);
  }

// GL_EXT_vertex_attrib_64bit

  static void REGAL_CALL glGetVertexAttribLdvEXT(GLuint index, GLenum pname, GLdouble *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetVertexAttribLdvEXT),reinterpret_cast<void (*)()>(glGetVertexAttribLdvEXT),"glGetVertexAttribLdvEXT");
    _driver.call(&_driver.glGetVertexAttribLdvEXT)(index, pname, params);
  }

  static void REGAL_CALL glVertexArrayVertexAttribLOffsetEXT(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexArrayVertexAttribLOffsetEXT),reinterpret_cast<void (*)()>(glVertexArrayVertexAttribLOffsetEXT),"glVertexArrayVertexAttribLOffsetEXT");
    _driver.call(&_driver.glVertexArrayVertexAttribLOffsetEXT)(vaobj, buffer, index, size, type, stride, offset);
  }

  static void REGAL_CALL glVertexAttribL1dEXT(GLuint index, GLdouble x)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribL1dEXT),reinterpret_cast<void (*)()>(glVertexAttribL1dEXT),"glVertexAttribL1dEXT");
    _driver.call(&_driver.glVertexAttribL1dEXT)(index, x);
  }

  static void REGAL_CALL glVertexAttribL1dvEXT(GLuint index, const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribL1dvEXT),reinterpret_cast<void (*)()>(glVertexAttribL1dvEXT),"glVertexAttribL1dvEXT");
    _driver.call(&_driver.glVertexAttribL1dvEXT)(index, v);
  }

  static void REGAL_CALL glVertexAttribL2dEXT(GLuint index, GLdouble x, GLdouble y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribL2dEXT),reinterpret_cast<void (*)()>(glVertexAttribL2dEXT),"glVertexAttribL2dEXT");
    _driver.call(&_driver.glVertexAttribL2dEXT)(index, x, y);
  }

  static void REGAL_CALL glVertexAttribL2dvEXT(GLuint index, const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribL2dvEXT),reinterpret_cast<void (*)()>(glVertexAttribL2dvEXT),"glVertexAttribL2dvEXT");
    _driver.call(&_driver.glVertexAttribL2dvEXT)(index, v);
  }

  static void REGAL_CALL glVertexAttribL3dEXT(GLuint index, GLdouble x, GLdouble y, GLdouble z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribL3dEXT),reinterpret_cast<void (*)()>(glVertexAttribL3dEXT),"glVertexAttribL3dEXT");
    _driver.call(&_driver.glVertexAttribL3dEXT)(index, x, y, z);
  }

  static void REGAL_CALL glVertexAttribL3dvEXT(GLuint index, const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribL3dvEXT),reinterpret_cast<void (*)()>(glVertexAttribL3dvEXT),"glVertexAttribL3dvEXT");
    _driver.call(&_driver.glVertexAttribL3dvEXT)(index, v);
  }

  static void REGAL_CALL glVertexAttribL4dEXT(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribL4dEXT),reinterpret_cast<void (*)()>(glVertexAttribL4dEXT),"glVertexAttribL4dEXT");
    _driver.call(&_driver.glVertexAttribL4dEXT)(index, x, y, z, w);
  }

  static void REGAL_CALL glVertexAttribL4dvEXT(GLuint index, const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribL4dvEXT),reinterpret_cast<void (*)()>(glVertexAttribL4dvEXT),"glVertexAttribL4dvEXT");
    _driver.call(&_driver.glVertexAttribL4dvEXT)(index, v);
  }

  static void REGAL_CALL glVertexAttribLPointerEXT(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribLPointerEXT),reinterpret_cast<void (*)()>(glVertexAttribLPointerEXT),"glVertexAttribLPointerEXT");
    _driver.call(&_driver.glVertexAttribLPointerEXT)(index, size, type, stride, pointer);
  }

// GL_EXT_vertex_shader

  static void REGAL_CALL glBeginVertexShaderEXT(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBeginVertexShaderEXT),reinterpret_cast<void (*)()>(glBeginVertexShaderEXT),"glBeginVertexShaderEXT");
    _driver.call(&_driver.glBeginVertexShaderEXT)();
  }

  static GLuint REGAL_CALL glBindLightParameterEXT(GLenum light, GLenum value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBindLightParameterEXT),reinterpret_cast<void (*)()>(glBindLightParameterEXT),"glBindLightParameterEXT");
    return _driver.call(&_driver.glBindLightParameterEXT)(light, value);
  }

  static GLuint REGAL_CALL glBindMaterialParameterEXT(GLenum face, GLenum value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBindMaterialParameterEXT),reinterpret_cast<void (*)()>(glBindMaterialParameterEXT),"glBindMaterialParameterEXT");
    return _driver.call(&_driver.glBindMaterialParameterEXT)(face, value);
  }

  static GLuint REGAL_CALL glBindParameterEXT(GLenum value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBindParameterEXT),reinterpret_cast<void (*)()>(glBindParameterEXT),"glBindParameterEXT");
    return _driver.call(&_driver.glBindParameterEXT)(value);
  }

  static GLuint REGAL_CALL glBindTexGenParameterEXT(GLenum unit, GLenum coord, GLenum value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBindTexGenParameterEXT),reinterpret_cast<void (*)()>(glBindTexGenParameterEXT),"glBindTexGenParameterEXT");
    return _driver.call(&_driver.glBindTexGenParameterEXT)(unit, coord, value);
  }

  static GLuint REGAL_CALL glBindTextureUnitParameterEXT(GLenum unit, GLenum value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBindTextureUnitParameterEXT),reinterpret_cast<void (*)()>(glBindTextureUnitParameterEXT),"glBindTextureUnitParameterEXT");
    return _driver.call(&_driver.glBindTextureUnitParameterEXT)(unit, value);
  }

  static void REGAL_CALL glBindVertexShaderEXT(GLuint id)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBindVertexShaderEXT),reinterpret_cast<void (*)()>(glBindVertexShaderEXT),"glBindVertexShaderEXT");
    _driver.call(&_driver.glBindVertexShaderEXT)(id);
  }

  static void REGAL_CALL glDeleteVertexShaderEXT(GLuint id)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDeleteVertexShaderEXT),reinterpret_cast<void (*)()>(glDeleteVertexShaderEXT),"glDeleteVertexShaderEXT");
    _driver.call(&_driver.glDeleteVertexShaderEXT)(id);
  }

  static void REGAL_CALL glDisableVariantClientStateEXT(GLuint id)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDisableVariantClientStateEXT),reinterpret_cast<void (*)()>(glDisableVariantClientStateEXT),"glDisableVariantClientStateEXT");
    _driver.call(&_driver.glDisableVariantClientStateEXT)(id);
  }

  static void REGAL_CALL glEnableVariantClientStateEXT(GLuint id)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glEnableVariantClientStateEXT),reinterpret_cast<void (*)()>(glEnableVariantClientStateEXT),"glEnableVariantClientStateEXT");
    _driver.call(&_driver.glEnableVariantClientStateEXT)(id);
  }

  static void REGAL_CALL glEndVertexShaderEXT(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glEndVertexShaderEXT),reinterpret_cast<void (*)()>(glEndVertexShaderEXT),"glEndVertexShaderEXT");
    _driver.call(&_driver.glEndVertexShaderEXT)();
  }

  static void REGAL_CALL glExtractComponentEXT(GLuint res, GLuint src, GLuint num)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glExtractComponentEXT),reinterpret_cast<void (*)()>(glExtractComponentEXT),"glExtractComponentEXT");
    _driver.call(&_driver.glExtractComponentEXT)(res, src, num);
  }

  static GLuint REGAL_CALL glGenSymbolsEXT(GLenum datatype, GLenum storagetype, GLenum range, GLuint components)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGenSymbolsEXT),reinterpret_cast<void (*)()>(glGenSymbolsEXT),"glGenSymbolsEXT");
    return _driver.call(&_driver.glGenSymbolsEXT)(datatype, storagetype, range, components);
  }

  static GLuint REGAL_CALL glGenVertexShadersEXT(GLuint range)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGenVertexShadersEXT),reinterpret_cast<void (*)()>(glGenVertexShadersEXT),"glGenVertexShadersEXT");
    return _driver.call(&_driver.glGenVertexShadersEXT)(range);
  }

  static void REGAL_CALL glGetInvariantBooleanvEXT(GLuint id, GLenum value, GLboolean *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetInvariantBooleanvEXT),reinterpret_cast<void (*)()>(glGetInvariantBooleanvEXT),"glGetInvariantBooleanvEXT");
    _driver.call(&_driver.glGetInvariantBooleanvEXT)(id, value, data);
  }

  static void REGAL_CALL glGetInvariantFloatvEXT(GLuint id, GLenum value, GLfloat *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetInvariantFloatvEXT),reinterpret_cast<void (*)()>(glGetInvariantFloatvEXT),"glGetInvariantFloatvEXT");
    _driver.call(&_driver.glGetInvariantFloatvEXT)(id, value, data);
  }

  static void REGAL_CALL glGetInvariantIntegervEXT(GLuint id, GLenum value, GLint *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetInvariantIntegervEXT),reinterpret_cast<void (*)()>(glGetInvariantIntegervEXT),"glGetInvariantIntegervEXT");
    _driver.call(&_driver.glGetInvariantIntegervEXT)(id, value, data);
  }

  static void REGAL_CALL glGetLocalConstantBooleanvEXT(GLuint id, GLenum value, GLboolean *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetLocalConstantBooleanvEXT),reinterpret_cast<void (*)()>(glGetLocalConstantBooleanvEXT),"glGetLocalConstantBooleanvEXT");
    _driver.call(&_driver.glGetLocalConstantBooleanvEXT)(id, value, data);
  }

  static void REGAL_CALL glGetLocalConstantFloatvEXT(GLuint id, GLenum value, GLfloat *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetLocalConstantFloatvEXT),reinterpret_cast<void (*)()>(glGetLocalConstantFloatvEXT),"glGetLocalConstantFloatvEXT");
    _driver.call(&_driver.glGetLocalConstantFloatvEXT)(id, value, data);
  }

  static void REGAL_CALL glGetLocalConstantIntegervEXT(GLuint id, GLenum value, GLint *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetLocalConstantIntegervEXT),reinterpret_cast<void (*)()>(glGetLocalConstantIntegervEXT),"glGetLocalConstantIntegervEXT");
    _driver.call(&_driver.glGetLocalConstantIntegervEXT)(id, value, data);
  }

  static void REGAL_CALL glGetVariantBooleanvEXT(GLuint id, GLenum value, GLboolean *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetVariantBooleanvEXT),reinterpret_cast<void (*)()>(glGetVariantBooleanvEXT),"glGetVariantBooleanvEXT");
    _driver.call(&_driver.glGetVariantBooleanvEXT)(id, value, data);
  }

  static void REGAL_CALL glGetVariantFloatvEXT(GLuint id, GLenum value, GLfloat *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetVariantFloatvEXT),reinterpret_cast<void (*)()>(glGetVariantFloatvEXT),"glGetVariantFloatvEXT");
    _driver.call(&_driver.glGetVariantFloatvEXT)(id, value, data);
  }

  static void REGAL_CALL glGetVariantIntegervEXT(GLuint id, GLenum value, GLint *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetVariantIntegervEXT),reinterpret_cast<void (*)()>(glGetVariantIntegervEXT),"glGetVariantIntegervEXT");
    _driver.call(&_driver.glGetVariantIntegervEXT)(id, value, data);
  }

  static void REGAL_CALL glGetVariantPointervEXT(GLuint id, GLenum value, GLvoid **data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetVariantPointervEXT),reinterpret_cast<void (*)()>(glGetVariantPointervEXT),"glGetVariantPointervEXT");
    _driver.call(&_driver.glGetVariantPointervEXT)(id, value, data);
  }

  static void REGAL_CALL glInsertComponentEXT(GLuint res, GLuint src, GLuint num)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glInsertComponentEXT),reinterpret_cast<void (*)()>(glInsertComponentEXT),"glInsertComponentEXT");
    _driver.call(&_driver.glInsertComponentEXT)(res, src, num);
  }

  static GLboolean REGAL_CALL glIsVariantEnabledEXT(GLuint id, GLenum cap)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIsVariantEnabledEXT),reinterpret_cast<void (*)()>(glIsVariantEnabledEXT),"glIsVariantEnabledEXT");
    return _driver.call(&_driver.glIsVariantEnabledEXT)(id, cap);
  }

  static void REGAL_CALL glSetInvariantEXT(GLuint id, GLenum type, const GLvoid *addr)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSetInvariantEXT),reinterpret_cast<void (*)()>(glSetInvariantEXT),"glSetInvariantEXT");
    _driver.call(&_driver.glSetInvariantEXT)(id, type, addr);
  }

  static void REGAL_CALL glSetLocalConstantEXT(GLuint id, GLenum type, const GLvoid *addr)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSetLocalConstantEXT),reinterpret_cast<void (*)()>(glSetLocalConstantEXT),"glSetLocalConstantEXT");
    _driver.call(&_driver.glSetLocalConstantEXT)(id, type, addr);
  }

  static void REGAL_CALL glShaderOp1EXT(GLenum op, GLuint res, GLuint arg1)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glShaderOp1EXT),reinterpret_cast<void (*)()>(glShaderOp1EXT),"glShaderOp1EXT");
    _driver.call(&_driver.glShaderOp1EXT)(op, res, arg1);
  }

  static void REGAL_CALL glShaderOp2EXT(GLenum op, GLuint res, GLuint arg1, GLuint arg2)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glShaderOp2EXT),reinterpret_cast<void (*)()>(glShaderOp2EXT),"glShaderOp2EXT");
    _driver.call(&_driver.glShaderOp2EXT)(op, res, arg1, arg2);
  }

  static void REGAL_CALL glShaderOp3EXT(GLenum op, GLuint res, GLuint arg1, GLuint arg2, GLuint arg3)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glShaderOp3EXT),reinterpret_cast<void (*)()>(glShaderOp3EXT),"glShaderOp3EXT");
    _driver.call(&_driver.glShaderOp3EXT)(op, res, arg1, arg2, arg3);
  }

  static void REGAL_CALL glSwizzleEXT(GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSwizzleEXT),reinterpret_cast<void (*)()>(glSwizzleEXT),"glSwizzleEXT");
    _driver.call(&_driver.glSwizzleEXT)(res, in, outX, outY, outZ, outW);
  }

  static void REGAL_CALL glVariantPointerEXT(GLuint id, GLenum type, GLuint stride, const GLvoid *addr)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVariantPointerEXT),reinterpret_cast<void (*)()>(glVariantPointerEXT),"glVariantPointerEXT");
    _driver.call(&_driver.glVariantPointerEXT)(id, type, stride, addr);
  }

  static void REGAL_CALL glVariantbvEXT(GLuint id, const GLbyte *addr)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVariantbvEXT),reinterpret_cast<void (*)()>(glVariantbvEXT),"glVariantbvEXT");
    _driver.call(&_driver.glVariantbvEXT)(id, addr);
  }

  static void REGAL_CALL glVariantdvEXT(GLuint id, const GLdouble *addr)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVariantdvEXT),reinterpret_cast<void (*)()>(glVariantdvEXT),"glVariantdvEXT");
    _driver.call(&_driver.glVariantdvEXT)(id, addr);
  }

  static void REGAL_CALL glVariantfvEXT(GLuint id, const GLfloat *addr)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVariantfvEXT),reinterpret_cast<void (*)()>(glVariantfvEXT),"glVariantfvEXT");
    _driver.call(&_driver.glVariantfvEXT)(id, addr);
  }

  static void REGAL_CALL glVariantivEXT(GLuint id, const GLint *addr)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVariantivEXT),reinterpret_cast<void (*)()>(glVariantivEXT),"glVariantivEXT");
    _driver.call(&_driver.glVariantivEXT)(id, addr);
  }

  static void REGAL_CALL glVariantsvEXT(GLuint id, const GLshort *addr)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVariantsvEXT),reinterpret_cast<void (*)()>(glVariantsvEXT),"glVariantsvEXT");
    _driver.call(&_driver.glVariantsvEXT)(id, addr);
  }

  static void REGAL_CALL glVariantubvEXT(GLuint id, const GLubyte *addr)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVariantubvEXT),reinterpret_cast<void (*)()>(glVariantubvEXT),"glVariantubvEXT");
    _driver.call(&_driver.glVariantubvEXT)(id, addr);
  }

  static void REGAL_CALL glVariantuivEXT(GLuint id, const GLuint *addr)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVariantuivEXT),reinterpret_cast<void (*)()>(glVariantuivEXT),"glVariantuivEXT");
    _driver.call(&_driver.glVariantuivEXT)(id, addr);
  }

  static void REGAL_CALL glVariantusvEXT(GLuint id, const GLushort *addr)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVariantusvEXT),reinterpret_cast<void (*)()>(glVariantusvEXT),"glVariantusvEXT");
    _driver.call(&_driver.glVariantusvEXT)(id, addr);
  }

  static void REGAL_CALL glWriteMaskEXT(GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWriteMaskEXT),reinterpret_cast<void (*)()>(glWriteMaskEXT),"glWriteMaskEXT");
    _driver.call(&_driver.glWriteMaskEXT)(res, in, outX, outY, outZ, outW);
  }

// GL_EXT_vertex_weighting

  static void REGAL_CALL glVertexWeightPointerEXT(GLsizei size, GLenum type, GLsizei stride, const GLvoid *pointer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexWeightPointerEXT),reinterpret_cast<void (*)()>(glVertexWeightPointerEXT),"glVertexWeightPointerEXT");
    _driver.call(&_driver.glVertexWeightPointerEXT)(size, type, stride, pointer);
  }

  static void REGAL_CALL glVertexWeightfEXT(GLfloat weight)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexWeightfEXT),reinterpret_cast<void (*)()>(glVertexWeightfEXT),"glVertexWeightfEXT");
    _driver.call(&_driver.glVertexWeightfEXT)(weight);
  }

  static void REGAL_CALL glVertexWeightfvEXT(const GLfloat *weight)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexWeightfvEXT),reinterpret_cast<void (*)()>(glVertexWeightfvEXT),"glVertexWeightfvEXT");
    _driver.call(&_driver.glVertexWeightfvEXT)(weight);
  }

// GL_EXT_x11_sync_object

  static GLsync REGAL_CALL glImportSyncEXT(GLenum external_sync_type, GLintptr external_sync, GLbitfield flags)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glImportSyncEXT),reinterpret_cast<void (*)()>(glImportSyncEXT),"glImportSyncEXT");
    return _driver.call(&_driver.glImportSyncEXT)(external_sync_type, external_sync, flags);
  }

// GL_GREMEDY_frame_terminator

  static void REGAL_CALL glFrameTerminatorGREMEDY(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFrameTerminatorGREMEDY),reinterpret_cast<void (*)()>(glFrameTerminatorGREMEDY),"glFrameTerminatorGREMEDY");
    _driver.call(&_driver.glFrameTerminatorGREMEDY)();
  }

// GL_GREMEDY_string_marker

  static void REGAL_CALL glStringMarkerGREMEDY(GLsizei len, const GLvoid *string)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glStringMarkerGREMEDY),reinterpret_cast<void (*)()>(glStringMarkerGREMEDY),"glStringMarkerGREMEDY");
    _driver.call(&_driver.glStringMarkerGREMEDY)(len, string);
  }

// GL_HP_image_transform

  static void REGAL_CALL glGetImageTransformParameterfvHP(GLenum target, GLenum pname, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetImageTransformParameterfvHP),reinterpret_cast<void (*)()>(glGetImageTransformParameterfvHP),"glGetImageTransformParameterfvHP");
    _driver.call(&_driver.glGetImageTransformParameterfvHP)(target, pname, params);
  }

  static void REGAL_CALL glGetImageTransformParameterivHP(GLenum target, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetImageTransformParameterivHP),reinterpret_cast<void (*)()>(glGetImageTransformParameterivHP),"glGetImageTransformParameterivHP");
    _driver.call(&_driver.glGetImageTransformParameterivHP)(target, pname, params);
  }

  static void REGAL_CALL glImageTransformParameterfHP(GLenum target, GLenum pname, GLfloat param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glImageTransformParameterfHP),reinterpret_cast<void (*)()>(glImageTransformParameterfHP),"glImageTransformParameterfHP");
    _driver.call(&_driver.glImageTransformParameterfHP)(target, pname, param);
  }

  static void REGAL_CALL glImageTransformParameterfvHP(GLenum target, GLenum pname, const GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glImageTransformParameterfvHP),reinterpret_cast<void (*)()>(glImageTransformParameterfvHP),"glImageTransformParameterfvHP");
    _driver.call(&_driver.glImageTransformParameterfvHP)(target, pname, params);
  }

  static void REGAL_CALL glImageTransformParameteriHP(GLenum target, GLenum pname, GLint param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glImageTransformParameteriHP),reinterpret_cast<void (*)()>(glImageTransformParameteriHP),"glImageTransformParameteriHP");
    _driver.call(&_driver.glImageTransformParameteriHP)(target, pname, param);
  }

  static void REGAL_CALL glImageTransformParameterivHP(GLenum target, GLenum pname, const GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glImageTransformParameterivHP),reinterpret_cast<void (*)()>(glImageTransformParameterivHP),"glImageTransformParameterivHP");
    _driver.call(&_driver.glImageTransformParameterivHP)(target, pname, params);
  }

// GL_IBM_multimode_draw_arrays

  static void REGAL_CALL glMultiModeDrawArraysIBM(const GLenum *mode, const GLint *first, const GLsizei *count, GLsizei primcount, GLint modestride)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiModeDrawArraysIBM),reinterpret_cast<void (*)()>(glMultiModeDrawArraysIBM),"glMultiModeDrawArraysIBM");
    _driver.call(&_driver.glMultiModeDrawArraysIBM)(mode, first, count, primcount, modestride);
  }

  static void REGAL_CALL glMultiModeDrawElementsIBM(const GLenum *mode, const GLsizei *count, GLenum type, const GLvoid * const *indices, GLsizei primcount, GLint modestride)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiModeDrawElementsIBM),reinterpret_cast<void (*)()>(glMultiModeDrawElementsIBM),"glMultiModeDrawElementsIBM");
    _driver.call(&_driver.glMultiModeDrawElementsIBM)(mode, count, type, indices, primcount, modestride);
  }

// GL_IBM_vertex_array_lists

  static void REGAL_CALL glColorPointerListIBM(GLint size, GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColorPointerListIBM),reinterpret_cast<void (*)()>(glColorPointerListIBM),"glColorPointerListIBM");
    _driver.call(&_driver.glColorPointerListIBM)(size, type, stride, pointer, ptrstride);
  }

  static void REGAL_CALL glEdgeFlagPointerListIBM(GLint stride, const GLboolean **pointer, GLint ptrstride)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glEdgeFlagPointerListIBM),reinterpret_cast<void (*)()>(glEdgeFlagPointerListIBM),"glEdgeFlagPointerListIBM");
    _driver.call(&_driver.glEdgeFlagPointerListIBM)(stride, pointer, ptrstride);
  }

  static void REGAL_CALL glFogCoordPointerListIBM(GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFogCoordPointerListIBM),reinterpret_cast<void (*)()>(glFogCoordPointerListIBM),"glFogCoordPointerListIBM");
    _driver.call(&_driver.glFogCoordPointerListIBM)(type, stride, pointer, ptrstride);
  }

  static void REGAL_CALL glIndexPointerListIBM(GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIndexPointerListIBM),reinterpret_cast<void (*)()>(glIndexPointerListIBM),"glIndexPointerListIBM");
    _driver.call(&_driver.glIndexPointerListIBM)(type, stride, pointer, ptrstride);
  }

  static void REGAL_CALL glNormalPointerListIBM(GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNormalPointerListIBM),reinterpret_cast<void (*)()>(glNormalPointerListIBM),"glNormalPointerListIBM");
    _driver.call(&_driver.glNormalPointerListIBM)(type, stride, pointer, ptrstride);
  }

  static void REGAL_CALL glSecondaryColorPointerListIBM(GLint size, GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSecondaryColorPointerListIBM),reinterpret_cast<void (*)()>(glSecondaryColorPointerListIBM),"glSecondaryColorPointerListIBM");
    _driver.call(&_driver.glSecondaryColorPointerListIBM)(size, type, stride, pointer, ptrstride);
  }

  static void REGAL_CALL glTexCoordPointerListIBM(GLint size, GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoordPointerListIBM),reinterpret_cast<void (*)()>(glTexCoordPointerListIBM),"glTexCoordPointerListIBM");
    _driver.call(&_driver.glTexCoordPointerListIBM)(size, type, stride, pointer, ptrstride);
  }

  static void REGAL_CALL glVertexPointerListIBM(GLint size, GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexPointerListIBM),reinterpret_cast<void (*)()>(glVertexPointerListIBM),"glVertexPointerListIBM");
    _driver.call(&_driver.glVertexPointerListIBM)(size, type, stride, pointer, ptrstride);
  }

// GL_IMG_multisampled_render_to_texture

  static void REGAL_CALL glFramebufferTexture2DMultisampleIMG(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFramebufferTexture2DMultisampleIMG),reinterpret_cast<void (*)()>(glFramebufferTexture2DMultisampleIMG),"glFramebufferTexture2DMultisampleIMG");
    _driver.call(&_driver.glFramebufferTexture2DMultisampleIMG)(target, attachment, textarget, texture, level, samples);
  }

  static void REGAL_CALL glRenderbufferStorageMultisampleIMG(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glRenderbufferStorageMultisampleIMG),reinterpret_cast<void (*)()>(glRenderbufferStorageMultisampleIMG),"glRenderbufferStorageMultisampleIMG");
    _driver.call(&_driver.glRenderbufferStorageMultisampleIMG)(target, samples, internalformat, width, height);
  }

// GL_INGR_blend_func_separate

  static void REGAL_CALL glBlendFuncSeparateINGR(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBlendFuncSeparateINGR),reinterpret_cast<void (*)()>(glBlendFuncSeparateINGR),"glBlendFuncSeparateINGR");
    _driver.call(&_driver.glBlendFuncSeparateINGR)(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
  }

// GL_INTEL_map_texture

  static GLvoid *REGAL_CALL glMapTexture2DINTEL(GLuint texture, GLint level, GLbitfield access, GLint *stride, GLenum *layout)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMapTexture2DINTEL),reinterpret_cast<void (*)()>(glMapTexture2DINTEL),"glMapTexture2DINTEL");
    return _driver.call(&_driver.glMapTexture2DINTEL)(texture, level, access, stride, layout);
  }

  static void REGAL_CALL glSyncTextureINTEL(GLuint texture)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSyncTextureINTEL),reinterpret_cast<void (*)()>(glSyncTextureINTEL),"glSyncTextureINTEL");
    _driver.call(&_driver.glSyncTextureINTEL)(texture);
  }

  static void REGAL_CALL glUnmapTexture2DINTEL(GLuint texture, GLint level)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUnmapTexture2DINTEL),reinterpret_cast<void (*)()>(glUnmapTexture2DINTEL),"glUnmapTexture2DINTEL");
    _driver.call(&_driver.glUnmapTexture2DINTEL)(texture, level);
  }

// GL_INTEL_parallel_arrays

  static void REGAL_CALL glColorPointervINTEL(GLint size, GLenum type, const GLvoid **pointer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColorPointervINTEL),reinterpret_cast<void (*)()>(glColorPointervINTEL),"glColorPointervINTEL");
    _driver.call(&_driver.glColorPointervINTEL)(size, type, pointer);
  }

  static void REGAL_CALL glNormalPointervINTEL(GLenum type, const GLvoid **pointer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNormalPointervINTEL),reinterpret_cast<void (*)()>(glNormalPointervINTEL),"glNormalPointervINTEL");
    _driver.call(&_driver.glNormalPointervINTEL)(type, pointer);
  }

  static void REGAL_CALL glTexCoordPointervINTEL(GLint size, GLenum type, const GLvoid **pointer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoordPointervINTEL),reinterpret_cast<void (*)()>(glTexCoordPointervINTEL),"glTexCoordPointervINTEL");
    _driver.call(&_driver.glTexCoordPointervINTEL)(size, type, pointer);
  }

  static void REGAL_CALL glVertexPointervINTEL(GLint size, GLenum type, const GLvoid **pointer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexPointervINTEL),reinterpret_cast<void (*)()>(glVertexPointervINTEL),"glVertexPointervINTEL");
    _driver.call(&_driver.glVertexPointervINTEL)(size, type, pointer);
  }

// GL_INTEL_texture_scissor

  static void REGAL_CALL glTexScissorFuncINTEL(GLenum target, GLenum lfunc, GLenum hfunc)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexScissorFuncINTEL),reinterpret_cast<void (*)()>(glTexScissorFuncINTEL),"glTexScissorFuncINTEL");
    _driver.call(&_driver.glTexScissorFuncINTEL)(target, lfunc, hfunc);
  }

  static void REGAL_CALL glTexScissorINTEL(GLenum target, GLclampf tlow, GLclampf thigh)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexScissorINTEL),reinterpret_cast<void (*)()>(glTexScissorINTEL),"glTexScissorINTEL");
    _driver.call(&_driver.glTexScissorINTEL)(target, tlow, thigh);
  }

// GL_KHR_debug

  static void REGAL_CALL glDebugMessageCallback(GLDEBUGPROC callback, const GLvoid *userParam)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDebugMessageCallback),reinterpret_cast<void (*)()>(glDebugMessageCallback),"glDebugMessageCallback");
    _driver.call(&_driver.glDebugMessageCallback)(callback, userParam);
  }

  static void REGAL_CALL glDebugMessageControl(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDebugMessageControl),reinterpret_cast<void (*)()>(glDebugMessageControl),"glDebugMessageControl");
    _driver.call(&_driver.glDebugMessageControl)(source, type, severity, count, ids, enabled);
  }

  static void REGAL_CALL glDebugMessageInsert(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDebugMessageInsert),reinterpret_cast<void (*)()>(glDebugMessageInsert),"glDebugMessageInsert");
    _driver.call(&_driver.glDebugMessageInsert)(source, type, id, severity, length, buf);
  }

  static GLuint REGAL_CALL glGetDebugMessageLog(GLuint count, GLsizei bufsize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetDebugMessageLog),reinterpret_cast<void (*)()>(glGetDebugMessageLog),"glGetDebugMessageLog");
    return _driver.call(&_driver.glGetDebugMessageLog)(count, bufsize, sources, types, ids, severities, lengths, messageLog);
  }

  static void REGAL_CALL glGetObjectLabel(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei *length, GLchar *label)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetObjectLabel),reinterpret_cast<void (*)()>(glGetObjectLabel),"glGetObjectLabel");
    _driver.call(&_driver.glGetObjectLabel)(identifier, name, bufSize, length, label);
  }

  static void REGAL_CALL glGetObjectPtrLabel(const GLvoid *ptr, GLsizei bufSize, GLsizei *length, GLchar *label)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetObjectPtrLabel),reinterpret_cast<void (*)()>(glGetObjectPtrLabel),"glGetObjectPtrLabel");
    _driver.call(&_driver.glGetObjectPtrLabel)(ptr, bufSize, length, label);
  }

  static void REGAL_CALL glObjectLabel(GLenum identifier, GLuint name, GLsizei length, const GLchar *label)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glObjectLabel),reinterpret_cast<void (*)()>(glObjectLabel),"glObjectLabel");
    _driver.call(&_driver.glObjectLabel)(identifier, name, length, label);
  }

  static void REGAL_CALL glObjectPtrLabel(const GLvoid *ptr, GLsizei length, const GLchar *label)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glObjectPtrLabel),reinterpret_cast<void (*)()>(glObjectPtrLabel),"glObjectPtrLabel");
    _driver.call(&_driver.glObjectPtrLabel)(ptr, length, label);
  }

  static void REGAL_CALL glPopDebugGroup(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPopDebugGroup),reinterpret_cast<void (*)()>(glPopDebugGroup),"glPopDebugGroup");
    _driver.call(&_driver.glPopDebugGroup)();
  }

  static void REGAL_CALL glPushDebugGroup(GLenum source, GLuint id, GLsizei length, const GLchar *message)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPushDebugGroup),reinterpret_cast<void (*)()>(glPushDebugGroup),"glPushDebugGroup");
    _driver.call(&_driver.glPushDebugGroup)(source, id, length, message);
  }

// GL_KTX_buffer_region

  static GLuint REGAL_CALL glBufferRegionEnabled(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBufferRegionEnabled),reinterpret_cast<void (*)()>(glBufferRegionEnabled),"glBufferRegionEnabled");
    return _driver.call(&_driver.glBufferRegionEnabled)();
  }

  static void REGAL_CALL glDeleteBufferRegion(GLenum region)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDeleteBufferRegion),reinterpret_cast<void (*)()>(glDeleteBufferRegion),"glDeleteBufferRegion");
    _driver.call(&_driver.glDeleteBufferRegion)(region);
  }

  static void REGAL_CALL glDrawBufferRegion(GLuint region, GLint x, GLint y, GLsizei width, GLsizei height, GLint xDest, GLint yDest)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDrawBufferRegion),reinterpret_cast<void (*)()>(glDrawBufferRegion),"glDrawBufferRegion");
    _driver.call(&_driver.glDrawBufferRegion)(region, x, y, width, height, xDest, yDest);
  }

  static GLuint REGAL_CALL glNewBufferRegion(GLenum region)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNewBufferRegion),reinterpret_cast<void (*)()>(glNewBufferRegion),"glNewBufferRegion");
    return _driver.call(&_driver.glNewBufferRegion)(region);
  }

  static void REGAL_CALL glReadBufferRegion(GLuint region, GLint x, GLint y, GLsizei width, GLsizei height)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glReadBufferRegion),reinterpret_cast<void (*)()>(glReadBufferRegion),"glReadBufferRegion");
    _driver.call(&_driver.glReadBufferRegion)(region, x, y, width, height);
  }

// GL_MESA_resize_buffers

  static void REGAL_CALL glResizeBuffersMESA(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glResizeBuffersMESA),reinterpret_cast<void (*)()>(glResizeBuffersMESA),"glResizeBuffersMESA");
    _driver.call(&_driver.glResizeBuffersMESA)();
  }

// GL_MESA_window_pos

  static void REGAL_CALL glWindowPos2dMESA(GLdouble x, GLdouble y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos2dMESA),reinterpret_cast<void (*)()>(glWindowPos2dMESA),"glWindowPos2dMESA");
    _driver.call(&_driver.glWindowPos2dMESA)(x, y);
  }

  static void REGAL_CALL glWindowPos2dvMESA(const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos2dvMESA),reinterpret_cast<void (*)()>(glWindowPos2dvMESA),"glWindowPos2dvMESA");
    _driver.call(&_driver.glWindowPos2dvMESA)(v);
  }

  static void REGAL_CALL glWindowPos2fMESA(GLfloat x, GLfloat y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos2fMESA),reinterpret_cast<void (*)()>(glWindowPos2fMESA),"glWindowPos2fMESA");
    _driver.call(&_driver.glWindowPos2fMESA)(x, y);
  }

  static void REGAL_CALL glWindowPos2fvMESA(const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos2fvMESA),reinterpret_cast<void (*)()>(glWindowPos2fvMESA),"glWindowPos2fvMESA");
    _driver.call(&_driver.glWindowPos2fvMESA)(v);
  }

  static void REGAL_CALL glWindowPos2iMESA(GLint x, GLint y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos2iMESA),reinterpret_cast<void (*)()>(glWindowPos2iMESA),"glWindowPos2iMESA");
    _driver.call(&_driver.glWindowPos2iMESA)(x, y);
  }

  static void REGAL_CALL glWindowPos2ivMESA(const GLint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos2ivMESA),reinterpret_cast<void (*)()>(glWindowPos2ivMESA),"glWindowPos2ivMESA");
    _driver.call(&_driver.glWindowPos2ivMESA)(v);
  }

  static void REGAL_CALL glWindowPos2sMESA(GLshort x, GLshort y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos2sMESA),reinterpret_cast<void (*)()>(glWindowPos2sMESA),"glWindowPos2sMESA");
    _driver.call(&_driver.glWindowPos2sMESA)(x, y);
  }

  static void REGAL_CALL glWindowPos2svMESA(const GLshort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos2svMESA),reinterpret_cast<void (*)()>(glWindowPos2svMESA),"glWindowPos2svMESA");
    _driver.call(&_driver.glWindowPos2svMESA)(v);
  }

  static void REGAL_CALL glWindowPos3dMESA(GLdouble x, GLdouble y, GLdouble z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos3dMESA),reinterpret_cast<void (*)()>(glWindowPos3dMESA),"glWindowPos3dMESA");
    _driver.call(&_driver.glWindowPos3dMESA)(x, y, z);
  }

  static void REGAL_CALL glWindowPos3dvMESA(const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos3dvMESA),reinterpret_cast<void (*)()>(glWindowPos3dvMESA),"glWindowPos3dvMESA");
    _driver.call(&_driver.glWindowPos3dvMESA)(v);
  }

  static void REGAL_CALL glWindowPos3fMESA(GLfloat x, GLfloat y, GLfloat z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos3fMESA),reinterpret_cast<void (*)()>(glWindowPos3fMESA),"glWindowPos3fMESA");
    _driver.call(&_driver.glWindowPos3fMESA)(x, y, z);
  }

  static void REGAL_CALL glWindowPos3fvMESA(const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos3fvMESA),reinterpret_cast<void (*)()>(glWindowPos3fvMESA),"glWindowPos3fvMESA");
    _driver.call(&_driver.glWindowPos3fvMESA)(v);
  }

  static void REGAL_CALL glWindowPos3iMESA(GLint x, GLint y, GLint z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos3iMESA),reinterpret_cast<void (*)()>(glWindowPos3iMESA),"glWindowPos3iMESA");
    _driver.call(&_driver.glWindowPos3iMESA)(x, y, z);
  }

  static void REGAL_CALL glWindowPos3ivMESA(const GLint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos3ivMESA),reinterpret_cast<void (*)()>(glWindowPos3ivMESA),"glWindowPos3ivMESA");
    _driver.call(&_driver.glWindowPos3ivMESA)(v);
  }

  static void REGAL_CALL glWindowPos3sMESA(GLshort x, GLshort y, GLshort z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos3sMESA),reinterpret_cast<void (*)()>(glWindowPos3sMESA),"glWindowPos3sMESA");
    _driver.call(&_driver.glWindowPos3sMESA)(x, y, z);
  }

  static void REGAL_CALL glWindowPos3svMESA(const GLshort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos3svMESA),reinterpret_cast<void (*)()>(glWindowPos3svMESA),"glWindowPos3svMESA");
    _driver.call(&_driver.glWindowPos3svMESA)(v);
  }

  static void REGAL_CALL glWindowPos4dMESA(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos4dMESA),reinterpret_cast<void (*)()>(glWindowPos4dMESA),"glWindowPos4dMESA");
    _driver.call(&_driver.glWindowPos4dMESA)(x, y, z, w);
  }

  static void REGAL_CALL glWindowPos4dvMESA(const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos4dvMESA),reinterpret_cast<void (*)()>(glWindowPos4dvMESA),"glWindowPos4dvMESA");
    _driver.call(&_driver.glWindowPos4dvMESA)(v);
  }

  static void REGAL_CALL glWindowPos4fMESA(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos4fMESA),reinterpret_cast<void (*)()>(glWindowPos4fMESA),"glWindowPos4fMESA");
    _driver.call(&_driver.glWindowPos4fMESA)(x, y, z, w);
  }

  static void REGAL_CALL glWindowPos4fvMESA(const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos4fvMESA),reinterpret_cast<void (*)()>(glWindowPos4fvMESA),"glWindowPos4fvMESA");
    _driver.call(&_driver.glWindowPos4fvMESA)(v);
  }

  static void REGAL_CALL glWindowPos4iMESA(GLint x, GLint y, GLint z, GLint w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos4iMESA),reinterpret_cast<void (*)()>(glWindowPos4iMESA),"glWindowPos4iMESA");
    _driver.call(&_driver.glWindowPos4iMESA)(x, y, z, w);
  }

  static void REGAL_CALL glWindowPos4ivMESA(const GLint *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos4ivMESA),reinterpret_cast<void (*)()>(glWindowPos4ivMESA),"glWindowPos4ivMESA");
    _driver.call(&_driver.glWindowPos4ivMESA)(v);
  }

  static void REGAL_CALL glWindowPos4sMESA(GLshort x, GLshort y, GLshort z, GLshort w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos4sMESA),reinterpret_cast<void (*)()>(glWindowPos4sMESA),"glWindowPos4sMESA");
    _driver.call(&_driver.glWindowPos4sMESA)(x, y, z, w);
  }

  static void REGAL_CALL glWindowPos4svMESA(const GLshort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWindowPos4svMESA),reinterpret_cast<void (*)()>(glWindowPos4svMESA),"glWindowPos4svMESA");
    _driver.call(&_driver.glWindowPos4svMESA)(v);
  }

// GL_NVX_conditional_render

  static void REGAL_CALL glBeginConditionalRenderNVX(GLuint id)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBeginConditionalRenderNVX),reinterpret_cast<void (*)()>(glBeginConditionalRenderNVX),"glBeginConditionalRenderNVX");
    _driver.call(&_driver.glBeginConditionalRenderNVX)(id);
  }

  static void REGAL_CALL glEndConditionalRenderNVX(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glEndConditionalRenderNVX),reinterpret_cast<void (*)()>(glEndConditionalRenderNVX),"glEndConditionalRenderNVX");
    _driver.call(&_driver.glEndConditionalRenderNVX)();
  }

// GL_NV_bindless_texture

  static GLuint64 REGAL_CALL glGetImageHandleNV(GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetImageHandleNV),reinterpret_cast<void (*)()>(glGetImageHandleNV),"glGetImageHandleNV");
    return _driver.call(&_driver.glGetImageHandleNV)(texture, level, layered, layer, format);
  }

  static GLuint64 REGAL_CALL glGetTextureHandleNV(GLuint texture)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetTextureHandleNV),reinterpret_cast<void (*)()>(glGetTextureHandleNV),"glGetTextureHandleNV");
    return _driver.call(&_driver.glGetTextureHandleNV)(texture);
  }

  static GLuint64 REGAL_CALL glGetTextureSamplerHandleNV(GLuint texture, GLuint sampler)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetTextureSamplerHandleNV),reinterpret_cast<void (*)()>(glGetTextureSamplerHandleNV),"glGetTextureSamplerHandleNV");
    return _driver.call(&_driver.glGetTextureSamplerHandleNV)(texture, sampler);
  }

  static GLboolean REGAL_CALL glIsImageHandleResidentNV(GLuint64 handle)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIsImageHandleResidentNV),reinterpret_cast<void (*)()>(glIsImageHandleResidentNV),"glIsImageHandleResidentNV");
    return _driver.call(&_driver.glIsImageHandleResidentNV)(handle);
  }

  static GLboolean REGAL_CALL glIsTextureHandleResidentNV(GLuint64 handle)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIsTextureHandleResidentNV),reinterpret_cast<void (*)()>(glIsTextureHandleResidentNV),"glIsTextureHandleResidentNV");
    return _driver.call(&_driver.glIsTextureHandleResidentNV)(handle);
  }

  static void REGAL_CALL glMakeImageHandleNonResidentNV(GLuint64 handle)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMakeImageHandleNonResidentNV),reinterpret_cast<void (*)()>(glMakeImageHandleNonResidentNV),"glMakeImageHandleNonResidentNV");
    _driver.call(&_driver.glMakeImageHandleNonResidentNV)(handle);
  }

  static void REGAL_CALL glMakeImageHandleResidentNV(GLuint64 handle, GLenum access)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMakeImageHandleResidentNV),reinterpret_cast<void (*)()>(glMakeImageHandleResidentNV),"glMakeImageHandleResidentNV");
    _driver.call(&_driver.glMakeImageHandleResidentNV)(handle, access);
  }

  static void REGAL_CALL glMakeTextureHandleNonResidentNV(GLuint64 handle)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMakeTextureHandleNonResidentNV),reinterpret_cast<void (*)()>(glMakeTextureHandleNonResidentNV),"glMakeTextureHandleNonResidentNV");
    _driver.call(&_driver.glMakeTextureHandleNonResidentNV)(handle);
  }

  static void REGAL_CALL glMakeTextureHandleResidentNV(GLuint64 handle)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMakeTextureHandleResidentNV),reinterpret_cast<void (*)()>(glMakeTextureHandleResidentNV),"glMakeTextureHandleResidentNV");
    _driver.call(&_driver.glMakeTextureHandleResidentNV)(handle);
  }

  static void REGAL_CALL glProgramUniformHandleui64NV(GLuint program, GLint location, GLuint64 value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniformHandleui64NV),reinterpret_cast<void (*)()>(glProgramUniformHandleui64NV),"glProgramUniformHandleui64NV");
    _driver.call(&_driver.glProgramUniformHandleui64NV)(program, location, value);
  }

  static void REGAL_CALL glProgramUniformHandleui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64 *values)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniformHandleui64vNV),reinterpret_cast<void (*)()>(glProgramUniformHandleui64vNV),"glProgramUniformHandleui64vNV");
    _driver.call(&_driver.glProgramUniformHandleui64vNV)(program, location, count, values);
  }

  static void REGAL_CALL glUniformHandleui64NV(GLint location, GLuint64 value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniformHandleui64NV),reinterpret_cast<void (*)()>(glUniformHandleui64NV),"glUniformHandleui64NV");
    _driver.call(&_driver.glUniformHandleui64NV)(location, value);
  }

  static void REGAL_CALL glUniformHandleui64vNV(GLint location, GLsizei count, const GLuint64 *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniformHandleui64vNV),reinterpret_cast<void (*)()>(glUniformHandleui64vNV),"glUniformHandleui64vNV");
    _driver.call(&_driver.glUniformHandleui64vNV)(location, count, value);
  }

// GL_NV_blend_equation_advanced

  static void REGAL_CALL glBlendBarrierNV(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBlendBarrierNV),reinterpret_cast<void (*)()>(glBlendBarrierNV),"glBlendBarrierNV");
    _driver.call(&_driver.glBlendBarrierNV)();
  }

  static void REGAL_CALL glBlendParameteriNV(GLenum pname, GLint value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBlendParameteriNV),reinterpret_cast<void (*)()>(glBlendParameteriNV),"glBlendParameteriNV");
    _driver.call(&_driver.glBlendParameteriNV)(pname, value);
  }

// GL_NV_conditional_render

  static void REGAL_CALL glBeginConditionalRenderNV(GLuint id, GLenum mode)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBeginConditionalRenderNV),reinterpret_cast<void (*)()>(glBeginConditionalRenderNV),"glBeginConditionalRenderNV");
    _driver.call(&_driver.glBeginConditionalRenderNV)(id, mode);
  }

  static void REGAL_CALL glEndConditionalRenderNV(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glEndConditionalRenderNV),reinterpret_cast<void (*)()>(glEndConditionalRenderNV),"glEndConditionalRenderNV");
    _driver.call(&_driver.glEndConditionalRenderNV)();
  }

// GL_NV_copy_buffer

  static void REGAL_CALL glCopyBufferSubDataNV(GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCopyBufferSubDataNV),reinterpret_cast<void (*)()>(glCopyBufferSubDataNV),"glCopyBufferSubDataNV");
    _driver.call(&_driver.glCopyBufferSubDataNV)(readtarget, writetarget, readoffset, writeoffset, size);
  }

// GL_NV_copy_image

  static void REGAL_CALL glCopyImageSubDataNV(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCopyImageSubDataNV),reinterpret_cast<void (*)()>(glCopyImageSubDataNV),"glCopyImageSubDataNV");
    _driver.call(&_driver.glCopyImageSubDataNV)(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
  }

// GL_NV_coverage_sample

  static void REGAL_CALL glCoverageMaskNV(GLboolean mask)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCoverageMaskNV),reinterpret_cast<void (*)()>(glCoverageMaskNV),"glCoverageMaskNV");
    _driver.call(&_driver.glCoverageMaskNV)(mask);
  }

  static void REGAL_CALL glCoverageOperationNV(GLenum operation)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCoverageOperationNV),reinterpret_cast<void (*)()>(glCoverageOperationNV),"glCoverageOperationNV");
    _driver.call(&_driver.glCoverageOperationNV)(operation);
  }

// GL_NV_depth_buffer_float

  static void REGAL_CALL glClearDepthdNV(GLdouble depth)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glClearDepthdNV),reinterpret_cast<void (*)()>(glClearDepthdNV),"glClearDepthdNV");
    _driver.call(&_driver.glClearDepthdNV)(depth);
  }

  static void REGAL_CALL glDepthBoundsdNV(GLdouble zmin, GLdouble zmax)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDepthBoundsdNV),reinterpret_cast<void (*)()>(glDepthBoundsdNV),"glDepthBoundsdNV");
    _driver.call(&_driver.glDepthBoundsdNV)(zmin, zmax);
  }

  static void REGAL_CALL glDepthRangedNV(GLdouble zNear, GLdouble zFar)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDepthRangedNV),reinterpret_cast<void (*)()>(glDepthRangedNV),"glDepthRangedNV");
    _driver.call(&_driver.glDepthRangedNV)(zNear, zFar);
  }

// GL_NV_draw_buffers

  static void REGAL_CALL glDrawBuffersNV(GLsizei n, const GLenum *bufs)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDrawBuffersNV),reinterpret_cast<void (*)()>(glDrawBuffersNV),"glDrawBuffersNV");
    _driver.call(&_driver.glDrawBuffersNV)(n, bufs);
  }

// GL_NV_draw_texture

  static void REGAL_CALL glDrawTextureNV(GLuint texture, GLuint sampler, GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1, GLfloat z, GLfloat s0, GLfloat t0, GLfloat s1, GLfloat t1)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDrawTextureNV),reinterpret_cast<void (*)()>(glDrawTextureNV),"glDrawTextureNV");
    _driver.call(&_driver.glDrawTextureNV)(texture, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1);
  }

// GL_NV_evaluators

  static void REGAL_CALL glEvalMapsNV(GLenum target, GLenum mode)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glEvalMapsNV),reinterpret_cast<void (*)()>(glEvalMapsNV),"glEvalMapsNV");
    _driver.call(&_driver.glEvalMapsNV)(target, mode);
  }

  static void REGAL_CALL glGetMapAttribParameterfvNV(GLenum target, GLuint index, GLenum pname, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetMapAttribParameterfvNV),reinterpret_cast<void (*)()>(glGetMapAttribParameterfvNV),"glGetMapAttribParameterfvNV");
    _driver.call(&_driver.glGetMapAttribParameterfvNV)(target, index, pname, params);
  }

  static void REGAL_CALL glGetMapAttribParameterivNV(GLenum target, GLuint index, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetMapAttribParameterivNV),reinterpret_cast<void (*)()>(glGetMapAttribParameterivNV),"glGetMapAttribParameterivNV");
    _driver.call(&_driver.glGetMapAttribParameterivNV)(target, index, pname, params);
  }

  static void REGAL_CALL glGetMapControlPointsNV(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, GLvoid *points)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetMapControlPointsNV),reinterpret_cast<void (*)()>(glGetMapControlPointsNV),"glGetMapControlPointsNV");
    _driver.call(&_driver.glGetMapControlPointsNV)(target, index, type, ustride, vstride, packed, points);
  }

  static void REGAL_CALL glGetMapParameterfvNV(GLenum target, GLenum pname, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetMapParameterfvNV),reinterpret_cast<void (*)()>(glGetMapParameterfvNV),"glGetMapParameterfvNV");
    _driver.call(&_driver.glGetMapParameterfvNV)(target, pname, params);
  }

  static void REGAL_CALL glGetMapParameterivNV(GLenum target, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetMapParameterivNV),reinterpret_cast<void (*)()>(glGetMapParameterivNV),"glGetMapParameterivNV");
    _driver.call(&_driver.glGetMapParameterivNV)(target, pname, params);
  }

  static void REGAL_CALL glMapControlPointsNV(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const GLvoid *points)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMapControlPointsNV),reinterpret_cast<void (*)()>(glMapControlPointsNV),"glMapControlPointsNV");
    _driver.call(&_driver.glMapControlPointsNV)(target, index, type, ustride, vstride, uorder, vorder, packed, points);
  }

  static void REGAL_CALL glMapParameterfvNV(GLenum target, GLenum pname, const GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMapParameterfvNV),reinterpret_cast<void (*)()>(glMapParameterfvNV),"glMapParameterfvNV");
    _driver.call(&_driver.glMapParameterfvNV)(target, pname, params);
  }

  static void REGAL_CALL glMapParameterivNV(GLenum target, GLenum pname, const GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMapParameterivNV),reinterpret_cast<void (*)()>(glMapParameterivNV),"glMapParameterivNV");
    _driver.call(&_driver.glMapParameterivNV)(target, pname, params);
  }

// GL_NV_explicit_multisample

  static void REGAL_CALL glGetMultisamplefvNV(GLenum pname, GLuint index, GLfloat *val)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetMultisamplefvNV),reinterpret_cast<void (*)()>(glGetMultisamplefvNV),"glGetMultisamplefvNV");
    _driver.call(&_driver.glGetMultisamplefvNV)(pname, index, val);
  }

  static void REGAL_CALL glSampleMaskIndexedNV(GLuint index, GLbitfield mask)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSampleMaskIndexedNV),reinterpret_cast<void (*)()>(glSampleMaskIndexedNV),"glSampleMaskIndexedNV");
    _driver.call(&_driver.glSampleMaskIndexedNV)(index, mask);
  }

  static void REGAL_CALL glTexRenderbufferNV(GLenum target, GLuint renderbuffer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexRenderbufferNV),reinterpret_cast<void (*)()>(glTexRenderbufferNV),"glTexRenderbufferNV");
    _driver.call(&_driver.glTexRenderbufferNV)(target, renderbuffer);
  }

// GL_NV_fence

  static void REGAL_CALL glDeleteFencesNV(GLsizei n, const GLuint *fences)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDeleteFencesNV),reinterpret_cast<void (*)()>(glDeleteFencesNV),"glDeleteFencesNV");
    _driver.call(&_driver.glDeleteFencesNV)(n, fences);
  }

  static void REGAL_CALL glFinishFenceNV(GLuint fence)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFinishFenceNV),reinterpret_cast<void (*)()>(glFinishFenceNV),"glFinishFenceNV");
    _driver.call(&_driver.glFinishFenceNV)(fence);
  }

  static void REGAL_CALL glGenFencesNV(GLsizei n, GLuint *fences)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGenFencesNV),reinterpret_cast<void (*)()>(glGenFencesNV),"glGenFencesNV");
    _driver.call(&_driver.glGenFencesNV)(n, fences);
  }

  static void REGAL_CALL glGetFenceivNV(GLuint fence, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetFenceivNV),reinterpret_cast<void (*)()>(glGetFenceivNV),"glGetFenceivNV");
    _driver.call(&_driver.glGetFenceivNV)(fence, pname, params);
  }

  static GLboolean REGAL_CALL glIsFenceNV(GLuint fence)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIsFenceNV),reinterpret_cast<void (*)()>(glIsFenceNV),"glIsFenceNV");
    return _driver.call(&_driver.glIsFenceNV)(fence);
  }

  static void REGAL_CALL glSetFenceNV(GLuint fence, GLenum condition)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSetFenceNV),reinterpret_cast<void (*)()>(glSetFenceNV),"glSetFenceNV");
    _driver.call(&_driver.glSetFenceNV)(fence, condition);
  }

  static GLboolean REGAL_CALL glTestFenceNV(GLuint fence)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTestFenceNV),reinterpret_cast<void (*)()>(glTestFenceNV),"glTestFenceNV");
    return _driver.call(&_driver.glTestFenceNV)(fence);
  }

// GL_NV_fragment_program

  static void REGAL_CALL glGetProgramNamedParameterdvNV(GLuint id, GLsizei len, const GLubyte *name, GLdouble *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetProgramNamedParameterdvNV),reinterpret_cast<void (*)()>(glGetProgramNamedParameterdvNV),"glGetProgramNamedParameterdvNV");
    _driver.call(&_driver.glGetProgramNamedParameterdvNV)(id, len, name, params);
  }

  static void REGAL_CALL glGetProgramNamedParameterfvNV(GLuint id, GLsizei len, const GLubyte *name, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetProgramNamedParameterfvNV),reinterpret_cast<void (*)()>(glGetProgramNamedParameterfvNV),"glGetProgramNamedParameterfvNV");
    _driver.call(&_driver.glGetProgramNamedParameterfvNV)(id, len, name, params);
  }

  static void REGAL_CALL glProgramNamedParameter4dNV(GLuint id, GLsizei len, const GLubyte *name, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramNamedParameter4dNV),reinterpret_cast<void (*)()>(glProgramNamedParameter4dNV),"glProgramNamedParameter4dNV");
    _driver.call(&_driver.glProgramNamedParameter4dNV)(id, len, name, x, y, z, w);
  }

  static void REGAL_CALL glProgramNamedParameter4dvNV(GLuint id, GLsizei len, const GLubyte *name, const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramNamedParameter4dvNV),reinterpret_cast<void (*)()>(glProgramNamedParameter4dvNV),"glProgramNamedParameter4dvNV");
    _driver.call(&_driver.glProgramNamedParameter4dvNV)(id, len, name, v);
  }

  static void REGAL_CALL glProgramNamedParameter4fNV(GLuint id, GLsizei len, const GLubyte *name, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramNamedParameter4fNV),reinterpret_cast<void (*)()>(glProgramNamedParameter4fNV),"glProgramNamedParameter4fNV");
    _driver.call(&_driver.glProgramNamedParameter4fNV)(id, len, name, x, y, z, w);
  }

  static void REGAL_CALL glProgramNamedParameter4fvNV(GLuint id, GLsizei len, const GLubyte *name, const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramNamedParameter4fvNV),reinterpret_cast<void (*)()>(glProgramNamedParameter4fvNV),"glProgramNamedParameter4fvNV");
    _driver.call(&_driver.glProgramNamedParameter4fvNV)(id, len, name, v);
  }

// GL_NV_framebuffer_blit

  static void REGAL_CALL glBlitFramebufferNV(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBlitFramebufferNV),reinterpret_cast<void (*)()>(glBlitFramebufferNV),"glBlitFramebufferNV");
    _driver.call(&_driver.glBlitFramebufferNV)(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
  }

// GL_NV_framebuffer_multisample_coverage

  static void REGAL_CALL glRenderbufferStorageMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glRenderbufferStorageMultisampleCoverageNV),reinterpret_cast<void (*)()>(glRenderbufferStorageMultisampleCoverageNV),"glRenderbufferStorageMultisampleCoverageNV");
    _driver.call(&_driver.glRenderbufferStorageMultisampleCoverageNV)(target, coverageSamples, colorSamples, internalformat, width, height);
  }

// GL_NV_geometry_program4

  static void REGAL_CALL glProgramVertexLimitNV(GLenum target, GLint limit)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramVertexLimitNV),reinterpret_cast<void (*)()>(glProgramVertexLimitNV),"glProgramVertexLimitNV");
    _driver.call(&_driver.glProgramVertexLimitNV)(target, limit);
  }

// GL_NV_gpu_program4

  static void REGAL_CALL glGetProgramEnvParameterIivNV(GLenum target, GLuint index, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetProgramEnvParameterIivNV),reinterpret_cast<void (*)()>(glGetProgramEnvParameterIivNV),"glGetProgramEnvParameterIivNV");
    _driver.call(&_driver.glGetProgramEnvParameterIivNV)(target, index, params);
  }

  static void REGAL_CALL glGetProgramEnvParameterIuivNV(GLenum target, GLuint index, GLuint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetProgramEnvParameterIuivNV),reinterpret_cast<void (*)()>(glGetProgramEnvParameterIuivNV),"glGetProgramEnvParameterIuivNV");
    _driver.call(&_driver.glGetProgramEnvParameterIuivNV)(target, index, params);
  }

  static void REGAL_CALL glGetProgramLocalParameterIivNV(GLenum target, GLuint index, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetProgramLocalParameterIivNV),reinterpret_cast<void (*)()>(glGetProgramLocalParameterIivNV),"glGetProgramLocalParameterIivNV");
    _driver.call(&_driver.glGetProgramLocalParameterIivNV)(target, index, params);
  }

  static void REGAL_CALL glGetProgramLocalParameterIuivNV(GLenum target, GLuint index, GLuint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetProgramLocalParameterIuivNV),reinterpret_cast<void (*)()>(glGetProgramLocalParameterIuivNV),"glGetProgramLocalParameterIuivNV");
    _driver.call(&_driver.glGetProgramLocalParameterIuivNV)(target, index, params);
  }

  static void REGAL_CALL glProgramEnvParameterI4iNV(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramEnvParameterI4iNV),reinterpret_cast<void (*)()>(glProgramEnvParameterI4iNV),"glProgramEnvParameterI4iNV");
    _driver.call(&_driver.glProgramEnvParameterI4iNV)(target, index, x, y, z, w);
  }

  static void REGAL_CALL glProgramEnvParameterI4ivNV(GLenum target, GLuint index, const GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramEnvParameterI4ivNV),reinterpret_cast<void (*)()>(glProgramEnvParameterI4ivNV),"glProgramEnvParameterI4ivNV");
    _driver.call(&_driver.glProgramEnvParameterI4ivNV)(target, index, params);
  }

  static void REGAL_CALL glProgramEnvParameterI4uiNV(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramEnvParameterI4uiNV),reinterpret_cast<void (*)()>(glProgramEnvParameterI4uiNV),"glProgramEnvParameterI4uiNV");
    _driver.call(&_driver.glProgramEnvParameterI4uiNV)(target, index, x, y, z, w);
  }

  static void REGAL_CALL glProgramEnvParameterI4uivNV(GLenum target, GLuint index, const GLuint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramEnvParameterI4uivNV),reinterpret_cast<void (*)()>(glProgramEnvParameterI4uivNV),"glProgramEnvParameterI4uivNV");
    _driver.call(&_driver.glProgramEnvParameterI4uivNV)(target, index, params);
  }

  static void REGAL_CALL glProgramEnvParametersI4ivNV(GLenum target, GLuint index, GLsizei count, const GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramEnvParametersI4ivNV),reinterpret_cast<void (*)()>(glProgramEnvParametersI4ivNV),"glProgramEnvParametersI4ivNV");
    _driver.call(&_driver.glProgramEnvParametersI4ivNV)(target, index, count, params);
  }

  static void REGAL_CALL glProgramEnvParametersI4uivNV(GLenum target, GLuint index, GLsizei count, const GLuint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramEnvParametersI4uivNV),reinterpret_cast<void (*)()>(glProgramEnvParametersI4uivNV),"glProgramEnvParametersI4uivNV");
    _driver.call(&_driver.glProgramEnvParametersI4uivNV)(target, index, count, params);
  }

  static void REGAL_CALL glProgramLocalParameterI4iNV(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramLocalParameterI4iNV),reinterpret_cast<void (*)()>(glProgramLocalParameterI4iNV),"glProgramLocalParameterI4iNV");
    _driver.call(&_driver.glProgramLocalParameterI4iNV)(target, index, x, y, z, w);
  }

  static void REGAL_CALL glProgramLocalParameterI4ivNV(GLenum target, GLuint index, const GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramLocalParameterI4ivNV),reinterpret_cast<void (*)()>(glProgramLocalParameterI4ivNV),"glProgramLocalParameterI4ivNV");
    _driver.call(&_driver.glProgramLocalParameterI4ivNV)(target, index, params);
  }

  static void REGAL_CALL glProgramLocalParameterI4uiNV(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramLocalParameterI4uiNV),reinterpret_cast<void (*)()>(glProgramLocalParameterI4uiNV),"glProgramLocalParameterI4uiNV");
    _driver.call(&_driver.glProgramLocalParameterI4uiNV)(target, index, x, y, z, w);
  }

  static void REGAL_CALL glProgramLocalParameterI4uivNV(GLenum target, GLuint index, const GLuint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramLocalParameterI4uivNV),reinterpret_cast<void (*)()>(glProgramLocalParameterI4uivNV),"glProgramLocalParameterI4uivNV");
    _driver.call(&_driver.glProgramLocalParameterI4uivNV)(target, index, params);
  }

  static void REGAL_CALL glProgramLocalParametersI4ivNV(GLenum target, GLuint index, GLsizei count, const GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramLocalParametersI4ivNV),reinterpret_cast<void (*)()>(glProgramLocalParametersI4ivNV),"glProgramLocalParametersI4ivNV");
    _driver.call(&_driver.glProgramLocalParametersI4ivNV)(target, index, count, params);
  }

  static void REGAL_CALL glProgramLocalParametersI4uivNV(GLenum target, GLuint index, GLsizei count, const GLuint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramLocalParametersI4uivNV),reinterpret_cast<void (*)()>(glProgramLocalParametersI4uivNV),"glProgramLocalParametersI4uivNV");
    _driver.call(&_driver.glProgramLocalParametersI4uivNV)(target, index, count, params);
  }

// GL_NV_gpu_shader5

  static void REGAL_CALL glGetUniformi64vNV(GLuint program, GLint location, GLint64EXT *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetUniformi64vNV),reinterpret_cast<void (*)()>(glGetUniformi64vNV),"glGetUniformi64vNV");
    _driver.call(&_driver.glGetUniformi64vNV)(program, location, params);
  }

  static void REGAL_CALL glProgramUniform1i64NV(GLuint program, GLint location, GLint64EXT x)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform1i64NV),reinterpret_cast<void (*)()>(glProgramUniform1i64NV),"glProgramUniform1i64NV");
    _driver.call(&_driver.glProgramUniform1i64NV)(program, location, x);
  }

  static void REGAL_CALL glProgramUniform1i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform1i64vNV),reinterpret_cast<void (*)()>(glProgramUniform1i64vNV),"glProgramUniform1i64vNV");
    _driver.call(&_driver.glProgramUniform1i64vNV)(program, location, count, value);
  }

  static void REGAL_CALL glProgramUniform1ui64NV(GLuint program, GLint location, GLuint64EXT x)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform1ui64NV),reinterpret_cast<void (*)()>(glProgramUniform1ui64NV),"glProgramUniform1ui64NV");
    _driver.call(&_driver.glProgramUniform1ui64NV)(program, location, x);
  }

  static void REGAL_CALL glProgramUniform1ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform1ui64vNV),reinterpret_cast<void (*)()>(glProgramUniform1ui64vNV),"glProgramUniform1ui64vNV");
    _driver.call(&_driver.glProgramUniform1ui64vNV)(program, location, count, value);
  }

  static void REGAL_CALL glProgramUniform2i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform2i64NV),reinterpret_cast<void (*)()>(glProgramUniform2i64NV),"glProgramUniform2i64NV");
    _driver.call(&_driver.glProgramUniform2i64NV)(program, location, x, y);
  }

  static void REGAL_CALL glProgramUniform2i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform2i64vNV),reinterpret_cast<void (*)()>(glProgramUniform2i64vNV),"glProgramUniform2i64vNV");
    _driver.call(&_driver.glProgramUniform2i64vNV)(program, location, count, value);
  }

  static void REGAL_CALL glProgramUniform2ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform2ui64NV),reinterpret_cast<void (*)()>(glProgramUniform2ui64NV),"glProgramUniform2ui64NV");
    _driver.call(&_driver.glProgramUniform2ui64NV)(program, location, x, y);
  }

  static void REGAL_CALL glProgramUniform2ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform2ui64vNV),reinterpret_cast<void (*)()>(glProgramUniform2ui64vNV),"glProgramUniform2ui64vNV");
    _driver.call(&_driver.glProgramUniform2ui64vNV)(program, location, count, value);
  }

  static void REGAL_CALL glProgramUniform3i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform3i64NV),reinterpret_cast<void (*)()>(glProgramUniform3i64NV),"glProgramUniform3i64NV");
    _driver.call(&_driver.glProgramUniform3i64NV)(program, location, x, y, z);
  }

  static void REGAL_CALL glProgramUniform3i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform3i64vNV),reinterpret_cast<void (*)()>(glProgramUniform3i64vNV),"glProgramUniform3i64vNV");
    _driver.call(&_driver.glProgramUniform3i64vNV)(program, location, count, value);
  }

  static void REGAL_CALL glProgramUniform3ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform3ui64NV),reinterpret_cast<void (*)()>(glProgramUniform3ui64NV),"glProgramUniform3ui64NV");
    _driver.call(&_driver.glProgramUniform3ui64NV)(program, location, x, y, z);
  }

  static void REGAL_CALL glProgramUniform3ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform3ui64vNV),reinterpret_cast<void (*)()>(glProgramUniform3ui64vNV),"glProgramUniform3ui64vNV");
    _driver.call(&_driver.glProgramUniform3ui64vNV)(program, location, count, value);
  }

  static void REGAL_CALL glProgramUniform4i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform4i64NV),reinterpret_cast<void (*)()>(glProgramUniform4i64NV),"glProgramUniform4i64NV");
    _driver.call(&_driver.glProgramUniform4i64NV)(program, location, x, y, z, w);
  }

  static void REGAL_CALL glProgramUniform4i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform4i64vNV),reinterpret_cast<void (*)()>(glProgramUniform4i64vNV),"glProgramUniform4i64vNV");
    _driver.call(&_driver.glProgramUniform4i64vNV)(program, location, count, value);
  }

  static void REGAL_CALL glProgramUniform4ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform4ui64NV),reinterpret_cast<void (*)()>(glProgramUniform4ui64NV),"glProgramUniform4ui64NV");
    _driver.call(&_driver.glProgramUniform4ui64NV)(program, location, x, y, z, w);
  }

  static void REGAL_CALL glProgramUniform4ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniform4ui64vNV),reinterpret_cast<void (*)()>(glProgramUniform4ui64vNV),"glProgramUniform4ui64vNV");
    _driver.call(&_driver.glProgramUniform4ui64vNV)(program, location, count, value);
  }

  static void REGAL_CALL glUniform1i64NV(GLint location, GLint64EXT x)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform1i64NV),reinterpret_cast<void (*)()>(glUniform1i64NV),"glUniform1i64NV");
    _driver.call(&_driver.glUniform1i64NV)(location, x);
  }

  static void REGAL_CALL glUniform1i64vNV(GLint location, GLsizei count, const GLint64EXT *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform1i64vNV),reinterpret_cast<void (*)()>(glUniform1i64vNV),"glUniform1i64vNV");
    _driver.call(&_driver.glUniform1i64vNV)(location, count, value);
  }

  static void REGAL_CALL glUniform1ui64NV(GLint location, GLuint64EXT x)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform1ui64NV),reinterpret_cast<void (*)()>(glUniform1ui64NV),"glUniform1ui64NV");
    _driver.call(&_driver.glUniform1ui64NV)(location, x);
  }

  static void REGAL_CALL glUniform1ui64vNV(GLint location, GLsizei count, const GLuint64EXT *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform1ui64vNV),reinterpret_cast<void (*)()>(glUniform1ui64vNV),"glUniform1ui64vNV");
    _driver.call(&_driver.glUniform1ui64vNV)(location, count, value);
  }

  static void REGAL_CALL glUniform2i64NV(GLint location, GLint64EXT x, GLint64EXT y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform2i64NV),reinterpret_cast<void (*)()>(glUniform2i64NV),"glUniform2i64NV");
    _driver.call(&_driver.glUniform2i64NV)(location, x, y);
  }

  static void REGAL_CALL glUniform2i64vNV(GLint location, GLsizei count, const GLint64EXT *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform2i64vNV),reinterpret_cast<void (*)()>(glUniform2i64vNV),"glUniform2i64vNV");
    _driver.call(&_driver.glUniform2i64vNV)(location, count, value);
  }

  static void REGAL_CALL glUniform2ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform2ui64NV),reinterpret_cast<void (*)()>(glUniform2ui64NV),"glUniform2ui64NV");
    _driver.call(&_driver.glUniform2ui64NV)(location, x, y);
  }

  static void REGAL_CALL glUniform2ui64vNV(GLint location, GLsizei count, const GLuint64EXT *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform2ui64vNV),reinterpret_cast<void (*)()>(glUniform2ui64vNV),"glUniform2ui64vNV");
    _driver.call(&_driver.glUniform2ui64vNV)(location, count, value);
  }

  static void REGAL_CALL glUniform3i64NV(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform3i64NV),reinterpret_cast<void (*)()>(glUniform3i64NV),"glUniform3i64NV");
    _driver.call(&_driver.glUniform3i64NV)(location, x, y, z);
  }

  static void REGAL_CALL glUniform3i64vNV(GLint location, GLsizei count, const GLint64EXT *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform3i64vNV),reinterpret_cast<void (*)()>(glUniform3i64vNV),"glUniform3i64vNV");
    _driver.call(&_driver.glUniform3i64vNV)(location, count, value);
  }

  static void REGAL_CALL glUniform3ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform3ui64NV),reinterpret_cast<void (*)()>(glUniform3ui64NV),"glUniform3ui64NV");
    _driver.call(&_driver.glUniform3ui64NV)(location, x, y, z);
  }

  static void REGAL_CALL glUniform3ui64vNV(GLint location, GLsizei count, const GLuint64EXT *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform3ui64vNV),reinterpret_cast<void (*)()>(glUniform3ui64vNV),"glUniform3ui64vNV");
    _driver.call(&_driver.glUniform3ui64vNV)(location, count, value);
  }

  static void REGAL_CALL glUniform4i64NV(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform4i64NV),reinterpret_cast<void (*)()>(glUniform4i64NV),"glUniform4i64NV");
    _driver.call(&_driver.glUniform4i64NV)(location, x, y, z, w);
  }

  static void REGAL_CALL glUniform4i64vNV(GLint location, GLsizei count, const GLint64EXT *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform4i64vNV),reinterpret_cast<void (*)()>(glUniform4i64vNV),"glUniform4i64vNV");
    _driver.call(&_driver.glUniform4i64vNV)(location, count, value);
  }

  static void REGAL_CALL glUniform4ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform4ui64NV),reinterpret_cast<void (*)()>(glUniform4ui64NV),"glUniform4ui64NV");
    _driver.call(&_driver.glUniform4ui64NV)(location, x, y, z, w);
  }

  static void REGAL_CALL glUniform4ui64vNV(GLint location, GLsizei count, const GLuint64EXT *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniform4ui64vNV),reinterpret_cast<void (*)()>(glUniform4ui64vNV),"glUniform4ui64vNV");
    _driver.call(&_driver.glUniform4ui64vNV)(location, count, value);
  }

// GL_NV_half_float

  static void REGAL_CALL glColor3hNV(GLhalfNV red, GLhalfNV green, GLhalfNV blue)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColor3hNV),reinterpret_cast<void (*)()>(glColor3hNV),"glColor3hNV");
    _driver.call(&_driver.glColor3hNV)(red, green, blue);
  }

  static void REGAL_CALL glColor3hvNV(const GLhalfNV *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColor3hvNV),reinterpret_cast<void (*)()>(glColor3hvNV),"glColor3hvNV");
    _driver.call(&_driver.glColor3hvNV)(v);
  }

  static void REGAL_CALL glColor4hNV(GLhalfNV red, GLhalfNV green, GLhalfNV blue, GLhalfNV alpha)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColor4hNV),reinterpret_cast<void (*)()>(glColor4hNV),"glColor4hNV");
    _driver.call(&_driver.glColor4hNV)(red, green, blue, alpha);
  }

  static void REGAL_CALL glColor4hvNV(const GLhalfNV *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColor4hvNV),reinterpret_cast<void (*)()>(glColor4hvNV),"glColor4hvNV");
    _driver.call(&_driver.glColor4hvNV)(v);
  }

  static void REGAL_CALL glFogCoordhNV(GLhalfNV coord)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFogCoordhNV),reinterpret_cast<void (*)()>(glFogCoordhNV),"glFogCoordhNV");
    _driver.call(&_driver.glFogCoordhNV)(coord);
  }

  static void REGAL_CALL glFogCoordhvNV(const GLhalfNV *coord)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFogCoordhvNV),reinterpret_cast<void (*)()>(glFogCoordhvNV),"glFogCoordhvNV");
    _driver.call(&_driver.glFogCoordhvNV)(coord);
  }

  static void REGAL_CALL glMultiTexCoord1hNV(GLenum target, GLhalfNV s)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord1hNV),reinterpret_cast<void (*)()>(glMultiTexCoord1hNV),"glMultiTexCoord1hNV");
    _driver.call(&_driver.glMultiTexCoord1hNV)(target, s);
  }

  static void REGAL_CALL glMultiTexCoord1hvNV(GLenum target, const GLhalfNV *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord1hvNV),reinterpret_cast<void (*)()>(glMultiTexCoord1hvNV),"glMultiTexCoord1hvNV");
    _driver.call(&_driver.glMultiTexCoord1hvNV)(target, v);
  }

  static void REGAL_CALL glMultiTexCoord2hNV(GLenum target, GLhalfNV s, GLhalfNV t)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord2hNV),reinterpret_cast<void (*)()>(glMultiTexCoord2hNV),"glMultiTexCoord2hNV");
    _driver.call(&_driver.glMultiTexCoord2hNV)(target, s, t);
  }

  static void REGAL_CALL glMultiTexCoord2hvNV(GLenum target, const GLhalfNV *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord2hvNV),reinterpret_cast<void (*)()>(glMultiTexCoord2hvNV),"glMultiTexCoord2hvNV");
    _driver.call(&_driver.glMultiTexCoord2hvNV)(target, v);
  }

  static void REGAL_CALL glMultiTexCoord3hNV(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord3hNV),reinterpret_cast<void (*)()>(glMultiTexCoord3hNV),"glMultiTexCoord3hNV");
    _driver.call(&_driver.glMultiTexCoord3hNV)(target, s, t, r);
  }

  static void REGAL_CALL glMultiTexCoord3hvNV(GLenum target, const GLhalfNV *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord3hvNV),reinterpret_cast<void (*)()>(glMultiTexCoord3hvNV),"glMultiTexCoord3hvNV");
    _driver.call(&_driver.glMultiTexCoord3hvNV)(target, v);
  }

  static void REGAL_CALL glMultiTexCoord4hNV(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord4hNV),reinterpret_cast<void (*)()>(glMultiTexCoord4hNV),"glMultiTexCoord4hNV");
    _driver.call(&_driver.glMultiTexCoord4hNV)(target, s, t, r, q);
  }

  static void REGAL_CALL glMultiTexCoord4hvNV(GLenum target, const GLhalfNV *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord4hvNV),reinterpret_cast<void (*)()>(glMultiTexCoord4hvNV),"glMultiTexCoord4hvNV");
    _driver.call(&_driver.glMultiTexCoord4hvNV)(target, v);
  }

  static void REGAL_CALL glNormal3hNV(GLhalfNV nx, GLhalfNV ny, GLhalfNV nz)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNormal3hNV),reinterpret_cast<void (*)()>(glNormal3hNV),"glNormal3hNV");
    _driver.call(&_driver.glNormal3hNV)(nx, ny, nz);
  }

  static void REGAL_CALL glNormal3hvNV(const GLhalfNV *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNormal3hvNV),reinterpret_cast<void (*)()>(glNormal3hvNV),"glNormal3hvNV");
    _driver.call(&_driver.glNormal3hvNV)(v);
  }

  static void REGAL_CALL glSecondaryColor3hNV(GLhalfNV red, GLhalfNV green, GLhalfNV blue)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSecondaryColor3hNV),reinterpret_cast<void (*)()>(glSecondaryColor3hNV),"glSecondaryColor3hNV");
    _driver.call(&_driver.glSecondaryColor3hNV)(red, green, blue);
  }

  static void REGAL_CALL glSecondaryColor3hvNV(const GLhalfNV *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSecondaryColor3hvNV),reinterpret_cast<void (*)()>(glSecondaryColor3hvNV),"glSecondaryColor3hvNV");
    _driver.call(&_driver.glSecondaryColor3hvNV)(v);
  }

  static void REGAL_CALL glTexCoord1hNV(GLhalfNV s)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord1hNV),reinterpret_cast<void (*)()>(glTexCoord1hNV),"glTexCoord1hNV");
    _driver.call(&_driver.glTexCoord1hNV)(s);
  }

  static void REGAL_CALL glTexCoord1hvNV(const GLhalfNV *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord1hvNV),reinterpret_cast<void (*)()>(glTexCoord1hvNV),"glTexCoord1hvNV");
    _driver.call(&_driver.glTexCoord1hvNV)(v);
  }

  static void REGAL_CALL glTexCoord2hNV(GLhalfNV s, GLhalfNV t)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord2hNV),reinterpret_cast<void (*)()>(glTexCoord2hNV),"glTexCoord2hNV");
    _driver.call(&_driver.glTexCoord2hNV)(s, t);
  }

  static void REGAL_CALL glTexCoord2hvNV(const GLhalfNV *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord2hvNV),reinterpret_cast<void (*)()>(glTexCoord2hvNV),"glTexCoord2hvNV");
    _driver.call(&_driver.glTexCoord2hvNV)(v);
  }

  static void REGAL_CALL glTexCoord3hNV(GLhalfNV s, GLhalfNV t, GLhalfNV r)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord3hNV),reinterpret_cast<void (*)()>(glTexCoord3hNV),"glTexCoord3hNV");
    _driver.call(&_driver.glTexCoord3hNV)(s, t, r);
  }

  static void REGAL_CALL glTexCoord3hvNV(const GLhalfNV *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord3hvNV),reinterpret_cast<void (*)()>(glTexCoord3hvNV),"glTexCoord3hvNV");
    _driver.call(&_driver.glTexCoord3hvNV)(v);
  }

  static void REGAL_CALL glTexCoord4hNV(GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord4hNV),reinterpret_cast<void (*)()>(glTexCoord4hNV),"glTexCoord4hNV");
    _driver.call(&_driver.glTexCoord4hNV)(s, t, r, q);
  }

  static void REGAL_CALL glTexCoord4hvNV(const GLhalfNV *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord4hvNV),reinterpret_cast<void (*)()>(glTexCoord4hvNV),"glTexCoord4hvNV");
    _driver.call(&_driver.glTexCoord4hvNV)(v);
  }

  static void REGAL_CALL glVertex2hNV(GLhalfNV x, GLhalfNV y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertex2hNV),reinterpret_cast<void (*)()>(glVertex2hNV),"glVertex2hNV");
    _driver.call(&_driver.glVertex2hNV)(x, y);
  }

  static void REGAL_CALL glVertex2hvNV(const GLhalfNV *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertex2hvNV),reinterpret_cast<void (*)()>(glVertex2hvNV),"glVertex2hvNV");
    _driver.call(&_driver.glVertex2hvNV)(v);
  }

  static void REGAL_CALL glVertex3hNV(GLhalfNV x, GLhalfNV y, GLhalfNV z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertex3hNV),reinterpret_cast<void (*)()>(glVertex3hNV),"glVertex3hNV");
    _driver.call(&_driver.glVertex3hNV)(x, y, z);
  }

  static void REGAL_CALL glVertex3hvNV(const GLhalfNV *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertex3hvNV),reinterpret_cast<void (*)()>(glVertex3hvNV),"glVertex3hvNV");
    _driver.call(&_driver.glVertex3hvNV)(v);
  }

  static void REGAL_CALL glVertex4hNV(GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertex4hNV),reinterpret_cast<void (*)()>(glVertex4hNV),"glVertex4hNV");
    _driver.call(&_driver.glVertex4hNV)(x, y, z, w);
  }

  static void REGAL_CALL glVertex4hvNV(const GLhalfNV *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertex4hvNV),reinterpret_cast<void (*)()>(glVertex4hvNV),"glVertex4hvNV");
    _driver.call(&_driver.glVertex4hvNV)(v);
  }

  static void REGAL_CALL glVertexAttrib1hNV(GLuint index, GLhalfNV x)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib1hNV),reinterpret_cast<void (*)()>(glVertexAttrib1hNV),"glVertexAttrib1hNV");
    _driver.call(&_driver.glVertexAttrib1hNV)(index, x);
  }

  static void REGAL_CALL glVertexAttrib1hvNV(GLuint index, const GLhalfNV *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib1hvNV),reinterpret_cast<void (*)()>(glVertexAttrib1hvNV),"glVertexAttrib1hvNV");
    _driver.call(&_driver.glVertexAttrib1hvNV)(index, v);
  }

  static void REGAL_CALL glVertexAttrib2hNV(GLuint index, GLhalfNV x, GLhalfNV y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib2hNV),reinterpret_cast<void (*)()>(glVertexAttrib2hNV),"glVertexAttrib2hNV");
    _driver.call(&_driver.glVertexAttrib2hNV)(index, x, y);
  }

  static void REGAL_CALL glVertexAttrib2hvNV(GLuint index, const GLhalfNV *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib2hvNV),reinterpret_cast<void (*)()>(glVertexAttrib2hvNV),"glVertexAttrib2hvNV");
    _driver.call(&_driver.glVertexAttrib2hvNV)(index, v);
  }

  static void REGAL_CALL glVertexAttrib3hNV(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib3hNV),reinterpret_cast<void (*)()>(glVertexAttrib3hNV),"glVertexAttrib3hNV");
    _driver.call(&_driver.glVertexAttrib3hNV)(index, x, y, z);
  }

  static void REGAL_CALL glVertexAttrib3hvNV(GLuint index, const GLhalfNV *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib3hvNV),reinterpret_cast<void (*)()>(glVertexAttrib3hvNV),"glVertexAttrib3hvNV");
    _driver.call(&_driver.glVertexAttrib3hvNV)(index, v);
  }

  static void REGAL_CALL glVertexAttrib4hNV(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib4hNV),reinterpret_cast<void (*)()>(glVertexAttrib4hNV),"glVertexAttrib4hNV");
    _driver.call(&_driver.glVertexAttrib4hNV)(index, x, y, z, w);
  }

  static void REGAL_CALL glVertexAttrib4hvNV(GLuint index, const GLhalfNV *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib4hvNV),reinterpret_cast<void (*)()>(glVertexAttrib4hvNV),"glVertexAttrib4hvNV");
    _driver.call(&_driver.glVertexAttrib4hvNV)(index, v);
  }

  static void REGAL_CALL glVertexAttribs1hvNV(GLuint index, GLsizei count, const GLhalfNV *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribs1hvNV),reinterpret_cast<void (*)()>(glVertexAttribs1hvNV),"glVertexAttribs1hvNV");
    _driver.call(&_driver.glVertexAttribs1hvNV)(index, count, v);
  }

  static void REGAL_CALL glVertexAttribs2hvNV(GLuint index, GLsizei count, const GLhalfNV *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribs2hvNV),reinterpret_cast<void (*)()>(glVertexAttribs2hvNV),"glVertexAttribs2hvNV");
    _driver.call(&_driver.glVertexAttribs2hvNV)(index, count, v);
  }

  static void REGAL_CALL glVertexAttribs3hvNV(GLuint index, GLsizei count, const GLhalfNV *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribs3hvNV),reinterpret_cast<void (*)()>(glVertexAttribs3hvNV),"glVertexAttribs3hvNV");
    _driver.call(&_driver.glVertexAttribs3hvNV)(index, count, v);
  }

  static void REGAL_CALL glVertexAttribs4hvNV(GLuint index, GLsizei count, const GLhalfNV *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribs4hvNV),reinterpret_cast<void (*)()>(glVertexAttribs4hvNV),"glVertexAttribs4hvNV");
    _driver.call(&_driver.glVertexAttribs4hvNV)(index, count, v);
  }

  static void REGAL_CALL glVertexWeighthNV(GLhalfNV weight)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexWeighthNV),reinterpret_cast<void (*)()>(glVertexWeighthNV),"glVertexWeighthNV");
    _driver.call(&_driver.glVertexWeighthNV)(weight);
  }

  static void REGAL_CALL glVertexWeighthvNV(const GLhalfNV *weight)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexWeighthvNV),reinterpret_cast<void (*)()>(glVertexWeighthvNV),"glVertexWeighthvNV");
    _driver.call(&_driver.glVertexWeighthvNV)(weight);
  }

// GL_NV_non_square_matrices

  static void REGAL_CALL glUniformMatrix2x3fvNV(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniformMatrix2x3fvNV),reinterpret_cast<void (*)()>(glUniformMatrix2x3fvNV),"glUniformMatrix2x3fvNV");
    _driver.call(&_driver.glUniformMatrix2x3fvNV)(location, count, transpose, value);
  }

  static void REGAL_CALL glUniformMatrix2x4fvNV(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniformMatrix2x4fvNV),reinterpret_cast<void (*)()>(glUniformMatrix2x4fvNV),"glUniformMatrix2x4fvNV");
    _driver.call(&_driver.glUniformMatrix2x4fvNV)(location, count, transpose, value);
  }

  static void REGAL_CALL glUniformMatrix3x2fvNV(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniformMatrix3x2fvNV),reinterpret_cast<void (*)()>(glUniformMatrix3x2fvNV),"glUniformMatrix3x2fvNV");
    _driver.call(&_driver.glUniformMatrix3x2fvNV)(location, count, transpose, value);
  }

  static void REGAL_CALL glUniformMatrix3x4fvNV(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniformMatrix3x4fvNV),reinterpret_cast<void (*)()>(glUniformMatrix3x4fvNV),"glUniformMatrix3x4fvNV");
    _driver.call(&_driver.glUniformMatrix3x4fvNV)(location, count, transpose, value);
  }

  static void REGAL_CALL glUniformMatrix4x2fvNV(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniformMatrix4x2fvNV),reinterpret_cast<void (*)()>(glUniformMatrix4x2fvNV),"glUniformMatrix4x2fvNV");
    _driver.call(&_driver.glUniformMatrix4x2fvNV)(location, count, transpose, value);
  }

  static void REGAL_CALL glUniformMatrix4x3fvNV(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniformMatrix4x3fvNV),reinterpret_cast<void (*)()>(glUniformMatrix4x3fvNV),"glUniformMatrix4x3fvNV");
    _driver.call(&_driver.glUniformMatrix4x3fvNV)(location, count, transpose, value);
  }

// GL_NV_occlusion_query

  static void REGAL_CALL glBeginOcclusionQueryNV(GLuint id)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBeginOcclusionQueryNV),reinterpret_cast<void (*)()>(glBeginOcclusionQueryNV),"glBeginOcclusionQueryNV");
    _driver.call(&_driver.glBeginOcclusionQueryNV)(id);
  }

  static void REGAL_CALL glDeleteOcclusionQueriesNV(GLsizei n, const GLuint *ids)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDeleteOcclusionQueriesNV),reinterpret_cast<void (*)()>(glDeleteOcclusionQueriesNV),"glDeleteOcclusionQueriesNV");
    _driver.call(&_driver.glDeleteOcclusionQueriesNV)(n, ids);
  }

  static void REGAL_CALL glEndOcclusionQueryNV(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glEndOcclusionQueryNV),reinterpret_cast<void (*)()>(glEndOcclusionQueryNV),"glEndOcclusionQueryNV");
    _driver.call(&_driver.glEndOcclusionQueryNV)();
  }

  static void REGAL_CALL glGenOcclusionQueriesNV(GLsizei n, GLuint *ids)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGenOcclusionQueriesNV),reinterpret_cast<void (*)()>(glGenOcclusionQueriesNV),"glGenOcclusionQueriesNV");
    _driver.call(&_driver.glGenOcclusionQueriesNV)(n, ids);
  }

  static void REGAL_CALL glGetOcclusionQueryivNV(GLuint id, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetOcclusionQueryivNV),reinterpret_cast<void (*)()>(glGetOcclusionQueryivNV),"glGetOcclusionQueryivNV");
    _driver.call(&_driver.glGetOcclusionQueryivNV)(id, pname, params);
  }

  static void REGAL_CALL glGetOcclusionQueryuivNV(GLuint id, GLenum pname, GLuint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetOcclusionQueryuivNV),reinterpret_cast<void (*)()>(glGetOcclusionQueryuivNV),"glGetOcclusionQueryuivNV");
    _driver.call(&_driver.glGetOcclusionQueryuivNV)(id, pname, params);
  }

  static GLboolean REGAL_CALL glIsOcclusionQueryNV(GLuint id)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIsOcclusionQueryNV),reinterpret_cast<void (*)()>(glIsOcclusionQueryNV),"glIsOcclusionQueryNV");
    return _driver.call(&_driver.glIsOcclusionQueryNV)(id);
  }

// GL_NV_parameter_buffer_object

  static void REGAL_CALL glProgramBufferParametersIivNV(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramBufferParametersIivNV),reinterpret_cast<void (*)()>(glProgramBufferParametersIivNV),"glProgramBufferParametersIivNV");
    _driver.call(&_driver.glProgramBufferParametersIivNV)(target, buffer, index, count, params);
  }

  static void REGAL_CALL glProgramBufferParametersIuivNV(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLuint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramBufferParametersIuivNV),reinterpret_cast<void (*)()>(glProgramBufferParametersIuivNV),"glProgramBufferParametersIuivNV");
    _driver.call(&_driver.glProgramBufferParametersIuivNV)(target, buffer, index, count, params);
  }

  static void REGAL_CALL glProgramBufferParametersfvNV(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramBufferParametersfvNV),reinterpret_cast<void (*)()>(glProgramBufferParametersfvNV),"glProgramBufferParametersfvNV");
    _driver.call(&_driver.glProgramBufferParametersfvNV)(target, buffer, index, count, params);
  }

// GL_NV_path_rendering

  static void REGAL_CALL glCopyPathNV(GLuint resultPath, GLuint srcPath)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCopyPathNV),reinterpret_cast<void (*)()>(glCopyPathNV),"glCopyPathNV");
    _driver.call(&_driver.glCopyPathNV)(resultPath, srcPath);
  }

  static void REGAL_CALL glCoverFillPathInstancedNV(GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCoverFillPathInstancedNV),reinterpret_cast<void (*)()>(glCoverFillPathInstancedNV),"glCoverFillPathInstancedNV");
    _driver.call(&_driver.glCoverFillPathInstancedNV)(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
  }

  static void REGAL_CALL glCoverFillPathNV(GLuint path, GLenum coverMode)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCoverFillPathNV),reinterpret_cast<void (*)()>(glCoverFillPathNV),"glCoverFillPathNV");
    _driver.call(&_driver.glCoverFillPathNV)(path, coverMode);
  }

  static void REGAL_CALL glCoverStrokePathInstancedNV(GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCoverStrokePathInstancedNV),reinterpret_cast<void (*)()>(glCoverStrokePathInstancedNV),"glCoverStrokePathInstancedNV");
    _driver.call(&_driver.glCoverStrokePathInstancedNV)(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
  }

  static void REGAL_CALL glCoverStrokePathNV(GLuint name, GLenum coverMode)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCoverStrokePathNV),reinterpret_cast<void (*)()>(glCoverStrokePathNV),"glCoverStrokePathNV");
    _driver.call(&_driver.glCoverStrokePathNV)(name, coverMode);
  }

  static void REGAL_CALL glDeletePathsNV(GLuint path, GLsizei range)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDeletePathsNV),reinterpret_cast<void (*)()>(glDeletePathsNV),"glDeletePathsNV");
    _driver.call(&_driver.glDeletePathsNV)(path, range);
  }

  static GLuint REGAL_CALL glGenPathsNV(GLsizei range)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGenPathsNV),reinterpret_cast<void (*)()>(glGenPathsNV),"glGenPathsNV");
    return _driver.call(&_driver.glGenPathsNV)(range);
  }

  static void REGAL_CALL glGetPathColorGenfvNV(GLenum color, GLenum pname, GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetPathColorGenfvNV),reinterpret_cast<void (*)()>(glGetPathColorGenfvNV),"glGetPathColorGenfvNV");
    _driver.call(&_driver.glGetPathColorGenfvNV)(color, pname, value);
  }

  static void REGAL_CALL glGetPathColorGenivNV(GLenum color, GLenum pname, GLint *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetPathColorGenivNV),reinterpret_cast<void (*)()>(glGetPathColorGenivNV),"glGetPathColorGenivNV");
    _driver.call(&_driver.glGetPathColorGenivNV)(color, pname, value);
  }

  static void REGAL_CALL glGetPathCommandsNV(GLuint name, GLubyte *commands)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetPathCommandsNV),reinterpret_cast<void (*)()>(glGetPathCommandsNV),"glGetPathCommandsNV");
    _driver.call(&_driver.glGetPathCommandsNV)(name, commands);
  }

  static void REGAL_CALL glGetPathCoordsNV(GLuint name, GLfloat *coords)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetPathCoordsNV),reinterpret_cast<void (*)()>(glGetPathCoordsNV),"glGetPathCoordsNV");
    _driver.call(&_driver.glGetPathCoordsNV)(name, coords);
  }

  static void REGAL_CALL glGetPathDashArrayNV(GLuint name, GLfloat *dashArray)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetPathDashArrayNV),reinterpret_cast<void (*)()>(glGetPathDashArrayNV),"glGetPathDashArrayNV");
    _driver.call(&_driver.glGetPathDashArrayNV)(name, dashArray);
  }

  static GLfloat REGAL_CALL glGetPathLengthNV(GLuint path, GLsizei startSegment, GLsizei numSegments)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetPathLengthNV),reinterpret_cast<void (*)()>(glGetPathLengthNV),"glGetPathLengthNV");
    return _driver.call(&_driver.glGetPathLengthNV)(path, startSegment, numSegments);
  }

  static void REGAL_CALL glGetPathMetricRangeNV(GLbitfield metricQueryMask, GLuint fistPathName, GLsizei numPaths, GLsizei stride, GLfloat *metrics)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetPathMetricRangeNV),reinterpret_cast<void (*)()>(glGetPathMetricRangeNV),"glGetPathMetricRangeNV");
    _driver.call(&_driver.glGetPathMetricRangeNV)(metricQueryMask, fistPathName, numPaths, stride, metrics);
  }

  static void REGAL_CALL glGetPathMetricsNV(GLbitfield metricQueryMask, GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLsizei stride, GLfloat *metrics)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetPathMetricsNV),reinterpret_cast<void (*)()>(glGetPathMetricsNV),"glGetPathMetricsNV");
    _driver.call(&_driver.glGetPathMetricsNV)(metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, metrics);
  }

  static void REGAL_CALL glGetPathParameterfvNV(GLuint name, GLenum param, GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetPathParameterfvNV),reinterpret_cast<void (*)()>(glGetPathParameterfvNV),"glGetPathParameterfvNV");
    _driver.call(&_driver.glGetPathParameterfvNV)(name, param, value);
  }

  static void REGAL_CALL glGetPathParameterivNV(GLuint name, GLenum param, GLint *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetPathParameterivNV),reinterpret_cast<void (*)()>(glGetPathParameterivNV),"glGetPathParameterivNV");
    _driver.call(&_driver.glGetPathParameterivNV)(name, param, value);
  }

  static void REGAL_CALL glGetPathSpacingNV(GLenum pathListMode, GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLfloat advanceScale, GLfloat kerningScale, GLenum transformType, GLfloat *returnedSpacing)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetPathSpacingNV),reinterpret_cast<void (*)()>(glGetPathSpacingNV),"glGetPathSpacingNV");
    _driver.call(&_driver.glGetPathSpacingNV)(pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, returnedSpacing);
  }

  static void REGAL_CALL glGetPathTexGenfvNV(GLenum texCoordSet, GLenum pname, GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetPathTexGenfvNV),reinterpret_cast<void (*)()>(glGetPathTexGenfvNV),"glGetPathTexGenfvNV");
    _driver.call(&_driver.glGetPathTexGenfvNV)(texCoordSet, pname, value);
  }

  static void REGAL_CALL glGetPathTexGenivNV(GLenum texCoordSet, GLenum pname, GLint *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetPathTexGenivNV),reinterpret_cast<void (*)()>(glGetPathTexGenivNV),"glGetPathTexGenivNV");
    _driver.call(&_driver.glGetPathTexGenivNV)(texCoordSet, pname, value);
  }

  static void REGAL_CALL glInterpolatePathsNV(GLuint resultPath, GLuint pathA, GLuint pathB, GLfloat weight)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glInterpolatePathsNV),reinterpret_cast<void (*)()>(glInterpolatePathsNV),"glInterpolatePathsNV");
    _driver.call(&_driver.glInterpolatePathsNV)(resultPath, pathA, pathB, weight);
  }

  static GLboolean REGAL_CALL glIsPathNV(GLuint path)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIsPathNV),reinterpret_cast<void (*)()>(glIsPathNV),"glIsPathNV");
    return _driver.call(&_driver.glIsPathNV)(path);
  }

  static GLboolean REGAL_CALL glIsPointInFillPathNV(GLuint path, GLuint mask, GLfloat x, GLfloat y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIsPointInFillPathNV),reinterpret_cast<void (*)()>(glIsPointInFillPathNV),"glIsPointInFillPathNV");
    return _driver.call(&_driver.glIsPointInFillPathNV)(path, mask, x, y);
  }

  static GLboolean REGAL_CALL glIsPointInStrokePathNV(GLuint path, GLfloat x, GLfloat y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIsPointInStrokePathNV),reinterpret_cast<void (*)()>(glIsPointInStrokePathNV),"glIsPointInStrokePathNV");
    return _driver.call(&_driver.glIsPointInStrokePathNV)(path, x, y);
  }

  static void REGAL_CALL glPathColorGenNV(GLenum color, GLenum genMode, GLenum colorFormat, const GLfloat *coeffs)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPathColorGenNV),reinterpret_cast<void (*)()>(glPathColorGenNV),"glPathColorGenNV");
    _driver.call(&_driver.glPathColorGenNV)(color, genMode, colorFormat, coeffs);
  }

  static void REGAL_CALL glPathCommandsNV(GLuint path, GLsizei numCommands, const GLubyte *commands, GLsizei numCoords, GLenum coordType, const GLvoid *coords)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPathCommandsNV),reinterpret_cast<void (*)()>(glPathCommandsNV),"glPathCommandsNV");
    _driver.call(&_driver.glPathCommandsNV)(path, numCommands, commands, numCoords, coordType, coords);
  }

  static void REGAL_CALL glPathCoordsNV(GLuint path, GLsizei numCoords, GLenum coordType, const GLvoid *coords)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPathCoordsNV),reinterpret_cast<void (*)()>(glPathCoordsNV),"glPathCoordsNV");
    _driver.call(&_driver.glPathCoordsNV)(path, numCoords, coordType, coords);
  }

  static void REGAL_CALL glPathCoverDepthFuncNV(GLenum zfunc)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPathCoverDepthFuncNV),reinterpret_cast<void (*)()>(glPathCoverDepthFuncNV),"glPathCoverDepthFuncNV");
    _driver.call(&_driver.glPathCoverDepthFuncNV)(zfunc);
  }

  static void REGAL_CALL glPathDashArrayNV(GLuint path, GLsizei dashCount, const GLfloat *dashArray)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPathDashArrayNV),reinterpret_cast<void (*)()>(glPathDashArrayNV),"glPathDashArrayNV");
    _driver.call(&_driver.glPathDashArrayNV)(path, dashCount, dashArray);
  }

  static void REGAL_CALL glPathFogGenNV(GLenum genMode)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPathFogGenNV),reinterpret_cast<void (*)()>(glPathFogGenNV),"glPathFogGenNV");
    _driver.call(&_driver.glPathFogGenNV)(genMode);
  }

  static void REGAL_CALL glPathGlyphRangeNV(GLuint firstPathName, GLenum fontTarget, const GLvoid *fontName, GLbitfield fontStyle, GLuint firstGlyph, GLsizei numGlyphs, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPathGlyphRangeNV),reinterpret_cast<void (*)()>(glPathGlyphRangeNV),"glPathGlyphRangeNV");
    _driver.call(&_driver.glPathGlyphRangeNV)(firstPathName, fontTarget, fontName, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale);
  }

  static void REGAL_CALL glPathGlyphsNV(GLuint firstPathName, GLenum fontTarget, const GLvoid *fontName, GLbitfield fontStyle, GLsizei numGlyphs, GLenum type, const GLvoid *charcodes, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPathGlyphsNV),reinterpret_cast<void (*)()>(glPathGlyphsNV),"glPathGlyphsNV");
    _driver.call(&_driver.glPathGlyphsNV)(firstPathName, fontTarget, fontName, fontStyle, numGlyphs, type, charcodes, handleMissingGlyphs, pathParameterTemplate, emScale);
  }

  static void REGAL_CALL glPathParameterfNV(GLuint path, GLenum pname, GLfloat value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPathParameterfNV),reinterpret_cast<void (*)()>(glPathParameterfNV),"glPathParameterfNV");
    _driver.call(&_driver.glPathParameterfNV)(path, pname, value);
  }

  static void REGAL_CALL glPathParameterfvNV(GLuint path, GLenum pname, const GLfloat *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPathParameterfvNV),reinterpret_cast<void (*)()>(glPathParameterfvNV),"glPathParameterfvNV");
    _driver.call(&_driver.glPathParameterfvNV)(path, pname, value);
  }

  static void REGAL_CALL glPathParameteriNV(GLuint path, GLenum pname, GLint value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPathParameteriNV),reinterpret_cast<void (*)()>(glPathParameteriNV),"glPathParameteriNV");
    _driver.call(&_driver.glPathParameteriNV)(path, pname, value);
  }

  static void REGAL_CALL glPathParameterivNV(GLuint path, GLenum pname, const GLint *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPathParameterivNV),reinterpret_cast<void (*)()>(glPathParameterivNV),"glPathParameterivNV");
    _driver.call(&_driver.glPathParameterivNV)(path, pname, value);
  }

  static void REGAL_CALL glPathStencilDepthOffsetNV(GLfloat factor, GLfloat units)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPathStencilDepthOffsetNV),reinterpret_cast<void (*)()>(glPathStencilDepthOffsetNV),"glPathStencilDepthOffsetNV");
    _driver.call(&_driver.glPathStencilDepthOffsetNV)(factor, units);
  }

  static void REGAL_CALL glPathStencilFuncNV(GLenum func, GLint ref, GLuint mask)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPathStencilFuncNV),reinterpret_cast<void (*)()>(glPathStencilFuncNV),"glPathStencilFuncNV");
    _driver.call(&_driver.glPathStencilFuncNV)(func, ref, mask);
  }

  static void REGAL_CALL glPathStringNV(GLuint path, GLenum format, GLsizei length, const GLvoid *pathString)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPathStringNV),reinterpret_cast<void (*)()>(glPathStringNV),"glPathStringNV");
    _driver.call(&_driver.glPathStringNV)(path, format, length, pathString);
  }

  static void REGAL_CALL glPathSubCommandsNV(GLuint path, GLsizei commandStart, GLsizei commandsToDelete, GLsizei numCommands, const GLubyte *commands, GLsizei numCoords, GLenum coordType, const GLvoid *coords)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPathSubCommandsNV),reinterpret_cast<void (*)()>(glPathSubCommandsNV),"glPathSubCommandsNV");
    _driver.call(&_driver.glPathSubCommandsNV)(path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, coords);
  }

  static void REGAL_CALL glPathSubCoordsNV(GLuint path, GLsizei coordStart, GLsizei numCoords, GLenum coordType, const GLvoid *coords)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPathSubCoordsNV),reinterpret_cast<void (*)()>(glPathSubCoordsNV),"glPathSubCoordsNV");
    _driver.call(&_driver.glPathSubCoordsNV)(path, coordStart, numCoords, coordType, coords);
  }

  static void REGAL_CALL glPathTexGenNV(GLenum texCoordSet, GLenum genMode, GLint components, const GLfloat *coeffs)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPathTexGenNV),reinterpret_cast<void (*)()>(glPathTexGenNV),"glPathTexGenNV");
    _driver.call(&_driver.glPathTexGenNV)(texCoordSet, genMode, components, coeffs);
  }

  static GLboolean REGAL_CALL glPointAlongPathNV(GLuint path, GLsizei startSegment, GLsizei numSegments, GLfloat distance, GLfloat *x, GLfloat *y, GLfloat *tangentX, GLfloat *tangentY)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPointAlongPathNV),reinterpret_cast<void (*)()>(glPointAlongPathNV),"glPointAlongPathNV");
    return _driver.call(&_driver.glPointAlongPathNV)(path, startSegment, numSegments, distance, x, y, tangentX, tangentY);
  }

  static void REGAL_CALL glStencilFillPathInstancedNV(GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum transformType, const GLfloat *transformValues)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glStencilFillPathInstancedNV),reinterpret_cast<void (*)()>(glStencilFillPathInstancedNV),"glStencilFillPathInstancedNV");
    _driver.call(&_driver.glStencilFillPathInstancedNV)(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues);
  }

  static void REGAL_CALL glStencilFillPathNV(GLuint path, GLenum fillMode, GLuint mask)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glStencilFillPathNV),reinterpret_cast<void (*)()>(glStencilFillPathNV),"glStencilFillPathNV");
    _driver.call(&_driver.glStencilFillPathNV)(path, fillMode, mask);
  }

  static void REGAL_CALL glStencilStrokePathInstancedNV(GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLint reference, GLuint mask, GLenum transformType, const GLfloat *transformValues)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glStencilStrokePathInstancedNV),reinterpret_cast<void (*)()>(glStencilStrokePathInstancedNV),"glStencilStrokePathInstancedNV");
    _driver.call(&_driver.glStencilStrokePathInstancedNV)(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues);
  }

  static void REGAL_CALL glStencilStrokePathNV(GLuint path, GLint reference, GLuint mask)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glStencilStrokePathNV),reinterpret_cast<void (*)()>(glStencilStrokePathNV),"glStencilStrokePathNV");
    _driver.call(&_driver.glStencilStrokePathNV)(path, reference, mask);
  }

  static void REGAL_CALL glTransformPathNV(GLuint resultPath, GLuint srcPath, GLenum transformType, const GLfloat *transformValues)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTransformPathNV),reinterpret_cast<void (*)()>(glTransformPathNV),"glTransformPathNV");
    _driver.call(&_driver.glTransformPathNV)(resultPath, srcPath, transformType, transformValues);
  }

  static void REGAL_CALL glWeightPathsNV(GLuint resultPath, GLsizei numPaths, const GLuint *paths, const GLfloat *weights)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWeightPathsNV),reinterpret_cast<void (*)()>(glWeightPathsNV),"glWeightPathsNV");
    _driver.call(&_driver.glWeightPathsNV)(resultPath, numPaths, paths, weights);
  }

// GL_NV_pixel_data_range

  static void REGAL_CALL glFlushPixelDataRangeNV(GLenum target)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFlushPixelDataRangeNV),reinterpret_cast<void (*)()>(glFlushPixelDataRangeNV),"glFlushPixelDataRangeNV");
    _driver.call(&_driver.glFlushPixelDataRangeNV)(target);
  }

  static void REGAL_CALL glPixelDataRangeNV(GLenum target, GLsizei size, const GLvoid *pointer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPixelDataRangeNV),reinterpret_cast<void (*)()>(glPixelDataRangeNV),"glPixelDataRangeNV");
    _driver.call(&_driver.glPixelDataRangeNV)(target, size, pointer);
  }

// GL_NV_point_sprite

  static void REGAL_CALL glPointParameteriNV(GLenum pname, GLint param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPointParameteriNV),reinterpret_cast<void (*)()>(glPointParameteriNV),"glPointParameteriNV");
    _driver.call(&_driver.glPointParameteriNV)(pname, param);
  }

  static void REGAL_CALL glPointParameterivNV(GLenum pname, const GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPointParameterivNV),reinterpret_cast<void (*)()>(glPointParameterivNV),"glPointParameterivNV");
    _driver.call(&_driver.glPointParameterivNV)(pname, params);
  }

// GL_NV_present_video

  static void REGAL_CALL glGetVideoi64vNV(GLuint video_slot, GLenum pname, GLint64EXT *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetVideoi64vNV),reinterpret_cast<void (*)()>(glGetVideoi64vNV),"glGetVideoi64vNV");
    _driver.call(&_driver.glGetVideoi64vNV)(video_slot, pname, params);
  }

  static void REGAL_CALL glGetVideoivNV(GLuint video_slot, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetVideoivNV),reinterpret_cast<void (*)()>(glGetVideoivNV),"glGetVideoivNV");
    _driver.call(&_driver.glGetVideoivNV)(video_slot, pname, params);
  }

  static void REGAL_CALL glGetVideoui64vNV(GLuint video_slot, GLenum pname, GLuint64EXT *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetVideoui64vNV),reinterpret_cast<void (*)()>(glGetVideoui64vNV),"glGetVideoui64vNV");
    _driver.call(&_driver.glGetVideoui64vNV)(video_slot, pname, params);
  }

  static void REGAL_CALL glGetVideouivNV(GLuint video_slot, GLenum pname, GLuint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetVideouivNV),reinterpret_cast<void (*)()>(glGetVideouivNV),"glGetVideouivNV");
    _driver.call(&_driver.glGetVideouivNV)(video_slot, pname, params);
  }

  static void REGAL_CALL glPresentFrameDualFillNV(GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLenum target1, GLuint fill1, GLenum target2, GLuint fill2, GLenum target3, GLuint fill3)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPresentFrameDualFillNV),reinterpret_cast<void (*)()>(glPresentFrameDualFillNV),"glPresentFrameDualFillNV");
    _driver.call(&_driver.glPresentFrameDualFillNV)(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, target1, fill1, target2, fill2, target3, fill3);
  }

  static void REGAL_CALL glPresentFrameKeyedNV(GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLuint key0, GLenum target1, GLuint fill1, GLuint key1)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPresentFrameKeyedNV),reinterpret_cast<void (*)()>(glPresentFrameKeyedNV),"glPresentFrameKeyedNV");
    _driver.call(&_driver.glPresentFrameKeyedNV)(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, key0, target1, fill1, key1);
  }

// GL_NV_primitive_restart

  static void REGAL_CALL glPrimitiveRestartIndexNV(GLuint index)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPrimitiveRestartIndexNV),reinterpret_cast<void (*)()>(glPrimitiveRestartIndexNV),"glPrimitiveRestartIndexNV");
    _driver.call(&_driver.glPrimitiveRestartIndexNV)(index);
  }

  static void REGAL_CALL glPrimitiveRestartNV(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPrimitiveRestartNV),reinterpret_cast<void (*)()>(glPrimitiveRestartNV),"glPrimitiveRestartNV");
    _driver.call(&_driver.glPrimitiveRestartNV)();
  }

// GL_NV_read_buffer

  static void REGAL_CALL glReadBufferNV(GLenum mode)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glReadBufferNV),reinterpret_cast<void (*)()>(glReadBufferNV),"glReadBufferNV");
    _driver.call(&_driver.glReadBufferNV)(mode);
  }

// GL_NV_register_combiners

  static void REGAL_CALL glCombinerInputNV(GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCombinerInputNV),reinterpret_cast<void (*)()>(glCombinerInputNV),"glCombinerInputNV");
    _driver.call(&_driver.glCombinerInputNV)(stage, portion, variable, input, mapping, componentUsage);
  }

  static void REGAL_CALL glCombinerOutputNV(GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCombinerOutputNV),reinterpret_cast<void (*)()>(glCombinerOutputNV),"glCombinerOutputNV");
    _driver.call(&_driver.glCombinerOutputNV)(stage, portion, abOutput, cdOutput, sumOutput, scale, bias, abDotProduct, cdDotProduct, muxSum);
  }

  static void REGAL_CALL glCombinerParameterfNV(GLenum pname, GLfloat param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCombinerParameterfNV),reinterpret_cast<void (*)()>(glCombinerParameterfNV),"glCombinerParameterfNV");
    _driver.call(&_driver.glCombinerParameterfNV)(pname, param);
  }

  static void REGAL_CALL glCombinerParameterfvNV(GLenum pname, const GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCombinerParameterfvNV),reinterpret_cast<void (*)()>(glCombinerParameterfvNV),"glCombinerParameterfvNV");
    _driver.call(&_driver.glCombinerParameterfvNV)(pname, params);
  }

  static void REGAL_CALL glCombinerParameteriNV(GLenum pname, GLint param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCombinerParameteriNV),reinterpret_cast<void (*)()>(glCombinerParameteriNV),"glCombinerParameteriNV");
    _driver.call(&_driver.glCombinerParameteriNV)(pname, param);
  }

  static void REGAL_CALL glCombinerParameterivNV(GLenum pname, const GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCombinerParameterivNV),reinterpret_cast<void (*)()>(glCombinerParameterivNV),"glCombinerParameterivNV");
    _driver.call(&_driver.glCombinerParameterivNV)(pname, params);
  }

  static void REGAL_CALL glFinalCombinerInputNV(GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFinalCombinerInputNV),reinterpret_cast<void (*)()>(glFinalCombinerInputNV),"glFinalCombinerInputNV");
    _driver.call(&_driver.glFinalCombinerInputNV)(variable, input, mapping, componentUsage);
  }

  static void REGAL_CALL glGetCombinerInputParameterfvNV(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetCombinerInputParameterfvNV),reinterpret_cast<void (*)()>(glGetCombinerInputParameterfvNV),"glGetCombinerInputParameterfvNV");
    _driver.call(&_driver.glGetCombinerInputParameterfvNV)(stage, portion, variable, pname, params);
  }

  static void REGAL_CALL glGetCombinerInputParameterivNV(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetCombinerInputParameterivNV),reinterpret_cast<void (*)()>(glGetCombinerInputParameterivNV),"glGetCombinerInputParameterivNV");
    _driver.call(&_driver.glGetCombinerInputParameterivNV)(stage, portion, variable, pname, params);
  }

  static void REGAL_CALL glGetCombinerOutputParameterfvNV(GLenum stage, GLenum portion, GLenum pname, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetCombinerOutputParameterfvNV),reinterpret_cast<void (*)()>(glGetCombinerOutputParameterfvNV),"glGetCombinerOutputParameterfvNV");
    _driver.call(&_driver.glGetCombinerOutputParameterfvNV)(stage, portion, pname, params);
  }

  static void REGAL_CALL glGetCombinerOutputParameterivNV(GLenum stage, GLenum portion, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetCombinerOutputParameterivNV),reinterpret_cast<void (*)()>(glGetCombinerOutputParameterivNV),"glGetCombinerOutputParameterivNV");
    _driver.call(&_driver.glGetCombinerOutputParameterivNV)(stage, portion, pname, params);
  }

  static void REGAL_CALL glGetFinalCombinerInputParameterfvNV(GLenum variable, GLenum pname, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetFinalCombinerInputParameterfvNV),reinterpret_cast<void (*)()>(glGetFinalCombinerInputParameterfvNV),"glGetFinalCombinerInputParameterfvNV");
    _driver.call(&_driver.glGetFinalCombinerInputParameterfvNV)(variable, pname, params);
  }

  static void REGAL_CALL glGetFinalCombinerInputParameterivNV(GLenum variable, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetFinalCombinerInputParameterivNV),reinterpret_cast<void (*)()>(glGetFinalCombinerInputParameterivNV),"glGetFinalCombinerInputParameterivNV");
    _driver.call(&_driver.glGetFinalCombinerInputParameterivNV)(variable, pname, params);
  }

// GL_NV_register_combiners2

  static void REGAL_CALL glCombinerStageParameterfvNV(GLenum stage, GLenum pname, const GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCombinerStageParameterfvNV),reinterpret_cast<void (*)()>(glCombinerStageParameterfvNV),"glCombinerStageParameterfvNV");
    _driver.call(&_driver.glCombinerStageParameterfvNV)(stage, pname, params);
  }

  static void REGAL_CALL glGetCombinerStageParameterfvNV(GLenum stage, GLenum pname, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetCombinerStageParameterfvNV),reinterpret_cast<void (*)()>(glGetCombinerStageParameterfvNV),"glGetCombinerStageParameterfvNV");
    _driver.call(&_driver.glGetCombinerStageParameterfvNV)(stage, pname, params);
  }

// GL_NV_shader_buffer_load

  static void REGAL_CALL glGetBufferParameterui64vNV(GLenum target, GLenum pname, GLuint64EXT *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetBufferParameterui64vNV),reinterpret_cast<void (*)()>(glGetBufferParameterui64vNV),"glGetBufferParameterui64vNV");
    _driver.call(&_driver.glGetBufferParameterui64vNV)(target, pname, params);
  }

  static void REGAL_CALL glGetIntegerui64vNV(GLenum target, GLuint64EXT *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetIntegerui64vNV),reinterpret_cast<void (*)()>(glGetIntegerui64vNV),"glGetIntegerui64vNV");
    _driver.call(&_driver.glGetIntegerui64vNV)(target, data);
  }

  static void REGAL_CALL glGetNamedBufferParameterui64vNV(GLuint buffer, GLenum pname, GLuint64EXT *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetNamedBufferParameterui64vNV),reinterpret_cast<void (*)()>(glGetNamedBufferParameterui64vNV),"glGetNamedBufferParameterui64vNV");
    _driver.call(&_driver.glGetNamedBufferParameterui64vNV)(buffer, pname, params);
  }

  static void REGAL_CALL glGetUniformui64vNV(GLuint program, GLint location, GLuint64EXT *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetUniformui64vNV),reinterpret_cast<void (*)()>(glGetUniformui64vNV),"glGetUniformui64vNV");
    _driver.call(&_driver.glGetUniformui64vNV)(program, location, params);
  }

  static GLboolean REGAL_CALL glIsBufferResidentNV(GLenum target)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIsBufferResidentNV),reinterpret_cast<void (*)()>(glIsBufferResidentNV),"glIsBufferResidentNV");
    return _driver.call(&_driver.glIsBufferResidentNV)(target);
  }

  static GLboolean REGAL_CALL glIsNamedBufferResidentNV(GLuint buffer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIsNamedBufferResidentNV),reinterpret_cast<void (*)()>(glIsNamedBufferResidentNV),"glIsNamedBufferResidentNV");
    return _driver.call(&_driver.glIsNamedBufferResidentNV)(buffer);
  }

  static void REGAL_CALL glMakeBufferNonResidentNV(GLenum target)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMakeBufferNonResidentNV),reinterpret_cast<void (*)()>(glMakeBufferNonResidentNV),"glMakeBufferNonResidentNV");
    _driver.call(&_driver.glMakeBufferNonResidentNV)(target);
  }

  static void REGAL_CALL glMakeBufferResidentNV(GLenum target, GLenum access)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMakeBufferResidentNV),reinterpret_cast<void (*)()>(glMakeBufferResidentNV),"glMakeBufferResidentNV");
    _driver.call(&_driver.glMakeBufferResidentNV)(target, access);
  }

  static void REGAL_CALL glMakeNamedBufferNonResidentNV(GLuint buffer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMakeNamedBufferNonResidentNV),reinterpret_cast<void (*)()>(glMakeNamedBufferNonResidentNV),"glMakeNamedBufferNonResidentNV");
    _driver.call(&_driver.glMakeNamedBufferNonResidentNV)(buffer);
  }

  static void REGAL_CALL glMakeNamedBufferResidentNV(GLuint buffer, GLenum access)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMakeNamedBufferResidentNV),reinterpret_cast<void (*)()>(glMakeNamedBufferResidentNV),"glMakeNamedBufferResidentNV");
    _driver.call(&_driver.glMakeNamedBufferResidentNV)(buffer, access);
  }

  static void REGAL_CALL glProgramUniformui64NV(GLuint program, GLint location, GLuint64EXT v0)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniformui64NV),reinterpret_cast<void (*)()>(glProgramUniformui64NV),"glProgramUniformui64NV");
    _driver.call(&_driver.glProgramUniformui64NV)(program, location, v0);
  }

  static void REGAL_CALL glProgramUniformui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramUniformui64vNV),reinterpret_cast<void (*)()>(glProgramUniformui64vNV),"glProgramUniformui64vNV");
    _driver.call(&_driver.glProgramUniformui64vNV)(program, location, count, value);
  }

  static void REGAL_CALL glUniformui64NV(GLint location, GLuint64EXT v0)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniformui64NV),reinterpret_cast<void (*)()>(glUniformui64NV),"glUniformui64NV");
    _driver.call(&_driver.glUniformui64NV)(location, v0);
  }

  static void REGAL_CALL glUniformui64vNV(GLint location, GLsizei count, const GLuint64EXT *value)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUniformui64vNV),reinterpret_cast<void (*)()>(glUniformui64vNV),"glUniformui64vNV");
    _driver.call(&_driver.glUniformui64vNV)(location, count, value);
  }

// GL_NV_texture_barrier

  static void REGAL_CALL glTextureBarrierNV(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTextureBarrierNV),reinterpret_cast<void (*)()>(glTextureBarrierNV),"glTextureBarrierNV");
    _driver.call(&_driver.glTextureBarrierNV)();
  }

// GL_NV_texture_multisample

  static void REGAL_CALL glTexImage2DMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexImage2DMultisampleCoverageNV),reinterpret_cast<void (*)()>(glTexImage2DMultisampleCoverageNV),"glTexImage2DMultisampleCoverageNV");
    _driver.call(&_driver.glTexImage2DMultisampleCoverageNV)(target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
  }

  static void REGAL_CALL glTexImage3DMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexImage3DMultisampleCoverageNV),reinterpret_cast<void (*)()>(glTexImage3DMultisampleCoverageNV),"glTexImage3DMultisampleCoverageNV");
    _driver.call(&_driver.glTexImage3DMultisampleCoverageNV)(target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
  }

  static void REGAL_CALL glTextureImage2DMultisampleCoverageNV(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTextureImage2DMultisampleCoverageNV),reinterpret_cast<void (*)()>(glTextureImage2DMultisampleCoverageNV),"glTextureImage2DMultisampleCoverageNV");
    _driver.call(&_driver.glTextureImage2DMultisampleCoverageNV)(texture, target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
  }

  static void REGAL_CALL glTextureImage2DMultisampleNV(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTextureImage2DMultisampleNV),reinterpret_cast<void (*)()>(glTextureImage2DMultisampleNV),"glTextureImage2DMultisampleNV");
    _driver.call(&_driver.glTextureImage2DMultisampleNV)(texture, target, samples, internalFormat, width, height, fixedSampleLocations);
  }

  static void REGAL_CALL glTextureImage3DMultisampleCoverageNV(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTextureImage3DMultisampleCoverageNV),reinterpret_cast<void (*)()>(glTextureImage3DMultisampleCoverageNV),"glTextureImage3DMultisampleCoverageNV");
    _driver.call(&_driver.glTextureImage3DMultisampleCoverageNV)(texture, target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
  }

  static void REGAL_CALL glTextureImage3DMultisampleNV(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTextureImage3DMultisampleNV),reinterpret_cast<void (*)()>(glTextureImage3DMultisampleNV),"glTextureImage3DMultisampleNV");
    _driver.call(&_driver.glTextureImage3DMultisampleNV)(texture, target, samples, internalFormat, width, height, depth, fixedSampleLocations);
  }

// GL_NV_transform_feedback

  static void REGAL_CALL glActiveVaryingNV(GLuint program, const GLchar *name)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glActiveVaryingNV),reinterpret_cast<void (*)()>(glActiveVaryingNV),"glActiveVaryingNV");
    _driver.call(&_driver.glActiveVaryingNV)(program, name);
  }

  static void REGAL_CALL glBeginTransformFeedbackNV(GLenum primitiveMode)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBeginTransformFeedbackNV),reinterpret_cast<void (*)()>(glBeginTransformFeedbackNV),"glBeginTransformFeedbackNV");
    _driver.call(&_driver.glBeginTransformFeedbackNV)(primitiveMode);
  }

  static void REGAL_CALL glBindBufferBaseNV(GLenum target, GLuint index, GLuint buffer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBindBufferBaseNV),reinterpret_cast<void (*)()>(glBindBufferBaseNV),"glBindBufferBaseNV");
    _driver.call(&_driver.glBindBufferBaseNV)(target, index, buffer);
  }

  static void REGAL_CALL glBindBufferOffsetNV(GLenum target, GLuint index, GLuint buffer, GLintptr offset)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBindBufferOffsetNV),reinterpret_cast<void (*)()>(glBindBufferOffsetNV),"glBindBufferOffsetNV");
    _driver.call(&_driver.glBindBufferOffsetNV)(target, index, buffer, offset);
  }

  static void REGAL_CALL glBindBufferRangeNV(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBindBufferRangeNV),reinterpret_cast<void (*)()>(glBindBufferRangeNV),"glBindBufferRangeNV");
    _driver.call(&_driver.glBindBufferRangeNV)(target, index, buffer, offset, size);
  }

  static void REGAL_CALL glEndTransformFeedbackNV(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glEndTransformFeedbackNV),reinterpret_cast<void (*)()>(glEndTransformFeedbackNV),"glEndTransformFeedbackNV");
    _driver.call(&_driver.glEndTransformFeedbackNV)();
  }

  static void REGAL_CALL glGetActiveVaryingNV(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetActiveVaryingNV),reinterpret_cast<void (*)()>(glGetActiveVaryingNV),"glGetActiveVaryingNV");
    _driver.call(&_driver.glGetActiveVaryingNV)(program, index, bufSize, length, size, type, name);
  }

  static void REGAL_CALL glGetTransformFeedbackVaryingNV(GLuint program, GLuint index, GLint *location)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetTransformFeedbackVaryingNV),reinterpret_cast<void (*)()>(glGetTransformFeedbackVaryingNV),"glGetTransformFeedbackVaryingNV");
    _driver.call(&_driver.glGetTransformFeedbackVaryingNV)(program, index, location);
  }

  static GLint REGAL_CALL glGetVaryingLocationNV(GLuint program, const GLchar *name)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetVaryingLocationNV),reinterpret_cast<void (*)()>(glGetVaryingLocationNV),"glGetVaryingLocationNV");
    return _driver.call(&_driver.glGetVaryingLocationNV)(program, name);
  }

  static void REGAL_CALL glTransformFeedbackAttribsNV(GLuint count, const GLint *attribs, GLenum bufferMode)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTransformFeedbackAttribsNV),reinterpret_cast<void (*)()>(glTransformFeedbackAttribsNV),"glTransformFeedbackAttribsNV");
    _driver.call(&_driver.glTransformFeedbackAttribsNV)(count, attribs, bufferMode);
  }

  static void REGAL_CALL glTransformFeedbackVaryingsNV(GLuint program, GLsizei count, const GLint *locations, GLenum bufferMode)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTransformFeedbackVaryingsNV),reinterpret_cast<void (*)()>(glTransformFeedbackVaryingsNV),"glTransformFeedbackVaryingsNV");
    _driver.call(&_driver.glTransformFeedbackVaryingsNV)(program, count, locations, bufferMode);
  }

// GL_NV_transform_feedback2

  static void REGAL_CALL glBindTransformFeedbackNV(GLenum target, GLuint id)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBindTransformFeedbackNV),reinterpret_cast<void (*)()>(glBindTransformFeedbackNV),"glBindTransformFeedbackNV");
    _driver.call(&_driver.glBindTransformFeedbackNV)(target, id);
  }

  static void REGAL_CALL glDeleteTransformFeedbacksNV(GLsizei n, const GLuint *ids)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDeleteTransformFeedbacksNV),reinterpret_cast<void (*)()>(glDeleteTransformFeedbacksNV),"glDeleteTransformFeedbacksNV");
    _driver.call(&_driver.glDeleteTransformFeedbacksNV)(n, ids);
  }

  static void REGAL_CALL glDrawTransformFeedbackNV(GLenum mode, GLuint name)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDrawTransformFeedbackNV),reinterpret_cast<void (*)()>(glDrawTransformFeedbackNV),"glDrawTransformFeedbackNV");
    _driver.call(&_driver.glDrawTransformFeedbackNV)(mode, name);
  }

  static void REGAL_CALL glGenTransformFeedbacksNV(GLsizei n, GLuint *ids)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGenTransformFeedbacksNV),reinterpret_cast<void (*)()>(glGenTransformFeedbacksNV),"glGenTransformFeedbacksNV");
    _driver.call(&_driver.glGenTransformFeedbacksNV)(n, ids);
  }

  static GLboolean REGAL_CALL glIsTransformFeedbackNV(GLuint id)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIsTransformFeedbackNV),reinterpret_cast<void (*)()>(glIsTransformFeedbackNV),"glIsTransformFeedbackNV");
    return _driver.call(&_driver.glIsTransformFeedbackNV)(id);
  }

  static void REGAL_CALL glPauseTransformFeedbackNV(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPauseTransformFeedbackNV),reinterpret_cast<void (*)()>(glPauseTransformFeedbackNV),"glPauseTransformFeedbackNV");
    _driver.call(&_driver.glPauseTransformFeedbackNV)();
  }

  static void REGAL_CALL glResumeTransformFeedbackNV(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glResumeTransformFeedbackNV),reinterpret_cast<void (*)()>(glResumeTransformFeedbackNV),"glResumeTransformFeedbackNV");
    _driver.call(&_driver.glResumeTransformFeedbackNV)();
  }

// GL_NV_vdpau_interop

  static void REGAL_CALL glVDPAUFiniNV(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVDPAUFiniNV),reinterpret_cast<void (*)()>(glVDPAUFiniNV),"glVDPAUFiniNV");
    _driver.call(&_driver.glVDPAUFiniNV)();
  }

  static void REGAL_CALL glVDPAUGetSurfaceivNV(GLvdpauSurfaceNV surface, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVDPAUGetSurfaceivNV),reinterpret_cast<void (*)()>(glVDPAUGetSurfaceivNV),"glVDPAUGetSurfaceivNV");
    _driver.call(&_driver.glVDPAUGetSurfaceivNV)(surface, pname, bufSize, length, values);
  }

  static void REGAL_CALL glVDPAUInitNV(const GLvoid *vdpDevice, const GLvoid *getProcAddress)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVDPAUInitNV),reinterpret_cast<void (*)()>(glVDPAUInitNV),"glVDPAUInitNV");
    _driver.call(&_driver.glVDPAUInitNV)(vdpDevice, getProcAddress);
  }

  static GLboolean REGAL_CALL glVDPAUIsSurfaceNV(GLvdpauSurfaceNV surface)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVDPAUIsSurfaceNV),reinterpret_cast<void (*)()>(glVDPAUIsSurfaceNV),"glVDPAUIsSurfaceNV");
    return _driver.call(&_driver.glVDPAUIsSurfaceNV)(surface);
  }

  static void REGAL_CALL glVDPAUMapSurfacesNV(GLsizei numSurfaces, const GLvdpauSurfaceNV *surfaces)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVDPAUMapSurfacesNV),reinterpret_cast<void (*)()>(glVDPAUMapSurfacesNV),"glVDPAUMapSurfacesNV");
    _driver.call(&_driver.glVDPAUMapSurfacesNV)(numSurfaces, surfaces);
  }

  static GLvdpauSurfaceNV REGAL_CALL glVDPAURegisterOutputSurfaceNV(const GLvoid *vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVDPAURegisterOutputSurfaceNV),reinterpret_cast<void (*)()>(glVDPAURegisterOutputSurfaceNV),"glVDPAURegisterOutputSurfaceNV");
    return _driver.call(&_driver.glVDPAURegisterOutputSurfaceNV)(vdpSurface, target, numTextureNames, textureNames);
  }

  static GLvdpauSurfaceNV REGAL_CALL glVDPAURegisterVideoSurfaceNV(const GLvoid *vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVDPAURegisterVideoSurfaceNV),reinterpret_cast<void (*)()>(glVDPAURegisterVideoSurfaceNV),"glVDPAURegisterVideoSurfaceNV");
    return _driver.call(&_driver.glVDPAURegisterVideoSurfaceNV)(vdpSurface, target, numTextureNames, textureNames);
  }

  static void REGAL_CALL glVDPAUSurfaceAccessNV(GLvdpauSurfaceNV surface, GLenum access)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVDPAUSurfaceAccessNV),reinterpret_cast<void (*)()>(glVDPAUSurfaceAccessNV),"glVDPAUSurfaceAccessNV");
    _driver.call(&_driver.glVDPAUSurfaceAccessNV)(surface, access);
  }

  static void REGAL_CALL glVDPAUUnmapSurfacesNV(GLsizei numSurfaces, const GLvdpauSurfaceNV *surfaces)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVDPAUUnmapSurfacesNV),reinterpret_cast<void (*)()>(glVDPAUUnmapSurfacesNV),"glVDPAUUnmapSurfacesNV");
    _driver.call(&_driver.glVDPAUUnmapSurfacesNV)(numSurfaces, surfaces);
  }

  static void REGAL_CALL glVDPAUUnregisterSurfaceNV(GLvdpauSurfaceNV surface)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVDPAUUnregisterSurfaceNV),reinterpret_cast<void (*)()>(glVDPAUUnregisterSurfaceNV),"glVDPAUUnregisterSurfaceNV");
    _driver.call(&_driver.glVDPAUUnregisterSurfaceNV)(surface);
  }

// GL_NV_vertex_array_range

  static void REGAL_CALL glFlushVertexArrayRangeNV(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFlushVertexArrayRangeNV),reinterpret_cast<void (*)()>(glFlushVertexArrayRangeNV),"glFlushVertexArrayRangeNV");
    _driver.call(&_driver.glFlushVertexArrayRangeNV)();
  }

  static void REGAL_CALL glVertexArrayRangeNV(GLsizei size, const GLvoid *pointer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexArrayRangeNV),reinterpret_cast<void (*)()>(glVertexArrayRangeNV),"glVertexArrayRangeNV");
    _driver.call(&_driver.glVertexArrayRangeNV)(size, pointer);
  }

// GL_NV_vertex_attrib_integer_64bit

  static void REGAL_CALL glGetVertexAttribLi64vNV(GLuint index, GLenum pname, GLint64EXT *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetVertexAttribLi64vNV),reinterpret_cast<void (*)()>(glGetVertexAttribLi64vNV),"glGetVertexAttribLi64vNV");
    _driver.call(&_driver.glGetVertexAttribLi64vNV)(index, pname, params);
  }

  static void REGAL_CALL glGetVertexAttribLui64vNV(GLuint index, GLenum pname, GLuint64EXT *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetVertexAttribLui64vNV),reinterpret_cast<void (*)()>(glGetVertexAttribLui64vNV),"glGetVertexAttribLui64vNV");
    _driver.call(&_driver.glGetVertexAttribLui64vNV)(index, pname, params);
  }

  static void REGAL_CALL glVertexAttribL1i64NV(GLuint index, GLint64EXT x)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribL1i64NV),reinterpret_cast<void (*)()>(glVertexAttribL1i64NV),"glVertexAttribL1i64NV");
    _driver.call(&_driver.glVertexAttribL1i64NV)(index, x);
  }

  static void REGAL_CALL glVertexAttribL1i64vNV(GLuint index, const GLint64EXT *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribL1i64vNV),reinterpret_cast<void (*)()>(glVertexAttribL1i64vNV),"glVertexAttribL1i64vNV");
    _driver.call(&_driver.glVertexAttribL1i64vNV)(index, v);
  }

  static void REGAL_CALL glVertexAttribL1ui64NV(GLuint index, GLuint64EXT x)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribL1ui64NV),reinterpret_cast<void (*)()>(glVertexAttribL1ui64NV),"glVertexAttribL1ui64NV");
    _driver.call(&_driver.glVertexAttribL1ui64NV)(index, x);
  }

  static void REGAL_CALL glVertexAttribL1ui64vNV(GLuint index, const GLuint64EXT *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribL1ui64vNV),reinterpret_cast<void (*)()>(glVertexAttribL1ui64vNV),"glVertexAttribL1ui64vNV");
    _driver.call(&_driver.glVertexAttribL1ui64vNV)(index, v);
  }

  static void REGAL_CALL glVertexAttribL2i64NV(GLuint index, GLint64EXT x, GLint64EXT y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribL2i64NV),reinterpret_cast<void (*)()>(glVertexAttribL2i64NV),"glVertexAttribL2i64NV");
    _driver.call(&_driver.glVertexAttribL2i64NV)(index, x, y);
  }

  static void REGAL_CALL glVertexAttribL2i64vNV(GLuint index, const GLint64EXT *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribL2i64vNV),reinterpret_cast<void (*)()>(glVertexAttribL2i64vNV),"glVertexAttribL2i64vNV");
    _driver.call(&_driver.glVertexAttribL2i64vNV)(index, v);
  }

  static void REGAL_CALL glVertexAttribL2ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribL2ui64NV),reinterpret_cast<void (*)()>(glVertexAttribL2ui64NV),"glVertexAttribL2ui64NV");
    _driver.call(&_driver.glVertexAttribL2ui64NV)(index, x, y);
  }

  static void REGAL_CALL glVertexAttribL2ui64vNV(GLuint index, const GLuint64EXT *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribL2ui64vNV),reinterpret_cast<void (*)()>(glVertexAttribL2ui64vNV),"glVertexAttribL2ui64vNV");
    _driver.call(&_driver.glVertexAttribL2ui64vNV)(index, v);
  }

  static void REGAL_CALL glVertexAttribL3i64NV(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribL3i64NV),reinterpret_cast<void (*)()>(glVertexAttribL3i64NV),"glVertexAttribL3i64NV");
    _driver.call(&_driver.glVertexAttribL3i64NV)(index, x, y, z);
  }

  static void REGAL_CALL glVertexAttribL3i64vNV(GLuint index, const GLint64EXT *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribL3i64vNV),reinterpret_cast<void (*)()>(glVertexAttribL3i64vNV),"glVertexAttribL3i64vNV");
    _driver.call(&_driver.glVertexAttribL3i64vNV)(index, v);
  }

  static void REGAL_CALL glVertexAttribL3ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribL3ui64NV),reinterpret_cast<void (*)()>(glVertexAttribL3ui64NV),"glVertexAttribL3ui64NV");
    _driver.call(&_driver.glVertexAttribL3ui64NV)(index, x, y, z);
  }

  static void REGAL_CALL glVertexAttribL3ui64vNV(GLuint index, const GLuint64EXT *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribL3ui64vNV),reinterpret_cast<void (*)()>(glVertexAttribL3ui64vNV),"glVertexAttribL3ui64vNV");
    _driver.call(&_driver.glVertexAttribL3ui64vNV)(index, v);
  }

  static void REGAL_CALL glVertexAttribL4i64NV(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribL4i64NV),reinterpret_cast<void (*)()>(glVertexAttribL4i64NV),"glVertexAttribL4i64NV");
    _driver.call(&_driver.glVertexAttribL4i64NV)(index, x, y, z, w);
  }

  static void REGAL_CALL glVertexAttribL4i64vNV(GLuint index, const GLint64EXT *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribL4i64vNV),reinterpret_cast<void (*)()>(glVertexAttribL4i64vNV),"glVertexAttribL4i64vNV");
    _driver.call(&_driver.glVertexAttribL4i64vNV)(index, v);
  }

  static void REGAL_CALL glVertexAttribL4ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribL4ui64NV),reinterpret_cast<void (*)()>(glVertexAttribL4ui64NV),"glVertexAttribL4ui64NV");
    _driver.call(&_driver.glVertexAttribL4ui64NV)(index, x, y, z, w);
  }

  static void REGAL_CALL glVertexAttribL4ui64vNV(GLuint index, const GLuint64EXT *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribL4ui64vNV),reinterpret_cast<void (*)()>(glVertexAttribL4ui64vNV),"glVertexAttribL4ui64vNV");
    _driver.call(&_driver.glVertexAttribL4ui64vNV)(index, v);
  }

  static void REGAL_CALL glVertexAttribLFormatNV(GLuint index, GLint size, GLenum type, GLsizei stride)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribLFormatNV),reinterpret_cast<void (*)()>(glVertexAttribLFormatNV),"glVertexAttribLFormatNV");
    _driver.call(&_driver.glVertexAttribLFormatNV)(index, size, type, stride);
  }

// GL_NV_vertex_buffer_unified_memory

  static void REGAL_CALL glBufferAddressRangeNV(GLenum pname, GLuint index, GLuint64EXT address, GLsizeiptr length)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBufferAddressRangeNV),reinterpret_cast<void (*)()>(glBufferAddressRangeNV),"glBufferAddressRangeNV");
    _driver.call(&_driver.glBufferAddressRangeNV)(pname, index, address, length);
  }

  static void REGAL_CALL glColorFormatNV(GLint size, GLenum type, GLsizei stride)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColorFormatNV),reinterpret_cast<void (*)()>(glColorFormatNV),"glColorFormatNV");
    _driver.call(&_driver.glColorFormatNV)(size, type, stride);
  }

  static void REGAL_CALL glEdgeFlagFormatNV(GLsizei stride)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glEdgeFlagFormatNV),reinterpret_cast<void (*)()>(glEdgeFlagFormatNV),"glEdgeFlagFormatNV");
    _driver.call(&_driver.glEdgeFlagFormatNV)(stride);
  }

  static void REGAL_CALL glFogCoordFormatNV(GLenum type, GLsizei stride)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFogCoordFormatNV),reinterpret_cast<void (*)()>(glFogCoordFormatNV),"glFogCoordFormatNV");
    _driver.call(&_driver.glFogCoordFormatNV)(type, stride);
  }

  static void REGAL_CALL glGetIntegerui64i_vNV(GLenum target, GLuint index, GLuint64EXT *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetIntegerui64i_vNV),reinterpret_cast<void (*)()>(glGetIntegerui64i_vNV),"glGetIntegerui64i_vNV");
    _driver.call(&_driver.glGetIntegerui64i_vNV)(target, index, data);
  }

  static void REGAL_CALL glIndexFormatNV(GLenum type, GLsizei stride)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIndexFormatNV),reinterpret_cast<void (*)()>(glIndexFormatNV),"glIndexFormatNV");
    _driver.call(&_driver.glIndexFormatNV)(type, stride);
  }

  static void REGAL_CALL glNormalFormatNV(GLenum type, GLsizei stride)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNormalFormatNV),reinterpret_cast<void (*)()>(glNormalFormatNV),"glNormalFormatNV");
    _driver.call(&_driver.glNormalFormatNV)(type, stride);
  }

  static void REGAL_CALL glSecondaryColorFormatNV(GLint size, GLenum type, GLsizei stride)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSecondaryColorFormatNV),reinterpret_cast<void (*)()>(glSecondaryColorFormatNV),"glSecondaryColorFormatNV");
    _driver.call(&_driver.glSecondaryColorFormatNV)(size, type, stride);
  }

  static void REGAL_CALL glTexCoordFormatNV(GLint size, GLenum type, GLsizei stride)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoordFormatNV),reinterpret_cast<void (*)()>(glTexCoordFormatNV),"glTexCoordFormatNV");
    _driver.call(&_driver.glTexCoordFormatNV)(size, type, stride);
  }

  static void REGAL_CALL glVertexAttribFormatNV(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribFormatNV),reinterpret_cast<void (*)()>(glVertexAttribFormatNV),"glVertexAttribFormatNV");
    _driver.call(&_driver.glVertexAttribFormatNV)(index, size, type, normalized, stride);
  }

  static void REGAL_CALL glVertexAttribIFormatNV(GLuint index, GLint size, GLenum type, GLsizei stride)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribIFormatNV),reinterpret_cast<void (*)()>(glVertexAttribIFormatNV),"glVertexAttribIFormatNV");
    _driver.call(&_driver.glVertexAttribIFormatNV)(index, size, type, stride);
  }

  static void REGAL_CALL glVertexFormatNV(GLint size, GLenum type, GLsizei stride)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexFormatNV),reinterpret_cast<void (*)()>(glVertexFormatNV),"glVertexFormatNV");
    _driver.call(&_driver.glVertexFormatNV)(size, type, stride);
  }

// GL_NV_vertex_program

  static GLboolean REGAL_CALL glAreProgramsResidentNV(GLsizei n, const GLuint *programs, GLboolean *residences)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glAreProgramsResidentNV),reinterpret_cast<void (*)()>(glAreProgramsResidentNV),"glAreProgramsResidentNV");
    return _driver.call(&_driver.glAreProgramsResidentNV)(n, programs, residences);
  }

  static void REGAL_CALL glBindProgramNV(GLenum target, GLuint id)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBindProgramNV),reinterpret_cast<void (*)()>(glBindProgramNV),"glBindProgramNV");
    _driver.call(&_driver.glBindProgramNV)(target, id);
  }

  static void REGAL_CALL glDeleteProgramsNV(GLsizei n, const GLuint *programs)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDeleteProgramsNV),reinterpret_cast<void (*)()>(glDeleteProgramsNV),"glDeleteProgramsNV");
    _driver.call(&_driver.glDeleteProgramsNV)(n, programs);
  }

  static void REGAL_CALL glExecuteProgramNV(GLenum target, GLuint id, const GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glExecuteProgramNV),reinterpret_cast<void (*)()>(glExecuteProgramNV),"glExecuteProgramNV");
    _driver.call(&_driver.glExecuteProgramNV)(target, id, params);
  }

  static void REGAL_CALL glGenProgramsNV(GLsizei n, GLuint *programs)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGenProgramsNV),reinterpret_cast<void (*)()>(glGenProgramsNV),"glGenProgramsNV");
    _driver.call(&_driver.glGenProgramsNV)(n, programs);
  }

  static void REGAL_CALL glGetProgramParameterdvNV(GLenum target, GLuint index, GLenum pname, GLdouble *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetProgramParameterdvNV),reinterpret_cast<void (*)()>(glGetProgramParameterdvNV),"glGetProgramParameterdvNV");
    _driver.call(&_driver.glGetProgramParameterdvNV)(target, index, pname, params);
  }

  static void REGAL_CALL glGetProgramParameterfvNV(GLenum target, GLuint index, GLenum pname, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetProgramParameterfvNV),reinterpret_cast<void (*)()>(glGetProgramParameterfvNV),"glGetProgramParameterfvNV");
    _driver.call(&_driver.glGetProgramParameterfvNV)(target, index, pname, params);
  }

  static void REGAL_CALL glGetProgramStringNV(GLuint id, GLenum pname, GLubyte *program)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetProgramStringNV),reinterpret_cast<void (*)()>(glGetProgramStringNV),"glGetProgramStringNV");
    _driver.call(&_driver.glGetProgramStringNV)(id, pname, program);
  }

  static void REGAL_CALL glGetProgramivNV(GLuint id, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetProgramivNV),reinterpret_cast<void (*)()>(glGetProgramivNV),"glGetProgramivNV");
    _driver.call(&_driver.glGetProgramivNV)(id, pname, params);
  }

  static void REGAL_CALL glGetTrackMatrixivNV(GLenum target, GLuint address, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetTrackMatrixivNV),reinterpret_cast<void (*)()>(glGetTrackMatrixivNV),"glGetTrackMatrixivNV");
    _driver.call(&_driver.glGetTrackMatrixivNV)(target, address, pname, params);
  }

  static void REGAL_CALL glGetVertexAttribPointervNV(GLuint index, GLenum pname, GLvoid **pointer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetVertexAttribPointervNV),reinterpret_cast<void (*)()>(glGetVertexAttribPointervNV),"glGetVertexAttribPointervNV");
    _driver.call(&_driver.glGetVertexAttribPointervNV)(index, pname, pointer);
  }

  static void REGAL_CALL glGetVertexAttribdvNV(GLuint index, GLenum pname, GLdouble *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetVertexAttribdvNV),reinterpret_cast<void (*)()>(glGetVertexAttribdvNV),"glGetVertexAttribdvNV");
    _driver.call(&_driver.glGetVertexAttribdvNV)(index, pname, params);
  }

  static void REGAL_CALL glGetVertexAttribfvNV(GLuint index, GLenum pname, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetVertexAttribfvNV),reinterpret_cast<void (*)()>(glGetVertexAttribfvNV),"glGetVertexAttribfvNV");
    _driver.call(&_driver.glGetVertexAttribfvNV)(index, pname, params);
  }

  static void REGAL_CALL glGetVertexAttribivNV(GLuint index, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetVertexAttribivNV),reinterpret_cast<void (*)()>(glGetVertexAttribivNV),"glGetVertexAttribivNV");
    _driver.call(&_driver.glGetVertexAttribivNV)(index, pname, params);
  }

  static GLboolean REGAL_CALL glIsProgramNV(GLuint id)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIsProgramNV),reinterpret_cast<void (*)()>(glIsProgramNV),"glIsProgramNV");
    return _driver.call(&_driver.glIsProgramNV)(id);
  }

  static void REGAL_CALL glLoadProgramNV(GLenum target, GLuint id, GLsizei len, const GLubyte *program)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glLoadProgramNV),reinterpret_cast<void (*)()>(glLoadProgramNV),"glLoadProgramNV");
    _driver.call(&_driver.glLoadProgramNV)(target, id, len, program);
  }

  static void REGAL_CALL glProgramParameter4dNV(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramParameter4dNV),reinterpret_cast<void (*)()>(glProgramParameter4dNV),"glProgramParameter4dNV");
    _driver.call(&_driver.glProgramParameter4dNV)(target, index, x, y, z, w);
  }

  static void REGAL_CALL glProgramParameter4dvNV(GLenum target, GLuint index, const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramParameter4dvNV),reinterpret_cast<void (*)()>(glProgramParameter4dvNV),"glProgramParameter4dvNV");
    _driver.call(&_driver.glProgramParameter4dvNV)(target, index, v);
  }

  static void REGAL_CALL glProgramParameter4fNV(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramParameter4fNV),reinterpret_cast<void (*)()>(glProgramParameter4fNV),"glProgramParameter4fNV");
    _driver.call(&_driver.glProgramParameter4fNV)(target, index, x, y, z, w);
  }

  static void REGAL_CALL glProgramParameter4fvNV(GLenum target, GLuint index, const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramParameter4fvNV),reinterpret_cast<void (*)()>(glProgramParameter4fvNV),"glProgramParameter4fvNV");
    _driver.call(&_driver.glProgramParameter4fvNV)(target, index, v);
  }

  static void REGAL_CALL glProgramParameters4dvNV(GLenum target, GLuint index, GLsizei count, const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramParameters4dvNV),reinterpret_cast<void (*)()>(glProgramParameters4dvNV),"glProgramParameters4dvNV");
    _driver.call(&_driver.glProgramParameters4dvNV)(target, index, count, v);
  }

  static void REGAL_CALL glProgramParameters4fvNV(GLenum target, GLuint index, GLsizei count, const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramParameters4fvNV),reinterpret_cast<void (*)()>(glProgramParameters4fvNV),"glProgramParameters4fvNV");
    _driver.call(&_driver.glProgramParameters4fvNV)(target, index, count, v);
  }

  static void REGAL_CALL glRequestResidentProgramsNV(GLsizei n, const GLuint *programs)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glRequestResidentProgramsNV),reinterpret_cast<void (*)()>(glRequestResidentProgramsNV),"glRequestResidentProgramsNV");
    _driver.call(&_driver.glRequestResidentProgramsNV)(n, programs);
  }

  static void REGAL_CALL glTrackMatrixNV(GLenum target, GLuint address, GLenum matrix, GLenum transform)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTrackMatrixNV),reinterpret_cast<void (*)()>(glTrackMatrixNV),"glTrackMatrixNV");
    _driver.call(&_driver.glTrackMatrixNV)(target, address, matrix, transform);
  }

  static void REGAL_CALL glVertexAttrib1dNV(GLuint index, GLdouble x)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib1dNV),reinterpret_cast<void (*)()>(glVertexAttrib1dNV),"glVertexAttrib1dNV");
    _driver.call(&_driver.glVertexAttrib1dNV)(index, x);
  }

  static void REGAL_CALL glVertexAttrib1dvNV(GLuint index, const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib1dvNV),reinterpret_cast<void (*)()>(glVertexAttrib1dvNV),"glVertexAttrib1dvNV");
    _driver.call(&_driver.glVertexAttrib1dvNV)(index, v);
  }

  static void REGAL_CALL glVertexAttrib1fNV(GLuint index, GLfloat x)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib1fNV),reinterpret_cast<void (*)()>(glVertexAttrib1fNV),"glVertexAttrib1fNV");
    _driver.call(&_driver.glVertexAttrib1fNV)(index, x);
  }

  static void REGAL_CALL glVertexAttrib1fvNV(GLuint index, const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib1fvNV),reinterpret_cast<void (*)()>(glVertexAttrib1fvNV),"glVertexAttrib1fvNV");
    _driver.call(&_driver.glVertexAttrib1fvNV)(index, v);
  }

  static void REGAL_CALL glVertexAttrib1sNV(GLuint index, GLshort x)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib1sNV),reinterpret_cast<void (*)()>(glVertexAttrib1sNV),"glVertexAttrib1sNV");
    _driver.call(&_driver.glVertexAttrib1sNV)(index, x);
  }

  static void REGAL_CALL glVertexAttrib1svNV(GLuint index, const GLshort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib1svNV),reinterpret_cast<void (*)()>(glVertexAttrib1svNV),"glVertexAttrib1svNV");
    _driver.call(&_driver.glVertexAttrib1svNV)(index, v);
  }

  static void REGAL_CALL glVertexAttrib2dNV(GLuint index, GLdouble x, GLdouble y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib2dNV),reinterpret_cast<void (*)()>(glVertexAttrib2dNV),"glVertexAttrib2dNV");
    _driver.call(&_driver.glVertexAttrib2dNV)(index, x, y);
  }

  static void REGAL_CALL glVertexAttrib2dvNV(GLuint index, const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib2dvNV),reinterpret_cast<void (*)()>(glVertexAttrib2dvNV),"glVertexAttrib2dvNV");
    _driver.call(&_driver.glVertexAttrib2dvNV)(index, v);
  }

  static void REGAL_CALL glVertexAttrib2fNV(GLuint index, GLfloat x, GLfloat y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib2fNV),reinterpret_cast<void (*)()>(glVertexAttrib2fNV),"glVertexAttrib2fNV");
    _driver.call(&_driver.glVertexAttrib2fNV)(index, x, y);
  }

  static void REGAL_CALL glVertexAttrib2fvNV(GLuint index, const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib2fvNV),reinterpret_cast<void (*)()>(glVertexAttrib2fvNV),"glVertexAttrib2fvNV");
    _driver.call(&_driver.glVertexAttrib2fvNV)(index, v);
  }

  static void REGAL_CALL glVertexAttrib2sNV(GLuint index, GLshort x, GLshort y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib2sNV),reinterpret_cast<void (*)()>(glVertexAttrib2sNV),"glVertexAttrib2sNV");
    _driver.call(&_driver.glVertexAttrib2sNV)(index, x, y);
  }

  static void REGAL_CALL glVertexAttrib2svNV(GLuint index, const GLshort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib2svNV),reinterpret_cast<void (*)()>(glVertexAttrib2svNV),"glVertexAttrib2svNV");
    _driver.call(&_driver.glVertexAttrib2svNV)(index, v);
  }

  static void REGAL_CALL glVertexAttrib3dNV(GLuint index, GLdouble x, GLdouble y, GLdouble z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib3dNV),reinterpret_cast<void (*)()>(glVertexAttrib3dNV),"glVertexAttrib3dNV");
    _driver.call(&_driver.glVertexAttrib3dNV)(index, x, y, z);
  }

  static void REGAL_CALL glVertexAttrib3dvNV(GLuint index, const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib3dvNV),reinterpret_cast<void (*)()>(glVertexAttrib3dvNV),"glVertexAttrib3dvNV");
    _driver.call(&_driver.glVertexAttrib3dvNV)(index, v);
  }

  static void REGAL_CALL glVertexAttrib3fNV(GLuint index, GLfloat x, GLfloat y, GLfloat z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib3fNV),reinterpret_cast<void (*)()>(glVertexAttrib3fNV),"glVertexAttrib3fNV");
    _driver.call(&_driver.glVertexAttrib3fNV)(index, x, y, z);
  }

  static void REGAL_CALL glVertexAttrib3fvNV(GLuint index, const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib3fvNV),reinterpret_cast<void (*)()>(glVertexAttrib3fvNV),"glVertexAttrib3fvNV");
    _driver.call(&_driver.glVertexAttrib3fvNV)(index, v);
  }

  static void REGAL_CALL glVertexAttrib3sNV(GLuint index, GLshort x, GLshort y, GLshort z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib3sNV),reinterpret_cast<void (*)()>(glVertexAttrib3sNV),"glVertexAttrib3sNV");
    _driver.call(&_driver.glVertexAttrib3sNV)(index, x, y, z);
  }

  static void REGAL_CALL glVertexAttrib3svNV(GLuint index, const GLshort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib3svNV),reinterpret_cast<void (*)()>(glVertexAttrib3svNV),"glVertexAttrib3svNV");
    _driver.call(&_driver.glVertexAttrib3svNV)(index, v);
  }

  static void REGAL_CALL glVertexAttrib4dNV(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib4dNV),reinterpret_cast<void (*)()>(glVertexAttrib4dNV),"glVertexAttrib4dNV");
    _driver.call(&_driver.glVertexAttrib4dNV)(index, x, y, z, w);
  }

  static void REGAL_CALL glVertexAttrib4dvNV(GLuint index, const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib4dvNV),reinterpret_cast<void (*)()>(glVertexAttrib4dvNV),"glVertexAttrib4dvNV");
    _driver.call(&_driver.glVertexAttrib4dvNV)(index, v);
  }

  static void REGAL_CALL glVertexAttrib4fNV(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib4fNV),reinterpret_cast<void (*)()>(glVertexAttrib4fNV),"glVertexAttrib4fNV");
    _driver.call(&_driver.glVertexAttrib4fNV)(index, x, y, z, w);
  }

  static void REGAL_CALL glVertexAttrib4fvNV(GLuint index, const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib4fvNV),reinterpret_cast<void (*)()>(glVertexAttrib4fvNV),"glVertexAttrib4fvNV");
    _driver.call(&_driver.glVertexAttrib4fvNV)(index, v);
  }

  static void REGAL_CALL glVertexAttrib4sNV(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib4sNV),reinterpret_cast<void (*)()>(glVertexAttrib4sNV),"glVertexAttrib4sNV");
    _driver.call(&_driver.glVertexAttrib4sNV)(index, x, y, z, w);
  }

  static void REGAL_CALL glVertexAttrib4svNV(GLuint index, const GLshort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib4svNV),reinterpret_cast<void (*)()>(glVertexAttrib4svNV),"glVertexAttrib4svNV");
    _driver.call(&_driver.glVertexAttrib4svNV)(index, v);
  }

  static void REGAL_CALL glVertexAttrib4ubNV(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib4ubNV),reinterpret_cast<void (*)()>(glVertexAttrib4ubNV),"glVertexAttrib4ubNV");
    _driver.call(&_driver.glVertexAttrib4ubNV)(index, x, y, z, w);
  }

  static void REGAL_CALL glVertexAttrib4ubvNV(GLuint index, const GLubyte *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttrib4ubvNV),reinterpret_cast<void (*)()>(glVertexAttrib4ubvNV),"glVertexAttrib4ubvNV");
    _driver.call(&_driver.glVertexAttrib4ubvNV)(index, v);
  }

  static void REGAL_CALL glVertexAttribPointerNV(GLuint index, GLint fsize, GLenum type, GLsizei stride, const GLvoid *pointer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribPointerNV),reinterpret_cast<void (*)()>(glVertexAttribPointerNV),"glVertexAttribPointerNV");
    _driver.call(&_driver.glVertexAttribPointerNV)(index, fsize, type, stride, pointer);
  }

  static void REGAL_CALL glVertexAttribs1dvNV(GLuint index, GLsizei n, const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribs1dvNV),reinterpret_cast<void (*)()>(glVertexAttribs1dvNV),"glVertexAttribs1dvNV");
    _driver.call(&_driver.glVertexAttribs1dvNV)(index, n, v);
  }

  static void REGAL_CALL glVertexAttribs1fvNV(GLuint index, GLsizei n, const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribs1fvNV),reinterpret_cast<void (*)()>(glVertexAttribs1fvNV),"glVertexAttribs1fvNV");
    _driver.call(&_driver.glVertexAttribs1fvNV)(index, n, v);
  }

  static void REGAL_CALL glVertexAttribs1svNV(GLuint index, GLsizei n, const GLshort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribs1svNV),reinterpret_cast<void (*)()>(glVertexAttribs1svNV),"glVertexAttribs1svNV");
    _driver.call(&_driver.glVertexAttribs1svNV)(index, n, v);
  }

  static void REGAL_CALL glVertexAttribs2dvNV(GLuint index, GLsizei n, const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribs2dvNV),reinterpret_cast<void (*)()>(glVertexAttribs2dvNV),"glVertexAttribs2dvNV");
    _driver.call(&_driver.glVertexAttribs2dvNV)(index, n, v);
  }

  static void REGAL_CALL glVertexAttribs2fvNV(GLuint index, GLsizei n, const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribs2fvNV),reinterpret_cast<void (*)()>(glVertexAttribs2fvNV),"glVertexAttribs2fvNV");
    _driver.call(&_driver.glVertexAttribs2fvNV)(index, n, v);
  }

  static void REGAL_CALL glVertexAttribs2svNV(GLuint index, GLsizei n, const GLshort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribs2svNV),reinterpret_cast<void (*)()>(glVertexAttribs2svNV),"glVertexAttribs2svNV");
    _driver.call(&_driver.glVertexAttribs2svNV)(index, n, v);
  }

  static void REGAL_CALL glVertexAttribs3dvNV(GLuint index, GLsizei n, const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribs3dvNV),reinterpret_cast<void (*)()>(glVertexAttribs3dvNV),"glVertexAttribs3dvNV");
    _driver.call(&_driver.glVertexAttribs3dvNV)(index, n, v);
  }

  static void REGAL_CALL glVertexAttribs3fvNV(GLuint index, GLsizei n, const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribs3fvNV),reinterpret_cast<void (*)()>(glVertexAttribs3fvNV),"glVertexAttribs3fvNV");
    _driver.call(&_driver.glVertexAttribs3fvNV)(index, n, v);
  }

  static void REGAL_CALL glVertexAttribs3svNV(GLuint index, GLsizei n, const GLshort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribs3svNV),reinterpret_cast<void (*)()>(glVertexAttribs3svNV),"glVertexAttribs3svNV");
    _driver.call(&_driver.glVertexAttribs3svNV)(index, n, v);
  }

  static void REGAL_CALL glVertexAttribs4dvNV(GLuint index, GLsizei n, const GLdouble *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribs4dvNV),reinterpret_cast<void (*)()>(glVertexAttribs4dvNV),"glVertexAttribs4dvNV");
    _driver.call(&_driver.glVertexAttribs4dvNV)(index, n, v);
  }

  static void REGAL_CALL glVertexAttribs4fvNV(GLuint index, GLsizei n, const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribs4fvNV),reinterpret_cast<void (*)()>(glVertexAttribs4fvNV),"glVertexAttribs4fvNV");
    _driver.call(&_driver.glVertexAttribs4fvNV)(index, n, v);
  }

  static void REGAL_CALL glVertexAttribs4svNV(GLuint index, GLsizei n, const GLshort *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribs4svNV),reinterpret_cast<void (*)()>(glVertexAttribs4svNV),"glVertexAttribs4svNV");
    _driver.call(&_driver.glVertexAttribs4svNV)(index, n, v);
  }

  static void REGAL_CALL glVertexAttribs4ubvNV(GLuint index, GLsizei n, const GLubyte *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVertexAttribs4ubvNV),reinterpret_cast<void (*)()>(glVertexAttribs4ubvNV),"glVertexAttribs4ubvNV");
    _driver.call(&_driver.glVertexAttribs4ubvNV)(index, n, v);
  }

// GL_NV_video_capture

  static void REGAL_CALL glBeginVideoCaptureNV(GLuint video_capture_slot)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBeginVideoCaptureNV),reinterpret_cast<void (*)()>(glBeginVideoCaptureNV),"glBeginVideoCaptureNV");
    _driver.call(&_driver.glBeginVideoCaptureNV)(video_capture_slot);
  }

  static void REGAL_CALL glBindVideoCaptureStreamBufferNV(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLintptr offset)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBindVideoCaptureStreamBufferNV),reinterpret_cast<void (*)()>(glBindVideoCaptureStreamBufferNV),"glBindVideoCaptureStreamBufferNV");
    _driver.call(&_driver.glBindVideoCaptureStreamBufferNV)(video_capture_slot, stream, frame_region, offset);
  }

  static void REGAL_CALL glBindVideoCaptureStreamTextureNV(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLenum target, GLuint texture)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBindVideoCaptureStreamTextureNV),reinterpret_cast<void (*)()>(glBindVideoCaptureStreamTextureNV),"glBindVideoCaptureStreamTextureNV");
    _driver.call(&_driver.glBindVideoCaptureStreamTextureNV)(video_capture_slot, stream, frame_region, target, texture);
  }

  static void REGAL_CALL glEndVideoCaptureNV(GLuint video_capture_slot)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glEndVideoCaptureNV),reinterpret_cast<void (*)()>(glEndVideoCaptureNV),"glEndVideoCaptureNV");
    _driver.call(&_driver.glEndVideoCaptureNV)(video_capture_slot);
  }

  static void REGAL_CALL glGetVideoCaptureStreamdvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, GLdouble *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetVideoCaptureStreamdvNV),reinterpret_cast<void (*)()>(glGetVideoCaptureStreamdvNV),"glGetVideoCaptureStreamdvNV");
    _driver.call(&_driver.glGetVideoCaptureStreamdvNV)(video_capture_slot, stream, pname, params);
  }

  static void REGAL_CALL glGetVideoCaptureStreamfvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetVideoCaptureStreamfvNV),reinterpret_cast<void (*)()>(glGetVideoCaptureStreamfvNV),"glGetVideoCaptureStreamfvNV");
    _driver.call(&_driver.glGetVideoCaptureStreamfvNV)(video_capture_slot, stream, pname, params);
  }

  static void REGAL_CALL glGetVideoCaptureStreamivNV(GLuint video_capture_slot, GLuint stream, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetVideoCaptureStreamivNV),reinterpret_cast<void (*)()>(glGetVideoCaptureStreamivNV),"glGetVideoCaptureStreamivNV");
    _driver.call(&_driver.glGetVideoCaptureStreamivNV)(video_capture_slot, stream, pname, params);
  }

  static void REGAL_CALL glGetVideoCaptureivNV(GLuint video_capture_slot, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetVideoCaptureivNV),reinterpret_cast<void (*)()>(glGetVideoCaptureivNV),"glGetVideoCaptureivNV");
    _driver.call(&_driver.glGetVideoCaptureivNV)(video_capture_slot, pname, params);
  }

  static GLenum REGAL_CALL glVideoCaptureNV(GLuint video_capture_slot, GLuint *sequence_num, GLuint64EXT *capture_time)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVideoCaptureNV),reinterpret_cast<void (*)()>(glVideoCaptureNV),"glVideoCaptureNV");
    return _driver.call(&_driver.glVideoCaptureNV)(video_capture_slot, sequence_num, capture_time);
  }

  static void REGAL_CALL glVideoCaptureStreamParameterdvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLdouble *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVideoCaptureStreamParameterdvNV),reinterpret_cast<void (*)()>(glVideoCaptureStreamParameterdvNV),"glVideoCaptureStreamParameterdvNV");
    _driver.call(&_driver.glVideoCaptureStreamParameterdvNV)(video_capture_slot, stream, pname, params);
  }

  static void REGAL_CALL glVideoCaptureStreamParameterfvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVideoCaptureStreamParameterfvNV),reinterpret_cast<void (*)()>(glVideoCaptureStreamParameterfvNV),"glVideoCaptureStreamParameterfvNV");
    _driver.call(&_driver.glVideoCaptureStreamParameterfvNV)(video_capture_slot, stream, pname, params);
  }

  static void REGAL_CALL glVideoCaptureStreamParameterivNV(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glVideoCaptureStreamParameterivNV),reinterpret_cast<void (*)()>(glVideoCaptureStreamParameterivNV),"glVideoCaptureStreamParameterivNV");
    _driver.call(&_driver.glVideoCaptureStreamParameterivNV)(video_capture_slot, stream, pname, params);
  }

// GL_OES_blend_equation_separate

  static void REGAL_CALL glBlendEquationSeparateOES(GLenum modeRGB, GLenum modeAlpha)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBlendEquationSeparateOES),reinterpret_cast<void (*)()>(glBlendEquationSeparateOES),"glBlendEquationSeparateOES");
    _driver.call(&_driver.glBlendEquationSeparateOES)(modeRGB, modeAlpha);
  }

// GL_OES_blend_func_separate

  static void REGAL_CALL glBlendFuncSeparateOES(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBlendFuncSeparateOES),reinterpret_cast<void (*)()>(glBlendFuncSeparateOES),"glBlendFuncSeparateOES");
    _driver.call(&_driver.glBlendFuncSeparateOES)(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
  }

// GL_OES_blend_subtract

  static void REGAL_CALL glBlendEquationOES(GLenum mode)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBlendEquationOES),reinterpret_cast<void (*)()>(glBlendEquationOES),"glBlendEquationOES");
    _driver.call(&_driver.glBlendEquationOES)(mode);
  }

// GL_OES_framebuffer_object

  static void REGAL_CALL glBindFramebufferOES(GLenum target, GLuint framebuffer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBindFramebufferOES),reinterpret_cast<void (*)()>(glBindFramebufferOES),"glBindFramebufferOES");
    _driver.call(&_driver.glBindFramebufferOES)(target, framebuffer);
  }

  static void REGAL_CALL glBindRenderbufferOES(GLenum target, GLuint renderbuffer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBindRenderbufferOES),reinterpret_cast<void (*)()>(glBindRenderbufferOES),"glBindRenderbufferOES");
    _driver.call(&_driver.glBindRenderbufferOES)(target, renderbuffer);
  }

  static GLenum REGAL_CALL glCheckFramebufferStatusOES(GLenum target)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCheckFramebufferStatusOES),reinterpret_cast<void (*)()>(glCheckFramebufferStatusOES),"glCheckFramebufferStatusOES");
    return _driver.call(&_driver.glCheckFramebufferStatusOES)(target);
  }

  static void REGAL_CALL glDeleteFramebuffersOES(GLsizei n, const GLuint *framebuffers)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDeleteFramebuffersOES),reinterpret_cast<void (*)()>(glDeleteFramebuffersOES),"glDeleteFramebuffersOES");
    _driver.call(&_driver.glDeleteFramebuffersOES)(n, framebuffers);
  }

  static void REGAL_CALL glDeleteRenderbuffersOES(GLsizei n, const GLuint *renderbuffers)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDeleteRenderbuffersOES),reinterpret_cast<void (*)()>(glDeleteRenderbuffersOES),"glDeleteRenderbuffersOES");
    _driver.call(&_driver.glDeleteRenderbuffersOES)(n, renderbuffers);
  }

  static void REGAL_CALL glFramebufferRenderbufferOES(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFramebufferRenderbufferOES),reinterpret_cast<void (*)()>(glFramebufferRenderbufferOES),"glFramebufferRenderbufferOES");
    _driver.call(&_driver.glFramebufferRenderbufferOES)(target, attachment, renderbuffertarget, renderbuffer);
  }

  static void REGAL_CALL glFramebufferTexture2DOES(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFramebufferTexture2DOES),reinterpret_cast<void (*)()>(glFramebufferTexture2DOES),"glFramebufferTexture2DOES");
    _driver.call(&_driver.glFramebufferTexture2DOES)(target, attachment, textarget, texture, level);
  }

  static void REGAL_CALL glGenFramebuffersOES(GLsizei n, GLuint *framebuffers)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGenFramebuffersOES),reinterpret_cast<void (*)()>(glGenFramebuffersOES),"glGenFramebuffersOES");
    _driver.call(&_driver.glGenFramebuffersOES)(n, framebuffers);
  }

  static void REGAL_CALL glGenRenderbuffersOES(GLsizei n, GLuint *renderbuffers)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGenRenderbuffersOES),reinterpret_cast<void (*)()>(glGenRenderbuffersOES),"glGenRenderbuffersOES");
    _driver.call(&_driver.glGenRenderbuffersOES)(n, renderbuffers);
  }

  static void REGAL_CALL glGenerateMipmapOES(GLenum target)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGenerateMipmapOES),reinterpret_cast<void (*)()>(glGenerateMipmapOES),"glGenerateMipmapOES");
    _driver.call(&_driver.glGenerateMipmapOES)(target);
  }

  static void REGAL_CALL glGetFramebufferAttachmentParameterivOES(GLenum target, GLenum attachment, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetFramebufferAttachmentParameterivOES),reinterpret_cast<void (*)()>(glGetFramebufferAttachmentParameterivOES),"glGetFramebufferAttachmentParameterivOES");
    _driver.call(&_driver.glGetFramebufferAttachmentParameterivOES)(target, attachment, pname, params);
  }

  static void REGAL_CALL glGetRenderbufferParameterivOES(GLenum target, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetRenderbufferParameterivOES),reinterpret_cast<void (*)()>(glGetRenderbufferParameterivOES),"glGetRenderbufferParameterivOES");
    _driver.call(&_driver.glGetRenderbufferParameterivOES)(target, pname, params);
  }

  static GLboolean REGAL_CALL glIsFramebufferOES(GLuint framebuffer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIsFramebufferOES),reinterpret_cast<void (*)()>(glIsFramebufferOES),"glIsFramebufferOES");
    return _driver.call(&_driver.glIsFramebufferOES)(framebuffer);
  }

  static GLboolean REGAL_CALL glIsRenderbufferOES(GLuint renderbuffer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIsRenderbufferOES),reinterpret_cast<void (*)()>(glIsRenderbufferOES),"glIsRenderbufferOES");
    return _driver.call(&_driver.glIsRenderbufferOES)(renderbuffer);
  }

  static void REGAL_CALL glRenderbufferStorageOES(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glRenderbufferStorageOES),reinterpret_cast<void (*)()>(glRenderbufferStorageOES),"glRenderbufferStorageOES");
    _driver.call(&_driver.glRenderbufferStorageOES)(target, internalformat, width, height);
  }

// GL_OES_get_program_binary

  static void REGAL_CALL glGetProgramBinaryOES(GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, GLvoid *binary)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetProgramBinaryOES),reinterpret_cast<void (*)()>(glGetProgramBinaryOES),"glGetProgramBinaryOES");
    _driver.call(&_driver.glGetProgramBinaryOES)(program, bufSize, length, binaryFormat, binary);
  }

  static void REGAL_CALL glProgramBinaryOES(GLuint program, GLenum binaryFormat, const GLvoid *binary, GLint length)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glProgramBinaryOES),reinterpret_cast<void (*)()>(glProgramBinaryOES),"glProgramBinaryOES");
    _driver.call(&_driver.glProgramBinaryOES)(program, binaryFormat, binary, length);
  }

// GL_OES_mapbuffer

  static void REGAL_CALL glGetBufferPointervOES(GLenum target, GLenum pname, GLvoid **params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetBufferPointervOES),reinterpret_cast<void (*)()>(glGetBufferPointervOES),"glGetBufferPointervOES");
    _driver.call(&_driver.glGetBufferPointervOES)(target, pname, params);
  }

  static GLvoid *REGAL_CALL glMapBufferOES(GLenum target, GLenum access)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMapBufferOES),reinterpret_cast<void (*)()>(glMapBufferOES),"glMapBufferOES");
    return _driver.call(&_driver.glMapBufferOES)(target, access);
  }

  static GLboolean REGAL_CALL glUnmapBufferOES(GLenum target)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glUnmapBufferOES),reinterpret_cast<void (*)()>(glUnmapBufferOES),"glUnmapBufferOES");
    return _driver.call(&_driver.glUnmapBufferOES)(target);
  }

// GL_OES_matrix_palette

  static void REGAL_CALL glCurrentPaletteMatrixOES(GLuint index)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCurrentPaletteMatrixOES),reinterpret_cast<void (*)()>(glCurrentPaletteMatrixOES),"glCurrentPaletteMatrixOES");
    _driver.call(&_driver.glCurrentPaletteMatrixOES)(index);
  }

  static void REGAL_CALL glMatrixIndexPointerOES(GLint size, GLenum type, GLsizei stride, GLvoid *pointer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMatrixIndexPointerOES),reinterpret_cast<void (*)()>(glMatrixIndexPointerOES),"glMatrixIndexPointerOES");
    _driver.call(&_driver.glMatrixIndexPointerOES)(size, type, stride, pointer);
  }

  static void REGAL_CALL glWeightPointerOES(GLint size, GLenum type, GLsizei stride, GLvoid *pointer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glWeightPointerOES),reinterpret_cast<void (*)()>(glWeightPointerOES),"glWeightPointerOES");
    _driver.call(&_driver.glWeightPointerOES)(size, type, stride, pointer);
  }

// GL_OES_single_precision

  static void REGAL_CALL glClearDepthfOES(GLclampd depth)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glClearDepthfOES),reinterpret_cast<void (*)()>(glClearDepthfOES),"glClearDepthfOES");
    _driver.call(&_driver.glClearDepthfOES)(depth);
  }

  static void REGAL_CALL glClipPlanefOES(GLenum plane, const GLfloat *equation)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glClipPlanefOES),reinterpret_cast<void (*)()>(glClipPlanefOES),"glClipPlanefOES");
    _driver.call(&_driver.glClipPlanefOES)(plane, equation);
  }

  static void REGAL_CALL glDepthRangefOES(GLclampf n, GLclampf f)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDepthRangefOES),reinterpret_cast<void (*)()>(glDepthRangefOES),"glDepthRangefOES");
    _driver.call(&_driver.glDepthRangefOES)(n, f);
  }

  static void REGAL_CALL glFrustumfOES(GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFrustumfOES),reinterpret_cast<void (*)()>(glFrustumfOES),"glFrustumfOES");
    _driver.call(&_driver.glFrustumfOES)(l, r, b, t, n, f);
  }

  static void REGAL_CALL glGetClipPlanefOES(GLenum plane, GLfloat *equation)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetClipPlanefOES),reinterpret_cast<void (*)()>(glGetClipPlanefOES),"glGetClipPlanefOES");
    _driver.call(&_driver.glGetClipPlanefOES)(plane, equation);
  }

  static void REGAL_CALL glOrthofOES(GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glOrthofOES),reinterpret_cast<void (*)()>(glOrthofOES),"glOrthofOES");
    _driver.call(&_driver.glOrthofOES)(l, r, b, t, n, f);
  }

// GL_OES_texture_3D

  static void REGAL_CALL glCompressedTexImage3DOES(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCompressedTexImage3DOES),reinterpret_cast<void (*)()>(glCompressedTexImage3DOES),"glCompressedTexImage3DOES");
    _driver.call(&_driver.glCompressedTexImage3DOES)(target, level, internalformat, width, height, depth, border, imageSize, data);
  }

  static void REGAL_CALL glCompressedTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCompressedTexSubImage3DOES),reinterpret_cast<void (*)()>(glCompressedTexSubImage3DOES),"glCompressedTexSubImage3DOES");
    _driver.call(&_driver.glCompressedTexSubImage3DOES)(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
  }

  static void REGAL_CALL glCopyTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCopyTexSubImage3DOES),reinterpret_cast<void (*)()>(glCopyTexSubImage3DOES),"glCopyTexSubImage3DOES");
    _driver.call(&_driver.glCopyTexSubImage3DOES)(target, level, xoffset, yoffset, zoffset, x, y, width, height);
  }

  static void REGAL_CALL glFramebufferTexture3DOES(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFramebufferTexture3DOES),reinterpret_cast<void (*)()>(glFramebufferTexture3DOES),"glFramebufferTexture3DOES");
    _driver.call(&_driver.glFramebufferTexture3DOES)(target, attachment, textarget, texture, level, zoffset);
  }

  static void REGAL_CALL glTexImage3DOES(GLenum target, GLint level, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexImage3DOES),reinterpret_cast<void (*)()>(glTexImage3DOES),"glTexImage3DOES");
    _driver.call(&_driver.glTexImage3DOES)(target, level, internalFormat, width, height, depth, border, format, type, pixels);
  }

  static void REGAL_CALL glTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexSubImage3DOES),reinterpret_cast<void (*)()>(glTexSubImage3DOES),"glTexSubImage3DOES");
    _driver.call(&_driver.glTexSubImage3DOES)(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
  }

// GL_OES_texture_cube_map

  static void REGAL_CALL glGetTexGenfvOES(GLenum coord, GLenum pname, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetTexGenfvOES),reinterpret_cast<void (*)()>(glGetTexGenfvOES),"glGetTexGenfvOES");
    _driver.call(&_driver.glGetTexGenfvOES)(coord, pname, params);
  }

  static void REGAL_CALL glGetTexGenivOES(GLenum coord, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetTexGenivOES),reinterpret_cast<void (*)()>(glGetTexGenivOES),"glGetTexGenivOES");
    _driver.call(&_driver.glGetTexGenivOES)(coord, pname, params);
  }

  static void REGAL_CALL glGetTexGenxvOES(GLenum coord, GLenum pname, GLfixed *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetTexGenxvOES),reinterpret_cast<void (*)()>(glGetTexGenxvOES),"glGetTexGenxvOES");
    _driver.call(&_driver.glGetTexGenxvOES)(coord, pname, params);
  }

  static void REGAL_CALL glTexGenfOES(GLenum coord, GLenum pname, GLfloat param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexGenfOES),reinterpret_cast<void (*)()>(glTexGenfOES),"glTexGenfOES");
    _driver.call(&_driver.glTexGenfOES)(coord, pname, param);
  }

  static void REGAL_CALL glTexGenfvOES(GLenum coord, GLenum pname, const GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexGenfvOES),reinterpret_cast<void (*)()>(glTexGenfvOES),"glTexGenfvOES");
    _driver.call(&_driver.glTexGenfvOES)(coord, pname, params);
  }

  static void REGAL_CALL glTexGeniOES(GLenum coord, GLenum pname, GLint param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexGeniOES),reinterpret_cast<void (*)()>(glTexGeniOES),"glTexGeniOES");
    _driver.call(&_driver.glTexGeniOES)(coord, pname, param);
  }

  static void REGAL_CALL glTexGenivOES(GLenum coord, GLenum pname, const GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexGenivOES),reinterpret_cast<void (*)()>(glTexGenivOES),"glTexGenivOES");
    _driver.call(&_driver.glTexGenivOES)(coord, pname, params);
  }

  static void REGAL_CALL glTexGenxOES(GLenum coord, GLenum pname, GLfixed param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexGenxOES),reinterpret_cast<void (*)()>(glTexGenxOES),"glTexGenxOES");
    _driver.call(&_driver.glTexGenxOES)(coord, pname, param);
  }

  static void REGAL_CALL glTexGenxvOES(GLenum coord, GLenum pname, const GLfixed *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexGenxvOES),reinterpret_cast<void (*)()>(glTexGenxvOES),"glTexGenxvOES");
    _driver.call(&_driver.glTexGenxvOES)(coord, pname, params);
  }

// GL_OES_vertex_array_object

  static void REGAL_CALL glBindVertexArrayOES(GLuint array)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glBindVertexArrayOES),reinterpret_cast<void (*)()>(glBindVertexArrayOES),"glBindVertexArrayOES");
    _driver.call(&_driver.glBindVertexArrayOES)(array);
  }

  static void REGAL_CALL glDeleteVertexArraysOES(GLsizei n, const GLuint *arrays)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDeleteVertexArraysOES),reinterpret_cast<void (*)()>(glDeleteVertexArraysOES),"glDeleteVertexArraysOES");
    _driver.call(&_driver.glDeleteVertexArraysOES)(n, arrays);
  }

  static void REGAL_CALL glGenVertexArraysOES(GLsizei n, GLuint *arrays)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGenVertexArraysOES),reinterpret_cast<void (*)()>(glGenVertexArraysOES),"glGenVertexArraysOES");
    _driver.call(&_driver.glGenVertexArraysOES)(n, arrays);
  }

  static GLboolean REGAL_CALL glIsVertexArrayOES(GLuint array)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIsVertexArrayOES),reinterpret_cast<void (*)()>(glIsVertexArrayOES),"glIsVertexArrayOES");
    return _driver.call(&_driver.glIsVertexArrayOES)(array);
  }

// GL_PGI_misc_hints

  static void REGAL_CALL glHintPGI(GLenum target, GLint mode)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glHintPGI),reinterpret_cast<void (*)()>(glHintPGI),"glHintPGI");
    _driver.call(&_driver.glHintPGI)(target, mode);
  }

// GL_QCOM_alpha_test

  static void REGAL_CALL glAlphaFuncQCOM(GLenum func, GLclampf ref)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glAlphaFuncQCOM),reinterpret_cast<void (*)()>(glAlphaFuncQCOM),"glAlphaFuncQCOM");
    _driver.call(&_driver.glAlphaFuncQCOM)(func, ref);
  }

// GL_QCOM_driver_control

  static void REGAL_CALL glDisableDriverControlQCOM(GLuint driverControl)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDisableDriverControlQCOM),reinterpret_cast<void (*)()>(glDisableDriverControlQCOM),"glDisableDriverControlQCOM");
    _driver.call(&_driver.glDisableDriverControlQCOM)(driverControl);
  }

  static void REGAL_CALL glEnableDriverControlQCOM(GLuint driverControl)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glEnableDriverControlQCOM),reinterpret_cast<void (*)()>(glEnableDriverControlQCOM),"glEnableDriverControlQCOM");
    _driver.call(&_driver.glEnableDriverControlQCOM)(driverControl);
  }

  static void REGAL_CALL glGetDriverControlStringQCOM(GLuint driverControl, GLsizei bufSize, GLsizei *length, GLchar *driverControlString)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetDriverControlStringQCOM),reinterpret_cast<void (*)()>(glGetDriverControlStringQCOM),"glGetDriverControlStringQCOM");
    _driver.call(&_driver.glGetDriverControlStringQCOM)(driverControl, bufSize, length, driverControlString);
  }

  static void REGAL_CALL glGetDriverControlsQCOM(GLint *num, GLsizei size, GLuint *driverControls)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetDriverControlsQCOM),reinterpret_cast<void (*)()>(glGetDriverControlsQCOM),"glGetDriverControlsQCOM");
    _driver.call(&_driver.glGetDriverControlsQCOM)(num, size, driverControls);
  }

// GL_QCOM_extended_get

  static void REGAL_CALL glExtGetBufferPointervQCOM(GLenum target, GLvoid **params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glExtGetBufferPointervQCOM),reinterpret_cast<void (*)()>(glExtGetBufferPointervQCOM),"glExtGetBufferPointervQCOM");
    _driver.call(&_driver.glExtGetBufferPointervQCOM)(target, params);
  }

  static void REGAL_CALL glExtGetBuffersQCOM(GLuint *buffers, GLint maxBuffers, GLint *numBuffers)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glExtGetBuffersQCOM),reinterpret_cast<void (*)()>(glExtGetBuffersQCOM),"glExtGetBuffersQCOM");
    _driver.call(&_driver.glExtGetBuffersQCOM)(buffers, maxBuffers, numBuffers);
  }

  static void REGAL_CALL glExtGetFramebuffersQCOM(GLuint *framebuffers, GLint maxFramebuffers, GLint *numFramebuffers)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glExtGetFramebuffersQCOM),reinterpret_cast<void (*)()>(glExtGetFramebuffersQCOM),"glExtGetFramebuffersQCOM");
    _driver.call(&_driver.glExtGetFramebuffersQCOM)(framebuffers, maxFramebuffers, numFramebuffers);
  }

  static void REGAL_CALL glExtGetRenderbuffersQCOM(GLuint *renderbuffers, GLint maxRenderbuffers, GLint *numRenderbuffers)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glExtGetRenderbuffersQCOM),reinterpret_cast<void (*)()>(glExtGetRenderbuffersQCOM),"glExtGetRenderbuffersQCOM");
    _driver.call(&_driver.glExtGetRenderbuffersQCOM)(renderbuffers, maxRenderbuffers, numRenderbuffers);
  }

  static void REGAL_CALL glExtGetTexLevelParameterivQCOM(GLuint texture, GLenum face, GLint level, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glExtGetTexLevelParameterivQCOM),reinterpret_cast<void (*)()>(glExtGetTexLevelParameterivQCOM),"glExtGetTexLevelParameterivQCOM");
    _driver.call(&_driver.glExtGetTexLevelParameterivQCOM)(texture, face, level, pname, params);
  }

  static void REGAL_CALL glExtGetTexSubImageQCOM(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLvoid *texels)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glExtGetTexSubImageQCOM),reinterpret_cast<void (*)()>(glExtGetTexSubImageQCOM),"glExtGetTexSubImageQCOM");
    _driver.call(&_driver.glExtGetTexSubImageQCOM)(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, texels);
  }

  static void REGAL_CALL glExtGetTexturesQCOM(GLuint *textures, GLint maxTextures, GLint *numTextures)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glExtGetTexturesQCOM),reinterpret_cast<void (*)()>(glExtGetTexturesQCOM),"glExtGetTexturesQCOM");
    _driver.call(&_driver.glExtGetTexturesQCOM)(textures, maxTextures, numTextures);
  }

  static void REGAL_CALL glExtTexObjectStateOverrideiQCOM(GLenum target, GLenum pname, GLint param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glExtTexObjectStateOverrideiQCOM),reinterpret_cast<void (*)()>(glExtTexObjectStateOverrideiQCOM),"glExtTexObjectStateOverrideiQCOM");
    _driver.call(&_driver.glExtTexObjectStateOverrideiQCOM)(target, pname, param);
  }

// GL_QCOM_extended_get2

  static void REGAL_CALL glExtGetProgramBinarySourceQCOM(GLuint program, GLenum shadertype, GLchar *source, GLint *length)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glExtGetProgramBinarySourceQCOM),reinterpret_cast<void (*)()>(glExtGetProgramBinarySourceQCOM),"glExtGetProgramBinarySourceQCOM");
    _driver.call(&_driver.glExtGetProgramBinarySourceQCOM)(program, shadertype, source, length);
  }

  static void REGAL_CALL glExtGetProgramsQCOM(GLuint *programs, GLint maxPrograms, GLint *numPrograms)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glExtGetProgramsQCOM),reinterpret_cast<void (*)()>(glExtGetProgramsQCOM),"glExtGetProgramsQCOM");
    _driver.call(&_driver.glExtGetProgramsQCOM)(programs, maxPrograms, numPrograms);
  }

  static void REGAL_CALL glExtGetShadersQCOM(GLuint *shaders, GLint maxShaders, GLint *numShaders)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glExtGetShadersQCOM),reinterpret_cast<void (*)()>(glExtGetShadersQCOM),"glExtGetShadersQCOM");
    _driver.call(&_driver.glExtGetShadersQCOM)(shaders, maxShaders, numShaders);
  }

  static GLboolean REGAL_CALL glExtIsProgramBinaryQCOM(GLuint program)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glExtIsProgramBinaryQCOM),reinterpret_cast<void (*)()>(glExtIsProgramBinaryQCOM),"glExtIsProgramBinaryQCOM");
    return _driver.call(&_driver.glExtIsProgramBinaryQCOM)(program);
  }

// GL_QCOM_tiled_rendering

  static void REGAL_CALL glEndTilingQCOM(GLbitfield preserveMask)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glEndTilingQCOM),reinterpret_cast<void (*)()>(glEndTilingQCOM),"glEndTilingQCOM");
    _driver.call(&_driver.glEndTilingQCOM)(preserveMask);
  }

  static void REGAL_CALL glStartTilingQCOM(GLuint x, GLuint y, GLuint width, GLuint height, GLbitfield preserveMask)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glStartTilingQCOM),reinterpret_cast<void (*)()>(glStartTilingQCOM),"glStartTilingQCOM");
    _driver.call(&_driver.glStartTilingQCOM)(x, y, width, height, preserveMask);
  }

// GL_REGAL_ES1_0_compatibility

  static void REGAL_CALL glAlphaFuncx(GLenum func, GLclampx ref)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glAlphaFuncx),reinterpret_cast<void (*)()>(glAlphaFuncx),"glAlphaFuncx");
    _driver.call(&_driver.glAlphaFuncx)(func, ref);
  }

  static void REGAL_CALL glClearColorx(GLclampx red, GLclampx green, GLclampx blue, GLclampx alpha)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glClearColorx),reinterpret_cast<void (*)()>(glClearColorx),"glClearColorx");
    _driver.call(&_driver.glClearColorx)(red, green, blue, alpha);
  }

  static void REGAL_CALL glClearDepthx(GLclampx depth)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glClearDepthx),reinterpret_cast<void (*)()>(glClearDepthx),"glClearDepthx");
    _driver.call(&_driver.glClearDepthx)(depth);
  }

  static void REGAL_CALL glColor4x(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColor4x),reinterpret_cast<void (*)()>(glColor4x),"glColor4x");
    _driver.call(&_driver.glColor4x)(red, green, blue, alpha);
  }

  static void REGAL_CALL glDepthRangex(GLclampx zNear, GLclampx zFar)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDepthRangex),reinterpret_cast<void (*)()>(glDepthRangex),"glDepthRangex");
    _driver.call(&_driver.glDepthRangex)(zNear, zFar);
  }

  static void REGAL_CALL glFogx(GLenum pname, GLfixed param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFogx),reinterpret_cast<void (*)()>(glFogx),"glFogx");
    _driver.call(&_driver.glFogx)(pname, param);
  }

  static void REGAL_CALL glFogxv(GLenum pname, const GLfixed *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFogxv),reinterpret_cast<void (*)()>(glFogxv),"glFogxv");
    _driver.call(&_driver.glFogxv)(pname, params);
  }

  static void REGAL_CALL glFrustumf(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFrustumf),reinterpret_cast<void (*)()>(glFrustumf),"glFrustumf");
    _driver.call(&_driver.glFrustumf)(left, right, bottom, top, zNear, zFar);
  }

  static void REGAL_CALL glFrustumx(GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFrustumx),reinterpret_cast<void (*)()>(glFrustumx),"glFrustumx");
    _driver.call(&_driver.glFrustumx)(left, right, bottom, top, zNear, zFar);
  }

  static void REGAL_CALL glLightModelx(GLenum pname, GLfixed param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glLightModelx),reinterpret_cast<void (*)()>(glLightModelx),"glLightModelx");
    _driver.call(&_driver.glLightModelx)(pname, param);
  }

  static void REGAL_CALL glLightModelxv(GLenum pname, const GLfixed *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glLightModelxv),reinterpret_cast<void (*)()>(glLightModelxv),"glLightModelxv");
    _driver.call(&_driver.glLightModelxv)(pname, params);
  }

  static void REGAL_CALL glLightx(GLenum light, GLenum pname, GLfixed param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glLightx),reinterpret_cast<void (*)()>(glLightx),"glLightx");
    _driver.call(&_driver.glLightx)(light, pname, param);
  }

  static void REGAL_CALL glLightxv(GLenum light, GLenum pname, const GLfixed *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glLightxv),reinterpret_cast<void (*)()>(glLightxv),"glLightxv");
    _driver.call(&_driver.glLightxv)(light, pname, params);
  }

  static void REGAL_CALL glLineWidthx(GLfixed width)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glLineWidthx),reinterpret_cast<void (*)()>(glLineWidthx),"glLineWidthx");
    _driver.call(&_driver.glLineWidthx)(width);
  }

  static void REGAL_CALL glLoadMatrixx(const GLfixed *m)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glLoadMatrixx),reinterpret_cast<void (*)()>(glLoadMatrixx),"glLoadMatrixx");
    _driver.call(&_driver.glLoadMatrixx)(m);
  }

  static void REGAL_CALL glMaterialx(GLenum face, GLenum pname, GLfixed param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMaterialx),reinterpret_cast<void (*)()>(glMaterialx),"glMaterialx");
    _driver.call(&_driver.glMaterialx)(face, pname, param);
  }

  static void REGAL_CALL glMaterialxv(GLenum face, GLenum pname, const GLfixed *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMaterialxv),reinterpret_cast<void (*)()>(glMaterialxv),"glMaterialxv");
    _driver.call(&_driver.glMaterialxv)(face, pname, params);
  }

  static void REGAL_CALL glMultMatrixx(const GLfixed *m)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultMatrixx),reinterpret_cast<void (*)()>(glMultMatrixx),"glMultMatrixx");
    _driver.call(&_driver.glMultMatrixx)(m);
  }

  static void REGAL_CALL glMultiTexCoord4x(GLenum target, GLfixed s, GLfixed t, GLfixed r, GLfixed q)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glMultiTexCoord4x),reinterpret_cast<void (*)()>(glMultiTexCoord4x),"glMultiTexCoord4x");
    _driver.call(&_driver.glMultiTexCoord4x)(target, s, t, r, q);
  }

  static void REGAL_CALL glNormal3x(GLfixed nx, GLfixed ny, GLfixed nz)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNormal3x),reinterpret_cast<void (*)()>(glNormal3x),"glNormal3x");
    _driver.call(&_driver.glNormal3x)(nx, ny, nz);
  }

  static void REGAL_CALL glOrthof(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glOrthof),reinterpret_cast<void (*)()>(glOrthof),"glOrthof");
    _driver.call(&_driver.glOrthof)(left, right, bottom, top, zNear, zFar);
  }

  static void REGAL_CALL glOrthox(GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glOrthox),reinterpret_cast<void (*)()>(glOrthox),"glOrthox");
    _driver.call(&_driver.glOrthox)(left, right, bottom, top, zNear, zFar);
  }

  static void REGAL_CALL glPointSizex(GLfixed size)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPointSizex),reinterpret_cast<void (*)()>(glPointSizex),"glPointSizex");
    _driver.call(&_driver.glPointSizex)(size);
  }

  static void REGAL_CALL glPolygonOffsetx(GLfixed factor, GLfixed units)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPolygonOffsetx),reinterpret_cast<void (*)()>(glPolygonOffsetx),"glPolygonOffsetx");
    _driver.call(&_driver.glPolygonOffsetx)(factor, units);
  }

  static void REGAL_CALL glRotatex(GLfixed angle, GLfixed x, GLfixed y, GLfixed z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glRotatex),reinterpret_cast<void (*)()>(glRotatex),"glRotatex");
    _driver.call(&_driver.glRotatex)(angle, x, y, z);
  }

  static void REGAL_CALL glSampleCoveragex(GLclampx value, GLboolean invert)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSampleCoveragex),reinterpret_cast<void (*)()>(glSampleCoveragex),"glSampleCoveragex");
    _driver.call(&_driver.glSampleCoveragex)(value, invert);
  }

  static void REGAL_CALL glScalex(GLfixed x, GLfixed y, GLfixed z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glScalex),reinterpret_cast<void (*)()>(glScalex),"glScalex");
    _driver.call(&_driver.glScalex)(x, y, z);
  }

  static void REGAL_CALL glTexEnvx(GLenum target, GLenum pname, GLfixed param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexEnvx),reinterpret_cast<void (*)()>(glTexEnvx),"glTexEnvx");
    _driver.call(&_driver.glTexEnvx)(target, pname, param);
  }

  static void REGAL_CALL glTexEnvxv(GLenum target, GLenum pname, const GLfixed *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexEnvxv),reinterpret_cast<void (*)()>(glTexEnvxv),"glTexEnvxv");
    _driver.call(&_driver.glTexEnvxv)(target, pname, params);
  }

  static void REGAL_CALL glTexParameterx(GLenum target, GLenum pname, GLfixed param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexParameterx),reinterpret_cast<void (*)()>(glTexParameterx),"glTexParameterx");
    _driver.call(&_driver.glTexParameterx)(target, pname, param);
  }

  static void REGAL_CALL glTranslatex(GLfixed x, GLfixed y, GLfixed z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTranslatex),reinterpret_cast<void (*)()>(glTranslatex),"glTranslatex");
    _driver.call(&_driver.glTranslatex)(x, y, z);
  }

// GL_REGAL_ES1_1_compatibility

  static void REGAL_CALL glClipPlanef(GLenum plane, const GLfloat *equation)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glClipPlanef),reinterpret_cast<void (*)()>(glClipPlanef),"glClipPlanef");
    _driver.call(&_driver.glClipPlanef)(plane, equation);
  }

  static void REGAL_CALL glClipPlanex(GLenum plane, const GLfixed *equation)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glClipPlanex),reinterpret_cast<void (*)()>(glClipPlanex),"glClipPlanex");
    _driver.call(&_driver.glClipPlanex)(plane, equation);
  }

  static void REGAL_CALL glGetClipPlanef(GLenum pname, GLfloat *eqn)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetClipPlanef),reinterpret_cast<void (*)()>(glGetClipPlanef),"glGetClipPlanef");
    _driver.call(&_driver.glGetClipPlanef)(pname, eqn);
  }

  static void REGAL_CALL glGetClipPlanex(GLenum pname, GLfixed *eqn)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetClipPlanex),reinterpret_cast<void (*)()>(glGetClipPlanex),"glGetClipPlanex");
    _driver.call(&_driver.glGetClipPlanex)(pname, eqn);
  }

  static void REGAL_CALL glGetFixedv(GLenum pname, GLfixed *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetFixedv),reinterpret_cast<void (*)()>(glGetFixedv),"glGetFixedv");
    _driver.call(&_driver.glGetFixedv)(pname, params);
  }

  static void REGAL_CALL glGetLightxv(GLenum light, GLenum pname, GLfixed *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetLightxv),reinterpret_cast<void (*)()>(glGetLightxv),"glGetLightxv");
    _driver.call(&_driver.glGetLightxv)(light, pname, params);
  }

  static void REGAL_CALL glGetMaterialxv(GLenum face, GLenum pname, GLfixed *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetMaterialxv),reinterpret_cast<void (*)()>(glGetMaterialxv),"glGetMaterialxv");
    _driver.call(&_driver.glGetMaterialxv)(face, pname, params);
  }

  static void REGAL_CALL glGetTexEnvxv(GLenum env, GLenum pname, GLfixed *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetTexEnvxv),reinterpret_cast<void (*)()>(glGetTexEnvxv),"glGetTexEnvxv");
    _driver.call(&_driver.glGetTexEnvxv)(env, pname, params);
  }

  static void REGAL_CALL glGetTexParameterxv(GLenum target, GLenum pname, GLfixed *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetTexParameterxv),reinterpret_cast<void (*)()>(glGetTexParameterxv),"glGetTexParameterxv");
    _driver.call(&_driver.glGetTexParameterxv)(target, pname, params);
  }

  static void REGAL_CALL glPointParameterx(GLenum pname, GLfixed param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPointParameterx),reinterpret_cast<void (*)()>(glPointParameterx),"glPointParameterx");
    _driver.call(&_driver.glPointParameterx)(pname, param);
  }

  static void REGAL_CALL glPointParameterxv(GLenum pname, const GLfixed *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPointParameterxv),reinterpret_cast<void (*)()>(glPointParameterxv),"glPointParameterxv");
    _driver.call(&_driver.glPointParameterxv)(pname, params);
  }

  static void REGAL_CALL glPointSizePointerOES(GLenum type, GLsizei stride, const GLvoid *pointer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPointSizePointerOES),reinterpret_cast<void (*)()>(glPointSizePointerOES),"glPointSizePointerOES");
    _driver.call(&_driver.glPointSizePointerOES)(type, stride, pointer);
  }

  static void REGAL_CALL glTexParameterxv(GLenum target, GLenum pname, const GLfixed *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexParameterxv),reinterpret_cast<void (*)()>(glTexParameterxv),"glTexParameterxv");
    _driver.call(&_driver.glTexParameterxv)(target, pname, params);
  }

// GL_REGAL_log

  static void REGAL_CALL glLogMessageCallbackREGAL(GLLOGPROCREGAL callback)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glLogMessageCallbackREGAL),reinterpret_cast<void (*)()>(glLogMessageCallbackREGAL),"glLogMessageCallbackREGAL");
    _driver.call(&_driver.glLogMessageCallbackREGAL)(callback);
  }

// GL_SGIS_detail_texture

  static void REGAL_CALL glDetailTexFuncSGIS(GLenum target, GLsizei n, const GLfloat *points)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDetailTexFuncSGIS),reinterpret_cast<void (*)()>(glDetailTexFuncSGIS),"glDetailTexFuncSGIS");
    _driver.call(&_driver.glDetailTexFuncSGIS)(target, n, points);
  }

  static void REGAL_CALL glGetDetailTexFuncSGIS(GLenum target, GLfloat *points)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetDetailTexFuncSGIS),reinterpret_cast<void (*)()>(glGetDetailTexFuncSGIS),"glGetDetailTexFuncSGIS");
    _driver.call(&_driver.glGetDetailTexFuncSGIS)(target, points);
  }

// GL_SGIS_fog_function

  static void REGAL_CALL glFogFuncSGIS(GLsizei n, const GLfloat *points)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFogFuncSGIS),reinterpret_cast<void (*)()>(glFogFuncSGIS),"glFogFuncSGIS");
    _driver.call(&_driver.glFogFuncSGIS)(n, points);
  }

  static void REGAL_CALL glGetFogFuncSGIS(GLfloat *points)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetFogFuncSGIS),reinterpret_cast<void (*)()>(glGetFogFuncSGIS),"glGetFogFuncSGIS");
    _driver.call(&_driver.glGetFogFuncSGIS)(points);
  }

// GL_SGIS_multisample

  static void REGAL_CALL glSampleMaskSGIS(GLclampf value, GLboolean invert)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSampleMaskSGIS),reinterpret_cast<void (*)()>(glSampleMaskSGIS),"glSampleMaskSGIS");
    _driver.call(&_driver.glSampleMaskSGIS)(value, invert);
  }

  static void REGAL_CALL glSamplePatternSGIS(GLenum pattern)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSamplePatternSGIS),reinterpret_cast<void (*)()>(glSamplePatternSGIS),"glSamplePatternSGIS");
    _driver.call(&_driver.glSamplePatternSGIS)(pattern);
  }

// GL_SGIS_pixel_texture

  static void REGAL_CALL glGetPixelTexGenParameterfvSGIS(GLenum pname, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetPixelTexGenParameterfvSGIS),reinterpret_cast<void (*)()>(glGetPixelTexGenParameterfvSGIS),"glGetPixelTexGenParameterfvSGIS");
    _driver.call(&_driver.glGetPixelTexGenParameterfvSGIS)(pname, params);
  }

  static void REGAL_CALL glGetPixelTexGenParameterivSGIS(GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetPixelTexGenParameterivSGIS),reinterpret_cast<void (*)()>(glGetPixelTexGenParameterivSGIS),"glGetPixelTexGenParameterivSGIS");
    _driver.call(&_driver.glGetPixelTexGenParameterivSGIS)(pname, params);
  }

  static void REGAL_CALL glPixelTexGenParameterfSGIS(GLenum pname, GLfloat param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPixelTexGenParameterfSGIS),reinterpret_cast<void (*)()>(glPixelTexGenParameterfSGIS),"glPixelTexGenParameterfSGIS");
    _driver.call(&_driver.glPixelTexGenParameterfSGIS)(pname, param);
  }

  static void REGAL_CALL glPixelTexGenParameterfvSGIS(GLenum pname, const GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPixelTexGenParameterfvSGIS),reinterpret_cast<void (*)()>(glPixelTexGenParameterfvSGIS),"glPixelTexGenParameterfvSGIS");
    _driver.call(&_driver.glPixelTexGenParameterfvSGIS)(pname, params);
  }

  static void REGAL_CALL glPixelTexGenParameteriSGIS(GLenum pname, GLint param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPixelTexGenParameteriSGIS),reinterpret_cast<void (*)()>(glPixelTexGenParameteriSGIS),"glPixelTexGenParameteriSGIS");
    _driver.call(&_driver.glPixelTexGenParameteriSGIS)(pname, param);
  }

  static void REGAL_CALL glPixelTexGenParameterivSGIS(GLenum pname, const GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPixelTexGenParameterivSGIS),reinterpret_cast<void (*)()>(glPixelTexGenParameterivSGIS),"glPixelTexGenParameterivSGIS");
    _driver.call(&_driver.glPixelTexGenParameterivSGIS)(pname, params);
  }

// GL_SGIS_point_parameters

  static void REGAL_CALL glPointParameterfSGIS(GLenum pname, GLfloat param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPointParameterfSGIS),reinterpret_cast<void (*)()>(glPointParameterfSGIS),"glPointParameterfSGIS");
    _driver.call(&_driver.glPointParameterfSGIS)(pname, param);
  }

  static void REGAL_CALL glPointParameterfvSGIS(GLenum pname, const GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPointParameterfvSGIS),reinterpret_cast<void (*)()>(glPointParameterfvSGIS),"glPointParameterfvSGIS");
    _driver.call(&_driver.glPointParameterfvSGIS)(pname, params);
  }

// GL_SGIS_sharpen_texture

  static void REGAL_CALL glGetSharpenTexFuncSGIS(GLenum target, GLfloat *points)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetSharpenTexFuncSGIS),reinterpret_cast<void (*)()>(glGetSharpenTexFuncSGIS),"glGetSharpenTexFuncSGIS");
    _driver.call(&_driver.glGetSharpenTexFuncSGIS)(target, points);
  }

  static void REGAL_CALL glSharpenTexFuncSGIS(GLenum target, GLsizei n, const GLfloat *points)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSharpenTexFuncSGIS),reinterpret_cast<void (*)()>(glSharpenTexFuncSGIS),"glSharpenTexFuncSGIS");
    _driver.call(&_driver.glSharpenTexFuncSGIS)(target, n, points);
  }

// GL_SGIS_texture4D

  static void REGAL_CALL glTexImage4DSGIS(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexImage4DSGIS),reinterpret_cast<void (*)()>(glTexImage4DSGIS),"glTexImage4DSGIS");
    _driver.call(&_driver.glTexImage4DSGIS)(target, level, internalformat, width, height, depth, size4d, border, format, type, pixels);
  }

  static void REGAL_CALL glTexSubImage4DSGIS(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLenum format, GLenum type, const GLvoid *pixels)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexSubImage4DSGIS),reinterpret_cast<void (*)()>(glTexSubImage4DSGIS),"glTexSubImage4DSGIS");
    _driver.call(&_driver.glTexSubImage4DSGIS)(target, level, xoffset, yoffset, zoffset, woffset, width, height, depth, size4d, format, type, pixels);
  }

// GL_SGIS_texture_color_mask

  static void REGAL_CALL glTextureColorMaskSGIS(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTextureColorMaskSGIS),reinterpret_cast<void (*)()>(glTextureColorMaskSGIS),"glTextureColorMaskSGIS");
    _driver.call(&_driver.glTextureColorMaskSGIS)(red, green, blue, alpha);
  }

// GL_SGIS_texture_filter4

  static void REGAL_CALL glGetTexFilterFuncSGIS(GLenum target, GLenum filter, GLfloat *weights)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetTexFilterFuncSGIS),reinterpret_cast<void (*)()>(glGetTexFilterFuncSGIS),"glGetTexFilterFuncSGIS");
    _driver.call(&_driver.glGetTexFilterFuncSGIS)(target, filter, weights);
  }

  static void REGAL_CALL glTexFilterFuncSGIS(GLenum target, GLenum filter, GLsizei n, const GLfloat *weights)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexFilterFuncSGIS),reinterpret_cast<void (*)()>(glTexFilterFuncSGIS),"glTexFilterFuncSGIS");
    _driver.call(&_driver.glTexFilterFuncSGIS)(target, filter, n, weights);
  }

// GL_SGIX_async

  static void REGAL_CALL glAsyncMarkerSGIX(GLuint marker)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glAsyncMarkerSGIX),reinterpret_cast<void (*)()>(glAsyncMarkerSGIX),"glAsyncMarkerSGIX");
    _driver.call(&_driver.glAsyncMarkerSGIX)(marker);
  }

  static void REGAL_CALL glDeleteAsyncMarkersSGIX(GLuint marker, GLsizei range)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDeleteAsyncMarkersSGIX),reinterpret_cast<void (*)()>(glDeleteAsyncMarkersSGIX),"glDeleteAsyncMarkersSGIX");
    _driver.call(&_driver.glDeleteAsyncMarkersSGIX)(marker, range);
  }

  static GLint REGAL_CALL glFinishAsyncSGIX(GLuint *markerp)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFinishAsyncSGIX),reinterpret_cast<void (*)()>(glFinishAsyncSGIX),"glFinishAsyncSGIX");
    return _driver.call(&_driver.glFinishAsyncSGIX)(markerp);
  }

  static GLuint REGAL_CALL glGenAsyncMarkersSGIX(GLsizei range)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGenAsyncMarkersSGIX),reinterpret_cast<void (*)()>(glGenAsyncMarkersSGIX),"glGenAsyncMarkersSGIX");
    return _driver.call(&_driver.glGenAsyncMarkersSGIX)(range);
  }

  static GLboolean REGAL_CALL glIsAsyncMarkerSGIX(GLuint marker)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIsAsyncMarkerSGIX),reinterpret_cast<void (*)()>(glIsAsyncMarkerSGIX),"glIsAsyncMarkerSGIX");
    return _driver.call(&_driver.glIsAsyncMarkerSGIX)(marker);
  }

  static GLint REGAL_CALL glPollAsyncSGIX(GLuint *markerp)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPollAsyncSGIX),reinterpret_cast<void (*)()>(glPollAsyncSGIX),"glPollAsyncSGIX");
    return _driver.call(&_driver.glPollAsyncSGIX)(markerp);
  }

// GL_SGIX_flush_raster

  static void REGAL_CALL glFlushRasterSGIX(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFlushRasterSGIX),reinterpret_cast<void (*)()>(glFlushRasterSGIX),"glFlushRasterSGIX");
    _driver.call(&_driver.glFlushRasterSGIX)();
  }

// GL_SGIX_fog_texture

  static void REGAL_CALL glTextureFogSGIX(GLenum pname)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTextureFogSGIX),reinterpret_cast<void (*)()>(glTextureFogSGIX),"glTextureFogSGIX");
    _driver.call(&_driver.glTextureFogSGIX)(pname);
  }

// GL_SGIX_fragment_lighting

  static void REGAL_CALL glFragmentColorMaterialSGIX(GLenum face, GLenum mode)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFragmentColorMaterialSGIX),reinterpret_cast<void (*)()>(glFragmentColorMaterialSGIX),"glFragmentColorMaterialSGIX");
    _driver.call(&_driver.glFragmentColorMaterialSGIX)(face, mode);
  }

  static void REGAL_CALL glFragmentLightModelfSGIX(GLenum pname, GLfloat param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFragmentLightModelfSGIX),reinterpret_cast<void (*)()>(glFragmentLightModelfSGIX),"glFragmentLightModelfSGIX");
    _driver.call(&_driver.glFragmentLightModelfSGIX)(pname, param);
  }

  static void REGAL_CALL glFragmentLightModelfvSGIX(GLenum pname, const GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFragmentLightModelfvSGIX),reinterpret_cast<void (*)()>(glFragmentLightModelfvSGIX),"glFragmentLightModelfvSGIX");
    _driver.call(&_driver.glFragmentLightModelfvSGIX)(pname, params);
  }

  static void REGAL_CALL glFragmentLightModeliSGIX(GLenum pname, GLint param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFragmentLightModeliSGIX),reinterpret_cast<void (*)()>(glFragmentLightModeliSGIX),"glFragmentLightModeliSGIX");
    _driver.call(&_driver.glFragmentLightModeliSGIX)(pname, param);
  }

  static void REGAL_CALL glFragmentLightModelivSGIX(GLenum pname, const GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFragmentLightModelivSGIX),reinterpret_cast<void (*)()>(glFragmentLightModelivSGIX),"glFragmentLightModelivSGIX");
    _driver.call(&_driver.glFragmentLightModelivSGIX)(pname, params);
  }

  static void REGAL_CALL glFragmentLightfSGIX(GLenum light, GLenum pname, GLfloat param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFragmentLightfSGIX),reinterpret_cast<void (*)()>(glFragmentLightfSGIX),"glFragmentLightfSGIX");
    _driver.call(&_driver.glFragmentLightfSGIX)(light, pname, param);
  }

  static void REGAL_CALL glFragmentLightfvSGIX(GLenum light, GLenum pname, const GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFragmentLightfvSGIX),reinterpret_cast<void (*)()>(glFragmentLightfvSGIX),"glFragmentLightfvSGIX");
    _driver.call(&_driver.glFragmentLightfvSGIX)(light, pname, params);
  }

  static void REGAL_CALL glFragmentLightiSGIX(GLenum light, GLenum pname, GLint param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFragmentLightiSGIX),reinterpret_cast<void (*)()>(glFragmentLightiSGIX),"glFragmentLightiSGIX");
    _driver.call(&_driver.glFragmentLightiSGIX)(light, pname, param);
  }

  static void REGAL_CALL glFragmentLightivSGIX(GLenum light, GLenum pname, const GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFragmentLightivSGIX),reinterpret_cast<void (*)()>(glFragmentLightivSGIX),"glFragmentLightivSGIX");
    _driver.call(&_driver.glFragmentLightivSGIX)(light, pname, params);
  }

  static void REGAL_CALL glFragmentMaterialfSGIX(GLenum face, GLenum pname, GLfloat param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFragmentMaterialfSGIX),reinterpret_cast<void (*)()>(glFragmentMaterialfSGIX),"glFragmentMaterialfSGIX");
    _driver.call(&_driver.glFragmentMaterialfSGIX)(face, pname, param);
  }

  static void REGAL_CALL glFragmentMaterialfvSGIX(GLenum face, GLenum pname, const GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFragmentMaterialfvSGIX),reinterpret_cast<void (*)()>(glFragmentMaterialfvSGIX),"glFragmentMaterialfvSGIX");
    _driver.call(&_driver.glFragmentMaterialfvSGIX)(face, pname, params);
  }

  static void REGAL_CALL glFragmentMaterialiSGIX(GLenum face, GLenum pname, GLint param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFragmentMaterialiSGIX),reinterpret_cast<void (*)()>(glFragmentMaterialiSGIX),"glFragmentMaterialiSGIX");
    _driver.call(&_driver.glFragmentMaterialiSGIX)(face, pname, param);
  }

  static void REGAL_CALL glFragmentMaterialivSGIX(GLenum face, GLenum pname, const GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFragmentMaterialivSGIX),reinterpret_cast<void (*)()>(glFragmentMaterialivSGIX),"glFragmentMaterialivSGIX");
    _driver.call(&_driver.glFragmentMaterialivSGIX)(face, pname, params);
  }

  static void REGAL_CALL glGetFragmentLightfvSGIX(GLenum light, GLenum pname, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetFragmentLightfvSGIX),reinterpret_cast<void (*)()>(glGetFragmentLightfvSGIX),"glGetFragmentLightfvSGIX");
    _driver.call(&_driver.glGetFragmentLightfvSGIX)(light, pname, params);
  }

  static void REGAL_CALL glGetFragmentLightivSGIX(GLenum light, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetFragmentLightivSGIX),reinterpret_cast<void (*)()>(glGetFragmentLightivSGIX),"glGetFragmentLightivSGIX");
    _driver.call(&_driver.glGetFragmentLightivSGIX)(light, pname, params);
  }

  static void REGAL_CALL glGetFragmentMaterialfvSGIX(GLenum face, GLenum pname, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetFragmentMaterialfvSGIX),reinterpret_cast<void (*)()>(glGetFragmentMaterialfvSGIX),"glGetFragmentMaterialfvSGIX");
    _driver.call(&_driver.glGetFragmentMaterialfvSGIX)(face, pname, params);
  }

  static void REGAL_CALL glGetFragmentMaterialivSGIX(GLenum face, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetFragmentMaterialivSGIX),reinterpret_cast<void (*)()>(glGetFragmentMaterialivSGIX),"glGetFragmentMaterialivSGIX");
    _driver.call(&_driver.glGetFragmentMaterialivSGIX)(face, pname, params);
  }

  static void REGAL_CALL glLightEnviSGIX(GLenum pname, GLint param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glLightEnviSGIX),reinterpret_cast<void (*)()>(glLightEnviSGIX),"glLightEnviSGIX");
    _driver.call(&_driver.glLightEnviSGIX)(pname, param);
  }

// GL_SGIX_framezoom

  static void REGAL_CALL glFrameZoomSGIX(GLint factor)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFrameZoomSGIX),reinterpret_cast<void (*)()>(glFrameZoomSGIX),"glFrameZoomSGIX");
    _driver.call(&_driver.glFrameZoomSGIX)(factor);
  }

// GL_SGIX_igloo_interface

  static void REGAL_CALL glIglooInterfaceSGIX(GLenum pname, const GLvoid *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glIglooInterfaceSGIX),reinterpret_cast<void (*)()>(glIglooInterfaceSGIX),"glIglooInterfaceSGIX");
    _driver.call(&_driver.glIglooInterfaceSGIX)(pname, params);
  }

// GL_SGIX_instruments

  static GLint REGAL_CALL glGetInstrumentsSGIX(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetInstrumentsSGIX),reinterpret_cast<void (*)()>(glGetInstrumentsSGIX),"glGetInstrumentsSGIX");
    return _driver.call(&_driver.glGetInstrumentsSGIX)();
  }

  static void REGAL_CALL glInstrumentsBufferSGIX(GLsizei size, GLint *buffer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glInstrumentsBufferSGIX),reinterpret_cast<void (*)()>(glInstrumentsBufferSGIX),"glInstrumentsBufferSGIX");
    _driver.call(&_driver.glInstrumentsBufferSGIX)(size, buffer);
  }

  static GLint REGAL_CALL glPollInstrumentsSGIX(GLint *marker_p)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPollInstrumentsSGIX),reinterpret_cast<void (*)()>(glPollInstrumentsSGIX),"glPollInstrumentsSGIX");
    return _driver.call(&_driver.glPollInstrumentsSGIX)(marker_p);
  }

  static void REGAL_CALL glReadInstrumentsSGIX(GLint marker)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glReadInstrumentsSGIX),reinterpret_cast<void (*)()>(glReadInstrumentsSGIX),"glReadInstrumentsSGIX");
    _driver.call(&_driver.glReadInstrumentsSGIX)(marker);
  }

  static void REGAL_CALL glStartInstrumentsSGIX(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glStartInstrumentsSGIX),reinterpret_cast<void (*)()>(glStartInstrumentsSGIX),"glStartInstrumentsSGIX");
    _driver.call(&_driver.glStartInstrumentsSGIX)();
  }

  static void REGAL_CALL glStopInstrumentsSGIX(GLint marker)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glStopInstrumentsSGIX),reinterpret_cast<void (*)()>(glStopInstrumentsSGIX),"glStopInstrumentsSGIX");
    _driver.call(&_driver.glStopInstrumentsSGIX)(marker);
  }

// GL_SGIX_list_priority

  static void REGAL_CALL glGetListParameterfvSGIX(GLuint list, GLenum pname, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetListParameterfvSGIX),reinterpret_cast<void (*)()>(glGetListParameterfvSGIX),"glGetListParameterfvSGIX");
    _driver.call(&_driver.glGetListParameterfvSGIX)(list, pname, params);
  }

  static void REGAL_CALL glGetListParameterivSGIX(GLuint list, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetListParameterivSGIX),reinterpret_cast<void (*)()>(glGetListParameterivSGIX),"glGetListParameterivSGIX");
    _driver.call(&_driver.glGetListParameterivSGIX)(list, pname, params);
  }

  static void REGAL_CALL glListParameterfSGIX(GLuint list, GLenum pname, GLfloat param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glListParameterfSGIX),reinterpret_cast<void (*)()>(glListParameterfSGIX),"glListParameterfSGIX");
    _driver.call(&_driver.glListParameterfSGIX)(list, pname, param);
  }

  static void REGAL_CALL glListParameterfvSGIX(GLuint list, GLenum pname, const GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glListParameterfvSGIX),reinterpret_cast<void (*)()>(glListParameterfvSGIX),"glListParameterfvSGIX");
    _driver.call(&_driver.glListParameterfvSGIX)(list, pname, params);
  }

  static void REGAL_CALL glListParameteriSGIX(GLuint list, GLenum pname, GLint param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glListParameteriSGIX),reinterpret_cast<void (*)()>(glListParameteriSGIX),"glListParameteriSGIX");
    _driver.call(&_driver.glListParameteriSGIX)(list, pname, param);
  }

  static void REGAL_CALL glListParameterivSGIX(GLuint list, GLenum pname, const GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glListParameterivSGIX),reinterpret_cast<void (*)()>(glListParameterivSGIX),"glListParameterivSGIX");
    _driver.call(&_driver.glListParameterivSGIX)(list, pname, params);
  }

// GL_SGIX_pixel_texture

  static void REGAL_CALL glPixelTexGenSGIX(GLenum mode)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glPixelTexGenSGIX),reinterpret_cast<void (*)()>(glPixelTexGenSGIX),"glPixelTexGenSGIX");
    _driver.call(&_driver.glPixelTexGenSGIX)(mode);
  }

// GL_SGIX_polynomial_ffd

  static void REGAL_CALL glDeformSGIX(GLbitfield mask)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDeformSGIX),reinterpret_cast<void (*)()>(glDeformSGIX),"glDeformSGIX");
    _driver.call(&_driver.glDeformSGIX)(mask);
  }

  static void REGAL_CALL glDeformationMap3dSGIX(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, GLdouble w1, GLdouble w2, GLint wstride, GLint worder, const GLdouble *points)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDeformationMap3dSGIX),reinterpret_cast<void (*)()>(glDeformationMap3dSGIX),"glDeformationMap3dSGIX");
    _driver.call(&_driver.glDeformationMap3dSGIX)(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
  }

  static void REGAL_CALL glDeformationMap3fSGIX(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, GLfloat w1, GLfloat w2, GLint wstride, GLint worder, const GLfloat *points)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDeformationMap3fSGIX),reinterpret_cast<void (*)()>(glDeformationMap3fSGIX),"glDeformationMap3fSGIX");
    _driver.call(&_driver.glDeformationMap3fSGIX)(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
  }

  static void REGAL_CALL glLoadIdentityDeformationMapSGIX(GLbitfield mask)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glLoadIdentityDeformationMapSGIX),reinterpret_cast<void (*)()>(glLoadIdentityDeformationMapSGIX),"glLoadIdentityDeformationMapSGIX");
    _driver.call(&_driver.glLoadIdentityDeformationMapSGIX)(mask);
  }

// GL_SGIX_reference_plane

  static void REGAL_CALL glReferencePlaneSGIX(const GLdouble *equation)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glReferencePlaneSGIX),reinterpret_cast<void (*)()>(glReferencePlaneSGIX),"glReferencePlaneSGIX");
    _driver.call(&_driver.glReferencePlaneSGIX)(equation);
  }

// GL_SGIX_sprite

  static void REGAL_CALL glSpriteParameterfSGIX(GLenum pname, GLfloat param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSpriteParameterfSGIX),reinterpret_cast<void (*)()>(glSpriteParameterfSGIX),"glSpriteParameterfSGIX");
    _driver.call(&_driver.glSpriteParameterfSGIX)(pname, param);
  }

  static void REGAL_CALL glSpriteParameterfvSGIX(GLenum pname, const GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSpriteParameterfvSGIX),reinterpret_cast<void (*)()>(glSpriteParameterfvSGIX),"glSpriteParameterfvSGIX");
    _driver.call(&_driver.glSpriteParameterfvSGIX)(pname, params);
  }

  static void REGAL_CALL glSpriteParameteriSGIX(GLenum pname, GLint param)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSpriteParameteriSGIX),reinterpret_cast<void (*)()>(glSpriteParameteriSGIX),"glSpriteParameteriSGIX");
    _driver.call(&_driver.glSpriteParameteriSGIX)(pname, param);
  }

  static void REGAL_CALL glSpriteParameterivSGIX(GLenum pname, const GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glSpriteParameterivSGIX),reinterpret_cast<void (*)()>(glSpriteParameterivSGIX),"glSpriteParameterivSGIX");
    _driver.call(&_driver.glSpriteParameterivSGIX)(pname, params);
  }

// GL_SGIX_tag_sample_buffer

  static void REGAL_CALL glTagSampleBufferSGIX(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTagSampleBufferSGIX),reinterpret_cast<void (*)()>(glTagSampleBufferSGIX),"glTagSampleBufferSGIX");
    _driver.call(&_driver.glTagSampleBufferSGIX)();
  }

// GL_SGI_color_table

  static void REGAL_CALL glColorTableParameterfvSGI(GLenum target, GLenum pname, const GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColorTableParameterfvSGI),reinterpret_cast<void (*)()>(glColorTableParameterfvSGI),"glColorTableParameterfvSGI");
    _driver.call(&_driver.glColorTableParameterfvSGI)(target, pname, params);
  }

  static void REGAL_CALL glColorTableParameterivSGI(GLenum target, GLenum pname, const GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColorTableParameterivSGI),reinterpret_cast<void (*)()>(glColorTableParameterivSGI),"glColorTableParameterivSGI");
    _driver.call(&_driver.glColorTableParameterivSGI)(target, pname, params);
  }

  static void REGAL_CALL glColorTableSGI(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColorTableSGI),reinterpret_cast<void (*)()>(glColorTableSGI),"glColorTableSGI");
    _driver.call(&_driver.glColorTableSGI)(target, internalformat, width, format, type, table);
  }

  static void REGAL_CALL glCopyColorTableSGI(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glCopyColorTableSGI),reinterpret_cast<void (*)()>(glCopyColorTableSGI),"glCopyColorTableSGI");
    _driver.call(&_driver.glCopyColorTableSGI)(target, internalformat, x, y, width);
  }

  static void REGAL_CALL glGetColorTableParameterfvSGI(GLenum target, GLenum pname, GLfloat *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetColorTableParameterfvSGI),reinterpret_cast<void (*)()>(glGetColorTableParameterfvSGI),"glGetColorTableParameterfvSGI");
    _driver.call(&_driver.glGetColorTableParameterfvSGI)(target, pname, params);
  }

  static void REGAL_CALL glGetColorTableParameterivSGI(GLenum target, GLenum pname, GLint *params)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetColorTableParameterivSGI),reinterpret_cast<void (*)()>(glGetColorTableParameterivSGI),"glGetColorTableParameterivSGI");
    _driver.call(&_driver.glGetColorTableParameterivSGI)(target, pname, params);
  }

  static void REGAL_CALL glGetColorTableSGI(GLenum target, GLenum format, GLenum type, GLvoid *table)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGetColorTableSGI),reinterpret_cast<void (*)()>(glGetColorTableSGI),"glGetColorTableSGI");
    _driver.call(&_driver.glGetColorTableSGI)(target, format, type, table);
  }

// GL_SUNX_constant_data

  static void REGAL_CALL glFinishTextureSUNX(void)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glFinishTextureSUNX),reinterpret_cast<void (*)()>(glFinishTextureSUNX),"glFinishTextureSUNX");
    _driver.call(&_driver.glFinishTextureSUNX)();
  }

// GL_SUN_global_alpha

  static void REGAL_CALL glGlobalAlphaFactorbSUN(GLbyte factor)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGlobalAlphaFactorbSUN),reinterpret_cast<void (*)()>(glGlobalAlphaFactorbSUN),"glGlobalAlphaFactorbSUN");
    _driver.call(&_driver.glGlobalAlphaFactorbSUN)(factor);
  }

  static void REGAL_CALL glGlobalAlphaFactordSUN(GLdouble factor)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGlobalAlphaFactordSUN),reinterpret_cast<void (*)()>(glGlobalAlphaFactordSUN),"glGlobalAlphaFactordSUN");
    _driver.call(&_driver.glGlobalAlphaFactordSUN)(factor);
  }

  static void REGAL_CALL glGlobalAlphaFactorfSUN(GLfloat factor)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGlobalAlphaFactorfSUN),reinterpret_cast<void (*)()>(glGlobalAlphaFactorfSUN),"glGlobalAlphaFactorfSUN");
    _driver.call(&_driver.glGlobalAlphaFactorfSUN)(factor);
  }

  static void REGAL_CALL glGlobalAlphaFactoriSUN(GLint factor)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGlobalAlphaFactoriSUN),reinterpret_cast<void (*)()>(glGlobalAlphaFactoriSUN),"glGlobalAlphaFactoriSUN");
    _driver.call(&_driver.glGlobalAlphaFactoriSUN)(factor);
  }

  static void REGAL_CALL glGlobalAlphaFactorsSUN(GLshort factor)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGlobalAlphaFactorsSUN),reinterpret_cast<void (*)()>(glGlobalAlphaFactorsSUN),"glGlobalAlphaFactorsSUN");
    _driver.call(&_driver.glGlobalAlphaFactorsSUN)(factor);
  }

  static void REGAL_CALL glGlobalAlphaFactorubSUN(GLubyte factor)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGlobalAlphaFactorubSUN),reinterpret_cast<void (*)()>(glGlobalAlphaFactorubSUN),"glGlobalAlphaFactorubSUN");
    _driver.call(&_driver.glGlobalAlphaFactorubSUN)(factor);
  }

  static void REGAL_CALL glGlobalAlphaFactoruiSUN(GLuint factor)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGlobalAlphaFactoruiSUN),reinterpret_cast<void (*)()>(glGlobalAlphaFactoruiSUN),"glGlobalAlphaFactoruiSUN");
    _driver.call(&_driver.glGlobalAlphaFactoruiSUN)(factor);
  }

  static void REGAL_CALL glGlobalAlphaFactorusSUN(GLushort factor)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glGlobalAlphaFactorusSUN),reinterpret_cast<void (*)()>(glGlobalAlphaFactorusSUN),"glGlobalAlphaFactorusSUN");
    _driver.call(&_driver.glGlobalAlphaFactorusSUN)(factor);
  }

// GL_SUN_mesh_array

  static void REGAL_CALL glDrawMeshArraysSUN(GLenum mode, GLint first, GLsizei count, GLsizei width)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glDrawMeshArraysSUN),reinterpret_cast<void (*)()>(glDrawMeshArraysSUN),"glDrawMeshArraysSUN");
    _driver.call(&_driver.glDrawMeshArraysSUN)(mode, first, count, width);
  }

// GL_SUN_read_video_pixels

  static void REGAL_CALL glReadVideoPixelsSUN(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glReadVideoPixelsSUN),reinterpret_cast<void (*)()>(glReadVideoPixelsSUN),"glReadVideoPixelsSUN");
    _driver.call(&_driver.glReadVideoPixelsSUN)(x, y, width, height, format, type, pixels);
  }

// GL_SUN_triangle_list

  static void REGAL_CALL glReplacementCodePointerSUN(GLenum type, GLsizei stride, const GLvoid **pointer)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glReplacementCodePointerSUN),reinterpret_cast<void (*)()>(glReplacementCodePointerSUN),"glReplacementCodePointerSUN");
    _driver.call(&_driver.glReplacementCodePointerSUN)(type, stride, pointer);
  }

  static void REGAL_CALL glReplacementCodeubSUN(GLubyte code)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glReplacementCodeubSUN),reinterpret_cast<void (*)()>(glReplacementCodeubSUN),"glReplacementCodeubSUN");
    _driver.call(&_driver.glReplacementCodeubSUN)(code);
  }

  static void REGAL_CALL glReplacementCodeubvSUN(const GLubyte *code)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glReplacementCodeubvSUN),reinterpret_cast<void (*)()>(glReplacementCodeubvSUN),"glReplacementCodeubvSUN");
    _driver.call(&_driver.glReplacementCodeubvSUN)(code);
  }

  static void REGAL_CALL glReplacementCodeuiSUN(GLuint code)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glReplacementCodeuiSUN),reinterpret_cast<void (*)()>(glReplacementCodeuiSUN),"glReplacementCodeuiSUN");
    _driver.call(&_driver.glReplacementCodeuiSUN)(code);
  }

  static void REGAL_CALL glReplacementCodeuivSUN(const GLuint *code)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glReplacementCodeuivSUN),reinterpret_cast<void (*)()>(glReplacementCodeuivSUN),"glReplacementCodeuivSUN");
    _driver.call(&_driver.glReplacementCodeuivSUN)(code);
  }

  static void REGAL_CALL glReplacementCodeusSUN(GLushort code)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glReplacementCodeusSUN),reinterpret_cast<void (*)()>(glReplacementCodeusSUN),"glReplacementCodeusSUN");
    _driver.call(&_driver.glReplacementCodeusSUN)(code);
  }

  static void REGAL_CALL glReplacementCodeusvSUN(const GLushort *code)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glReplacementCodeusvSUN),reinterpret_cast<void (*)()>(glReplacementCodeusvSUN),"glReplacementCodeusvSUN");
    _driver.call(&_driver.glReplacementCodeusvSUN)(code);
  }

// GL_SUN_vertex

  static void REGAL_CALL glColor3fVertex3fSUN(GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColor3fVertex3fSUN),reinterpret_cast<void (*)()>(glColor3fVertex3fSUN),"glColor3fVertex3fSUN");
    _driver.call(&_driver.glColor3fVertex3fSUN)(r, g, b, x, y, z);
  }

  static void REGAL_CALL glColor3fVertex3fvSUN(const GLfloat *c, const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColor3fVertex3fvSUN),reinterpret_cast<void (*)()>(glColor3fVertex3fvSUN),"glColor3fVertex3fvSUN");
    _driver.call(&_driver.glColor3fVertex3fvSUN)(c, v);
  }

  static void REGAL_CALL glColor4fNormal3fVertex3fSUN(GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColor4fNormal3fVertex3fSUN),reinterpret_cast<void (*)()>(glColor4fNormal3fVertex3fSUN),"glColor4fNormal3fVertex3fSUN");
    _driver.call(&_driver.glColor4fNormal3fVertex3fSUN)(r, g, b, a, nx, ny, nz, x, y, z);
  }

  static void REGAL_CALL glColor4fNormal3fVertex3fvSUN(const GLfloat *c, const GLfloat *n, const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColor4fNormal3fVertex3fvSUN),reinterpret_cast<void (*)()>(glColor4fNormal3fVertex3fvSUN),"glColor4fNormal3fVertex3fvSUN");
    _driver.call(&_driver.glColor4fNormal3fVertex3fvSUN)(c, n, v);
  }

  static void REGAL_CALL glColor4ubVertex2fSUN(GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColor4ubVertex2fSUN),reinterpret_cast<void (*)()>(glColor4ubVertex2fSUN),"glColor4ubVertex2fSUN");
    _driver.call(&_driver.glColor4ubVertex2fSUN)(r, g, b, a, x, y);
  }

  static void REGAL_CALL glColor4ubVertex2fvSUN(const GLubyte *c, const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColor4ubVertex2fvSUN),reinterpret_cast<void (*)()>(glColor4ubVertex2fvSUN),"glColor4ubVertex2fvSUN");
    _driver.call(&_driver.glColor4ubVertex2fvSUN)(c, v);
  }

  static void REGAL_CALL glColor4ubVertex3fSUN(GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColor4ubVertex3fSUN),reinterpret_cast<void (*)()>(glColor4ubVertex3fSUN),"glColor4ubVertex3fSUN");
    _driver.call(&_driver.glColor4ubVertex3fSUN)(r, g, b, a, x, y, z);
  }

  static void REGAL_CALL glColor4ubVertex3fvSUN(const GLubyte *c, const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glColor4ubVertex3fvSUN),reinterpret_cast<void (*)()>(glColor4ubVertex3fvSUN),"glColor4ubVertex3fvSUN");
    _driver.call(&_driver.glColor4ubVertex3fvSUN)(c, v);
  }

  static void REGAL_CALL glNormal3fVertex3fSUN(GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNormal3fVertex3fSUN),reinterpret_cast<void (*)()>(glNormal3fVertex3fSUN),"glNormal3fVertex3fSUN");
    _driver.call(&_driver.glNormal3fVertex3fSUN)(nx, ny, nz, x, y, z);
  }

  static void REGAL_CALL glNormal3fVertex3fvSUN(const GLfloat *n, const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glNormal3fVertex3fvSUN),reinterpret_cast<void (*)()>(glNormal3fVertex3fvSUN),"glNormal3fVertex3fvSUN");
    _driver.call(&_driver.glNormal3fVertex3fvSUN)(n, v);
  }

  static void REGAL_CALL glReplacementCodeuiColor3fVertex3fSUN(GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glReplacementCodeuiColor3fVertex3fSUN),reinterpret_cast<void (*)()>(glReplacementCodeuiColor3fVertex3fSUN),"glReplacementCodeuiColor3fVertex3fSUN");
    _driver.call(&_driver.glReplacementCodeuiColor3fVertex3fSUN)(rc, r, g, b, x, y, z);
  }

  static void REGAL_CALL glReplacementCodeuiColor3fVertex3fvSUN(const GLuint *rc, const GLfloat *c, const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glReplacementCodeuiColor3fVertex3fvSUN),reinterpret_cast<void (*)()>(glReplacementCodeuiColor3fVertex3fvSUN),"glReplacementCodeuiColor3fVertex3fvSUN");
    _driver.call(&_driver.glReplacementCodeuiColor3fVertex3fvSUN)(rc, c, v);
  }

  static void REGAL_CALL glReplacementCodeuiColor4fNormal3fVertex3fSUN(GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glReplacementCodeuiColor4fNormal3fVertex3fSUN),reinterpret_cast<void (*)()>(glReplacementCodeuiColor4fNormal3fVertex3fSUN),"glReplacementCodeuiColor4fNormal3fVertex3fSUN");
    _driver.call(&_driver.glReplacementCodeuiColor4fNormal3fVertex3fSUN)(rc, r, g, b, a, nx, ny, nz, x, y, z);
  }

  static void REGAL_CALL glReplacementCodeuiColor4fNormal3fVertex3fvSUN(const GLuint *rc, const GLfloat *c, const GLfloat *n, const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glReplacementCodeuiColor4fNormal3fVertex3fvSUN),reinterpret_cast<void (*)()>(glReplacementCodeuiColor4fNormal3fVertex3fvSUN),"glReplacementCodeuiColor4fNormal3fVertex3fvSUN");
    _driver.call(&_driver.glReplacementCodeuiColor4fNormal3fVertex3fvSUN)(rc, c, n, v);
  }

  static void REGAL_CALL glReplacementCodeuiColor4ubVertex3fSUN(GLuint rc, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glReplacementCodeuiColor4ubVertex3fSUN),reinterpret_cast<void (*)()>(glReplacementCodeuiColor4ubVertex3fSUN),"glReplacementCodeuiColor4ubVertex3fSUN");
    _driver.call(&_driver.glReplacementCodeuiColor4ubVertex3fSUN)(rc, r, g, b, a, x, y, z);
  }

  static void REGAL_CALL glReplacementCodeuiColor4ubVertex3fvSUN(const GLuint *rc, const GLubyte *c, const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glReplacementCodeuiColor4ubVertex3fvSUN),reinterpret_cast<void (*)()>(glReplacementCodeuiColor4ubVertex3fvSUN),"glReplacementCodeuiColor4ubVertex3fvSUN");
    _driver.call(&_driver.glReplacementCodeuiColor4ubVertex3fvSUN)(rc, c, v);
  }

  static void REGAL_CALL glReplacementCodeuiNormal3fVertex3fSUN(GLuint rc, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glReplacementCodeuiNormal3fVertex3fSUN),reinterpret_cast<void (*)()>(glReplacementCodeuiNormal3fVertex3fSUN),"glReplacementCodeuiNormal3fVertex3fSUN");
    _driver.call(&_driver.glReplacementCodeuiNormal3fVertex3fSUN)(rc, nx, ny, nz, x, y, z);
  }

  static void REGAL_CALL glReplacementCodeuiNormal3fVertex3fvSUN(const GLuint *rc, const GLfloat *n, const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glReplacementCodeuiNormal3fVertex3fvSUN),reinterpret_cast<void (*)()>(glReplacementCodeuiNormal3fVertex3fvSUN),"glReplacementCodeuiNormal3fVertex3fvSUN");
    _driver.call(&_driver.glReplacementCodeuiNormal3fVertex3fvSUN)(rc, n, v);
  }

  static void REGAL_CALL glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(GLuint rc, GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN),reinterpret_cast<void (*)()>(glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN),"glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN");
    _driver.call(&_driver.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN)(rc, s, t, r, g, b, a, nx, ny, nz, x, y, z);
  }

  static void REGAL_CALL glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(const GLuint *rc, const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN),reinterpret_cast<void (*)()>(glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN),"glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN");
    _driver.call(&_driver.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN)(rc, tc, c, n, v);
  }

  static void REGAL_CALL glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(GLuint rc, GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN),reinterpret_cast<void (*)()>(glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN),"glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN");
    _driver.call(&_driver.glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN)(rc, s, t, nx, ny, nz, x, y, z);
  }

  static void REGAL_CALL glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(const GLuint *rc, const GLfloat *tc, const GLfloat *n, const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN),reinterpret_cast<void (*)()>(glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN),"glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN");
    _driver.call(&_driver.glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN)(rc, tc, n, v);
  }

  static void REGAL_CALL glReplacementCodeuiTexCoord2fVertex3fSUN(GLuint rc, GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glReplacementCodeuiTexCoord2fVertex3fSUN),reinterpret_cast<void (*)()>(glReplacementCodeuiTexCoord2fVertex3fSUN),"glReplacementCodeuiTexCoord2fVertex3fSUN");
    _driver.call(&_driver.glReplacementCodeuiTexCoord2fVertex3fSUN)(rc, s, t, x, y, z);
  }

  static void REGAL_CALL glReplacementCodeuiTexCoord2fVertex3fvSUN(const GLuint *rc, const GLfloat *tc, const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glReplacementCodeuiTexCoord2fVertex3fvSUN),reinterpret_cast<void (*)()>(glReplacementCodeuiTexCoord2fVertex3fvSUN),"glReplacementCodeuiTexCoord2fVertex3fvSUN");
    _driver.call(&_driver.glReplacementCodeuiTexCoord2fVertex3fvSUN)(rc, tc, v);
  }

  static void REGAL_CALL glReplacementCodeuiVertex3fSUN(GLuint rc, GLfloat x, GLfloat y, GLfloat z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glReplacementCodeuiVertex3fSUN),reinterpret_cast<void (*)()>(glReplacementCodeuiVertex3fSUN),"glReplacementCodeuiVertex3fSUN");
    _driver.call(&_driver.glReplacementCodeuiVertex3fSUN)(rc, x, y, z);
  }

  static void REGAL_CALL glReplacementCodeuiVertex3fvSUN(const GLuint *rc, const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glReplacementCodeuiVertex3fvSUN),reinterpret_cast<void (*)()>(glReplacementCodeuiVertex3fvSUN),"glReplacementCodeuiVertex3fvSUN");
    _driver.call(&_driver.glReplacementCodeuiVertex3fvSUN)(rc, v);
  }

  static void REGAL_CALL glTexCoord2fColor3fVertex3fSUN(GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord2fColor3fVertex3fSUN),reinterpret_cast<void (*)()>(glTexCoord2fColor3fVertex3fSUN),"glTexCoord2fColor3fVertex3fSUN");
    _driver.call(&_driver.glTexCoord2fColor3fVertex3fSUN)(s, t, r, g, b, x, y, z);
  }

  static void REGAL_CALL glTexCoord2fColor3fVertex3fvSUN(const GLfloat *tc, const GLfloat *c, const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord2fColor3fVertex3fvSUN),reinterpret_cast<void (*)()>(glTexCoord2fColor3fVertex3fvSUN),"glTexCoord2fColor3fVertex3fvSUN");
    _driver.call(&_driver.glTexCoord2fColor3fVertex3fvSUN)(tc, c, v);
  }

  static void REGAL_CALL glTexCoord2fColor4fNormal3fVertex3fSUN(GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord2fColor4fNormal3fVertex3fSUN),reinterpret_cast<void (*)()>(glTexCoord2fColor4fNormal3fVertex3fSUN),"glTexCoord2fColor4fNormal3fVertex3fSUN");
    _driver.call(&_driver.glTexCoord2fColor4fNormal3fVertex3fSUN)(s, t, r, g, b, a, nx, ny, nz, x, y, z);
  }

  static void REGAL_CALL glTexCoord2fColor4fNormal3fVertex3fvSUN(const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord2fColor4fNormal3fVertex3fvSUN),reinterpret_cast<void (*)()>(glTexCoord2fColor4fNormal3fVertex3fvSUN),"glTexCoord2fColor4fNormal3fVertex3fvSUN");
    _driver.call(&_driver.glTexCoord2fColor4fNormal3fVertex3fvSUN)(tc, c, n, v);
  }

  static void REGAL_CALL glTexCoord2fColor4ubVertex3fSUN(GLfloat s, GLfloat t, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord2fColor4ubVertex3fSUN),reinterpret_cast<void (*)()>(glTexCoord2fColor4ubVertex3fSUN),"glTexCoord2fColor4ubVertex3fSUN");
    _driver.call(&_driver.glTexCoord2fColor4ubVertex3fSUN)(s, t, r, g, b, a, x, y, z);
  }

  static void REGAL_CALL glTexCoord2fColor4ubVertex3fvSUN(const GLfloat *tc, const GLubyte *c, const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord2fColor4ubVertex3fvSUN),reinterpret_cast<void (*)()>(glTexCoord2fColor4ubVertex3fvSUN),"glTexCoord2fColor4ubVertex3fvSUN");
    _driver.call(&_driver.glTexCoord2fColor4ubVertex3fvSUN)(tc, c, v);
  }

  static void REGAL_CALL glTexCoord2fNormal3fVertex3fSUN(GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord2fNormal3fVertex3fSUN),reinterpret_cast<void (*)()>(glTexCoord2fNormal3fVertex3fSUN),"glTexCoord2fNormal3fVertex3fSUN");
    _driver.call(&_driver.glTexCoord2fNormal3fVertex3fSUN)(s, t, nx, ny, nz, x, y, z);
  }

  static void REGAL_CALL glTexCoord2fNormal3fVertex3fvSUN(const GLfloat *tc, const GLfloat *n, const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord2fNormal3fVertex3fvSUN),reinterpret_cast<void (*)()>(glTexCoord2fNormal3fVertex3fvSUN),"glTexCoord2fNormal3fVertex3fvSUN");
    _driver.call(&_driver.glTexCoord2fNormal3fVertex3fvSUN)(tc, n, v);
  }

  static void REGAL_CALL glTexCoord2fVertex3fSUN(GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord2fVertex3fSUN),reinterpret_cast<void (*)()>(glTexCoord2fVertex3fSUN),"glTexCoord2fVertex3fSUN");
    _driver.call(&_driver.glTexCoord2fVertex3fSUN)(s, t, x, y, z);
  }

  static void REGAL_CALL glTexCoord2fVertex3fvSUN(const GLfloat *tc, const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord2fVertex3fvSUN),reinterpret_cast<void (*)()>(glTexCoord2fVertex3fvSUN),"glTexCoord2fVertex3fvSUN");
    _driver.call(&_driver.glTexCoord2fVertex3fvSUN)(tc, v);
  }

  static void REGAL_CALL glTexCoord4fColor4fNormal3fVertex4fSUN(GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord4fColor4fNormal3fVertex4fSUN),reinterpret_cast<void (*)()>(glTexCoord4fColor4fNormal3fVertex4fSUN),"glTexCoord4fColor4fNormal3fVertex4fSUN");
    _driver.call(&_driver.glTexCoord4fColor4fNormal3fVertex4fSUN)(s, t, p, q, r, g, b, a, nx, ny, nz, x, y, z, w);
  }

  static void REGAL_CALL glTexCoord4fColor4fNormal3fVertex4fvSUN(const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord4fColor4fNormal3fVertex4fvSUN),reinterpret_cast<void (*)()>(glTexCoord4fColor4fNormal3fVertex4fvSUN),"glTexCoord4fColor4fNormal3fVertex4fvSUN");
    _driver.call(&_driver.glTexCoord4fColor4fNormal3fVertex4fvSUN)(tc, c, n, v);
  }

  static void REGAL_CALL glTexCoord4fVertex4fSUN(GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord4fVertex4fSUN),reinterpret_cast<void (*)()>(glTexCoord4fVertex4fSUN),"glTexCoord4fVertex4fSUN");
    _driver.call(&_driver.glTexCoord4fVertex4fSUN)(s, t, p, q, x, y, z, w);
  }

  static void REGAL_CALL glTexCoord4fVertex4fvSUN(const GLfloat *tc, const GLfloat *v)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glTexCoord4fVertex4fvSUN),reinterpret_cast<void (*)()>(glTexCoord4fVertex4fvSUN),"glTexCoord4fVertex4fvSUN");
    _driver.call(&_driver.glTexCoord4fVertex4fvSUN)(tc, v);
  }

// GL_WIN_swap_hint

  static void REGAL_CALL glAddSwapHintRectWIN(GLint x, GLint y, GLsizei width, GLsizei height)
  {
    DispatchTableGL &_driver = _getDispatchGL();
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glAddSwapHintRectWIN),reinterpret_cast<void (*)()>(glAddSwapHintRectWIN),"glAddSwapHintRectWIN");
    _driver.call(&_driver.glAddSwapHintRectWIN)(x, y, width, height);
  }

#if REGAL_SYS_WGL

// WGL_3DL_stereo_control

  static BOOL REGAL_CALL wglSetStereoEmitterState3DL(HDC hDC, UINT uState)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglSetStereoEmitterState3DL),reinterpret_cast<void (*)()>(wglSetStereoEmitterState3DL),"wglSetStereoEmitterState3DL");
    return _driver.call(&_driver.wglSetStereoEmitterState3DL)(hDC, uState);
  }

// WGL_AMD_gpu_association

  static VOID REGAL_CALL wglBlitContextFramebufferAMD(HGLRC dstCtx, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglBlitContextFramebufferAMD),reinterpret_cast<void (*)()>(wglBlitContextFramebufferAMD),"wglBlitContextFramebufferAMD");
    _driver.call(&_driver.wglBlitContextFramebufferAMD)(dstCtx, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
  }

  static HGLRC REGAL_CALL wglCreateAssociatedContextAMD(UINT id)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglCreateAssociatedContextAMD),reinterpret_cast<void (*)()>(wglCreateAssociatedContextAMD),"wglCreateAssociatedContextAMD");
    return _driver.call(&_driver.wglCreateAssociatedContextAMD)(id);
  }

  static HGLRC REGAL_CALL wglCreateAssociatedContextAttribsAMD(UINT id, HGLRC hShareContext, const int *attribList)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglCreateAssociatedContextAttribsAMD),reinterpret_cast<void (*)()>(wglCreateAssociatedContextAttribsAMD),"wglCreateAssociatedContextAttribsAMD");
    return _driver.call(&_driver.wglCreateAssociatedContextAttribsAMD)(id, hShareContext, attribList);
  }

  static BOOL REGAL_CALL wglDeleteAssociatedContextAMD(HGLRC hglrc)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglDeleteAssociatedContextAMD),reinterpret_cast<void (*)()>(wglDeleteAssociatedContextAMD),"wglDeleteAssociatedContextAMD");
    return _driver.call(&_driver.wglDeleteAssociatedContextAMD)(hglrc);
  }

  static UINT REGAL_CALL wglGetContextGPUIDAMD(HGLRC hglrc)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglGetContextGPUIDAMD),reinterpret_cast<void (*)()>(wglGetContextGPUIDAMD),"wglGetContextGPUIDAMD");
    return _driver.call(&_driver.wglGetContextGPUIDAMD)(hglrc);
  }

  static HGLRC REGAL_CALL wglGetCurrentAssociatedContextAMD(void)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglGetCurrentAssociatedContextAMD),reinterpret_cast<void (*)()>(wglGetCurrentAssociatedContextAMD),"wglGetCurrentAssociatedContextAMD");
    return _driver.call(&_driver.wglGetCurrentAssociatedContextAMD)();
  }

  static UINT REGAL_CALL wglGetGPUIDsAMD(UINT maxCount, UINT *ids)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglGetGPUIDsAMD),reinterpret_cast<void (*)()>(wglGetGPUIDsAMD),"wglGetGPUIDsAMD");
    return _driver.call(&_driver.wglGetGPUIDsAMD)(maxCount, ids);
  }

  static INT REGAL_CALL wglGetGPUInfoAMD(UINT id, int property, GLenum dataType, UINT size, void *data)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglGetGPUInfoAMD),reinterpret_cast<void (*)()>(wglGetGPUInfoAMD),"wglGetGPUInfoAMD");
    return _driver.call(&_driver.wglGetGPUInfoAMD)(id, property, dataType, size, data);
  }

  static BOOL REGAL_CALL wglMakeAssociatedContextCurrentAMD(HGLRC hglrc)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglMakeAssociatedContextCurrentAMD),reinterpret_cast<void (*)()>(wglMakeAssociatedContextCurrentAMD),"wglMakeAssociatedContextCurrentAMD");
    return _driver.call(&_driver.wglMakeAssociatedContextCurrentAMD)(hglrc);
  }

// WGL_ARB_buffer_region

  static HANDLE REGAL_CALL wglCreateBufferRegionARB(HDC hDC, int iLayerPlane, UINT uType)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglCreateBufferRegionARB),reinterpret_cast<void (*)()>(wglCreateBufferRegionARB),"wglCreateBufferRegionARB");
    return _driver.call(&_driver.wglCreateBufferRegionARB)(hDC, iLayerPlane, uType);
  }

  static VOID REGAL_CALL wglDeleteBufferRegionARB(HANDLE hRegion)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglDeleteBufferRegionARB),reinterpret_cast<void (*)()>(wglDeleteBufferRegionARB),"wglDeleteBufferRegionARB");
    _driver.call(&_driver.wglDeleteBufferRegionARB)(hRegion);
  }

  static BOOL REGAL_CALL wglRestoreBufferRegionARB(HANDLE hRegion, int x, int y, int width, int height, int xSrc, int ySrc)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglRestoreBufferRegionARB),reinterpret_cast<void (*)()>(wglRestoreBufferRegionARB),"wglRestoreBufferRegionARB");
    return _driver.call(&_driver.wglRestoreBufferRegionARB)(hRegion, x, y, width, height, xSrc, ySrc);
  }

  static BOOL REGAL_CALL wglSaveBufferRegionARB(HANDLE hRegion, int x, int y, int width, int height)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglSaveBufferRegionARB),reinterpret_cast<void (*)()>(wglSaveBufferRegionARB),"wglSaveBufferRegionARB");
    return _driver.call(&_driver.wglSaveBufferRegionARB)(hRegion, x, y, width, height);
  }

// WGL_ARB_create_context

  static HGLRC REGAL_CALL wglCreateContextAttribsARB(HDC hDC, HGLRC hShareContext, const int *piAttribList)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglCreateContextAttribsARB),reinterpret_cast<void (*)()>(wglCreateContextAttribsARB),"wglCreateContextAttribsARB");
    return _driver.call(&_driver.wglCreateContextAttribsARB)(hDC, hShareContext, piAttribList);
  }

// WGL_ARB_extensions_string

  static const char *REGAL_CALL wglGetExtensionsStringARB(HDC hDC)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglGetExtensionsStringARB),reinterpret_cast<void (*)()>(wglGetExtensionsStringARB),"wglGetExtensionsStringARB");
    return _driver.call(&_driver.wglGetExtensionsStringARB)(hDC);
  }

// WGL_ARB_make_current_read

  static HDC REGAL_CALL wglGetCurrentReadDCARB(void)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglGetCurrentReadDCARB),reinterpret_cast<void (*)()>(wglGetCurrentReadDCARB),"wglGetCurrentReadDCARB");
    return _driver.call(&_driver.wglGetCurrentReadDCARB)();
  }

  static BOOL REGAL_CALL wglMakeContextCurrentARB(HDC hDrawDC, HDC hReadDC, HGLRC hglrc)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglMakeContextCurrentARB),reinterpret_cast<void (*)()>(wglMakeContextCurrentARB),"wglMakeContextCurrentARB");
    return _driver.call(&_driver.wglMakeContextCurrentARB)(hDrawDC, hReadDC, hglrc);
  }

// WGL_ARB_pbuffer

  static HPBUFFERARB REGAL_CALL wglCreatePbufferARB(HDC hDC, int iPixelFormat, int iWidth, int iHeight, const int *piAttribList)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglCreatePbufferARB),reinterpret_cast<void (*)()>(wglCreatePbufferARB),"wglCreatePbufferARB");
    return _driver.call(&_driver.wglCreatePbufferARB)(hDC, iPixelFormat, iWidth, iHeight, piAttribList);
  }

  static BOOL REGAL_CALL wglDestroyPbufferARB(HPBUFFERARB hPbuffer)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglDestroyPbufferARB),reinterpret_cast<void (*)()>(wglDestroyPbufferARB),"wglDestroyPbufferARB");
    return _driver.call(&_driver.wglDestroyPbufferARB)(hPbuffer);
  }

  static HDC REGAL_CALL wglGetPbufferDCARB(HPBUFFERARB hPbuffer)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglGetPbufferDCARB),reinterpret_cast<void (*)()>(wglGetPbufferDCARB),"wglGetPbufferDCARB");
    return _driver.call(&_driver.wglGetPbufferDCARB)(hPbuffer);
  }

  static BOOL REGAL_CALL wglQueryPbufferARB(HPBUFFERARB hPbuffer, int iAttribute, int *piValue)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglQueryPbufferARB),reinterpret_cast<void (*)()>(wglQueryPbufferARB),"wglQueryPbufferARB");
    return _driver.call(&_driver.wglQueryPbufferARB)(hPbuffer, iAttribute, piValue);
  }

  static int REGAL_CALL wglReleasePbufferDCARB(HPBUFFERARB hPbuffer, HDC hDC)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglReleasePbufferDCARB),reinterpret_cast<void (*)()>(wglReleasePbufferDCARB),"wglReleasePbufferDCARB");
    return _driver.call(&_driver.wglReleasePbufferDCARB)(hPbuffer, hDC);
  }

// WGL_ARB_pixel_format

  static BOOL REGAL_CALL wglChoosePixelFormatARB(HDC hDC, const int *piAttribIList, const FLOAT *pfAttribFList, UINT nMaxFormats, int *piFormats, UINT *nNumFormats)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglChoosePixelFormatARB),reinterpret_cast<void (*)()>(wglChoosePixelFormatARB),"wglChoosePixelFormatARB");
    return _driver.call(&_driver.wglChoosePixelFormatARB)(hDC, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
  }

  static BOOL REGAL_CALL wglGetPixelFormatAttribfvARB(HDC hDC, int iPixelFormat, int iLayerPlane, UINT nAttributes, const int *piAttributes, FLOAT *pfValues)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglGetPixelFormatAttribfvARB),reinterpret_cast<void (*)()>(wglGetPixelFormatAttribfvARB),"wglGetPixelFormatAttribfvARB");
    return _driver.call(&_driver.wglGetPixelFormatAttribfvARB)(hDC, iPixelFormat, iLayerPlane, nAttributes, piAttributes, pfValues);
  }

  static BOOL REGAL_CALL wglGetPixelFormatAttribivARB(HDC hDC, int iPixelFormat, int iLayerPlane, UINT nAttributes, const int *piAttributes, int *piValues)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglGetPixelFormatAttribivARB),reinterpret_cast<void (*)()>(wglGetPixelFormatAttribivARB),"wglGetPixelFormatAttribivARB");
    return _driver.call(&_driver.wglGetPixelFormatAttribivARB)(hDC, iPixelFormat, iLayerPlane, nAttributes, piAttributes, piValues);
  }

// WGL_ARB_render_texture

  static BOOL REGAL_CALL wglBindTexImageARB(HPBUFFERARB hPbuffer, int iBuffer)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglBindTexImageARB),reinterpret_cast<void (*)()>(wglBindTexImageARB),"wglBindTexImageARB");
    return _driver.call(&_driver.wglBindTexImageARB)(hPbuffer, iBuffer);
  }

  static BOOL REGAL_CALL wglReleaseTexImageARB(HPBUFFERARB hPbuffer, int iBuffer)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglReleaseTexImageARB),reinterpret_cast<void (*)()>(wglReleaseTexImageARB),"wglReleaseTexImageARB");
    return _driver.call(&_driver.wglReleaseTexImageARB)(hPbuffer, iBuffer);
  }

  static BOOL REGAL_CALL wglSetPbufferAttribARB(HPBUFFERARB hPbuffer, const int *piAttribList)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglSetPbufferAttribARB),reinterpret_cast<void (*)()>(wglSetPbufferAttribARB),"wglSetPbufferAttribARB");
    return _driver.call(&_driver.wglSetPbufferAttribARB)(hPbuffer, piAttribList);
  }

// WGL_EXT_display_color_table

  static GLboolean REGAL_CALL wglBindDisplayColorTableEXT(GLushort id)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglBindDisplayColorTableEXT),reinterpret_cast<void (*)()>(wglBindDisplayColorTableEXT),"wglBindDisplayColorTableEXT");
    return _driver.call(&_driver.wglBindDisplayColorTableEXT)(id);
  }

  static GLboolean REGAL_CALL wglCreateDisplayColorTableEXT(GLushort id)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglCreateDisplayColorTableEXT),reinterpret_cast<void (*)()>(wglCreateDisplayColorTableEXT),"wglCreateDisplayColorTableEXT");
    return _driver.call(&_driver.wglCreateDisplayColorTableEXT)(id);
  }

  static VOID REGAL_CALL wglDestroyDisplayColorTableEXT(GLushort id)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglDestroyDisplayColorTableEXT),reinterpret_cast<void (*)()>(wglDestroyDisplayColorTableEXT),"wglDestroyDisplayColorTableEXT");
    _driver.call(&_driver.wglDestroyDisplayColorTableEXT)(id);
  }

  static GLboolean REGAL_CALL wglLoadDisplayColorTableEXT(const GLushort *table, GLuint length)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglLoadDisplayColorTableEXT),reinterpret_cast<void (*)()>(wglLoadDisplayColorTableEXT),"wglLoadDisplayColorTableEXT");
    return _driver.call(&_driver.wglLoadDisplayColorTableEXT)(table, length);
  }

// WGL_EXT_extensions_string

  static const char *REGAL_CALL wglGetExtensionsStringEXT(void)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglGetExtensionsStringEXT),reinterpret_cast<void (*)()>(wglGetExtensionsStringEXT),"wglGetExtensionsStringEXT");
    return _driver.call(&_driver.wglGetExtensionsStringEXT)();
  }

// WGL_EXT_make_current_read

  static HDC REGAL_CALL wglGetCurrentReadDCEXT(void)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglGetCurrentReadDCEXT),reinterpret_cast<void (*)()>(wglGetCurrentReadDCEXT),"wglGetCurrentReadDCEXT");
    return _driver.call(&_driver.wglGetCurrentReadDCEXT)();
  }

  static BOOL REGAL_CALL wglMakeContextCurrentEXT(HDC hDrawDC, HDC hReadDC, HGLRC hglrc)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglMakeContextCurrentEXT),reinterpret_cast<void (*)()>(wglMakeContextCurrentEXT),"wglMakeContextCurrentEXT");
    return _driver.call(&_driver.wglMakeContextCurrentEXT)(hDrawDC, hReadDC, hglrc);
  }

// WGL_EXT_pbuffer

  static HPBUFFEREXT REGAL_CALL wglCreatePbufferEXT(HDC hDC, int iPixelFormat, int iWidth, int iHeight, const int *piAttribList)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglCreatePbufferEXT),reinterpret_cast<void (*)()>(wglCreatePbufferEXT),"wglCreatePbufferEXT");
    return _driver.call(&_driver.wglCreatePbufferEXT)(hDC, iPixelFormat, iWidth, iHeight, piAttribList);
  }

  static BOOL REGAL_CALL wglDestroyPbufferEXT(HPBUFFEREXT hPbuffer)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglDestroyPbufferEXT),reinterpret_cast<void (*)()>(wglDestroyPbufferEXT),"wglDestroyPbufferEXT");
    return _driver.call(&_driver.wglDestroyPbufferEXT)(hPbuffer);
  }

  static HDC REGAL_CALL wglGetPbufferDCEXT(HPBUFFEREXT hPbuffer)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglGetPbufferDCEXT),reinterpret_cast<void (*)()>(wglGetPbufferDCEXT),"wglGetPbufferDCEXT");
    return _driver.call(&_driver.wglGetPbufferDCEXT)(hPbuffer);
  }

  static BOOL REGAL_CALL wglQueryPbufferEXT(HPBUFFEREXT hPbuffer, int iAttribute, int *piValue)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglQueryPbufferEXT),reinterpret_cast<void (*)()>(wglQueryPbufferEXT),"wglQueryPbufferEXT");
    return _driver.call(&_driver.wglQueryPbufferEXT)(hPbuffer, iAttribute, piValue);
  }

  static int REGAL_CALL wglReleasePbufferDCEXT(HPBUFFEREXT hPbuffer, HDC hDC)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglReleasePbufferDCEXT),reinterpret_cast<void (*)()>(wglReleasePbufferDCEXT),"wglReleasePbufferDCEXT");
    return _driver.call(&_driver.wglReleasePbufferDCEXT)(hPbuffer, hDC);
  }

// WGL_EXT_pixel_format

  static BOOL REGAL_CALL wglChoosePixelFormatEXT(HDC hDC, const int *piAttribIList, const FLOAT *pfAttribFList, UINT nMaxFormats, int *piFormats, UINT *nNumFormats)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglChoosePixelFormatEXT),reinterpret_cast<void (*)()>(wglChoosePixelFormatEXT),"wglChoosePixelFormatEXT");
    return _driver.call(&_driver.wglChoosePixelFormatEXT)(hDC, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
  }

  static BOOL REGAL_CALL wglGetPixelFormatAttribfvEXT(HDC hDC, int iPixelFormat, int iLayerPlane, UINT nAttributes, const int *piAttributes, FLOAT *pfValues)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglGetPixelFormatAttribfvEXT),reinterpret_cast<void (*)()>(wglGetPixelFormatAttribfvEXT),"wglGetPixelFormatAttribfvEXT");
    return _driver.call(&_driver.wglGetPixelFormatAttribfvEXT)(hDC, iPixelFormat, iLayerPlane, nAttributes, piAttributes, pfValues);
  }

  static BOOL REGAL_CALL wglGetPixelFormatAttribivEXT(HDC hDC, int iPixelFormat, int iLayerPlane, UINT nAttributes, const int *piAttributes, int *piValues)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglGetPixelFormatAttribivEXT),reinterpret_cast<void (*)()>(wglGetPixelFormatAttribivEXT),"wglGetPixelFormatAttribivEXT");
    return _driver.call(&_driver.wglGetPixelFormatAttribivEXT)(hDC, iPixelFormat, iLayerPlane, nAttributes, piAttributes, piValues);
  }

// WGL_EXT_swap_control

  static int REGAL_CALL wglGetSwapIntervalEXT(void)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglGetSwapIntervalEXT),reinterpret_cast<void (*)()>(wglGetSwapIntervalEXT),"wglGetSwapIntervalEXT");
    return _driver.call(&_driver.wglGetSwapIntervalEXT)();
  }

  static BOOL REGAL_CALL wglSwapIntervalEXT(int interval)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglSwapIntervalEXT),reinterpret_cast<void (*)()>(wglSwapIntervalEXT),"wglSwapIntervalEXT");
    return _driver.call(&_driver.wglSwapIntervalEXT)(interval);
  }

// WGL_GDI

  static int REGAL_CALL wglChoosePixelFormat(HDC hDC, const PIXELFORMATDESCRIPTOR *ppfd)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglChoosePixelFormat),reinterpret_cast<void (*)()>(wglChoosePixelFormat),"wglChoosePixelFormat");
    return _driver.call(&_driver.wglChoosePixelFormat)(hDC, ppfd);
  }

  static int REGAL_CALL wglDescribePixelFormat(HDC hDC, int iPixelFormat, UINT nBytes, LPPIXELFORMATDESCRIPTOR ppfd)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglDescribePixelFormat),reinterpret_cast<void (*)()>(wglDescribePixelFormat),"wglDescribePixelFormat");
    return _driver.call(&_driver.wglDescribePixelFormat)(hDC, iPixelFormat, nBytes, ppfd);
  }

  static int REGAL_CALL wglGetPixelFormat(HDC hDC)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglGetPixelFormat),reinterpret_cast<void (*)()>(wglGetPixelFormat),"wglGetPixelFormat");
    return _driver.call(&_driver.wglGetPixelFormat)(hDC);
  }

  static BOOL REGAL_CALL wglSetPixelFormat(HDC hDC, int iPixelFormat, const PIXELFORMATDESCRIPTOR *ppfd)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglSetPixelFormat),reinterpret_cast<void (*)()>(wglSetPixelFormat),"wglSetPixelFormat");
    return _driver.call(&_driver.wglSetPixelFormat)(hDC, iPixelFormat, ppfd);
  }

  static BOOL REGAL_CALL wglSwapBuffers(HDC hDC)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglSwapBuffers),reinterpret_cast<void (*)()>(wglSwapBuffers),"wglSwapBuffers");
    return _driver.call(&_driver.wglSwapBuffers)(hDC);
  }

// WGL_I3D_digital_video_control

  static BOOL REGAL_CALL wglGetDigitalVideoParametersI3D(HDC hDC, int iAttribute, int *piValue)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglGetDigitalVideoParametersI3D),reinterpret_cast<void (*)()>(wglGetDigitalVideoParametersI3D),"wglGetDigitalVideoParametersI3D");
    return _driver.call(&_driver.wglGetDigitalVideoParametersI3D)(hDC, iAttribute, piValue);
  }

  static BOOL REGAL_CALL wglSetDigitalVideoParametersI3D(HDC hDC, int iAttribute, const int *piValue)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglSetDigitalVideoParametersI3D),reinterpret_cast<void (*)()>(wglSetDigitalVideoParametersI3D),"wglSetDigitalVideoParametersI3D");
    return _driver.call(&_driver.wglSetDigitalVideoParametersI3D)(hDC, iAttribute, piValue);
  }

// WGL_I3D_gamma

  static BOOL REGAL_CALL wglGetGammaTableI3D(HDC hDC, int iEntries, USHORT *puRed, USHORT *puGreen, USHORT *puBlue)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglGetGammaTableI3D),reinterpret_cast<void (*)()>(wglGetGammaTableI3D),"wglGetGammaTableI3D");
    return _driver.call(&_driver.wglGetGammaTableI3D)(hDC, iEntries, puRed, puGreen, puBlue);
  }

  static BOOL REGAL_CALL wglGetGammaTableParametersI3D(HDC hDC, int iAttribute, int *piValue)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglGetGammaTableParametersI3D),reinterpret_cast<void (*)()>(wglGetGammaTableParametersI3D),"wglGetGammaTableParametersI3D");
    return _driver.call(&_driver.wglGetGammaTableParametersI3D)(hDC, iAttribute, piValue);
  }

  static BOOL REGAL_CALL wglSetGammaTableI3D(HDC hDC, int iEntries, const USHORT *puRed, const USHORT *puGreen, const USHORT *puBlue)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglSetGammaTableI3D),reinterpret_cast<void (*)()>(wglSetGammaTableI3D),"wglSetGammaTableI3D");
    return _driver.call(&_driver.wglSetGammaTableI3D)(hDC, iEntries, puRed, puGreen, puBlue);
  }

  static BOOL REGAL_CALL wglSetGammaTableParametersI3D(HDC hDC, int iAttribute, const int *piValue)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglSetGammaTableParametersI3D),reinterpret_cast<void (*)()>(wglSetGammaTableParametersI3D),"wglSetGammaTableParametersI3D");
    return _driver.call(&_driver.wglSetGammaTableParametersI3D)(hDC, iAttribute, piValue);
  }

// WGL_I3D_genlock

  static BOOL REGAL_CALL wglDisableGenlockI3D(HDC hDC)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglDisableGenlockI3D),reinterpret_cast<void (*)()>(wglDisableGenlockI3D),"wglDisableGenlockI3D");
    return _driver.call(&_driver.wglDisableGenlockI3D)(hDC);
  }

  static BOOL REGAL_CALL wglEnableGenlockI3D(HDC hDC)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglEnableGenlockI3D),reinterpret_cast<void (*)()>(wglEnableGenlockI3D),"wglEnableGenlockI3D");
    return _driver.call(&_driver.wglEnableGenlockI3D)(hDC);
  }

  static BOOL REGAL_CALL wglGenlockSampleRateI3D(HDC hDC, UINT uRate)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglGenlockSampleRateI3D),reinterpret_cast<void (*)()>(wglGenlockSampleRateI3D),"wglGenlockSampleRateI3D");
    return _driver.call(&_driver.wglGenlockSampleRateI3D)(hDC, uRate);
  }

  static BOOL REGAL_CALL wglGenlockSourceDelayI3D(HDC hDC, UINT uDelay)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglGenlockSourceDelayI3D),reinterpret_cast<void (*)()>(wglGenlockSourceDelayI3D),"wglGenlockSourceDelayI3D");
    return _driver.call(&_driver.wglGenlockSourceDelayI3D)(hDC, uDelay);
  }

  static BOOL REGAL_CALL wglGenlockSourceEdgeI3D(HDC hDC, UINT uEdge)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglGenlockSourceEdgeI3D),reinterpret_cast<void (*)()>(wglGenlockSourceEdgeI3D),"wglGenlockSourceEdgeI3D");
    return _driver.call(&_driver.wglGenlockSourceEdgeI3D)(hDC, uEdge);
  }

  static BOOL REGAL_CALL wglGenlockSourceI3D(HDC hDC, UINT uSource)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglGenlockSourceI3D),reinterpret_cast<void (*)()>(wglGenlockSourceI3D),"wglGenlockSourceI3D");
    return _driver.call(&_driver.wglGenlockSourceI3D)(hDC, uSource);
  }

  static BOOL REGAL_CALL wglGetGenlockSampleRateI3D(HDC hDC, UINT *uRate)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglGetGenlockSampleRateI3D),reinterpret_cast<void (*)()>(wglGetGenlockSampleRateI3D),"wglGetGenlockSampleRateI3D");
    return _driver.call(&_driver.wglGetGenlockSampleRateI3D)(hDC, uRate);
  }

  static BOOL REGAL_CALL wglGetGenlockSourceDelayI3D(HDC hDC, UINT *uDelay)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglGetGenlockSourceDelayI3D),reinterpret_cast<void (*)()>(wglGetGenlockSourceDelayI3D),"wglGetGenlockSourceDelayI3D");
    return _driver.call(&_driver.wglGetGenlockSourceDelayI3D)(hDC, uDelay);
  }

  static BOOL REGAL_CALL wglGetGenlockSourceEdgeI3D(HDC hDC, UINT *uEdge)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglGetGenlockSourceEdgeI3D),reinterpret_cast<void (*)()>(wglGetGenlockSourceEdgeI3D),"wglGetGenlockSourceEdgeI3D");
    return _driver.call(&_driver.wglGetGenlockSourceEdgeI3D)(hDC, uEdge);
  }

  static BOOL REGAL_CALL wglGetGenlockSourceI3D(HDC hDC, UINT *uSource)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglGetGenlockSourceI3D),reinterpret_cast<void (*)()>(wglGetGenlockSourceI3D),"wglGetGenlockSourceI3D");
    return _driver.call(&_driver.wglGetGenlockSourceI3D)(hDC, uSource);
  }

  static BOOL REGAL_CALL wglIsEnabledGenlockI3D(HDC hDC, BOOL *pFlag)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglIsEnabledGenlockI3D),reinterpret_cast<void (*)()>(wglIsEnabledGenlockI3D),"wglIsEnabledGenlockI3D");
    return _driver.call(&_driver.wglIsEnabledGenlockI3D)(hDC, pFlag);
  }

  static BOOL REGAL_CALL wglQueryGenlockMaxSourceDelayI3D(HDC hDC, UINT *uMaxLineDelay, UINT *uMaxPixelDelay)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglQueryGenlockMaxSourceDelayI3D),reinterpret_cast<void (*)()>(wglQueryGenlockMaxSourceDelayI3D),"wglQueryGenlockMaxSourceDelayI3D");
    return _driver.call(&_driver.wglQueryGenlockMaxSourceDelayI3D)(hDC, uMaxLineDelay, uMaxPixelDelay);
  }

// WGL_I3D_image_buffer

  static BOOL REGAL_CALL wglAssociateImageBufferEventsI3D(HDC hDC, const HANDLE *pEvent, const LPVOID *pAddress, const DWORD *pSize, UINT count)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglAssociateImageBufferEventsI3D),reinterpret_cast<void (*)()>(wglAssociateImageBufferEventsI3D),"wglAssociateImageBufferEventsI3D");
    return _driver.call(&_driver.wglAssociateImageBufferEventsI3D)(hDC, pEvent, pAddress, pSize, count);
  }

  static LPVOID REGAL_CALL wglCreateImageBufferI3D(HDC hDC, DWORD dwSize, UINT uFlags)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglCreateImageBufferI3D),reinterpret_cast<void (*)()>(wglCreateImageBufferI3D),"wglCreateImageBufferI3D");
    return _driver.call(&_driver.wglCreateImageBufferI3D)(hDC, dwSize, uFlags);
  }

  static BOOL REGAL_CALL wglDestroyImageBufferI3D(HDC hDC, LPVOID pAddress)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglDestroyImageBufferI3D),reinterpret_cast<void (*)()>(wglDestroyImageBufferI3D),"wglDestroyImageBufferI3D");
    return _driver.call(&_driver.wglDestroyImageBufferI3D)(hDC, pAddress);
  }

  static BOOL REGAL_CALL wglReleaseImageBufferEventsI3D(HDC hDC, const LPVOID *pAddress, UINT count)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglReleaseImageBufferEventsI3D),reinterpret_cast<void (*)()>(wglReleaseImageBufferEventsI3D),"wglReleaseImageBufferEventsI3D");
    return _driver.call(&_driver.wglReleaseImageBufferEventsI3D)(hDC, pAddress, count);
  }

// WGL_I3D_swap_frame_lock

  static BOOL REGAL_CALL wglDisableFrameLockI3D(void)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglDisableFrameLockI3D),reinterpret_cast<void (*)()>(wglDisableFrameLockI3D),"wglDisableFrameLockI3D");
    return _driver.call(&_driver.wglDisableFrameLockI3D)();
  }

  static BOOL REGAL_CALL wglEnableFrameLockI3D(void)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglEnableFrameLockI3D),reinterpret_cast<void (*)()>(wglEnableFrameLockI3D),"wglEnableFrameLockI3D");
    return _driver.call(&_driver.wglEnableFrameLockI3D)();
  }

  static BOOL REGAL_CALL wglIsEnabledFrameLockI3D(BOOL *pFlag)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglIsEnabledFrameLockI3D),reinterpret_cast<void (*)()>(wglIsEnabledFrameLockI3D),"wglIsEnabledFrameLockI3D");
    return _driver.call(&_driver.wglIsEnabledFrameLockI3D)(pFlag);
  }

  static BOOL REGAL_CALL wglQueryFrameLockMasterI3D(BOOL *pFlag)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglQueryFrameLockMasterI3D),reinterpret_cast<void (*)()>(wglQueryFrameLockMasterI3D),"wglQueryFrameLockMasterI3D");
    return _driver.call(&_driver.wglQueryFrameLockMasterI3D)(pFlag);
  }

// WGL_I3D_swap_frame_usage

  static BOOL REGAL_CALL wglBeginFrameTrackingI3D(void)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglBeginFrameTrackingI3D),reinterpret_cast<void (*)()>(wglBeginFrameTrackingI3D),"wglBeginFrameTrackingI3D");
    return _driver.call(&_driver.wglBeginFrameTrackingI3D)();
  }

  static BOOL REGAL_CALL wglEndFrameTrackingI3D(void)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglEndFrameTrackingI3D),reinterpret_cast<void (*)()>(wglEndFrameTrackingI3D),"wglEndFrameTrackingI3D");
    return _driver.call(&_driver.wglEndFrameTrackingI3D)();
  }

  static BOOL REGAL_CALL wglGetFrameUsageI3D(float *pUsage)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglGetFrameUsageI3D),reinterpret_cast<void (*)()>(wglGetFrameUsageI3D),"wglGetFrameUsageI3D");
    return _driver.call(&_driver.wglGetFrameUsageI3D)(pUsage);
  }

  static BOOL REGAL_CALL wglQueryFrameTrackingI3D(DWORD *pFrameCount, DWORD *pMissedFrames, float *pLastMissedUsage)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglQueryFrameTrackingI3D),reinterpret_cast<void (*)()>(wglQueryFrameTrackingI3D),"wglQueryFrameTrackingI3D");
    return _driver.call(&_driver.wglQueryFrameTrackingI3D)(pFrameCount, pMissedFrames, pLastMissedUsage);
  }

// WGL_NV_DX_interop

  static BOOL REGAL_CALL wglDXCloseDeviceNV(HANDLE hDevice)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglDXCloseDeviceNV),reinterpret_cast<void (*)()>(wglDXCloseDeviceNV),"wglDXCloseDeviceNV");
    return _driver.call(&_driver.wglDXCloseDeviceNV)(hDevice);
  }

  static BOOL REGAL_CALL wglDXLockObjectsNV(HANDLE hDevice, GLint count, HANDLE *hObjects)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglDXLockObjectsNV),reinterpret_cast<void (*)()>(wglDXLockObjectsNV),"wglDXLockObjectsNV");
    return _driver.call(&_driver.wglDXLockObjectsNV)(hDevice, count, hObjects);
  }

  static BOOL REGAL_CALL wglDXObjectAccessNV(HANDLE hObject, GLenum access)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglDXObjectAccessNV),reinterpret_cast<void (*)()>(wglDXObjectAccessNV),"wglDXObjectAccessNV");
    return _driver.call(&_driver.wglDXObjectAccessNV)(hObject, access);
  }

  static HANDLE REGAL_CALL wglDXOpenDeviceNV(GLvoid *dxDevice)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglDXOpenDeviceNV),reinterpret_cast<void (*)()>(wglDXOpenDeviceNV),"wglDXOpenDeviceNV");
    return _driver.call(&_driver.wglDXOpenDeviceNV)(dxDevice);
  }

  static HANDLE REGAL_CALL wglDXRegisterObjectNV(HANDLE hDevice, GLvoid *dxObject, GLuint name, GLenum type, GLenum access)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglDXRegisterObjectNV),reinterpret_cast<void (*)()>(wglDXRegisterObjectNV),"wglDXRegisterObjectNV");
    return _driver.call(&_driver.wglDXRegisterObjectNV)(hDevice, dxObject, name, type, access);
  }

  static BOOL REGAL_CALL wglDXSetResourceShareHandleNV(GLvoid *dxObject, HANDLE shareHandle)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglDXSetResourceShareHandleNV),reinterpret_cast<void (*)()>(wglDXSetResourceShareHandleNV),"wglDXSetResourceShareHandleNV");
    return _driver.call(&_driver.wglDXSetResourceShareHandleNV)(dxObject, shareHandle);
  }

  static BOOL REGAL_CALL wglDXUnlockObjectsNV(HANDLE hDevice, GLint count, HANDLE *hObjects)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglDXUnlockObjectsNV),reinterpret_cast<void (*)()>(wglDXUnlockObjectsNV),"wglDXUnlockObjectsNV");
    return _driver.call(&_driver.wglDXUnlockObjectsNV)(hDevice, count, hObjects);
  }

  static BOOL REGAL_CALL wglDXUnregisterObjectNV(HANDLE hDevice, HANDLE hObject)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglDXUnregisterObjectNV),reinterpret_cast<void (*)()>(wglDXUnregisterObjectNV),"wglDXUnregisterObjectNV");
    return _driver.call(&_driver.wglDXUnregisterObjectNV)(hDevice, hObject);
  }

// WGL_NV_copy_image

  static BOOL REGAL_CALL wglCopyImageSubDataNV(HGLRC hSrcRC, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, HGLRC hDstRC, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglCopyImageSubDataNV),reinterpret_cast<void (*)()>(wglCopyImageSubDataNV),"wglCopyImageSubDataNV");
    return _driver.call(&_driver.wglCopyImageSubDataNV)(hSrcRC, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, hDstRC, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
  }

// WGL_NV_gpu_affinity

  static HDC REGAL_CALL wglCreateAffinityDCNV(const HGPUNV *phGpuList)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglCreateAffinityDCNV),reinterpret_cast<void (*)()>(wglCreateAffinityDCNV),"wglCreateAffinityDCNV");
    return _driver.call(&_driver.wglCreateAffinityDCNV)(phGpuList);
  }

  static BOOL REGAL_CALL wglDeleteDCNV(HDC hAffinityDC)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglDeleteDCNV),reinterpret_cast<void (*)()>(wglDeleteDCNV),"wglDeleteDCNV");
    return _driver.call(&_driver.wglDeleteDCNV)(hAffinityDC);
  }

  static BOOL REGAL_CALL wglEnumGpuDevicesNV(HGPUNV hGpu, UINT iDeviceIndex, PGPU_DEVICE lpGpuDevice)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglEnumGpuDevicesNV),reinterpret_cast<void (*)()>(wglEnumGpuDevicesNV),"wglEnumGpuDevicesNV");
    return _driver.call(&_driver.wglEnumGpuDevicesNV)(hGpu, iDeviceIndex, lpGpuDevice);
  }

  static BOOL REGAL_CALL wglEnumGpusFromAffinityDCNV(HDC hAffinityDC, UINT iGpuIndex, HGPUNV *hGpu)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglEnumGpusFromAffinityDCNV),reinterpret_cast<void (*)()>(wglEnumGpusFromAffinityDCNV),"wglEnumGpusFromAffinityDCNV");
    return _driver.call(&_driver.wglEnumGpusFromAffinityDCNV)(hAffinityDC, iGpuIndex, hGpu);
  }

  static BOOL REGAL_CALL wglEnumGpusNV(UINT iGpuIndex, HGPUNV *phGpu)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglEnumGpusNV),reinterpret_cast<void (*)()>(wglEnumGpusNV),"wglEnumGpusNV");
    return _driver.call(&_driver.wglEnumGpusNV)(iGpuIndex, phGpu);
  }

// WGL_NV_present_video

  static BOOL REGAL_CALL wglBindVideoDeviceNV(HDC hDC, unsigned int uVideoSlot, HVIDEOOUTPUTDEVICENV hVideoDevice, const int *piAttribList)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglBindVideoDeviceNV),reinterpret_cast<void (*)()>(wglBindVideoDeviceNV),"wglBindVideoDeviceNV");
    return _driver.call(&_driver.wglBindVideoDeviceNV)(hDC, uVideoSlot, hVideoDevice, piAttribList);
  }

  static int REGAL_CALL wglEnumerateVideoDevicesNV(HDC hDC, HVIDEOOUTPUTDEVICENV *phDeviceList)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglEnumerateVideoDevicesNV),reinterpret_cast<void (*)()>(wglEnumerateVideoDevicesNV),"wglEnumerateVideoDevicesNV");
    return _driver.call(&_driver.wglEnumerateVideoDevicesNV)(hDC, phDeviceList);
  }

  static BOOL REGAL_CALL wglQueryCurrentContextNV(int iAttribute, int *piValue)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglQueryCurrentContextNV),reinterpret_cast<void (*)()>(wglQueryCurrentContextNV),"wglQueryCurrentContextNV");
    return _driver.call(&_driver.wglQueryCurrentContextNV)(iAttribute, piValue);
  }

// WGL_NV_swap_group

  static BOOL REGAL_CALL wglBindSwapBarrierNV(GLuint group, GLuint barrier)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglBindSwapBarrierNV),reinterpret_cast<void (*)()>(wglBindSwapBarrierNV),"wglBindSwapBarrierNV");
    return _driver.call(&_driver.wglBindSwapBarrierNV)(group, barrier);
  }

  static BOOL REGAL_CALL wglJoinSwapGroupNV(HDC hDC, GLuint group)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglJoinSwapGroupNV),reinterpret_cast<void (*)()>(wglJoinSwapGroupNV),"wglJoinSwapGroupNV");
    return _driver.call(&_driver.wglJoinSwapGroupNV)(hDC, group);
  }

  static BOOL REGAL_CALL wglQueryFrameCountNV(HDC hDC, GLuint *count)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglQueryFrameCountNV),reinterpret_cast<void (*)()>(wglQueryFrameCountNV),"wglQueryFrameCountNV");
    return _driver.call(&_driver.wglQueryFrameCountNV)(hDC, count);
  }

  static BOOL REGAL_CALL wglQueryMaxSwapGroupsNV(HDC hDC, GLuint *maxGroups, GLuint *maxBarriers)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglQueryMaxSwapGroupsNV),reinterpret_cast<void (*)()>(wglQueryMaxSwapGroupsNV),"wglQueryMaxSwapGroupsNV");
    return _driver.call(&_driver.wglQueryMaxSwapGroupsNV)(hDC, maxGroups, maxBarriers);
  }

  static BOOL REGAL_CALL wglQuerySwapGroupNV(HDC hDC, GLuint *group, GLuint *barrier)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglQuerySwapGroupNV),reinterpret_cast<void (*)()>(wglQuerySwapGroupNV),"wglQuerySwapGroupNV");
    return _driver.call(&_driver.wglQuerySwapGroupNV)(hDC, group, barrier);
  }

  static BOOL REGAL_CALL wglResetFrameCountNV(HDC hDC)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglResetFrameCountNV),reinterpret_cast<void (*)()>(wglResetFrameCountNV),"wglResetFrameCountNV");
    return _driver.call(&_driver.wglResetFrameCountNV)(hDC);
  }

// WGL_NV_vertex_array_range

  static void *REGAL_CALL wglAllocateMemoryNV(GLsizei size, GLfloat readfreq, GLfloat writefreq, GLfloat priority)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglAllocateMemoryNV),reinterpret_cast<void (*)()>(wglAllocateMemoryNV),"wglAllocateMemoryNV");
    return _driver.call(&_driver.wglAllocateMemoryNV)(size, readfreq, writefreq, priority);
  }

  static void REGAL_CALL wglFreeMemoryNV(void *pointer)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglFreeMemoryNV),reinterpret_cast<void (*)()>(wglFreeMemoryNV),"wglFreeMemoryNV");
    _driver.call(&_driver.wglFreeMemoryNV)(pointer);
  }

// WGL_NV_video_capture

  static BOOL REGAL_CALL wglBindVideoCaptureDeviceNV(UINT uVideoSlot, HVIDEOINPUTDEVICENV hDevice)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglBindVideoCaptureDeviceNV),reinterpret_cast<void (*)()>(wglBindVideoCaptureDeviceNV),"wglBindVideoCaptureDeviceNV");
    return _driver.call(&_driver.wglBindVideoCaptureDeviceNV)(uVideoSlot, hDevice);
  }

  static UINT REGAL_CALL wglEnumerateVideoCaptureDevicesNV(HDC hDC, HVIDEOINPUTDEVICENV *phDeviceList)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglEnumerateVideoCaptureDevicesNV),reinterpret_cast<void (*)()>(wglEnumerateVideoCaptureDevicesNV),"wglEnumerateVideoCaptureDevicesNV");
    return _driver.call(&_driver.wglEnumerateVideoCaptureDevicesNV)(hDC, phDeviceList);
  }

  static BOOL REGAL_CALL wglLockVideoCaptureDeviceNV(HDC hDC, HVIDEOINPUTDEVICENV hDevice)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglLockVideoCaptureDeviceNV),reinterpret_cast<void (*)()>(wglLockVideoCaptureDeviceNV),"wglLockVideoCaptureDeviceNV");
    return _driver.call(&_driver.wglLockVideoCaptureDeviceNV)(hDC, hDevice);
  }

  static BOOL REGAL_CALL wglQueryVideoCaptureDeviceNV(HDC hDC, HVIDEOINPUTDEVICENV hDevice, int iAttribute, int *piValue)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglQueryVideoCaptureDeviceNV),reinterpret_cast<void (*)()>(wglQueryVideoCaptureDeviceNV),"wglQueryVideoCaptureDeviceNV");
    return _driver.call(&_driver.wglQueryVideoCaptureDeviceNV)(hDC, hDevice, iAttribute, piValue);
  }

  static BOOL REGAL_CALL wglReleaseVideoCaptureDeviceNV(HDC hDC, HVIDEOINPUTDEVICENV hDevice)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglReleaseVideoCaptureDeviceNV),reinterpret_cast<void (*)()>(wglReleaseVideoCaptureDeviceNV),"wglReleaseVideoCaptureDeviceNV");
    return _driver.call(&_driver.wglReleaseVideoCaptureDeviceNV)(hDC, hDevice);
  }

// WGL_NV_video_output

  static BOOL REGAL_CALL wglBindVideoImageNV(HPVIDEODEV hVideoDevice, HPBUFFERARB hPbuffer, int iVideoBuffer)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglBindVideoImageNV),reinterpret_cast<void (*)()>(wglBindVideoImageNV),"wglBindVideoImageNV");
    return _driver.call(&_driver.wglBindVideoImageNV)(hVideoDevice, hPbuffer, iVideoBuffer);
  }

  static BOOL REGAL_CALL wglGetVideoDeviceNV(HDC hDC, int numDevices, HPVIDEODEV *hVideoDevice)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglGetVideoDeviceNV),reinterpret_cast<void (*)()>(wglGetVideoDeviceNV),"wglGetVideoDeviceNV");
    return _driver.call(&_driver.wglGetVideoDeviceNV)(hDC, numDevices, hVideoDevice);
  }

  static BOOL REGAL_CALL wglGetVideoInfoNV(HPVIDEODEV hpVideoDevice, unsigned long *pulCounterOutputPbuffer, unsigned long *pulCounterOutputVideo)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglGetVideoInfoNV),reinterpret_cast<void (*)()>(wglGetVideoInfoNV),"wglGetVideoInfoNV");
    return _driver.call(&_driver.wglGetVideoInfoNV)(hpVideoDevice, pulCounterOutputPbuffer, pulCounterOutputVideo);
  }

  static BOOL REGAL_CALL wglReleaseVideoDeviceNV(HPVIDEODEV hVideoDevice)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglReleaseVideoDeviceNV),reinterpret_cast<void (*)()>(wglReleaseVideoDeviceNV),"wglReleaseVideoDeviceNV");
    return _driver.call(&_driver.wglReleaseVideoDeviceNV)(hVideoDevice);
  }

  static BOOL REGAL_CALL wglReleaseVideoImageNV(HPBUFFERARB hPbuffer, int iVideoBuffer)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglReleaseVideoImageNV),reinterpret_cast<void (*)()>(wglReleaseVideoImageNV),"wglReleaseVideoImageNV");
    return _driver.call(&_driver.wglReleaseVideoImageNV)(hPbuffer, iVideoBuffer);
  }

  static BOOL REGAL_CALL wglSendPbufferToVideoNV(HPBUFFERARB hPbuffer, int iBufferType, unsigned long *pulCounterPbuffer, BOOL bBlock)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglSendPbufferToVideoNV),reinterpret_cast<void (*)()>(wglSendPbufferToVideoNV),"wglSendPbufferToVideoNV");
    return _driver.call(&_driver.wglSendPbufferToVideoNV)(hPbuffer, iBufferType, pulCounterPbuffer, bBlock);
  }

// WGL_OML_sync_control

  static BOOL REGAL_CALL wglGetMscRateOML(HDC hDC, INT32 *numerator, INT32 *denominator)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglGetMscRateOML),reinterpret_cast<void (*)()>(wglGetMscRateOML),"wglGetMscRateOML");
    return _driver.call(&_driver.wglGetMscRateOML)(hDC, numerator, denominator);
  }

  static BOOL REGAL_CALL wglGetSyncValuesOML(HDC hDC, INT64 *ust, INT64 *msc, INT64 *sbc)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglGetSyncValuesOML),reinterpret_cast<void (*)()>(wglGetSyncValuesOML),"wglGetSyncValuesOML");
    return _driver.call(&_driver.wglGetSyncValuesOML)(hDC, ust, msc, sbc);
  }

  static INT64 REGAL_CALL wglSwapBuffersMscOML(HDC hDC, INT64 target_msc, INT64 divisor, INT64 remainder)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglSwapBuffersMscOML),reinterpret_cast<void (*)()>(wglSwapBuffersMscOML),"wglSwapBuffersMscOML");
    return _driver.call(&_driver.wglSwapBuffersMscOML)(hDC, target_msc, divisor, remainder);
  }

  static INT64 REGAL_CALL wglSwapLayerBuffersMscOML(HDC hDC, int fuPlanes, INT64 target_msc, INT64 divisor, INT64 remainder)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglSwapLayerBuffersMscOML),reinterpret_cast<void (*)()>(wglSwapLayerBuffersMscOML),"wglSwapLayerBuffersMscOML");
    return _driver.call(&_driver.wglSwapLayerBuffersMscOML)(hDC, fuPlanes, target_msc, divisor, remainder);
  }

  static BOOL REGAL_CALL wglWaitForMscOML(HDC hDC, INT64 target_msc, INT64 divisor, INT64 remainder, INT64 *ust, INT64 *msc, INT64 *sbc)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglWaitForMscOML),reinterpret_cast<void (*)()>(wglWaitForMscOML),"wglWaitForMscOML");
    return _driver.call(&_driver.wglWaitForMscOML)(hDC, target_msc, divisor, remainder, ust, msc, sbc);
  }

  static BOOL REGAL_CALL wglWaitForSbcOML(HDC hDC, INT64 target_sbc, INT64 *ust, INT64 *msc, INT64 *sbc)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglWaitForSbcOML),reinterpret_cast<void (*)()>(wglWaitForSbcOML),"wglWaitForSbcOML");
    return _driver.call(&_driver.wglWaitForSbcOML)(hDC, target_sbc, ust, msc, sbc);
  }

// WGL_core

  static BOOL REGAL_CALL wglCopyContext(HGLRC hglrcSrc, HGLRC hglrcDst, UINT mask)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglCopyContext),reinterpret_cast<void (*)()>(wglCopyContext),"wglCopyContext");
    return _driver.call(&_driver.wglCopyContext)(hglrcSrc, hglrcDst, mask);
  }

  static HGLRC REGAL_CALL wglCreateContext(HDC hDC)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglCreateContext),reinterpret_cast<void (*)()>(wglCreateContext),"wglCreateContext");
    return _driver.call(&_driver.wglCreateContext)(hDC);
  }

  static HGLRC REGAL_CALL wglCreateLayerContext(HDC hDC, int iLayerPlane)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglCreateLayerContext),reinterpret_cast<void (*)()>(wglCreateLayerContext),"wglCreateLayerContext");
    return _driver.call(&_driver.wglCreateLayerContext)(hDC, iLayerPlane);
  }

  static BOOL REGAL_CALL wglDeleteContext(HGLRC hglrc)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglDeleteContext),reinterpret_cast<void (*)()>(wglDeleteContext),"wglDeleteContext");
    return _driver.call(&_driver.wglDeleteContext)(hglrc);
  }

  static BOOL REGAL_CALL wglDescribeLayerPlane(HDC hDC, int iPixelFormat, int iLayerPlane, UINT nBytes, LPLAYERPLANEDESCRIPTOR plpd)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglDescribeLayerPlane),reinterpret_cast<void (*)()>(wglDescribeLayerPlane),"wglDescribeLayerPlane");
    return _driver.call(&_driver.wglDescribeLayerPlane)(hDC, iPixelFormat, iLayerPlane, nBytes, plpd);
  }

  static HGLRC REGAL_CALL wglGetCurrentContext(void)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglGetCurrentContext),reinterpret_cast<void (*)()>(wglGetCurrentContext),"wglGetCurrentContext");
    return _driver.call(&_driver.wglGetCurrentContext)();
  }

  static HDC REGAL_CALL wglGetCurrentDC(void)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglGetCurrentDC),reinterpret_cast<void (*)()>(wglGetCurrentDC),"wglGetCurrentDC");
    return _driver.call(&_driver.wglGetCurrentDC)();
  }

  static PROC REGAL_CALL wglGetDefaultProcAddress(LPCSTR lpszProc)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglGetDefaultProcAddress),reinterpret_cast<void (*)()>(wglGetDefaultProcAddress),"wglGetDefaultProcAddress");
    return _driver.call(&_driver.wglGetDefaultProcAddress)(lpszProc);
  }

  static int REGAL_CALL wglGetLayerPaletteEntries(HDC hDC, int iLayerPlane, int iStart, int nEntries, COLORREF *pcr)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglGetLayerPaletteEntries),reinterpret_cast<void (*)()>(wglGetLayerPaletteEntries),"wglGetLayerPaletteEntries");
    return _driver.call(&_driver.wglGetLayerPaletteEntries)(hDC, iLayerPlane, iStart, nEntries, pcr);
  }

  static PROC REGAL_CALL wglGetProcAddress(LPCSTR lpszProc)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglGetProcAddress),reinterpret_cast<void (*)()>(wglGetProcAddress),"wglGetProcAddress");
    return _driver.call(&_driver.wglGetProcAddress)(lpszProc);
  }

  static BOOL REGAL_CALL wglMakeCurrent(HDC hDC, HGLRC hglrc)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglMakeCurrent),reinterpret_cast<void (*)()>(wglMakeCurrent),"wglMakeCurrent");
    return _driver.call(&_driver.wglMakeCurrent)(hDC, hglrc);
  }

  static BOOL REGAL_CALL wglRealizeLayerPalette(HDC hDC, int iLayerPlane, BOOL bRealize)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglRealizeLayerPalette),reinterpret_cast<void (*)()>(wglRealizeLayerPalette),"wglRealizeLayerPalette");
    return _driver.call(&_driver.wglRealizeLayerPalette)(hDC, iLayerPlane, bRealize);
  }

  static int REGAL_CALL wglSetLayerPaletteEntries(HDC hDC, int iLayerPlane, int iStart, int nEntries, const COLORREF *pcr)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglSetLayerPaletteEntries),reinterpret_cast<void (*)()>(wglSetLayerPaletteEntries),"wglSetLayerPaletteEntries");
    return _driver.call(&_driver.wglSetLayerPaletteEntries)(hDC, iLayerPlane, iStart, nEntries, pcr);
  }

  static BOOL REGAL_CALL wglShareLists(HGLRC hglrcShare, HGLRC hglrcSrc)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglShareLists),reinterpret_cast<void (*)()>(wglShareLists),"wglShareLists");
    return _driver.call(&_driver.wglShareLists)(hglrcShare, hglrcSrc);
  }

  static BOOL REGAL_CALL wglSwapLayerBuffers(HDC hDC, UINT fuPlanes)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglSwapLayerBuffers),reinterpret_cast<void (*)()>(wglSwapLayerBuffers),"wglSwapLayerBuffers");
    return _driver.call(&_driver.wglSwapLayerBuffers)(hDC, fuPlanes);
  }

  static DWORD REGAL_CALL wglSwapMultipleBuffers(UINT n, const WGLSWAP *ps)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglSwapMultipleBuffers),reinterpret_cast<void (*)()>(wglSwapMultipleBuffers),"wglSwapMultipleBuffers");
    return _driver.call(&_driver.wglSwapMultipleBuffers)(n, ps);
  }

  static BOOL REGAL_CALL wglUseFontBitmapsA(HDC hDC, DWORD first, DWORD count, DWORD listBase)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglUseFontBitmapsA),reinterpret_cast<void (*)()>(wglUseFontBitmapsA),"wglUseFontBitmapsA");
    return _driver.call(&_driver.wglUseFontBitmapsA)(hDC, first, count, listBase);
  }

  static BOOL REGAL_CALL wglUseFontBitmapsW(HDC hDC, DWORD first, DWORD count, DWORD listBase)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglUseFontBitmapsW),reinterpret_cast<void (*)()>(wglUseFontBitmapsW),"wglUseFontBitmapsW");
    return _driver.call(&_driver.wglUseFontBitmapsW)(hDC, first, count, listBase);
  }

  static BOOL REGAL_CALL wglUseFontOutlinesA(HDC hDC, DWORD first, DWORD count, DWORD listBase, FLOAT deviation, FLOAT extrusion, int format, LPGLYPHMETRICSFLOAT lpgmf)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglUseFontOutlinesA),reinterpret_cast<void (*)()>(wglUseFontOutlinesA),"wglUseFontOutlinesA");
    return _driver.call(&_driver.wglUseFontOutlinesA)(hDC, first, count, listBase, deviation, extrusion, format, lpgmf);
  }

  static BOOL REGAL_CALL wglUseFontOutlinesW(HDC hDC, DWORD first, DWORD count, DWORD listBase, FLOAT deviation, FLOAT extrusion, int format, LPGLYPHMETRICSFLOAT lpgmf)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.wglUseFontOutlinesW),reinterpret_cast<void (*)()>(wglUseFontOutlinesW),"wglUseFontOutlinesW");
    return _driver.call(&_driver.wglUseFontOutlinesW)(hDC, first, count, listBase, deviation, extrusion, format, lpgmf);
  }

#endif // REGAL_SYS_WGL

#if REGAL_SYS_GLX

// GLX_VERSION_1_0

  static XVisualInfo *REGAL_CALL glXChooseVisual(Display *dpy, int screen, int *attribList)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXChooseVisual),reinterpret_cast<void (*)()>(glXChooseVisual),"glXChooseVisual");
    return _driver.call(&_driver.glXChooseVisual)(dpy, screen, attribList);
  }

  static void REGAL_CALL glXCopyContext(Display *dpy, GLXContext src, GLXContext dst, unsigned long mask)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXCopyContext),reinterpret_cast<void (*)()>(glXCopyContext),"glXCopyContext");
    _driver.call(&_driver.glXCopyContext)(dpy, src, dst, mask);
  }

  static GLXContext REGAL_CALL glXCreateContext(Display *dpy, XVisualInfo *vis, GLXContext shareList, Bool direct)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXCreateContext),reinterpret_cast<void (*)()>(glXCreateContext),"glXCreateContext");
    return _driver.call(&_driver.glXCreateContext)(dpy, vis, shareList, direct);
  }

  static GLXPixmap REGAL_CALL glXCreateGLXPixmap(Display *dpy, XVisualInfo *vis, Pixmap pixmap)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXCreateGLXPixmap),reinterpret_cast<void (*)()>(glXCreateGLXPixmap),"glXCreateGLXPixmap");
    return _driver.call(&_driver.glXCreateGLXPixmap)(dpy, vis, pixmap);
  }

  static void REGAL_CALL glXDestroyContext(Display *dpy, GLXContext ctx)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXDestroyContext),reinterpret_cast<void (*)()>(glXDestroyContext),"glXDestroyContext");
    _driver.call(&_driver.glXDestroyContext)(dpy, ctx);
  }

  static void REGAL_CALL glXDestroyGLXPixmap(Display *dpy, GLXPixmap pix)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXDestroyGLXPixmap),reinterpret_cast<void (*)()>(glXDestroyGLXPixmap),"glXDestroyGLXPixmap");
    _driver.call(&_driver.glXDestroyGLXPixmap)(dpy, pix);
  }

  static int REGAL_CALL glXGetConfig(Display *dpy, XVisualInfo *vis, int attrib, int *value)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXGetConfig),reinterpret_cast<void (*)()>(glXGetConfig),"glXGetConfig");
    return _driver.call(&_driver.glXGetConfig)(dpy, vis, attrib, value);
  }

  static GLXContext REGAL_CALL glXGetCurrentContext(void)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXGetCurrentContext),reinterpret_cast<void (*)()>(glXGetCurrentContext),"glXGetCurrentContext");
    return _driver.call(&_driver.glXGetCurrentContext)();
  }

  static GLXDrawable REGAL_CALL glXGetCurrentDrawable(void)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXGetCurrentDrawable),reinterpret_cast<void (*)()>(glXGetCurrentDrawable),"glXGetCurrentDrawable");
    return _driver.call(&_driver.glXGetCurrentDrawable)();
  }

  static Bool REGAL_CALL glXIsDirect(Display *dpy, GLXContext ctx)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXIsDirect),reinterpret_cast<void (*)()>(glXIsDirect),"glXIsDirect");
    return _driver.call(&_driver.glXIsDirect)(dpy, ctx);
  }

  static Bool REGAL_CALL glXMakeCurrent(Display *dpy, GLXDrawable drawable, GLXContext ctx)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXMakeCurrent),reinterpret_cast<void (*)()>(glXMakeCurrent),"glXMakeCurrent");
    return _driver.call(&_driver.glXMakeCurrent)(dpy, drawable, ctx);
  }

  static Bool REGAL_CALL glXQueryExtension(Display *dpy, int *errorBase, int *eventBase)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXQueryExtension),reinterpret_cast<void (*)()>(glXQueryExtension),"glXQueryExtension");
    return _driver.call(&_driver.glXQueryExtension)(dpy, errorBase, eventBase);
  }

  static Bool REGAL_CALL glXQueryVersion(Display *dpy, int *major, int *minor)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXQueryVersion),reinterpret_cast<void (*)()>(glXQueryVersion),"glXQueryVersion");
    return _driver.call(&_driver.glXQueryVersion)(dpy, major, minor);
  }

  static void REGAL_CALL glXSwapBuffers(Display *dpy, GLXDrawable drawable)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXSwapBuffers),reinterpret_cast<void (*)()>(glXSwapBuffers),"glXSwapBuffers");
    _driver.call(&_driver.glXSwapBuffers)(dpy, drawable);
  }

  static void REGAL_CALL glXUseXFont(Font font, int first, int count, int listBase)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXUseXFont),reinterpret_cast<void (*)()>(glXUseXFont),"glXUseXFont");
    _driver.call(&_driver.glXUseXFont)(font, first, count, listBase);
  }

  static void REGAL_CALL glXWaitGL(void)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXWaitGL),reinterpret_cast<void (*)()>(glXWaitGL),"glXWaitGL");
    _driver.call(&_driver.glXWaitGL)();
  }

  static void REGAL_CALL glXWaitX(void)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXWaitX),reinterpret_cast<void (*)()>(glXWaitX),"glXWaitX");
    _driver.call(&_driver.glXWaitX)();
  }

// GLX_VERSION_1_1

  static const char *REGAL_CALL glXGetClientString(Display *dpy, int name)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXGetClientString),reinterpret_cast<void (*)()>(glXGetClientString),"glXGetClientString");
    return _driver.call(&_driver.glXGetClientString)(dpy, name);
  }

  static const char *REGAL_CALL glXQueryExtensionsString(Display *dpy, int screen)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXQueryExtensionsString),reinterpret_cast<void (*)()>(glXQueryExtensionsString),"glXQueryExtensionsString");
    return _driver.call(&_driver.glXQueryExtensionsString)(dpy, screen);
  }

  static const char *REGAL_CALL glXQueryServerString(Display *dpy, int screen, int name)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXQueryServerString),reinterpret_cast<void (*)()>(glXQueryServerString),"glXQueryServerString");
    return _driver.call(&_driver.glXQueryServerString)(dpy, screen, name);
  }

// GLX_VERSION_1_2

  static Display *REGAL_CALL glXGetCurrentDisplay(void)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXGetCurrentDisplay),reinterpret_cast<void (*)()>(glXGetCurrentDisplay),"glXGetCurrentDisplay");
    return _driver.call(&_driver.glXGetCurrentDisplay)();
  }

// GLX_VERSION_1_3

  static GLXFBConfig *REGAL_CALL glXChooseFBConfig(Display *dpy, int screen, const int *attrib_list, int *nelements)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXChooseFBConfig),reinterpret_cast<void (*)()>(glXChooseFBConfig),"glXChooseFBConfig");
    return _driver.call(&_driver.glXChooseFBConfig)(dpy, screen, attrib_list, nelements);
  }

  static GLXContext REGAL_CALL glXCreateNewContext(Display *dpy, GLXFBConfig config, int render_type, GLXContext share_list, Bool direct)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXCreateNewContext),reinterpret_cast<void (*)()>(glXCreateNewContext),"glXCreateNewContext");
    return _driver.call(&_driver.glXCreateNewContext)(dpy, config, render_type, share_list, direct);
  }

  static GLXPbuffer REGAL_CALL glXCreatePbuffer(Display *dpy, GLXFBConfig config, const int *attrib_list)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXCreatePbuffer),reinterpret_cast<void (*)()>(glXCreatePbuffer),"glXCreatePbuffer");
    return _driver.call(&_driver.glXCreatePbuffer)(dpy, config, attrib_list);
  }

  static GLXPixmap REGAL_CALL glXCreatePixmap(Display *dpy, GLXFBConfig config, Pixmap pixmap, const int *attrib_list)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXCreatePixmap),reinterpret_cast<void (*)()>(glXCreatePixmap),"glXCreatePixmap");
    return _driver.call(&_driver.glXCreatePixmap)(dpy, config, pixmap, attrib_list);
  }

  static GLXWindow REGAL_CALL glXCreateWindow(Display *dpy, GLXFBConfig config, Window win, const int *attrib_list)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXCreateWindow),reinterpret_cast<void (*)()>(glXCreateWindow),"glXCreateWindow");
    return _driver.call(&_driver.glXCreateWindow)(dpy, config, win, attrib_list);
  }

  static void REGAL_CALL glXDestroyPbuffer(Display *dpy, GLXPbuffer pbuf)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXDestroyPbuffer),reinterpret_cast<void (*)()>(glXDestroyPbuffer),"glXDestroyPbuffer");
    _driver.call(&_driver.glXDestroyPbuffer)(dpy, pbuf);
  }

  static void REGAL_CALL glXDestroyPixmap(Display *dpy, GLXPixmap pixmap)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXDestroyPixmap),reinterpret_cast<void (*)()>(glXDestroyPixmap),"glXDestroyPixmap");
    _driver.call(&_driver.glXDestroyPixmap)(dpy, pixmap);
  }

  static void REGAL_CALL glXDestroyWindow(Display *dpy, GLXWindow win)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXDestroyWindow),reinterpret_cast<void (*)()>(glXDestroyWindow),"glXDestroyWindow");
    _driver.call(&_driver.glXDestroyWindow)(dpy, win);
  }

  static GLXDrawable REGAL_CALL glXGetCurrentReadDrawable(void)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXGetCurrentReadDrawable),reinterpret_cast<void (*)()>(glXGetCurrentReadDrawable),"glXGetCurrentReadDrawable");
    return _driver.call(&_driver.glXGetCurrentReadDrawable)();
  }

  static int REGAL_CALL glXGetFBConfigAttrib(Display *dpy, GLXFBConfig config, int attribute, int *value)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXGetFBConfigAttrib),reinterpret_cast<void (*)()>(glXGetFBConfigAttrib),"glXGetFBConfigAttrib");
    return _driver.call(&_driver.glXGetFBConfigAttrib)(dpy, config, attribute, value);
  }

  static GLXFBConfig *REGAL_CALL glXGetFBConfigs(Display *dpy, int screen, int *nelements)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXGetFBConfigs),reinterpret_cast<void (*)()>(glXGetFBConfigs),"glXGetFBConfigs");
    return _driver.call(&_driver.glXGetFBConfigs)(dpy, screen, nelements);
  }

  static void REGAL_CALL glXGetSelectedEvent(Display *dpy, GLXDrawable draw, unsigned long *event_mask)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXGetSelectedEvent),reinterpret_cast<void (*)()>(glXGetSelectedEvent),"glXGetSelectedEvent");
    _driver.call(&_driver.glXGetSelectedEvent)(dpy, draw, event_mask);
  }

  static XVisualInfo *REGAL_CALL glXGetVisualFromFBConfig(Display *dpy, GLXFBConfig config)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXGetVisualFromFBConfig),reinterpret_cast<void (*)()>(glXGetVisualFromFBConfig),"glXGetVisualFromFBConfig");
    return _driver.call(&_driver.glXGetVisualFromFBConfig)(dpy, config);
  }

  static Bool REGAL_CALL glXMakeContextCurrent(Display *display, GLXDrawable draw, GLXDrawable read, GLXContext ctx)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXMakeContextCurrent),reinterpret_cast<void (*)()>(glXMakeContextCurrent),"glXMakeContextCurrent");
    return _driver.call(&_driver.glXMakeContextCurrent)(display, draw, read, ctx);
  }

  static int REGAL_CALL glXQueryContext(Display *dpy, GLXContext ctx, int attribute, int *value)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXQueryContext),reinterpret_cast<void (*)()>(glXQueryContext),"glXQueryContext");
    return _driver.call(&_driver.glXQueryContext)(dpy, ctx, attribute, value);
  }

  static void REGAL_CALL glXQueryDrawable(Display *dpy, GLXDrawable draw, int attribute, unsigned int *value)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXQueryDrawable),reinterpret_cast<void (*)()>(glXQueryDrawable),"glXQueryDrawable");
    _driver.call(&_driver.glXQueryDrawable)(dpy, draw, attribute, value);
  }

  static void REGAL_CALL glXSelectEvent(Display *dpy, GLXDrawable draw, unsigned long event_mask)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXSelectEvent),reinterpret_cast<void (*)()>(glXSelectEvent),"glXSelectEvent");
    _driver.call(&_driver.glXSelectEvent)(dpy, draw, event_mask);
  }

// GLX_VERSION_1_4

  static __GLXextFuncPtr REGAL_CALL glXGetProcAddress(const GLubyte *procName)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXGetProcAddress),reinterpret_cast<void (*)()>(glXGetProcAddress),"glXGetProcAddress");
    return _driver.call(&_driver.glXGetProcAddress)(procName);
  }

// GLX_AMD_gpu_association

  static void REGAL_CALL glXBlitContextFramebufferAMD(GLXContext dstCtx, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXBlitContextFramebufferAMD),reinterpret_cast<void (*)()>(glXBlitContextFramebufferAMD),"glXBlitContextFramebufferAMD");
    _driver.call(&_driver.glXBlitContextFramebufferAMD)(dstCtx, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
  }

  static GLXContext REGAL_CALL glXCreateAssociatedContextAMD(unsigned int id, GLXContext share_list)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXCreateAssociatedContextAMD),reinterpret_cast<void (*)()>(glXCreateAssociatedContextAMD),"glXCreateAssociatedContextAMD");
    return _driver.call(&_driver.glXCreateAssociatedContextAMD)(id, share_list);
  }

  static GLXContext REGAL_CALL glXCreateAssociatedContextAttribsAMD(unsigned int id, GLXContext share_context, const int *attribList)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXCreateAssociatedContextAttribsAMD),reinterpret_cast<void (*)()>(glXCreateAssociatedContextAttribsAMD),"glXCreateAssociatedContextAttribsAMD");
    return _driver.call(&_driver.glXCreateAssociatedContextAttribsAMD)(id, share_context, attribList);
  }

  static Bool REGAL_CALL glXDeleteAssociatedContextAMD(GLXContext ctx)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXDeleteAssociatedContextAMD),reinterpret_cast<void (*)()>(glXDeleteAssociatedContextAMD),"glXDeleteAssociatedContextAMD");
    return _driver.call(&_driver.glXDeleteAssociatedContextAMD)(ctx);
  }

  static unsigned int REGAL_CALL glXGetContextGPUIDAMD(GLXContext ctx)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXGetContextGPUIDAMD),reinterpret_cast<void (*)()>(glXGetContextGPUIDAMD),"glXGetContextGPUIDAMD");
    return _driver.call(&_driver.glXGetContextGPUIDAMD)(ctx);
  }

  static GLXContext REGAL_CALL glXGetCurrentAssociatedContextAMD(void)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXGetCurrentAssociatedContextAMD),reinterpret_cast<void (*)()>(glXGetCurrentAssociatedContextAMD),"glXGetCurrentAssociatedContextAMD");
    return _driver.call(&_driver.glXGetCurrentAssociatedContextAMD)();
  }

  static unsigned int REGAL_CALL glXGetGPUIDsAMD(unsigned int maxCount, unsigned int *ids)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXGetGPUIDsAMD),reinterpret_cast<void (*)()>(glXGetGPUIDsAMD),"glXGetGPUIDsAMD");
    return _driver.call(&_driver.glXGetGPUIDsAMD)(maxCount, ids);
  }

  static int REGAL_CALL glXGetGPUInfoAMD(unsigned int id, int property, GLenum dataType, unsigned int size, GLvoid *data)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXGetGPUInfoAMD),reinterpret_cast<void (*)()>(glXGetGPUInfoAMD),"glXGetGPUInfoAMD");
    return _driver.call(&_driver.glXGetGPUInfoAMD)(id, property, dataType, size, data);
  }

  static Bool REGAL_CALL glXMakeAssociatedContextCurrentAMD(GLXContext ctx)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXMakeAssociatedContextCurrentAMD),reinterpret_cast<void (*)()>(glXMakeAssociatedContextCurrentAMD),"glXMakeAssociatedContextCurrentAMD");
    return _driver.call(&_driver.glXMakeAssociatedContextCurrentAMD)(ctx);
  }

// GLX_ARB_create_context

  static GLXContext REGAL_CALL glXCreateContextAttribsARB(Display *dpy, GLXFBConfig config, GLXContext share_context, Bool direct, const int *attrib_list)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXCreateContextAttribsARB),reinterpret_cast<void (*)()>(glXCreateContextAttribsARB),"glXCreateContextAttribsARB");
    return _driver.call(&_driver.glXCreateContextAttribsARB)(dpy, config, share_context, direct, attrib_list);
  }

// GLX_ARB_get_proc_address

  static __GLXextFuncPtr REGAL_CALL glXGetProcAddressARB(const GLubyte *procName)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXGetProcAddressARB),reinterpret_cast<void (*)()>(glXGetProcAddressARB),"glXGetProcAddressARB");
    return _driver.call(&_driver.glXGetProcAddressARB)(procName);
  }

// GLX_ATI_render_texture

  static void REGAL_CALL glXBindTexImageATI(Display *dpy, GLXPbuffer pbuf, int buffer)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXBindTexImageATI),reinterpret_cast<void (*)()>(glXBindTexImageATI),"glXBindTexImageATI");
    _driver.call(&_driver.glXBindTexImageATI)(dpy, pbuf, buffer);
  }

  static void REGAL_CALL glXDrawableAttribATI(Display *dpy, GLXDrawable draw, const int *attrib_list)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXDrawableAttribATI),reinterpret_cast<void (*)()>(glXDrawableAttribATI),"glXDrawableAttribATI");
    _driver.call(&_driver.glXDrawableAttribATI)(dpy, draw, attrib_list);
  }

  static void REGAL_CALL glXReleaseTexImageATI(Display *dpy, GLXPbuffer pbuf, int buffer)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXReleaseTexImageATI),reinterpret_cast<void (*)()>(glXReleaseTexImageATI),"glXReleaseTexImageATI");
    _driver.call(&_driver.glXReleaseTexImageATI)(dpy, pbuf, buffer);
  }

// GLX_EXT_import_context

  static void REGAL_CALL glXFreeContextEXT(Display *dpy, GLXContext context)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXFreeContextEXT),reinterpret_cast<void (*)()>(glXFreeContextEXT),"glXFreeContextEXT");
    _driver.call(&_driver.glXFreeContextEXT)(dpy, context);
  }

  static GLXContextID REGAL_CALL glXGetContextIDEXT(const GLXContext context)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXGetContextIDEXT),reinterpret_cast<void (*)()>(glXGetContextIDEXT),"glXGetContextIDEXT");
    return _driver.call(&_driver.glXGetContextIDEXT)(context);
  }

  static GLXContext REGAL_CALL glXImportContextEXT(Display *dpy, GLXContextID contextID)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXImportContextEXT),reinterpret_cast<void (*)()>(glXImportContextEXT),"glXImportContextEXT");
    return _driver.call(&_driver.glXImportContextEXT)(dpy, contextID);
  }

  static int REGAL_CALL glXQueryContextInfoEXT(Display *dpy, GLXContext context, int attribute, int *value)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXQueryContextInfoEXT),reinterpret_cast<void (*)()>(glXQueryContextInfoEXT),"glXQueryContextInfoEXT");
    return _driver.call(&_driver.glXQueryContextInfoEXT)(dpy, context, attribute, value);
  }

// GLX_EXT_swap_control

  static void REGAL_CALL glXSwapIntervalEXT(Display *dpy, GLXDrawable drawable, int interval)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXSwapIntervalEXT),reinterpret_cast<void (*)()>(glXSwapIntervalEXT),"glXSwapIntervalEXT");
    _driver.call(&_driver.glXSwapIntervalEXT)(dpy, drawable, interval);
  }

// GLX_EXT_texture_from_pixmap

  static void REGAL_CALL glXBindTexImageEXT(Display *display, GLXDrawable drawable, int buffer, const int *attrib_list)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXBindTexImageEXT),reinterpret_cast<void (*)()>(glXBindTexImageEXT),"glXBindTexImageEXT");
    _driver.call(&_driver.glXBindTexImageEXT)(display, drawable, buffer, attrib_list);
  }

  static void REGAL_CALL glXReleaseTexImageEXT(Display *display, GLXDrawable drawable, int buffer)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXReleaseTexImageEXT),reinterpret_cast<void (*)()>(glXReleaseTexImageEXT),"glXReleaseTexImageEXT");
    _driver.call(&_driver.glXReleaseTexImageEXT)(display, drawable, buffer);
  }

// GLX_MESA_agp_offset

  static unsigned int REGAL_CALL glXGetAGPOffsetMESA(const void *pointer)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXGetAGPOffsetMESA),reinterpret_cast<void (*)()>(glXGetAGPOffsetMESA),"glXGetAGPOffsetMESA");
    return _driver.call(&_driver.glXGetAGPOffsetMESA)(pointer);
  }

// GLX_MESA_copy_sub_buffer

  static void REGAL_CALL glXCopySubBufferMESA(Display *dpy, GLXDrawable drawable, int x, int y, int width, int height)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXCopySubBufferMESA),reinterpret_cast<void (*)()>(glXCopySubBufferMESA),"glXCopySubBufferMESA");
    _driver.call(&_driver.glXCopySubBufferMESA)(dpy, drawable, x, y, width, height);
  }

// GLX_MESA_pixmap_colormap

  static GLXPixmap REGAL_CALL glXCreateGLXPixmapMESA(Display *dpy, XVisualInfo *visual, Pixmap pixmap, Colormap cmap)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXCreateGLXPixmapMESA),reinterpret_cast<void (*)()>(glXCreateGLXPixmapMESA),"glXCreateGLXPixmapMESA");
    return _driver.call(&_driver.glXCreateGLXPixmapMESA)(dpy, visual, pixmap, cmap);
  }

// GLX_MESA_release_buffers

  static Bool REGAL_CALL glXReleaseBuffersMESA(Display *dpy, GLXDrawable d)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXReleaseBuffersMESA),reinterpret_cast<void (*)()>(glXReleaseBuffersMESA),"glXReleaseBuffersMESA");
    return _driver.call(&_driver.glXReleaseBuffersMESA)(dpy, d);
  }

// GLX_MESA_set_3dfx_mode

  static GLboolean REGAL_CALL glXSet3DfxModeMESA(GLint mode)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXSet3DfxModeMESA),reinterpret_cast<void (*)()>(glXSet3DfxModeMESA),"glXSet3DfxModeMESA");
    return _driver.call(&_driver.glXSet3DfxModeMESA)(mode);
  }

// GLX_MESA_swap_control

  static int REGAL_CALL glXGetSwapIntervalMESA(void)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXGetSwapIntervalMESA),reinterpret_cast<void (*)()>(glXGetSwapIntervalMESA),"glXGetSwapIntervalMESA");
    return _driver.call(&_driver.glXGetSwapIntervalMESA)();
  }

  static int REGAL_CALL glXSwapIntervalMESA(unsigned int interval)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXSwapIntervalMESA),reinterpret_cast<void (*)()>(glXSwapIntervalMESA),"glXSwapIntervalMESA");
    return _driver.call(&_driver.glXSwapIntervalMESA)(interval);
  }

// GLX_NV_copy_image

  static void REGAL_CALL glXCopyImageSubDataNV(Display *dpy, GLXContext srcCtx, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLXContext dstCtx, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXCopyImageSubDataNV),reinterpret_cast<void (*)()>(glXCopyImageSubDataNV),"glXCopyImageSubDataNV");
    _driver.call(&_driver.glXCopyImageSubDataNV)(dpy, srcCtx, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstCtx, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
  }

// GLX_NV_present_video

  static int REGAL_CALL glXBindVideoDeviceNV(Display *dpy, unsigned int video_slot, unsigned int video_device, const int *attrib_list)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXBindVideoDeviceNV),reinterpret_cast<void (*)()>(glXBindVideoDeviceNV),"glXBindVideoDeviceNV");
    return _driver.call(&_driver.glXBindVideoDeviceNV)(dpy, video_slot, video_device, attrib_list);
  }

  static unsigned int *REGAL_CALL glXEnumerateVideoDevicesNV(Display *dpy, int screen, int *nelements)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXEnumerateVideoDevicesNV),reinterpret_cast<void (*)()>(glXEnumerateVideoDevicesNV),"glXEnumerateVideoDevicesNV");
    return _driver.call(&_driver.glXEnumerateVideoDevicesNV)(dpy, screen, nelements);
  }

// GLX_NV_swap_group

  static Bool REGAL_CALL glXBindSwapBarrierNV(Display *dpy, GLuint group, GLuint barrier)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXBindSwapBarrierNV),reinterpret_cast<void (*)()>(glXBindSwapBarrierNV),"glXBindSwapBarrierNV");
    return _driver.call(&_driver.glXBindSwapBarrierNV)(dpy, group, barrier);
  }

  static Bool REGAL_CALL glXJoinSwapGroupNV(Display *dpy, GLXDrawable drawable, GLuint group)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXJoinSwapGroupNV),reinterpret_cast<void (*)()>(glXJoinSwapGroupNV),"glXJoinSwapGroupNV");
    return _driver.call(&_driver.glXJoinSwapGroupNV)(dpy, drawable, group);
  }

  static Bool REGAL_CALL glXQueryFrameCountNV(Display *dpy, int screen, GLuint *count)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXQueryFrameCountNV),reinterpret_cast<void (*)()>(glXQueryFrameCountNV),"glXQueryFrameCountNV");
    return _driver.call(&_driver.glXQueryFrameCountNV)(dpy, screen, count);
  }

  static Bool REGAL_CALL glXQueryMaxSwapGroupsNV(Display *dpy, int screen, GLuint *maxGroups, GLuint *maxBarriers)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXQueryMaxSwapGroupsNV),reinterpret_cast<void (*)()>(glXQueryMaxSwapGroupsNV),"glXQueryMaxSwapGroupsNV");
    return _driver.call(&_driver.glXQueryMaxSwapGroupsNV)(dpy, screen, maxGroups, maxBarriers);
  }

  static Bool REGAL_CALL glXQuerySwapGroupNV(Display *dpy, GLXDrawable drawable, GLuint *group, GLuint *barrier)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXQuerySwapGroupNV),reinterpret_cast<void (*)()>(glXQuerySwapGroupNV),"glXQuerySwapGroupNV");
    return _driver.call(&_driver.glXQuerySwapGroupNV)(dpy, drawable, group, barrier);
  }

  static Bool REGAL_CALL glXResetFrameCountNV(Display *dpy, int screen)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXResetFrameCountNV),reinterpret_cast<void (*)()>(glXResetFrameCountNV),"glXResetFrameCountNV");
    return _driver.call(&_driver.glXResetFrameCountNV)(dpy, screen);
  }

// GLX_NV_vertex_array_range

  static void *REGAL_CALL glXAllocateMemoryNV(GLsizei size, GLfloat readFrequency, GLfloat writeFrequency, GLfloat priority)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXAllocateMemoryNV),reinterpret_cast<void (*)()>(glXAllocateMemoryNV),"glXAllocateMemoryNV");
    return _driver.call(&_driver.glXAllocateMemoryNV)(size, readFrequency, writeFrequency, priority);
  }

  static void REGAL_CALL glXFreeMemoryNV(void *pointer)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXFreeMemoryNV),reinterpret_cast<void (*)()>(glXFreeMemoryNV),"glXFreeMemoryNV");
    _driver.call(&_driver.glXFreeMemoryNV)(pointer);
  }

// GLX_NV_video_capture

  static int REGAL_CALL glXBindVideoCaptureDeviceNV(Display *dpy, unsigned int video_capture_slot, GLXVideoCaptureDeviceNV device)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXBindVideoCaptureDeviceNV),reinterpret_cast<void (*)()>(glXBindVideoCaptureDeviceNV),"glXBindVideoCaptureDeviceNV");
    return _driver.call(&_driver.glXBindVideoCaptureDeviceNV)(dpy, video_capture_slot, device);
  }

  static GLXVideoCaptureDeviceNV *REGAL_CALL glXEnumerateVideoCaptureDevicesNV(Display *dpy, int screen, int *nelements)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXEnumerateVideoCaptureDevicesNV),reinterpret_cast<void (*)()>(glXEnumerateVideoCaptureDevicesNV),"glXEnumerateVideoCaptureDevicesNV");
    return _driver.call(&_driver.glXEnumerateVideoCaptureDevicesNV)(dpy, screen, nelements);
  }

  static void REGAL_CALL glXLockVideoCaptureDeviceNV(Display *dpy, GLXVideoCaptureDeviceNV device)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXLockVideoCaptureDeviceNV),reinterpret_cast<void (*)()>(glXLockVideoCaptureDeviceNV),"glXLockVideoCaptureDeviceNV");
    _driver.call(&_driver.glXLockVideoCaptureDeviceNV)(dpy, device);
  }

  static int REGAL_CALL glXQueryVideoCaptureDeviceNV(Display *dpy, GLXVideoCaptureDeviceNV device, int attribute, int *value)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXQueryVideoCaptureDeviceNV),reinterpret_cast<void (*)()>(glXQueryVideoCaptureDeviceNV),"glXQueryVideoCaptureDeviceNV");
    return _driver.call(&_driver.glXQueryVideoCaptureDeviceNV)(dpy, device, attribute, value);
  }

  static void REGAL_CALL glXReleaseVideoCaptureDeviceNV(Display *dpy, GLXVideoCaptureDeviceNV device)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXReleaseVideoCaptureDeviceNV),reinterpret_cast<void (*)()>(glXReleaseVideoCaptureDeviceNV),"glXReleaseVideoCaptureDeviceNV");
    _driver.call(&_driver.glXReleaseVideoCaptureDeviceNV)(dpy, device);
  }

// GLX_NV_video_output

  static int REGAL_CALL glXBindVideoImageNV(Display *dpy, GLXVideoDeviceNV VideoDevice, GLXPbuffer pbuf, int iVideoBuffer)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXBindVideoImageNV),reinterpret_cast<void (*)()>(glXBindVideoImageNV),"glXBindVideoImageNV");
    return _driver.call(&_driver.glXBindVideoImageNV)(dpy, VideoDevice, pbuf, iVideoBuffer);
  }

  static int REGAL_CALL glXGetVideoDeviceNV(Display *dpy, int screen, int numVideoDevices, GLXVideoDeviceNV *pVideoDevice)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXGetVideoDeviceNV),reinterpret_cast<void (*)()>(glXGetVideoDeviceNV),"glXGetVideoDeviceNV");
    return _driver.call(&_driver.glXGetVideoDeviceNV)(dpy, screen, numVideoDevices, pVideoDevice);
  }

  static int REGAL_CALL glXGetVideoInfoNV(Display *dpy, int screen, GLXVideoDeviceNV VideoDevice, unsigned long *pulCounterOutputPbuffer, unsigned long *pulCounterOutputVideo)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXGetVideoInfoNV),reinterpret_cast<void (*)()>(glXGetVideoInfoNV),"glXGetVideoInfoNV");
    return _driver.call(&_driver.glXGetVideoInfoNV)(dpy, screen, VideoDevice, pulCounterOutputPbuffer, pulCounterOutputVideo);
  }

  static int REGAL_CALL glXReleaseVideoDeviceNV(Display *dpy, int screen, GLXVideoDeviceNV VideoDevice)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXReleaseVideoDeviceNV),reinterpret_cast<void (*)()>(glXReleaseVideoDeviceNV),"glXReleaseVideoDeviceNV");
    return _driver.call(&_driver.glXReleaseVideoDeviceNV)(dpy, screen, VideoDevice);
  }

  static int REGAL_CALL glXReleaseVideoImageNV(Display *dpy, GLXPbuffer pbuf)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXReleaseVideoImageNV),reinterpret_cast<void (*)()>(glXReleaseVideoImageNV),"glXReleaseVideoImageNV");
    return _driver.call(&_driver.glXReleaseVideoImageNV)(dpy, pbuf);
  }

  static int REGAL_CALL glXSendPbufferToVideoNV(Display *dpy, GLXPbuffer pbuf, int iBufferType, unsigned long *pulCounterPbuffer, GLboolean bBlock)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXSendPbufferToVideoNV),reinterpret_cast<void (*)()>(glXSendPbufferToVideoNV),"glXSendPbufferToVideoNV");
    return _driver.call(&_driver.glXSendPbufferToVideoNV)(dpy, pbuf, iBufferType, pulCounterPbuffer, bBlock);
  }

// GLX_OML_sync_control

  static Bool REGAL_CALL glXGetMscRateOML(Display *dpy, GLXDrawable drawable, int32_t *numerator, int32_t *denominator)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXGetMscRateOML),reinterpret_cast<void (*)()>(glXGetMscRateOML),"glXGetMscRateOML");
    return _driver.call(&_driver.glXGetMscRateOML)(dpy, drawable, numerator, denominator);
  }

  static Bool REGAL_CALL glXGetSyncValuesOML(Display *dpy, GLXDrawable drawable, int64_t *ust, int64_t *msc, int64_t *sbc)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXGetSyncValuesOML),reinterpret_cast<void (*)()>(glXGetSyncValuesOML),"glXGetSyncValuesOML");
    return _driver.call(&_driver.glXGetSyncValuesOML)(dpy, drawable, ust, msc, sbc);
  }

  static int64_t REGAL_CALL glXSwapBuffersMscOML(Display *dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXSwapBuffersMscOML),reinterpret_cast<void (*)()>(glXSwapBuffersMscOML),"glXSwapBuffersMscOML");
    return _driver.call(&_driver.glXSwapBuffersMscOML)(dpy, drawable, target_msc, divisor, remainder);
  }

  static Bool REGAL_CALL glXWaitForMscOML(Display *dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder, int64_t *ust, int64_t *msc, int64_t *sbc)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXWaitForMscOML),reinterpret_cast<void (*)()>(glXWaitForMscOML),"glXWaitForMscOML");
    return _driver.call(&_driver.glXWaitForMscOML)(dpy, drawable, target_msc, divisor, remainder, ust, msc, sbc);
  }

  static Bool REGAL_CALL glXWaitForSbcOML(Display *dpy, GLXDrawable drawable, int64_t target_sbc, int64_t *ust, int64_t *msc, int64_t *sbc)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXWaitForSbcOML),reinterpret_cast<void (*)()>(glXWaitForSbcOML),"glXWaitForSbcOML");
    return _driver.call(&_driver.glXWaitForSbcOML)(dpy, drawable, target_sbc, ust, msc, sbc);
  }

// GLX_SGIX_fbconfig

  static GLXFBConfigSGIX *REGAL_CALL glXChooseFBConfigSGIX(Display *dpy, int screen, const int *attrib_list, int *nelements)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXChooseFBConfigSGIX),reinterpret_cast<void (*)()>(glXChooseFBConfigSGIX),"glXChooseFBConfigSGIX");
    return _driver.call(&_driver.glXChooseFBConfigSGIX)(dpy, screen, attrib_list, nelements);
  }

  static GLXContext REGAL_CALL glXCreateContextWithConfigSGIX(Display *dpy, GLXFBConfig config, int render_type, GLXContext share_list, Bool direct)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXCreateContextWithConfigSGIX),reinterpret_cast<void (*)()>(glXCreateContextWithConfigSGIX),"glXCreateContextWithConfigSGIX");
    return _driver.call(&_driver.glXCreateContextWithConfigSGIX)(dpy, config, render_type, share_list, direct);
  }

  static GLXPixmap REGAL_CALL glXCreateGLXPixmapWithConfigSGIX(Display *dpy, GLXFBConfig config, Pixmap pixmap)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXCreateGLXPixmapWithConfigSGIX),reinterpret_cast<void (*)()>(glXCreateGLXPixmapWithConfigSGIX),"glXCreateGLXPixmapWithConfigSGIX");
    return _driver.call(&_driver.glXCreateGLXPixmapWithConfigSGIX)(dpy, config, pixmap);
  }

  static int REGAL_CALL glXGetFBConfigAttribSGIX(Display *dpy, GLXFBConfigSGIX config, int attribute, int *value)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXGetFBConfigAttribSGIX),reinterpret_cast<void (*)()>(glXGetFBConfigAttribSGIX),"glXGetFBConfigAttribSGIX");
    return _driver.call(&_driver.glXGetFBConfigAttribSGIX)(dpy, config, attribute, value);
  }

  static GLXFBConfigSGIX REGAL_CALL glXGetFBConfigFromVisualSGIX(Display *dpy, XVisualInfo *vis)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXGetFBConfigFromVisualSGIX),reinterpret_cast<void (*)()>(glXGetFBConfigFromVisualSGIX),"glXGetFBConfigFromVisualSGIX");
    return _driver.call(&_driver.glXGetFBConfigFromVisualSGIX)(dpy, vis);
  }

  static XVisualInfo *REGAL_CALL glXGetVisualFromFBConfigSGIX(Display *dpy, GLXFBConfig config)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXGetVisualFromFBConfigSGIX),reinterpret_cast<void (*)()>(glXGetVisualFromFBConfigSGIX),"glXGetVisualFromFBConfigSGIX");
    return _driver.call(&_driver.glXGetVisualFromFBConfigSGIX)(dpy, config);
  }

// GLX_SGIX_pbuffer

  static GLXPbuffer REGAL_CALL glXCreateGLXPbufferSGIX(Display *dpy, GLXFBConfig config, unsigned int width, unsigned int height, int *attrib_list)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXCreateGLXPbufferSGIX),reinterpret_cast<void (*)()>(glXCreateGLXPbufferSGIX),"glXCreateGLXPbufferSGIX");
    return _driver.call(&_driver.glXCreateGLXPbufferSGIX)(dpy, config, width, height, attrib_list);
  }

  static void REGAL_CALL glXDestroyGLXPbufferSGIX(Display *dpy, GLXPbuffer pbuf)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXDestroyGLXPbufferSGIX),reinterpret_cast<void (*)()>(glXDestroyGLXPbufferSGIX),"glXDestroyGLXPbufferSGIX");
    _driver.call(&_driver.glXDestroyGLXPbufferSGIX)(dpy, pbuf);
  }

  static void REGAL_CALL glXGetSelectedEventSGIX(Display *dpy, GLXDrawable drawable, unsigned long *mask)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXGetSelectedEventSGIX),reinterpret_cast<void (*)()>(glXGetSelectedEventSGIX),"glXGetSelectedEventSGIX");
    _driver.call(&_driver.glXGetSelectedEventSGIX)(dpy, drawable, mask);
  }

  static void REGAL_CALL glXQueryGLXPbufferSGIX(Display *dpy, GLXPbuffer pbuf, int attribute, unsigned int *value)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXQueryGLXPbufferSGIX),reinterpret_cast<void (*)()>(glXQueryGLXPbufferSGIX),"glXQueryGLXPbufferSGIX");
    _driver.call(&_driver.glXQueryGLXPbufferSGIX)(dpy, pbuf, attribute, value);
  }

  static void REGAL_CALL glXSelectEventSGIX(Display *dpy, GLXDrawable drawable, unsigned long mask)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXSelectEventSGIX),reinterpret_cast<void (*)()>(glXSelectEventSGIX),"glXSelectEventSGIX");
    _driver.call(&_driver.glXSelectEventSGIX)(dpy, drawable, mask);
  }

// GLX_SGIX_swap_barrier

  static void REGAL_CALL glXBindSwapBarrierSGIX(Display *dpy, GLXDrawable drawable, int barrier)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXBindSwapBarrierSGIX),reinterpret_cast<void (*)()>(glXBindSwapBarrierSGIX),"glXBindSwapBarrierSGIX");
    _driver.call(&_driver.glXBindSwapBarrierSGIX)(dpy, drawable, barrier);
  }

  static Bool REGAL_CALL glXQueryMaxSwapBarriersSGIX(Display *dpy, int screen, int *max)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXQueryMaxSwapBarriersSGIX),reinterpret_cast<void (*)()>(glXQueryMaxSwapBarriersSGIX),"glXQueryMaxSwapBarriersSGIX");
    return _driver.call(&_driver.glXQueryMaxSwapBarriersSGIX)(dpy, screen, max);
  }

// GLX_SGIX_swap_group

  static void REGAL_CALL glXJoinSwapGroupSGIX(Display *dpy, GLXDrawable drawable, GLXDrawable member)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXJoinSwapGroupSGIX),reinterpret_cast<void (*)()>(glXJoinSwapGroupSGIX),"glXJoinSwapGroupSGIX");
    _driver.call(&_driver.glXJoinSwapGroupSGIX)(dpy, drawable, member);
  }

// GLX_SGIX_video_resize

  static int REGAL_CALL glXBindChannelToWindowSGIX(Display *display, int screen, int channel, Window window)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXBindChannelToWindowSGIX),reinterpret_cast<void (*)()>(glXBindChannelToWindowSGIX),"glXBindChannelToWindowSGIX");
    return _driver.call(&_driver.glXBindChannelToWindowSGIX)(display, screen, channel, window);
  }

  static int REGAL_CALL glXChannelRectSGIX(Display *display, int screen, int channel, int x, int y, int w, int h)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXChannelRectSGIX),reinterpret_cast<void (*)()>(glXChannelRectSGIX),"glXChannelRectSGIX");
    return _driver.call(&_driver.glXChannelRectSGIX)(display, screen, channel, x, y, w, h);
  }

  static int REGAL_CALL glXChannelRectSyncSGIX(Display *display, int screen, int channel, GLenum synctype)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXChannelRectSyncSGIX),reinterpret_cast<void (*)()>(glXChannelRectSyncSGIX),"glXChannelRectSyncSGIX");
    return _driver.call(&_driver.glXChannelRectSyncSGIX)(display, screen, channel, synctype);
  }

  static int REGAL_CALL glXQueryChannelDeltasSGIX(Display *display, int screen, int channel, int *x, int *y, int *w, int *h)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXQueryChannelDeltasSGIX),reinterpret_cast<void (*)()>(glXQueryChannelDeltasSGIX),"glXQueryChannelDeltasSGIX");
    return _driver.call(&_driver.glXQueryChannelDeltasSGIX)(display, screen, channel, x, y, w, h);
  }

  static int REGAL_CALL glXQueryChannelRectSGIX(Display *display, int screen, int channel, int *dx, int *dy, int *dw, int *dh)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXQueryChannelRectSGIX),reinterpret_cast<void (*)()>(glXQueryChannelRectSGIX),"glXQueryChannelRectSGIX");
    return _driver.call(&_driver.glXQueryChannelRectSGIX)(display, screen, channel, dx, dy, dw, dh);
  }

// GLX_SGI_cushion

  static void REGAL_CALL glXCushionSGI(Display *dpy, Window window, float cushion)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXCushionSGI),reinterpret_cast<void (*)()>(glXCushionSGI),"glXCushionSGI");
    _driver.call(&_driver.glXCushionSGI)(dpy, window, cushion);
  }

// GLX_SGI_make_current_read

  static GLXDrawable REGAL_CALL glXGetCurrentReadDrawableSGI(void)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXGetCurrentReadDrawableSGI),reinterpret_cast<void (*)()>(glXGetCurrentReadDrawableSGI),"glXGetCurrentReadDrawableSGI");
    return _driver.call(&_driver.glXGetCurrentReadDrawableSGI)();
  }

  static Bool REGAL_CALL glXMakeCurrentReadSGI(Display *dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXMakeCurrentReadSGI),reinterpret_cast<void (*)()>(glXMakeCurrentReadSGI),"glXMakeCurrentReadSGI");
    return _driver.call(&_driver.glXMakeCurrentReadSGI)(dpy, draw, read, ctx);
  }

// GLX_SGI_swap_control

  static int REGAL_CALL glXSwapIntervalSGI(int interval)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXSwapIntervalSGI),reinterpret_cast<void (*)()>(glXSwapIntervalSGI),"glXSwapIntervalSGI");
    return _driver.call(&_driver.glXSwapIntervalSGI)(interval);
  }

// GLX_SGI_video_sync

  static int REGAL_CALL glXGetVideoSyncSGI(unsigned int *count)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXGetVideoSyncSGI),reinterpret_cast<void (*)()>(glXGetVideoSyncSGI),"glXGetVideoSyncSGI");
    return _driver.call(&_driver.glXGetVideoSyncSGI)(count);
  }

  static int REGAL_CALL glXWaitVideoSyncSGI(int divisor, int remainder, unsigned int *count)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXWaitVideoSyncSGI),reinterpret_cast<void (*)()>(glXWaitVideoSyncSGI),"glXWaitVideoSyncSGI");
    return _driver.call(&_driver.glXWaitVideoSyncSGI)(divisor, remainder, count);
  }

// GLX_SUN_get_transparent_index

  static Status REGAL_CALL glXGetTransparentIndexSUN(Display *dpy, Window overlay, Window underlay, unsigned long *pTransparentIndex)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXGetTransparentIndexSUN),reinterpret_cast<void (*)()>(glXGetTransparentIndexSUN),"glXGetTransparentIndexSUN");
    return _driver.call(&_driver.glXGetTransparentIndexSUN)(dpy, overlay, underlay, pTransparentIndex);
  }

// GLX_SUN_video_resize

  static int REGAL_CALL glXGetVideoResizeSUN(Display *display, GLXDrawable window, float *factor)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXGetVideoResizeSUN),reinterpret_cast<void (*)()>(glXGetVideoResizeSUN),"glXGetVideoResizeSUN");
    return _driver.call(&_driver.glXGetVideoResizeSUN)(display, window, factor);
  }

  static int REGAL_CALL glXVideoResizeSUN(Display *display, GLXDrawable window, float factor)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.glXVideoResizeSUN),reinterpret_cast<void (*)()>(glXVideoResizeSUN),"glXVideoResizeSUN");
    return _driver.call(&_driver.glXVideoResizeSUN)(display, window, factor);
  }

#endif // REGAL_SYS_GLX

#if REGAL_SYS_OSX

// CGL_VERSION_1_0

  static CGLError REGAL_CALL CGLChoosePixelFormat(const CGLPixelFormatAttribute *attribs, CGLPixelFormatObj *pix, GLint *npix)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.CGLChoosePixelFormat),reinterpret_cast<void (*)()>(CGLChoosePixelFormat),"CGLChoosePixelFormat");
    return _driver.call(&_driver.CGLChoosePixelFormat)(attribs, pix, npix);
  }

  static CGLError REGAL_CALL CGLClearDrawable(CGLContextObj ctx)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.CGLClearDrawable),reinterpret_cast<void (*)()>(CGLClearDrawable),"CGLClearDrawable");
    return _driver.call(&_driver.CGLClearDrawable)(ctx);
  }

  static CGLError REGAL_CALL CGLCopyContext(CGLContextObj src, CGLContextObj dst, GLbitfield mask)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.CGLCopyContext),reinterpret_cast<void (*)()>(CGLCopyContext),"CGLCopyContext");
    return _driver.call(&_driver.CGLCopyContext)(src, dst, mask);
  }

  static CGLError REGAL_CALL CGLCreateContext(CGLPixelFormatObj pix, CGLContextObj share, CGLContextObj *ctx)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.CGLCreateContext),reinterpret_cast<void (*)()>(CGLCreateContext),"CGLCreateContext");
    return _driver.call(&_driver.CGLCreateContext)(pix, share, ctx);
  }

  static CGLError REGAL_CALL CGLDescribePixelFormat(CGLPixelFormatObj pix, GLint pix_num, CGLPixelFormatAttribute attrib, GLint *value)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.CGLDescribePixelFormat),reinterpret_cast<void (*)()>(CGLDescribePixelFormat),"CGLDescribePixelFormat");
    return _driver.call(&_driver.CGLDescribePixelFormat)(pix, pix_num, attrib, value);
  }

  static CGLError REGAL_CALL CGLDescribeRenderer(CGLRendererInfoObj rend, GLint rend_num, CGLRendererProperty prop, GLint *value)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.CGLDescribeRenderer),reinterpret_cast<void (*)()>(CGLDescribeRenderer),"CGLDescribeRenderer");
    return _driver.call(&_driver.CGLDescribeRenderer)(rend, rend_num, prop, value);
  }

  static CGLError REGAL_CALL CGLDestroyContext(CGLContextObj ctx)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.CGLDestroyContext),reinterpret_cast<void (*)()>(CGLDestroyContext),"CGLDestroyContext");
    return _driver.call(&_driver.CGLDestroyContext)(ctx);
  }

  static CGLError REGAL_CALL CGLDestroyPixelFormat(CGLPixelFormatObj pix)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.CGLDestroyPixelFormat),reinterpret_cast<void (*)()>(CGLDestroyPixelFormat),"CGLDestroyPixelFormat");
    return _driver.call(&_driver.CGLDestroyPixelFormat)(pix);
  }

  static CGLError REGAL_CALL CGLDestroyRendererInfo(CGLRendererInfoObj rend)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.CGLDestroyRendererInfo),reinterpret_cast<void (*)()>(CGLDestroyRendererInfo),"CGLDestroyRendererInfo");
    return _driver.call(&_driver.CGLDestroyRendererInfo)(rend);
  }

  static CGLError REGAL_CALL CGLDisable(CGLContextObj ctx, CGLContextEnable pname)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.CGLDisable),reinterpret_cast<void (*)()>(CGLDisable),"CGLDisable");
    return _driver.call(&_driver.CGLDisable)(ctx, pname);
  }

  static CGLError REGAL_CALL CGLEnable(CGLContextObj ctx, CGLContextEnable pname)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.CGLEnable),reinterpret_cast<void (*)()>(CGLEnable),"CGLEnable");
    return _driver.call(&_driver.CGLEnable)(ctx, pname);
  }

  static const char *REGAL_CALL CGLErrorString(CGLError error)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.CGLErrorString),reinterpret_cast<void (*)()>(CGLErrorString),"CGLErrorString");
    return _driver.call(&_driver.CGLErrorString)(error);
  }

  static CGLError REGAL_CALL CGLFlushDrawable(CGLContextObj ctx)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.CGLFlushDrawable),reinterpret_cast<void (*)()>(CGLFlushDrawable),"CGLFlushDrawable");
    return _driver.call(&_driver.CGLFlushDrawable)(ctx);
  }

  static CGLError REGAL_CALL CGLGetOffScreen(CGLContextObj ctx, GLsizei *width, GLsizei *height, GLsizei *rowbytes, void **baseaddr)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.CGLGetOffScreen),reinterpret_cast<void (*)()>(CGLGetOffScreen),"CGLGetOffScreen");
    return _driver.call(&_driver.CGLGetOffScreen)(ctx, width, height, rowbytes, baseaddr);
  }

  static CGLError REGAL_CALL CGLGetOption(CGLGlobalOption pname, GLint *param)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.CGLGetOption),reinterpret_cast<void (*)()>(CGLGetOption),"CGLGetOption");
    return _driver.call(&_driver.CGLGetOption)(pname, param);
  }

  static CGLError REGAL_CALL CGLGetParameter(CGLContextObj ctx, CGLContextParameter pname, GLint *params)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.CGLGetParameter),reinterpret_cast<void (*)()>(CGLGetParameter),"CGLGetParameter");
    return _driver.call(&_driver.CGLGetParameter)(ctx, pname, params);
  }

  static void REGAL_CALL CGLGetVersion(GLint *majorvers, GLint *minorvers)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.CGLGetVersion),reinterpret_cast<void (*)()>(CGLGetVersion),"CGLGetVersion");
    _driver.call(&_driver.CGLGetVersion)(majorvers, minorvers);
  }

  static CGLError REGAL_CALL CGLGetVirtualScreen(CGLContextObj ctx, GLint *screen)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.CGLGetVirtualScreen),reinterpret_cast<void (*)()>(CGLGetVirtualScreen),"CGLGetVirtualScreen");
    return _driver.call(&_driver.CGLGetVirtualScreen)(ctx, screen);
  }

  static CGLError REGAL_CALL CGLIsEnabled(CGLContextObj ctx, CGLContextEnable pname, GLint *enable)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.CGLIsEnabled),reinterpret_cast<void (*)()>(CGLIsEnabled),"CGLIsEnabled");
    return _driver.call(&_driver.CGLIsEnabled)(ctx, pname, enable);
  }

  static CGLError REGAL_CALL CGLQueryRendererInfo(GLuint display_mask, CGLRendererInfoObj *rend, GLint *nrend)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.CGLQueryRendererInfo),reinterpret_cast<void (*)()>(CGLQueryRendererInfo),"CGLQueryRendererInfo");
    return _driver.call(&_driver.CGLQueryRendererInfo)(display_mask, rend, nrend);
  }

  static CGLError REGAL_CALL CGLSetFullScreen(CGLContextObj ctx)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.CGLSetFullScreen),reinterpret_cast<void (*)()>(CGLSetFullScreen),"CGLSetFullScreen");
    return _driver.call(&_driver.CGLSetFullScreen)(ctx);
  }

  static CGLError REGAL_CALL CGLSetOffScreen(CGLContextObj ctx, GLsizei width, GLsizei height, GLsizei rowbytes, void *baseaddr)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.CGLSetOffScreen),reinterpret_cast<void (*)()>(CGLSetOffScreen),"CGLSetOffScreen");
    return _driver.call(&_driver.CGLSetOffScreen)(ctx, width, height, rowbytes, baseaddr);
  }

  static CGLError REGAL_CALL CGLSetOption(CGLGlobalOption pname, GLint param)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.CGLSetOption),reinterpret_cast<void (*)()>(CGLSetOption),"CGLSetOption");
    return _driver.call(&_driver.CGLSetOption)(pname, param);
  }

  static CGLError REGAL_CALL CGLSetParameter(CGLContextObj ctx, CGLContextParameter pname, const GLint *params)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.CGLSetParameter),reinterpret_cast<void (*)()>(CGLSetParameter),"CGLSetParameter");
    return _driver.call(&_driver.CGLSetParameter)(ctx, pname, params);
  }

  static CGLError REGAL_CALL CGLSetVirtualScreen(CGLContextObj ctx, GLint screen)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.CGLSetVirtualScreen),reinterpret_cast<void (*)()>(CGLSetVirtualScreen),"CGLSetVirtualScreen");
    return _driver.call(&_driver.CGLSetVirtualScreen)(ctx, screen);
  }

// CGL_VERSION_1_1

  static CGLError REGAL_CALL CGLCreatePBuffer(GLsizei width, GLsizei height, GLenum target, GLenum internalFormat, GLint max_level, CGLPBufferObj *pbuffer)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.CGLCreatePBuffer),reinterpret_cast<void (*)()>(CGLCreatePBuffer),"CGLCreatePBuffer");
    return _driver.call(&_driver.CGLCreatePBuffer)(width, height, target, internalFormat, max_level, pbuffer);
  }

  static CGLError REGAL_CALL CGLDescribePBuffer(CGLPBufferObj pbuffer, GLsizei *width, GLsizei *height, GLenum *target, GLenum *internalFormat, GLint *mipmap)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.CGLDescribePBuffer),reinterpret_cast<void (*)()>(CGLDescribePBuffer),"CGLDescribePBuffer");
    return _driver.call(&_driver.CGLDescribePBuffer)(pbuffer, width, height, target, internalFormat, mipmap);
  }

  static CGLError REGAL_CALL CGLDestroyPBuffer(CGLPBufferObj pbuffer)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.CGLDestroyPBuffer),reinterpret_cast<void (*)()>(CGLDestroyPBuffer),"CGLDestroyPBuffer");
    return _driver.call(&_driver.CGLDestroyPBuffer)(pbuffer);
  }

  static CGLError REGAL_CALL CGLGetPBuffer(CGLContextObj ctx, CGLPBufferObj *pbuffer, GLenum *face, GLint *level, GLint *screen)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.CGLGetPBuffer),reinterpret_cast<void (*)()>(CGLGetPBuffer),"CGLGetPBuffer");
    return _driver.call(&_driver.CGLGetPBuffer)(ctx, pbuffer, face, level, screen);
  }

  static CGLError REGAL_CALL CGLSetPBuffer(CGLContextObj ctx, CGLPBufferObj pbuffer, GLenum face, GLint level, GLint screen)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.CGLSetPBuffer),reinterpret_cast<void (*)()>(CGLSetPBuffer),"CGLSetPBuffer");
    return _driver.call(&_driver.CGLSetPBuffer)(ctx, pbuffer, face, level, screen);
  }

  static CGLError REGAL_CALL CGLTexImagePBuffer(CGLContextObj ctx, CGLPBufferObj pbuffer, GLenum source)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.CGLTexImagePBuffer),reinterpret_cast<void (*)()>(CGLTexImagePBuffer),"CGLTexImagePBuffer");
    return _driver.call(&_driver.CGLTexImagePBuffer)(ctx, pbuffer, source);
  }

// CGL_VERSION_1_2

  static GLuint REGAL_CALL CGLGetContextRetainCount(CGLContextObj ctx)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.CGLGetContextRetainCount),reinterpret_cast<void (*)()>(CGLGetContextRetainCount),"CGLGetContextRetainCount");
    return _driver.call(&_driver.CGLGetContextRetainCount)(ctx);
  }

  static CGLError REGAL_CALL CGLGetGlobalOption(CGLGlobalOption pname, GLint *params)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.CGLGetGlobalOption),reinterpret_cast<void (*)()>(CGLGetGlobalOption),"CGLGetGlobalOption");
    return _driver.call(&_driver.CGLGetGlobalOption)(pname, params);
  }

  static GLuint REGAL_CALL CGLGetPBufferRetainCount(CGLPBufferObj pbuffer)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.CGLGetPBufferRetainCount),reinterpret_cast<void (*)()>(CGLGetPBufferRetainCount),"CGLGetPBufferRetainCount");
    return _driver.call(&_driver.CGLGetPBufferRetainCount)(pbuffer);
  }

  static CGLPixelFormatObj REGAL_CALL CGLGetPixelFormat(CGLContextObj ctx)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.CGLGetPixelFormat),reinterpret_cast<void (*)()>(CGLGetPixelFormat),"CGLGetPixelFormat");
    return _driver.call(&_driver.CGLGetPixelFormat)(ctx);
  }

  static GLuint REGAL_CALL CGLGetPixelFormatRetainCount(CGLPixelFormatObj pix)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.CGLGetPixelFormatRetainCount),reinterpret_cast<void (*)()>(CGLGetPixelFormatRetainCount),"CGLGetPixelFormatRetainCount");
    return _driver.call(&_driver.CGLGetPixelFormatRetainCount)(pix);
  }

  static CGLError REGAL_CALL CGLLockContext(CGLContextObj ctx)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.CGLLockContext),reinterpret_cast<void (*)()>(CGLLockContext),"CGLLockContext");
    return _driver.call(&_driver.CGLLockContext)(ctx);
  }

  static void REGAL_CALL CGLReleaseContext(CGLContextObj ctx)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.CGLReleaseContext),reinterpret_cast<void (*)()>(CGLReleaseContext),"CGLReleaseContext");
    _driver.call(&_driver.CGLReleaseContext)(ctx);
  }

  static void REGAL_CALL CGLReleasePBuffer(CGLPBufferObj pbuffer)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.CGLReleasePBuffer),reinterpret_cast<void (*)()>(CGLReleasePBuffer),"CGLReleasePBuffer");
    _driver.call(&_driver.CGLReleasePBuffer)(pbuffer);
  }

  static void REGAL_CALL CGLReleasePixelFormat(CGLPixelFormatObj pix)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.CGLReleasePixelFormat),reinterpret_cast<void (*)()>(CGLReleasePixelFormat),"CGLReleasePixelFormat");
    _driver.call(&_driver.CGLReleasePixelFormat)(pix);
  }

  static CGLContextObj REGAL_CALL CGLRetainContext(CGLContextObj ctx)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.CGLRetainContext),reinterpret_cast<void (*)()>(CGLRetainContext),"CGLRetainContext");
    return _driver.call(&_driver.CGLRetainContext)(ctx);
  }

  static CGLPBufferObj REGAL_CALL CGLRetainPBuffer(CGLPBufferObj pbuffer)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.CGLRetainPBuffer),reinterpret_cast<void (*)()>(CGLRetainPBuffer),"CGLRetainPBuffer");
    return _driver.call(&_driver.CGLRetainPBuffer)(pbuffer);
  }

  static CGLPixelFormatObj REGAL_CALL CGLRetainPixelFormat(CGLPixelFormatObj pix)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.CGLRetainPixelFormat),reinterpret_cast<void (*)()>(CGLRetainPixelFormat),"CGLRetainPixelFormat");
    return _driver.call(&_driver.CGLRetainPixelFormat)(pix);
  }

  static CGLError REGAL_CALL CGLSetGlobalOption(CGLGlobalOption pname, const GLint *params)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.CGLSetGlobalOption),reinterpret_cast<void (*)()>(CGLSetGlobalOption),"CGLSetGlobalOption");
    return _driver.call(&_driver.CGLSetGlobalOption)(pname, params);
  }

  static CGLError REGAL_CALL CGLUnlockContext(CGLContextObj ctx)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.CGLUnlockContext),reinterpret_cast<void (*)()>(CGLUnlockContext),"CGLUnlockContext");
    return _driver.call(&_driver.CGLUnlockContext)(ctx);
  }

// CGL_VERSION_1_3

  static CGLContextObj REGAL_CALL CGLGetCurrentContext(void)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.CGLGetCurrentContext),reinterpret_cast<void (*)()>(CGLGetCurrentContext),"CGLGetCurrentContext");
    return _driver.call(&_driver.CGLGetCurrentContext)();
  }

  static CGLShareGroupObj REGAL_CALL CGLGetShareGroup(CGLContextObj ctx)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.CGLGetShareGroup),reinterpret_cast<void (*)()>(CGLGetShareGroup),"CGLGetShareGroup");
    return _driver.call(&_driver.CGLGetShareGroup)(ctx);
  }

  static CGLError REGAL_CALL CGLGetSurface(CGLContextObj ctx, CGSConnectionID *conn, CGSWindowID *win, CGSSurfaceID *srf)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.CGLGetSurface),reinterpret_cast<void (*)()>(CGLGetSurface),"CGLGetSurface");
    return _driver.call(&_driver.CGLGetSurface)(ctx, conn, win, srf);
  }

  static CGLError REGAL_CALL CGLSetCurrentContext(CGLContextObj ctx)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.CGLSetCurrentContext),reinterpret_cast<void (*)()>(CGLSetCurrentContext),"CGLSetCurrentContext");
    return _driver.call(&_driver.CGLSetCurrentContext)(ctx);
  }

  static CGLError REGAL_CALL CGLSetSurface(CGLContextObj ctx, CGSConnectionID conn, CGSWindowID win, CGSSurfaceID srf)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.CGLSetSurface),reinterpret_cast<void (*)()>(CGLSetSurface),"CGLSetSurface");
    return _driver.call(&_driver.CGLSetSurface)(ctx, conn, win, srf);
  }

  static CGLError REGAL_CALL CGLTexImageIOSurface2D(CGLContextObj ctx, GLenum target, GLenum internal_format, GLsizei width, GLsizei height, GLenum format, GLenum type, IOSurfaceRef ioSurface, GLuint plane)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.CGLTexImageIOSurface2D),reinterpret_cast<void (*)()>(CGLTexImageIOSurface2D),"CGLTexImageIOSurface2D");
    return _driver.call(&_driver.CGLTexImageIOSurface2D)(ctx, target, internal_format, width, height, format, type, ioSurface, plane);
  }

  static CGLError REGAL_CALL CGLUpdateContext(CGLContextObj ctx)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.CGLUpdateContext),reinterpret_cast<void (*)()>(CGLUpdateContext),"CGLUpdateContext");
    return _driver.call(&_driver.CGLUpdateContext)(ctx);
  }

#endif // REGAL_SYS_OSX

#if REGAL_SYS_EGL

// EGL_ANGLE_query_surface_pointer

  static EGLBoolean REGAL_CALL eglQuerySurfacePointerANGLE(EGLDisplay dpy, EGLSurface surface, EGLint attribute, GLvoid **value)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglQuerySurfacePointerANGLE),reinterpret_cast<void (*)()>(eglQuerySurfacePointerANGLE),"eglQuerySurfacePointerANGLE");
    return _driver.call(&_driver.eglQuerySurfacePointerANGLE)(dpy, surface, attribute, value);
  }

// EGL_KHR_fence_sync

  static EGLint REGAL_CALL eglClientWaitSyncKHR(EGLDisplay dpy, EGLSyncKHR GLsync, EGLint flags, EGLTimeKHR timeout)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglClientWaitSyncKHR),reinterpret_cast<void (*)()>(eglClientWaitSyncKHR),"eglClientWaitSyncKHR");
    return _driver.call(&_driver.eglClientWaitSyncKHR)(dpy, GLsync, flags, timeout);
  }

  static EGLSyncKHR REGAL_CALL eglCreateSyncKHR(EGLDisplay dpy, EGLenum type, const EGLint *attrib_list)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglCreateSyncKHR),reinterpret_cast<void (*)()>(eglCreateSyncKHR),"eglCreateSyncKHR");
    return _driver.call(&_driver.eglCreateSyncKHR)(dpy, type, attrib_list);
  }

  static EGLBoolean REGAL_CALL eglDestroySyncKHR(EGLDisplay dpy, EGLSyncKHR GLsync)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglDestroySyncKHR),reinterpret_cast<void (*)()>(eglDestroySyncKHR),"eglDestroySyncKHR");
    return _driver.call(&_driver.eglDestroySyncKHR)(dpy, GLsync);
  }

  static EGLBoolean REGAL_CALL eglGetSyncAttribKHR(EGLDisplay dpy, EGLSyncKHR GLsync, EGLint attribute, EGLint *value)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglGetSyncAttribKHR),reinterpret_cast<void (*)()>(eglGetSyncAttribKHR),"eglGetSyncAttribKHR");
    return _driver.call(&_driver.eglGetSyncAttribKHR)(dpy, GLsync, attribute, value);
  }

// EGL_KHR_image_base

  static EGLImageKHR REGAL_CALL eglCreateImageKHR(EGLDisplay dpy, EGLContext ctx, EGLenum target, EGLClientBuffer buffer, const EGLint *attrib_list)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglCreateImageKHR),reinterpret_cast<void (*)()>(eglCreateImageKHR),"eglCreateImageKHR");
    return _driver.call(&_driver.eglCreateImageKHR)(dpy, ctx, target, buffer, attrib_list);
  }

  static EGLBoolean REGAL_CALL eglDestroyImageKHR(EGLDisplay dpy, EGLImageKHR image)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglDestroyImageKHR),reinterpret_cast<void (*)()>(eglDestroyImageKHR),"eglDestroyImageKHR");
    return _driver.call(&_driver.eglDestroyImageKHR)(dpy, image);
  }

// EGL_KHR_lock_surface

  static EGLBoolean REGAL_CALL eglLockSurfaceKHR(EGLDisplay display, EGLSurface surface, const EGLint *attrib_list)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglLockSurfaceKHR),reinterpret_cast<void (*)()>(eglLockSurfaceKHR),"eglLockSurfaceKHR");
    return _driver.call(&_driver.eglLockSurfaceKHR)(display, surface, attrib_list);
  }

  static EGLBoolean REGAL_CALL eglUnlockSurfaceKHR(EGLDisplay display, EGLSurface surface)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglUnlockSurfaceKHR),reinterpret_cast<void (*)()>(eglUnlockSurfaceKHR),"eglUnlockSurfaceKHR");
    return _driver.call(&_driver.eglUnlockSurfaceKHR)(display, surface);
  }

// EGL_KHR_stream_consumer_gltexture

  static EGLBoolean REGAL_CALL eglStreamConsumerAcquireKHR(EGLDisplay dpy, EGLStreamKHR stream)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglStreamConsumerAcquireKHR),reinterpret_cast<void (*)()>(eglStreamConsumerAcquireKHR),"eglStreamConsumerAcquireKHR");
    return _driver.call(&_driver.eglStreamConsumerAcquireKHR)(dpy, stream);
  }

  static EGLBoolean REGAL_CALL eglStreamConsumerGLTextureExternalKHR(EGLDisplay dpy, EGLStreamKHR stream)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglStreamConsumerGLTextureExternalKHR),reinterpret_cast<void (*)()>(eglStreamConsumerGLTextureExternalKHR),"eglStreamConsumerGLTextureExternalKHR");
    return _driver.call(&_driver.eglStreamConsumerGLTextureExternalKHR)(dpy, stream);
  }

  static EGLBoolean REGAL_CALL eglStreamConsumerReleaseKHR(EGLDisplay dpy, EGLStreamKHR stream)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglStreamConsumerReleaseKHR),reinterpret_cast<void (*)()>(eglStreamConsumerReleaseKHR),"eglStreamConsumerReleaseKHR");
    return _driver.call(&_driver.eglStreamConsumerReleaseKHR)(dpy, stream);
  }

// EGL_KHR_stream_cross_process_fd

  static EGLStreamKHR REGAL_CALL eglCreateStreamFromFileDescriptorKHR(EGLDisplay dpy, EGLNativeFileDescriptorKHR file_descriptor)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglCreateStreamFromFileDescriptorKHR),reinterpret_cast<void (*)()>(eglCreateStreamFromFileDescriptorKHR),"eglCreateStreamFromFileDescriptorKHR");
    return _driver.call(&_driver.eglCreateStreamFromFileDescriptorKHR)(dpy, file_descriptor);
  }

  static EGLNativeFileDescriptorKHR REGAL_CALL eglGetStreamFileDescriptorKHR(EGLDisplay dpy, EGLStreamKHR stream)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglGetStreamFileDescriptorKHR),reinterpret_cast<void (*)()>(eglGetStreamFileDescriptorKHR),"eglGetStreamFileDescriptorKHR");
    return _driver.call(&_driver.eglGetStreamFileDescriptorKHR)(dpy, stream);
  }

// EGL_KHR_stream_producer_eglsurface

  static EGLSurface REGAL_CALL eglCreateStreamProducerSurfaceKHR(EGLDisplay dpy, EGLConfig config, EGLStreamKHR stream, const EGLint *attrib_list)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglCreateStreamProducerSurfaceKHR),reinterpret_cast<void (*)()>(eglCreateStreamProducerSurfaceKHR),"eglCreateStreamProducerSurfaceKHR");
    return _driver.call(&_driver.eglCreateStreamProducerSurfaceKHR)(dpy, config, stream, attrib_list);
  }

// EGL_KHR_wait_sync

  static EGLint REGAL_CALL eglWaitSyncKHR(EGLDisplay dpy, EGLSyncKHR GLsync, EGLint flags)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglWaitSyncKHR),reinterpret_cast<void (*)()>(eglWaitSyncKHR),"eglWaitSyncKHR");
    return _driver.call(&_driver.eglWaitSyncKHR)(dpy, GLsync, flags);
  }

// EGL_MESA_drm_image

  static EGLImageKHR REGAL_CALL eglCreateDRMImageMESA(EGLDisplay dpy, const EGLint *attrib_list)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglCreateDRMImageMESA),reinterpret_cast<void (*)()>(eglCreateDRMImageMESA),"eglCreateDRMImageMESA");
    return _driver.call(&_driver.eglCreateDRMImageMESA)(dpy, attrib_list);
  }

  static EGLBoolean REGAL_CALL eglExportDRMImageMESA(EGLDisplay dpy, EGLImageKHR image, EGLint *name, EGLint *handle, EGLint *stride)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglExportDRMImageMESA),reinterpret_cast<void (*)()>(eglExportDRMImageMESA),"eglExportDRMImageMESA");
    return _driver.call(&_driver.eglExportDRMImageMESA)(dpy, image, name, handle, stride);
  }

// EGL_NV_coverage_sample

  static void REGAL_CALL eglCoverageMaskNV(GLboolean mask)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglCoverageMaskNV),reinterpret_cast<void (*)()>(eglCoverageMaskNV),"eglCoverageMaskNV");
    _driver.call(&_driver.eglCoverageMaskNV)(mask);
  }

  static void REGAL_CALL eglCoverageOperationNV(GLenum operation)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglCoverageOperationNV),reinterpret_cast<void (*)()>(eglCoverageOperationNV),"eglCoverageOperationNV");
    _driver.call(&_driver.eglCoverageOperationNV)(operation);
  }

// EGL_NV_post_sub_buffer

  static EGLBoolean REGAL_CALL eglPostSubBufferNV(EGLDisplay dpy, EGLSurface surface, EGLint x, EGLint y, EGLint width, EGLint height)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglPostSubBufferNV),reinterpret_cast<void (*)()>(eglPostSubBufferNV),"eglPostSubBufferNV");
    return _driver.call(&_driver.eglPostSubBufferNV)(dpy, surface, x, y, width, height);
  }

// EGL_NV_sync

  static EGLint REGAL_CALL eglClientWaitSyncNV(EGLSyncNV GLsync, EGLint flags, EGLTimeNV timeout)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglClientWaitSyncNV),reinterpret_cast<void (*)()>(eglClientWaitSyncNV),"eglClientWaitSyncNV");
    return _driver.call(&_driver.eglClientWaitSyncNV)(GLsync, flags, timeout);
  }

  static EGLSyncNV REGAL_CALL eglCreateFenceSyncNV(EGLDisplay dpy, EGLenum condition, const EGLint *attrib_list)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglCreateFenceSyncNV),reinterpret_cast<void (*)()>(eglCreateFenceSyncNV),"eglCreateFenceSyncNV");
    return _driver.call(&_driver.eglCreateFenceSyncNV)(dpy, condition, attrib_list);
  }

  static EGLBoolean REGAL_CALL eglDestroySyncNV(EGLSyncNV GLsync)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglDestroySyncNV),reinterpret_cast<void (*)()>(eglDestroySyncNV),"eglDestroySyncNV");
    return _driver.call(&_driver.eglDestroySyncNV)(GLsync);
  }

  static EGLBoolean REGAL_CALL eglFenceNV(EGLSyncNV GLsync)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglFenceNV),reinterpret_cast<void (*)()>(eglFenceNV),"eglFenceNV");
    return _driver.call(&_driver.eglFenceNV)(GLsync);
  }

  static EGLBoolean REGAL_CALL eglGetSyncAttribNV(EGLSyncNV GLsync, EGLint attribute, EGLint *value)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglGetSyncAttribNV),reinterpret_cast<void (*)()>(eglGetSyncAttribNV),"eglGetSyncAttribNV");
    return _driver.call(&_driver.eglGetSyncAttribNV)(GLsync, attribute, value);
  }

  static EGLBoolean REGAL_CALL eglSignalSyncNV(EGLSyncNV GLsync, EGLenum mode)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglSignalSyncNV),reinterpret_cast<void (*)()>(eglSignalSyncNV),"eglSignalSyncNV");
    return _driver.call(&_driver.eglSignalSyncNV)(GLsync, mode);
  }

// EGL_NV_system_time

  static EGLuint64NV REGAL_CALL eglGetSystemTimeFrequencyNV(void)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglGetSystemTimeFrequencyNV),reinterpret_cast<void (*)()>(eglGetSystemTimeFrequencyNV),"eglGetSystemTimeFrequencyNV");
    return _driver.call(&_driver.eglGetSystemTimeFrequencyNV)();
  }

  static EGLuint64NV REGAL_CALL eglGetSystemTimeNV(void)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglGetSystemTimeNV),reinterpret_cast<void (*)()>(eglGetSystemTimeNV),"eglGetSystemTimeNV");
    return _driver.call(&_driver.eglGetSystemTimeNV)();
  }

// EGL_VERSION_1_0

  static EGLBoolean REGAL_CALL eglChooseConfig(EGLDisplay dpy, const EGLint *attrib_list, EGLConfig *configs, EGLint config_size, EGLint *num_config)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglChooseConfig),reinterpret_cast<void (*)()>(eglChooseConfig),"eglChooseConfig");
    return _driver.call(&_driver.eglChooseConfig)(dpy, attrib_list, configs, config_size, num_config);
  }

  static EGLBoolean REGAL_CALL eglCopyBuffers(EGLDisplay dpy, EGLSurface surface, EGLNativePixmapType target)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglCopyBuffers),reinterpret_cast<void (*)()>(eglCopyBuffers),"eglCopyBuffers");
    return _driver.call(&_driver.eglCopyBuffers)(dpy, surface, target);
  }

  static EGLContext REGAL_CALL eglCreateContext(EGLDisplay dpy, EGLConfig config, EGLContext share_context, const EGLint *attrib_list)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglCreateContext),reinterpret_cast<void (*)()>(eglCreateContext),"eglCreateContext");
    return _driver.call(&_driver.eglCreateContext)(dpy, config, share_context, attrib_list);
  }

  static EGLSurface REGAL_CALL eglCreatePbufferSurface(EGLDisplay dpy, EGLConfig config, const EGLint *attrib_list)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglCreatePbufferSurface),reinterpret_cast<void (*)()>(eglCreatePbufferSurface),"eglCreatePbufferSurface");
    return _driver.call(&_driver.eglCreatePbufferSurface)(dpy, config, attrib_list);
  }

  static EGLSurface REGAL_CALL eglCreatePixmapSurface(EGLDisplay dpy, EGLConfig config, EGLNativePixmapType pixmap, const EGLint *attrib_list)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglCreatePixmapSurface),reinterpret_cast<void (*)()>(eglCreatePixmapSurface),"eglCreatePixmapSurface");
    return _driver.call(&_driver.eglCreatePixmapSurface)(dpy, config, pixmap, attrib_list);
  }

  static EGLSurface REGAL_CALL eglCreateWindowSurface(EGLDisplay dpy, EGLConfig config, EGLNativeWindowType win, const EGLint *attrib_list)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglCreateWindowSurface),reinterpret_cast<void (*)()>(eglCreateWindowSurface),"eglCreateWindowSurface");
    return _driver.call(&_driver.eglCreateWindowSurface)(dpy, config, win, attrib_list);
  }

  static EGLBoolean REGAL_CALL eglDestroyContext(EGLDisplay dpy, EGLContext ctx)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglDestroyContext),reinterpret_cast<void (*)()>(eglDestroyContext),"eglDestroyContext");
    return _driver.call(&_driver.eglDestroyContext)(dpy, ctx);
  }

  static EGLBoolean REGAL_CALL eglDestroySurface(EGLDisplay dpy, EGLSurface surface)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglDestroySurface),reinterpret_cast<void (*)()>(eglDestroySurface),"eglDestroySurface");
    return _driver.call(&_driver.eglDestroySurface)(dpy, surface);
  }

  static EGLBoolean REGAL_CALL eglGetConfigAttrib(EGLDisplay dpy, EGLConfig config, EGLint attribute, EGLint *value)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglGetConfigAttrib),reinterpret_cast<void (*)()>(eglGetConfigAttrib),"eglGetConfigAttrib");
    return _driver.call(&_driver.eglGetConfigAttrib)(dpy, config, attribute, value);
  }

  static EGLBoolean REGAL_CALL eglGetConfigs(EGLDisplay dpy, EGLConfig *configs, EGLint config_size, EGLint *num_config)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglGetConfigs),reinterpret_cast<void (*)()>(eglGetConfigs),"eglGetConfigs");
    return _driver.call(&_driver.eglGetConfigs)(dpy, configs, config_size, num_config);
  }

  static EGLContext REGAL_CALL eglGetCurrentContext(void)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglGetCurrentContext),reinterpret_cast<void (*)()>(eglGetCurrentContext),"eglGetCurrentContext");
    return _driver.call(&_driver.eglGetCurrentContext)();
  }

  static EGLDisplay REGAL_CALL eglGetCurrentDisplay(void)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglGetCurrentDisplay),reinterpret_cast<void (*)()>(eglGetCurrentDisplay),"eglGetCurrentDisplay");
    return _driver.call(&_driver.eglGetCurrentDisplay)();
  }

  static EGLSurface REGAL_CALL eglGetCurrentSurface(EGLint readdraw)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglGetCurrentSurface),reinterpret_cast<void (*)()>(eglGetCurrentSurface),"eglGetCurrentSurface");
    return _driver.call(&_driver.eglGetCurrentSurface)(readdraw);
  }

  static EGLDisplay REGAL_CALL eglGetDisplay(EGLNativeDisplayType display_id)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglGetDisplay),reinterpret_cast<void (*)()>(eglGetDisplay),"eglGetDisplay");
    return _driver.call(&_driver.eglGetDisplay)(display_id);
  }

  static EGLint REGAL_CALL eglGetError(void)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglGetError),reinterpret_cast<void (*)()>(eglGetError),"eglGetError");
    return _driver.call(&_driver.eglGetError)();
  }

  static __eglMustCastToProperFunctionPointerType REGAL_CALL eglGetProcAddress(const char *procname)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglGetProcAddress),reinterpret_cast<void (*)()>(eglGetProcAddress),"eglGetProcAddress");
    return _driver.call(&_driver.eglGetProcAddress)(procname);
  }

  static EGLBoolean REGAL_CALL eglInitialize(EGLDisplay dpy, EGLint *major, EGLint *minor)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglInitialize),reinterpret_cast<void (*)()>(eglInitialize),"eglInitialize");
    return _driver.call(&_driver.eglInitialize)(dpy, major, minor);
  }

  static EGLBoolean REGAL_CALL eglMakeCurrent(EGLDisplay dpy, EGLSurface draw, EGLSurface read, EGLContext ctx)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglMakeCurrent),reinterpret_cast<void (*)()>(eglMakeCurrent),"eglMakeCurrent");
    return _driver.call(&_driver.eglMakeCurrent)(dpy, draw, read, ctx);
  }

  static EGLBoolean REGAL_CALL eglQueryContext(EGLDisplay dpy, EGLContext ctx, EGLint attribute, EGLint *value)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglQueryContext),reinterpret_cast<void (*)()>(eglQueryContext),"eglQueryContext");
    return _driver.call(&_driver.eglQueryContext)(dpy, ctx, attribute, value);
  }

  static const char *REGAL_CALL eglQueryString(EGLDisplay dpy, EGLint name)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglQueryString),reinterpret_cast<void (*)()>(eglQueryString),"eglQueryString");
    return _driver.call(&_driver.eglQueryString)(dpy, name);
  }

  static EGLBoolean REGAL_CALL eglQuerySurface(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint *value)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglQuerySurface),reinterpret_cast<void (*)()>(eglQuerySurface),"eglQuerySurface");
    return _driver.call(&_driver.eglQuerySurface)(dpy, surface, attribute, value);
  }

  static EGLBoolean REGAL_CALL eglSwapBuffers(EGLDisplay dpy, EGLSurface surface)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglSwapBuffers),reinterpret_cast<void (*)()>(eglSwapBuffers),"eglSwapBuffers");
    return _driver.call(&_driver.eglSwapBuffers)(dpy, surface);
  }

  static EGLBoolean REGAL_CALL eglTerminate(EGLDisplay dpy)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglTerminate),reinterpret_cast<void (*)()>(eglTerminate),"eglTerminate");
    return _driver.call(&_driver.eglTerminate)(dpy);
  }

  static EGLBoolean REGAL_CALL eglWaitGL(void)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglWaitGL),reinterpret_cast<void (*)()>(eglWaitGL),"eglWaitGL");
    return _driver.call(&_driver.eglWaitGL)();
  }

  static EGLBoolean REGAL_CALL eglWaitNative(EGLint engine)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglWaitNative),reinterpret_cast<void (*)()>(eglWaitNative),"eglWaitNative");
    return _driver.call(&_driver.eglWaitNative)(engine);
  }

// EGL_VERSION_1_1

  static EGLBoolean REGAL_CALL eglBindTexImage(EGLDisplay dpy, EGLSurface surface, EGLint buffer)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglBindTexImage),reinterpret_cast<void (*)()>(eglBindTexImage),"eglBindTexImage");
    return _driver.call(&_driver.eglBindTexImage)(dpy, surface, buffer);
  }

  static EGLBoolean REGAL_CALL eglReleaseTexImage(EGLDisplay dpy, EGLSurface surface, EGLint buffer)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglReleaseTexImage),reinterpret_cast<void (*)()>(eglReleaseTexImage),"eglReleaseTexImage");
    return _driver.call(&_driver.eglReleaseTexImage)(dpy, surface, buffer);
  }

// EGL_VERSION_1_2

  static EGLBoolean REGAL_CALL eglBindAPI(EGLenum api)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglBindAPI),reinterpret_cast<void (*)()>(eglBindAPI),"eglBindAPI");
    return _driver.call(&_driver.eglBindAPI)(api);
  }

  static EGLSurface REGAL_CALL eglCreatePbufferFromClientBuffer(EGLDisplay dpy, EGLenum buftype, EGLClientBuffer buffer, EGLConfig config, const EGLint *attrib_list)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglCreatePbufferFromClientBuffer),reinterpret_cast<void (*)()>(eglCreatePbufferFromClientBuffer),"eglCreatePbufferFromClientBuffer");
    return _driver.call(&_driver.eglCreatePbufferFromClientBuffer)(dpy, buftype, buffer, config, attrib_list);
  }

  static EGLenum REGAL_CALL eglQueryAPI(void)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglQueryAPI),reinterpret_cast<void (*)()>(eglQueryAPI),"eglQueryAPI");
    return _driver.call(&_driver.eglQueryAPI)();
  }

  static EGLBoolean REGAL_CALL eglReleaseThread(void)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglReleaseThread),reinterpret_cast<void (*)()>(eglReleaseThread),"eglReleaseThread");
    return _driver.call(&_driver.eglReleaseThread)();
  }

  static EGLBoolean REGAL_CALL eglSurfaceAttrib(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint value)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglSurfaceAttrib),reinterpret_cast<void (*)()>(eglSurfaceAttrib),"eglSurfaceAttrib");
    return _driver.call(&_driver.eglSurfaceAttrib)(dpy, surface, attribute, value);
  }

  static EGLBoolean REGAL_CALL eglSwapInterval(EGLDisplay dpy, EGLint interval)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglSwapInterval),reinterpret_cast<void (*)()>(eglSwapInterval),"eglSwapInterval");
    return _driver.call(&_driver.eglSwapInterval)(dpy, interval);
  }

  static EGLBoolean REGAL_CALL eglWaitClient(void)
  {
    DispatchTableGlobal &_driver = dispatcherGlobal.driver;
    _getProcAddress(reinterpret_cast<void (**)()>(&_driver.eglWaitClient),reinterpret_cast<void (*)()>(eglWaitClient),"eglWaitClient");
    return _driver.call(&_driver.eglWaitClient)();
  }

#endif // REGAL_SYS_EGL

  void Init(DispatchTableGL &tbl)
  {

  // GL_VERSION_1_0

    tbl.glAccum = glAccum;
    tbl.glAlphaFunc = glAlphaFunc;
    tbl.glBegin = glBegin;
    tbl.glBitmap = glBitmap;
    tbl.glBlendFunc = glBlendFunc;
    tbl.glCallList = glCallList;
    tbl.glCallLists = glCallLists;
    tbl.glClear = glClear;
    tbl.glClearAccum = glClearAccum;
    tbl.glClearColor = glClearColor;
    tbl.glClearDepth = glClearDepth;
    tbl.glClearIndex = glClearIndex;
    tbl.glClearStencil = glClearStencil;
    tbl.glClipPlane = glClipPlane;
    tbl.glColor3b = glColor3b;
    tbl.glColor3bv = glColor3bv;
    tbl.glColor3d = glColor3d;
    tbl.glColor3dv = glColor3dv;
    tbl.glColor3f = glColor3f;
    tbl.glColor3fv = glColor3fv;
    tbl.glColor3i = glColor3i;
    tbl.glColor3iv = glColor3iv;
    tbl.glColor3s = glColor3s;
    tbl.glColor3sv = glColor3sv;
    tbl.glColor3ub = glColor3ub;
    tbl.glColor3ubv = glColor3ubv;
    tbl.glColor3ui = glColor3ui;
    tbl.glColor3uiv = glColor3uiv;
    tbl.glColor3us = glColor3us;
    tbl.glColor3usv = glColor3usv;
    tbl.glColor4b = glColor4b;
    tbl.glColor4bv = glColor4bv;
    tbl.glColor4d = glColor4d;
    tbl.glColor4dv = glColor4dv;
    tbl.glColor4f = glColor4f;
    tbl.glColor4fv = glColor4fv;
    tbl.glColor4i = glColor4i;
    tbl.glColor4iv = glColor4iv;
    tbl.glColor4s = glColor4s;
    tbl.glColor4sv = glColor4sv;
    tbl.glColor4ub = glColor4ub;
    tbl.glColor4ubv = glColor4ubv;
    tbl.glColor4ui = glColor4ui;
    tbl.glColor4uiv = glColor4uiv;
    tbl.glColor4us = glColor4us;
    tbl.glColor4usv = glColor4usv;
    tbl.glColorMask = glColorMask;
    tbl.glColorMaterial = glColorMaterial;
    tbl.glCopyPixels = glCopyPixels;
    tbl.glCullFace = glCullFace;
    tbl.glDeleteLists = glDeleteLists;
    tbl.glDepthFunc = glDepthFunc;
    tbl.glDepthMask = glDepthMask;
    tbl.glDepthRange = glDepthRange;
    tbl.glDisable = glDisable;
    tbl.glDrawBuffer = glDrawBuffer;
    tbl.glDrawPixels = glDrawPixels;
    tbl.glEdgeFlag = glEdgeFlag;
    tbl.glEdgeFlagv = glEdgeFlagv;
    tbl.glEnable = glEnable;
    tbl.glEnd = glEnd;
    tbl.glEndList = glEndList;
    tbl.glEvalCoord1d = glEvalCoord1d;
    tbl.glEvalCoord1dv = glEvalCoord1dv;
    tbl.glEvalCoord1f = glEvalCoord1f;
    tbl.glEvalCoord1fv = glEvalCoord1fv;
    tbl.glEvalCoord2d = glEvalCoord2d;
    tbl.glEvalCoord2dv = glEvalCoord2dv;
    tbl.glEvalCoord2f = glEvalCoord2f;
    tbl.glEvalCoord2fv = glEvalCoord2fv;
    tbl.glEvalMesh1 = glEvalMesh1;
    tbl.glEvalMesh2 = glEvalMesh2;
    tbl.glEvalPoint1 = glEvalPoint1;
    tbl.glEvalPoint2 = glEvalPoint2;
    tbl.glFeedbackBuffer = glFeedbackBuffer;
    tbl.glFinish = glFinish;
    tbl.glFlush = glFlush;
    tbl.glFogf = glFogf;
    tbl.glFogfv = glFogfv;
    tbl.glFogi = glFogi;
    tbl.glFogiv = glFogiv;
    tbl.glFrontFace = glFrontFace;
    tbl.glFrustum = glFrustum;
    tbl.glGenLists = glGenLists;
    tbl.glGetBooleanv = glGetBooleanv;
    tbl.glGetClipPlane = glGetClipPlane;
    tbl.glGetDoublev = glGetDoublev;
    tbl.glGetError = glGetError;
    tbl.glGetFloatv = glGetFloatv;
    tbl.glGetIntegerv = glGetIntegerv;
    tbl.glGetLightfv = glGetLightfv;
    tbl.glGetLightiv = glGetLightiv;
    tbl.glGetMapdv = glGetMapdv;
    tbl.glGetMapfv = glGetMapfv;
    tbl.glGetMapiv = glGetMapiv;
    tbl.glGetMaterialfv = glGetMaterialfv;
    tbl.glGetMaterialiv = glGetMaterialiv;
    tbl.glGetPixelMapfv = glGetPixelMapfv;
    tbl.glGetPixelMapuiv = glGetPixelMapuiv;
    tbl.glGetPixelMapusv = glGetPixelMapusv;
    tbl.glGetPolygonStipple = glGetPolygonStipple;
    tbl.glGetString = glGetString;
    tbl.glGetTexEnvfv = glGetTexEnvfv;
    tbl.glGetTexEnviv = glGetTexEnviv;
    tbl.glGetTexGendv = glGetTexGendv;
    tbl.glGetTexGenfv = glGetTexGenfv;
    tbl.glGetTexGeniv = glGetTexGeniv;
    tbl.glGetTexImage = glGetTexImage;
    tbl.glGetTexLevelParameterfv = glGetTexLevelParameterfv;
    tbl.glGetTexLevelParameteriv = glGetTexLevelParameteriv;
    tbl.glGetTexParameterfv = glGetTexParameterfv;
    tbl.glGetTexParameteriv = glGetTexParameteriv;
    tbl.glHint = glHint;
    tbl.glIndexMask = glIndexMask;
    tbl.glIndexd = glIndexd;
    tbl.glIndexdv = glIndexdv;
    tbl.glIndexf = glIndexf;
    tbl.glIndexfv = glIndexfv;
    tbl.glIndexi = glIndexi;
    tbl.glIndexiv = glIndexiv;
    tbl.glIndexs = glIndexs;
    tbl.glIndexsv = glIndexsv;
    tbl.glInitNames = glInitNames;
    tbl.glIsEnabled = glIsEnabled;
    tbl.glIsList = glIsList;
    tbl.glLightModelf = glLightModelf;
    tbl.glLightModelfv = glLightModelfv;
    tbl.glLightModeli = glLightModeli;
    tbl.glLightModeliv = glLightModeliv;
    tbl.glLightf = glLightf;
    tbl.glLightfv = glLightfv;
    tbl.glLighti = glLighti;
    tbl.glLightiv = glLightiv;
    tbl.glLineStipple = glLineStipple;
    tbl.glLineWidth = glLineWidth;
    tbl.glListBase = glListBase;
    tbl.glLoadIdentity = glLoadIdentity;
    tbl.glLoadMatrixd = glLoadMatrixd;
    tbl.glLoadMatrixf = glLoadMatrixf;
    tbl.glLoadName = glLoadName;
    tbl.glLogicOp = glLogicOp;
    tbl.glMap1d = glMap1d;
    tbl.glMap1f = glMap1f;
    tbl.glMap2d = glMap2d;
    tbl.glMap2f = glMap2f;
    tbl.glMapGrid1d = glMapGrid1d;
    tbl.glMapGrid1f = glMapGrid1f;
    tbl.glMapGrid2d = glMapGrid2d;
    tbl.glMapGrid2f = glMapGrid2f;
    tbl.glMaterialf = glMaterialf;
    tbl.glMaterialfv = glMaterialfv;
    tbl.glMateriali = glMateriali;
    tbl.glMaterialiv = glMaterialiv;
    tbl.glMatrixMode = glMatrixMode;
    tbl.glMultMatrixd = glMultMatrixd;
    tbl.glMultMatrixf = glMultMatrixf;
    tbl.glNewList = glNewList;
    tbl.glNormal3b = glNormal3b;
    tbl.glNormal3bv = glNormal3bv;
    tbl.glNormal3d = glNormal3d;
    tbl.glNormal3dv = glNormal3dv;
    tbl.glNormal3f = glNormal3f;
    tbl.glNormal3fv = glNormal3fv;
    tbl.glNormal3i = glNormal3i;
    tbl.glNormal3iv = glNormal3iv;
    tbl.glNormal3s = glNormal3s;
    tbl.glNormal3sv = glNormal3sv;
    tbl.glOrtho = glOrtho;
    tbl.glPassThrough = glPassThrough;
    tbl.glPixelMapfv = glPixelMapfv;
    tbl.glPixelMapuiv = glPixelMapuiv;
    tbl.glPixelMapusv = glPixelMapusv;
    tbl.glPixelStoref = glPixelStoref;
    tbl.glPixelStorei = glPixelStorei;
    tbl.glPixelTransferf = glPixelTransferf;
    tbl.glPixelTransferi = glPixelTransferi;
    tbl.glPixelZoom = glPixelZoom;
    tbl.glPointSize = glPointSize;
    tbl.glPolygonMode = glPolygonMode;
    tbl.glPolygonStipple = glPolygonStipple;
    tbl.glPopAttrib = glPopAttrib;
    tbl.glPopMatrix = glPopMatrix;
    tbl.glPopName = glPopName;
    tbl.glPushAttrib = glPushAttrib;
    tbl.glPushMatrix = glPushMatrix;
    tbl.glPushName = glPushName;
    tbl.glRasterPos2d = glRasterPos2d;
    tbl.glRasterPos2dv = glRasterPos2dv;
    tbl.glRasterPos2f = glRasterPos2f;
    tbl.glRasterPos2fv = glRasterPos2fv;
    tbl.glRasterPos2i = glRasterPos2i;
    tbl.glRasterPos2iv = glRasterPos2iv;
    tbl.glRasterPos2s = glRasterPos2s;
    tbl.glRasterPos2sv = glRasterPos2sv;
    tbl.glRasterPos3d = glRasterPos3d;
    tbl.glRasterPos3dv = glRasterPos3dv;
    tbl.glRasterPos3f = glRasterPos3f;
    tbl.glRasterPos3fv = glRasterPos3fv;
    tbl.glRasterPos3i = glRasterPos3i;
    tbl.glRasterPos3iv = glRasterPos3iv;
    tbl.glRasterPos3s = glRasterPos3s;
    tbl.glRasterPos3sv = glRasterPos3sv;
    tbl.glRasterPos4d = glRasterPos4d;
    tbl.glRasterPos4dv = glRasterPos4dv;
    tbl.glRasterPos4f = glRasterPos4f;
    tbl.glRasterPos4fv = glRasterPos4fv;
    tbl.glRasterPos4i = glRasterPos4i;
    tbl.glRasterPos4iv = glRasterPos4iv;
    tbl.glRasterPos4s = glRasterPos4s;
    tbl.glRasterPos4sv = glRasterPos4sv;
    tbl.glReadBuffer = glReadBuffer;
    tbl.glReadPixels = glReadPixels;
    tbl.glRectd = glRectd;
    tbl.glRectdv = glRectdv;
    tbl.glRectf = glRectf;
    tbl.glRectfv = glRectfv;
    tbl.glRecti = glRecti;
    tbl.glRectiv = glRectiv;
    tbl.glRects = glRects;
    tbl.glRectsv = glRectsv;
    tbl.glRenderMode = glRenderMode;
    tbl.glRotated = glRotated;
    tbl.glRotatef = glRotatef;
    tbl.glScaled = glScaled;
    tbl.glScalef = glScalef;
    tbl.glScissor = glScissor;
    tbl.glSelectBuffer = glSelectBuffer;
    tbl.glShadeModel = glShadeModel;
    tbl.glStencilFunc = glStencilFunc;
    tbl.glStencilMask = glStencilMask;
    tbl.glStencilOp = glStencilOp;
    tbl.glTexCoord1d = glTexCoord1d;
    tbl.glTexCoord1dv = glTexCoord1dv;
    tbl.glTexCoord1f = glTexCoord1f;
    tbl.glTexCoord1fv = glTexCoord1fv;
    tbl.glTexCoord1i = glTexCoord1i;
    tbl.glTexCoord1iv = glTexCoord1iv;
    tbl.glTexCoord1s = glTexCoord1s;
    tbl.glTexCoord1sv = glTexCoord1sv;
    tbl.glTexCoord2d = glTexCoord2d;
    tbl.glTexCoord2dv = glTexCoord2dv;
    tbl.glTexCoord2f = glTexCoord2f;
    tbl.glTexCoord2fv = glTexCoord2fv;
    tbl.glTexCoord2i = glTexCoord2i;
    tbl.glTexCoord2iv = glTexCoord2iv;
    tbl.glTexCoord2s = glTexCoord2s;
    tbl.glTexCoord2sv = glTexCoord2sv;
    tbl.glTexCoord3d = glTexCoord3d;
    tbl.glTexCoord3dv = glTexCoord3dv;
    tbl.glTexCoord3f = glTexCoord3f;
    tbl.glTexCoord3fv = glTexCoord3fv;
    tbl.glTexCoord3i = glTexCoord3i;
    tbl.glTexCoord3iv = glTexCoord3iv;
    tbl.glTexCoord3s = glTexCoord3s;
    tbl.glTexCoord3sv = glTexCoord3sv;
    tbl.glTexCoord4d = glTexCoord4d;
    tbl.glTexCoord4dv = glTexCoord4dv;
    tbl.glTexCoord4f = glTexCoord4f;
    tbl.glTexCoord4fv = glTexCoord4fv;
    tbl.glTexCoord4i = glTexCoord4i;
    tbl.glTexCoord4iv = glTexCoord4iv;
    tbl.glTexCoord4s = glTexCoord4s;
    tbl.glTexCoord4sv = glTexCoord4sv;
    tbl.glTexEnvf = glTexEnvf;
    tbl.glTexEnvfv = glTexEnvfv;
    tbl.glTexEnvi = glTexEnvi;
    tbl.glTexEnviv = glTexEnviv;
    tbl.glTexGend = glTexGend;
    tbl.glTexGendv = glTexGendv;
    tbl.glTexGenf = glTexGenf;
    tbl.glTexGenfv = glTexGenfv;
    tbl.glTexGeni = glTexGeni;
    tbl.glTexGeniv = glTexGeniv;
    tbl.glTexImage1D = glTexImage1D;
    tbl.glTexImage2D = glTexImage2D;
    tbl.glTexParameterf = glTexParameterf;
    tbl.glTexParameterfv = glTexParameterfv;
    tbl.glTexParameteri = glTexParameteri;
    tbl.glTexParameteriv = glTexParameteriv;
    tbl.glTranslated = glTranslated;
    tbl.glTranslatef = glTranslatef;
    tbl.glVertex2d = glVertex2d;
    tbl.glVertex2dv = glVertex2dv;
    tbl.glVertex2f = glVertex2f;
    tbl.glVertex2fv = glVertex2fv;
    tbl.glVertex2i = glVertex2i;
    tbl.glVertex2iv = glVertex2iv;
    tbl.glVertex2s = glVertex2s;
    tbl.glVertex2sv = glVertex2sv;
    tbl.glVertex3d = glVertex3d;
    tbl.glVertex3dv = glVertex3dv;
    tbl.glVertex3f = glVertex3f;
    tbl.glVertex3fv = glVertex3fv;
    tbl.glVertex3i = glVertex3i;
    tbl.glVertex3iv = glVertex3iv;
    tbl.glVertex3s = glVertex3s;
    tbl.glVertex3sv = glVertex3sv;
    tbl.glVertex4d = glVertex4d;
    tbl.glVertex4dv = glVertex4dv;
    tbl.glVertex4f = glVertex4f;
    tbl.glVertex4fv = glVertex4fv;
    tbl.glVertex4i = glVertex4i;
    tbl.glVertex4iv = glVertex4iv;
    tbl.glVertex4s = glVertex4s;
    tbl.glVertex4sv = glVertex4sv;
    tbl.glViewport = glViewport;

  // GL_VERSION_1_1

    tbl.glAreTexturesResident = glAreTexturesResident;
    tbl.glArrayElement = glArrayElement;
    tbl.glBindTexture = glBindTexture;
    tbl.glColorPointer = glColorPointer;
    tbl.glCopyTexImage1D = glCopyTexImage1D;
    tbl.glCopyTexImage2D = glCopyTexImage2D;
    tbl.glCopyTexSubImage1D = glCopyTexSubImage1D;
    tbl.glCopyTexSubImage2D = glCopyTexSubImage2D;
    tbl.glDeleteTextures = glDeleteTextures;
    tbl.glDisableClientState = glDisableClientState;
    tbl.glDrawArrays = glDrawArrays;
    tbl.glDrawElements = glDrawElements;
    tbl.glEdgeFlagPointer = glEdgeFlagPointer;
    tbl.glEnableClientState = glEnableClientState;
    tbl.glGenTextures = glGenTextures;
    tbl.glGetPointerv = glGetPointerv;
    tbl.glIndexPointer = glIndexPointer;
    tbl.glIndexub = glIndexub;
    tbl.glIndexubv = glIndexubv;
    tbl.glInterleavedArrays = glInterleavedArrays;
    tbl.glIsTexture = glIsTexture;
    tbl.glNormalPointer = glNormalPointer;
    tbl.glPolygonOffset = glPolygonOffset;
    tbl.glPopClientAttrib = glPopClientAttrib;
    tbl.glPrioritizeTextures = glPrioritizeTextures;
    tbl.glPushClientAttrib = glPushClientAttrib;
    tbl.glTexCoordPointer = glTexCoordPointer;
    tbl.glTexSubImage1D = glTexSubImage1D;
    tbl.glTexSubImage2D = glTexSubImage2D;
    tbl.glVertexPointer = glVertexPointer;

  // GL_VERSION_1_2

    tbl.glBlendColor = glBlendColor;
    tbl.glBlendEquation = glBlendEquation;
    tbl.glCopyTexSubImage3D = glCopyTexSubImage3D;
    tbl.glDrawRangeElements = glDrawRangeElements;
    tbl.glTexImage3D = glTexImage3D;
    tbl.glTexSubImage3D = glTexSubImage3D;

  // GL_VERSION_1_3

    tbl.glActiveTexture = glActiveTexture;
    tbl.glClientActiveTexture = glClientActiveTexture;
    tbl.glCompressedTexImage1D = glCompressedTexImage1D;
    tbl.glCompressedTexImage2D = glCompressedTexImage2D;
    tbl.glCompressedTexImage3D = glCompressedTexImage3D;
    tbl.glCompressedTexSubImage1D = glCompressedTexSubImage1D;
    tbl.glCompressedTexSubImage2D = glCompressedTexSubImage2D;
    tbl.glCompressedTexSubImage3D = glCompressedTexSubImage3D;
    tbl.glGetCompressedTexImage = glGetCompressedTexImage;
    tbl.glLoadTransposeMatrixd = glLoadTransposeMatrixd;
    tbl.glLoadTransposeMatrixf = glLoadTransposeMatrixf;
    tbl.glMultTransposeMatrixd = glMultTransposeMatrixd;
    tbl.glMultTransposeMatrixf = glMultTransposeMatrixf;
    tbl.glMultiTexCoord1d = glMultiTexCoord1d;
    tbl.glMultiTexCoord1dv = glMultiTexCoord1dv;
    tbl.glMultiTexCoord1f = glMultiTexCoord1f;
    tbl.glMultiTexCoord1fv = glMultiTexCoord1fv;
    tbl.glMultiTexCoord1i = glMultiTexCoord1i;
    tbl.glMultiTexCoord1iv = glMultiTexCoord1iv;
    tbl.glMultiTexCoord1s = glMultiTexCoord1s;
    tbl.glMultiTexCoord1sv = glMultiTexCoord1sv;
    tbl.glMultiTexCoord2d = glMultiTexCoord2d;
    tbl.glMultiTexCoord2dv = glMultiTexCoord2dv;
    tbl.glMultiTexCoord2f = glMultiTexCoord2f;
    tbl.glMultiTexCoord2fv = glMultiTexCoord2fv;
    tbl.glMultiTexCoord2i = glMultiTexCoord2i;
    tbl.glMultiTexCoord2iv = glMultiTexCoord2iv;
    tbl.glMultiTexCoord2s = glMultiTexCoord2s;
    tbl.glMultiTexCoord2sv = glMultiTexCoord2sv;
    tbl.glMultiTexCoord3d = glMultiTexCoord3d;
    tbl.glMultiTexCoord3dv = glMultiTexCoord3dv;
    tbl.glMultiTexCoord3f = glMultiTexCoord3f;
    tbl.glMultiTexCoord3fv = glMultiTexCoord3fv;
    tbl.glMultiTexCoord3i = glMultiTexCoord3i;
    tbl.glMultiTexCoord3iv = glMultiTexCoord3iv;
    tbl.glMultiTexCoord3s = glMultiTexCoord3s;
    tbl.glMultiTexCoord3sv = glMultiTexCoord3sv;
    tbl.glMultiTexCoord4d = glMultiTexCoord4d;
    tbl.glMultiTexCoord4dv = glMultiTexCoord4dv;
    tbl.glMultiTexCoord4f = glMultiTexCoord4f;
    tbl.glMultiTexCoord4fv = glMultiTexCoord4fv;
    tbl.glMultiTexCoord4i = glMultiTexCoord4i;
    tbl.glMultiTexCoord4iv = glMultiTexCoord4iv;
    tbl.glMultiTexCoord4s = glMultiTexCoord4s;
    tbl.glMultiTexCoord4sv = glMultiTexCoord4sv;
    tbl.glSampleCoverage = glSampleCoverage;

  // GL_VERSION_1_4

    tbl.glBlendFuncSeparate = glBlendFuncSeparate;
    tbl.glFogCoordPointer = glFogCoordPointer;
    tbl.glFogCoordd = glFogCoordd;
    tbl.glFogCoorddv = glFogCoorddv;
    tbl.glFogCoordf = glFogCoordf;
    tbl.glFogCoordfv = glFogCoordfv;
    tbl.glMultiDrawArrays = glMultiDrawArrays;
    tbl.glMultiDrawElements = glMultiDrawElements;
    tbl.glPointParameterf = glPointParameterf;
    tbl.glPointParameterfv = glPointParameterfv;
    tbl.glPointParameteri = glPointParameteri;
    tbl.glPointParameteriv = glPointParameteriv;
    tbl.glSecondaryColor3b = glSecondaryColor3b;
    tbl.glSecondaryColor3bv = glSecondaryColor3bv;
    tbl.glSecondaryColor3d = glSecondaryColor3d;
    tbl.glSecondaryColor3dv = glSecondaryColor3dv;
    tbl.glSecondaryColor3f = glSecondaryColor3f;
    tbl.glSecondaryColor3fv = glSecondaryColor3fv;
    tbl.glSecondaryColor3i = glSecondaryColor3i;
    tbl.glSecondaryColor3iv = glSecondaryColor3iv;
    tbl.glSecondaryColor3s = glSecondaryColor3s;
    tbl.glSecondaryColor3sv = glSecondaryColor3sv;
    tbl.glSecondaryColor3ub = glSecondaryColor3ub;
    tbl.glSecondaryColor3ubv = glSecondaryColor3ubv;
    tbl.glSecondaryColor3ui = glSecondaryColor3ui;
    tbl.glSecondaryColor3uiv = glSecondaryColor3uiv;
    tbl.glSecondaryColor3us = glSecondaryColor3us;
    tbl.glSecondaryColor3usv = glSecondaryColor3usv;
    tbl.glSecondaryColorPointer = glSecondaryColorPointer;
    tbl.glWindowPos2d = glWindowPos2d;
    tbl.glWindowPos2dv = glWindowPos2dv;
    tbl.glWindowPos2f = glWindowPos2f;
    tbl.glWindowPos2fv = glWindowPos2fv;
    tbl.glWindowPos2i = glWindowPos2i;
    tbl.glWindowPos2iv = glWindowPos2iv;
    tbl.glWindowPos2s = glWindowPos2s;
    tbl.glWindowPos2sv = glWindowPos2sv;
    tbl.glWindowPos3d = glWindowPos3d;
    tbl.glWindowPos3dv = glWindowPos3dv;
    tbl.glWindowPos3f = glWindowPos3f;
    tbl.glWindowPos3fv = glWindowPos3fv;
    tbl.glWindowPos3i = glWindowPos3i;
    tbl.glWindowPos3iv = glWindowPos3iv;
    tbl.glWindowPos3s = glWindowPos3s;
    tbl.glWindowPos3sv = glWindowPos3sv;

  // GL_VERSION_1_5

    tbl.glBeginQuery = glBeginQuery;
    tbl.glBindBuffer = glBindBuffer;
    tbl.glBufferData = glBufferData;
    tbl.glBufferSubData = glBufferSubData;
    tbl.glDeleteBuffers = glDeleteBuffers;
    tbl.glDeleteQueries = glDeleteQueries;
    tbl.glEndQuery = glEndQuery;
    tbl.glGenBuffers = glGenBuffers;
    tbl.glGenQueries = glGenQueries;
    tbl.glGetBufferParameteriv = glGetBufferParameteriv;
    tbl.glGetBufferPointerv = glGetBufferPointerv;
    tbl.glGetBufferSubData = glGetBufferSubData;
    tbl.glGetQueryObjectiv = glGetQueryObjectiv;
    tbl.glGetQueryObjectuiv = glGetQueryObjectuiv;
    tbl.glGetQueryiv = glGetQueryiv;
    tbl.glIsBuffer = glIsBuffer;
    tbl.glIsQuery = glIsQuery;
    tbl.glMapBuffer = glMapBuffer;
    tbl.glUnmapBuffer = glUnmapBuffer;

  // GL_VERSION_2_0

    tbl.glAttachShader = glAttachShader;
    tbl.glBindAttribLocation = glBindAttribLocation;
    tbl.glBlendEquationSeparate = glBlendEquationSeparate;
    tbl.glCompileShader = glCompileShader;
    tbl.glCreateProgram = glCreateProgram;
    tbl.glCreateShader = glCreateShader;
    tbl.glDeleteProgram = glDeleteProgram;
    tbl.glDeleteShader = glDeleteShader;
    tbl.glDetachShader = glDetachShader;
    tbl.glDisableVertexAttribArray = glDisableVertexAttribArray;
    tbl.glDrawBuffers = glDrawBuffers;
    tbl.glEnableVertexAttribArray = glEnableVertexAttribArray;
    tbl.glGetActiveAttrib = glGetActiveAttrib;
    tbl.glGetActiveUniform = glGetActiveUniform;
    tbl.glGetAttachedShaders = glGetAttachedShaders;
    tbl.glGetAttribLocation = glGetAttribLocation;
    tbl.glGetProgramInfoLog = glGetProgramInfoLog;
    tbl.glGetProgramiv = glGetProgramiv;
    tbl.glGetShaderInfoLog = glGetShaderInfoLog;
    tbl.glGetShaderSource = glGetShaderSource;
    tbl.glGetShaderiv = glGetShaderiv;
    tbl.glGetUniformLocation = glGetUniformLocation;
    tbl.glGetUniformfv = glGetUniformfv;
    tbl.glGetUniformiv = glGetUniformiv;
    tbl.glGetVertexAttribPointerv = glGetVertexAttribPointerv;
    tbl.glGetVertexAttribdv = glGetVertexAttribdv;
    tbl.glGetVertexAttribfv = glGetVertexAttribfv;
    tbl.glGetVertexAttribiv = glGetVertexAttribiv;
    tbl.glIsProgram = glIsProgram;
    tbl.glIsShader = glIsShader;
    tbl.glLinkProgram = glLinkProgram;
    tbl.glShaderSource = glShaderSource;
    tbl.glStencilFuncSeparate = glStencilFuncSeparate;
    tbl.glStencilMaskSeparate = glStencilMaskSeparate;
    tbl.glStencilOpSeparate = glStencilOpSeparate;
    tbl.glUniform1f = glUniform1f;
    tbl.glUniform1fv = glUniform1fv;
    tbl.glUniform1i = glUniform1i;
    tbl.glUniform1iv = glUniform1iv;
    tbl.glUniform2f = glUniform2f;
    tbl.glUniform2fv = glUniform2fv;
    tbl.glUniform2i = glUniform2i;
    tbl.glUniform2iv = glUniform2iv;
    tbl.glUniform3f = glUniform3f;
    tbl.glUniform3fv = glUniform3fv;
    tbl.glUniform3i = glUniform3i;
    tbl.glUniform3iv = glUniform3iv;
    tbl.glUniform4f = glUniform4f;
    tbl.glUniform4fv = glUniform4fv;
    tbl.glUniform4i = glUniform4i;
    tbl.glUniform4iv = glUniform4iv;
    tbl.glUniformMatrix2fv = glUniformMatrix2fv;
    tbl.glUniformMatrix3fv = glUniformMatrix3fv;
    tbl.glUniformMatrix4fv = glUniformMatrix4fv;
    tbl.glUseProgram = glUseProgram;
    tbl.glValidateProgram = glValidateProgram;
    tbl.glVertexAttrib1d = glVertexAttrib1d;
    tbl.glVertexAttrib1dv = glVertexAttrib1dv;
    tbl.glVertexAttrib1f = glVertexAttrib1f;
    tbl.glVertexAttrib1fv = glVertexAttrib1fv;
    tbl.glVertexAttrib1s = glVertexAttrib1s;
    tbl.glVertexAttrib1sv = glVertexAttrib1sv;
    tbl.glVertexAttrib2d = glVertexAttrib2d;
    tbl.glVertexAttrib2dv = glVertexAttrib2dv;
    tbl.glVertexAttrib2f = glVertexAttrib2f;
    tbl.glVertexAttrib2fv = glVertexAttrib2fv;
    tbl.glVertexAttrib2s = glVertexAttrib2s;
    tbl.glVertexAttrib2sv = glVertexAttrib2sv;
    tbl.glVertexAttrib3d = glVertexAttrib3d;
    tbl.glVertexAttrib3dv = glVertexAttrib3dv;
    tbl.glVertexAttrib3f = glVertexAttrib3f;
    tbl.glVertexAttrib3fv = glVertexAttrib3fv;
    tbl.glVertexAttrib3s = glVertexAttrib3s;
    tbl.glVertexAttrib3sv = glVertexAttrib3sv;
    tbl.glVertexAttrib4Nbv = glVertexAttrib4Nbv;
    tbl.glVertexAttrib4Niv = glVertexAttrib4Niv;
    tbl.glVertexAttrib4Nsv = glVertexAttrib4Nsv;
    tbl.glVertexAttrib4Nub = glVertexAttrib4Nub;
    tbl.glVertexAttrib4Nubv = glVertexAttrib4Nubv;
    tbl.glVertexAttrib4Nuiv = glVertexAttrib4Nuiv;
    tbl.glVertexAttrib4Nusv = glVertexAttrib4Nusv;
    tbl.glVertexAttrib4bv = glVertexAttrib4bv;
    tbl.glVertexAttrib4d = glVertexAttrib4d;
    tbl.glVertexAttrib4dv = glVertexAttrib4dv;
    tbl.glVertexAttrib4f = glVertexAttrib4f;
    tbl.glVertexAttrib4fv = glVertexAttrib4fv;
    tbl.glVertexAttrib4iv = glVertexAttrib4iv;
    tbl.glVertexAttrib4s = glVertexAttrib4s;
    tbl.glVertexAttrib4sv = glVertexAttrib4sv;
    tbl.glVertexAttrib4ubv = glVertexAttrib4ubv;
    tbl.glVertexAttrib4uiv = glVertexAttrib4uiv;
    tbl.glVertexAttrib4usv = glVertexAttrib4usv;
    tbl.glVertexAttribPointer = glVertexAttribPointer;

  // GL_VERSION_2_1

    tbl.glUniformMatrix2x3fv = glUniformMatrix2x3fv;
    tbl.glUniformMatrix2x4fv = glUniformMatrix2x4fv;
    tbl.glUniformMatrix3x2fv = glUniformMatrix3x2fv;
    tbl.glUniformMatrix3x4fv = glUniformMatrix3x4fv;
    tbl.glUniformMatrix4x2fv = glUniformMatrix4x2fv;
    tbl.glUniformMatrix4x3fv = glUniformMatrix4x3fv;

  // GL_VERSION_3_0

    tbl.glBeginConditionalRender = glBeginConditionalRender;
    tbl.glBeginTransformFeedback = glBeginTransformFeedback;
    tbl.glBindFragDataLocation = glBindFragDataLocation;
    tbl.glClampColor = glClampColor;
    tbl.glClearBufferfi = glClearBufferfi;
    tbl.glClearBufferfv = glClearBufferfv;
    tbl.glClearBufferiv = glClearBufferiv;
    tbl.glClearBufferuiv = glClearBufferuiv;
    tbl.glColorMaski = glColorMaski;
    tbl.glDisablei = glDisablei;
    tbl.glEnablei = glEnablei;
    tbl.glEndConditionalRender = glEndConditionalRender;
    tbl.glEndTransformFeedback = glEndTransformFeedback;
    tbl.glGetBooleani_v = glGetBooleani_v;
    tbl.glGetFragDataLocation = glGetFragDataLocation;
    tbl.glGetStringi = glGetStringi;
    tbl.glGetTexParameterIiv = glGetTexParameterIiv;
    tbl.glGetTexParameterIuiv = glGetTexParameterIuiv;
    tbl.glGetTransformFeedbackVarying = glGetTransformFeedbackVarying;
    tbl.glGetUniformuiv = glGetUniformuiv;
    tbl.glGetVertexAttribIiv = glGetVertexAttribIiv;
    tbl.glGetVertexAttribIuiv = glGetVertexAttribIuiv;
    tbl.glIsEnabledi = glIsEnabledi;
    tbl.glTexParameterIiv = glTexParameterIiv;
    tbl.glTexParameterIuiv = glTexParameterIuiv;
    tbl.glTransformFeedbackVaryings = glTransformFeedbackVaryings;
    tbl.glUniform1ui = glUniform1ui;
    tbl.glUniform1uiv = glUniform1uiv;
    tbl.glUniform2ui = glUniform2ui;
    tbl.glUniform2uiv = glUniform2uiv;
    tbl.glUniform3ui = glUniform3ui;
    tbl.glUniform3uiv = glUniform3uiv;
    tbl.glUniform4ui = glUniform4ui;
    tbl.glUniform4uiv = glUniform4uiv;
    tbl.glVertexAttribI1i = glVertexAttribI1i;
    tbl.glVertexAttribI1iv = glVertexAttribI1iv;
    tbl.glVertexAttribI1ui = glVertexAttribI1ui;
    tbl.glVertexAttribI1uiv = glVertexAttribI1uiv;
    tbl.glVertexAttribI2i = glVertexAttribI2i;
    tbl.glVertexAttribI2iv = glVertexAttribI2iv;
    tbl.glVertexAttribI2ui = glVertexAttribI2ui;
    tbl.glVertexAttribI2uiv = glVertexAttribI2uiv;
    tbl.glVertexAttribI3i = glVertexAttribI3i;
    tbl.glVertexAttribI3iv = glVertexAttribI3iv;
    tbl.glVertexAttribI3ui = glVertexAttribI3ui;
    tbl.glVertexAttribI3uiv = glVertexAttribI3uiv;
    tbl.glVertexAttribI4bv = glVertexAttribI4bv;
    tbl.glVertexAttribI4i = glVertexAttribI4i;
    tbl.glVertexAttribI4iv = glVertexAttribI4iv;
    tbl.glVertexAttribI4sv = glVertexAttribI4sv;
    tbl.glVertexAttribI4ubv = glVertexAttribI4ubv;
    tbl.glVertexAttribI4ui = glVertexAttribI4ui;
    tbl.glVertexAttribI4uiv = glVertexAttribI4uiv;
    tbl.glVertexAttribI4usv = glVertexAttribI4usv;
    tbl.glVertexAttribIPointer = glVertexAttribIPointer;

  // GL_VERSION_3_1

    tbl.glDrawArraysInstanced = glDrawArraysInstanced;
    tbl.glDrawElementsInstanced = glDrawElementsInstanced;
    tbl.glPrimitiveRestartIndex = glPrimitiveRestartIndex;
    tbl.glTexBuffer = glTexBuffer;

  // GL_VERSION_3_2

    tbl.glFramebufferTexture = glFramebufferTexture;
    tbl.glGetBufferParameteri64v = glGetBufferParameteri64v;
    tbl.glGetInteger64i_v = glGetInteger64i_v;

  // GL_VERSION_3_3

    tbl.glVertexAttribDivisor = glVertexAttribDivisor;

  // GL_VERSION_4_0

    tbl.glBlendEquationSeparatei = glBlendEquationSeparatei;
    tbl.glBlendEquationi = glBlendEquationi;
    tbl.glBlendFuncSeparatei = glBlendFuncSeparatei;
    tbl.glBlendFunci = glBlendFunci;

  // GL_3DFX_tbuffer

    tbl.glTbufferMask3DFX = glTbufferMask3DFX;

  // GL_AMD_debug_output

    tbl.glDebugMessageCallbackAMD = glDebugMessageCallbackAMD;
    tbl.glDebugMessageEnableAMD = glDebugMessageEnableAMD;
    tbl.glDebugMessageInsertAMD = glDebugMessageInsertAMD;
    tbl.glGetDebugMessageLogAMD = glGetDebugMessageLogAMD;

  // GL_AMD_draw_buffers_blend

    tbl.glBlendEquationIndexedAMD = glBlendEquationIndexedAMD;
    tbl.glBlendEquationSeparateIndexedAMD = glBlendEquationSeparateIndexedAMD;
    tbl.glBlendFuncIndexedAMD = glBlendFuncIndexedAMD;
    tbl.glBlendFuncSeparateIndexedAMD = glBlendFuncSeparateIndexedAMD;

  // GL_AMD_interleaved_elements

    tbl.glVertexAttribParameteriAMD = glVertexAttribParameteriAMD;

  // GL_AMD_multi_draw_indirect

    tbl.glMultiDrawArraysIndirectAMD = glMultiDrawArraysIndirectAMD;
    tbl.glMultiDrawElementsIndirectAMD = glMultiDrawElementsIndirectAMD;

  // GL_AMD_name_gen_delete

    tbl.glDeleteNamesAMD = glDeleteNamesAMD;
    tbl.glGenNamesAMD = glGenNamesAMD;
    tbl.glIsNameAMD = glIsNameAMD;

  // GL_AMD_performance_monitor

    tbl.glBeginPerfMonitorAMD = glBeginPerfMonitorAMD;
    tbl.glDeletePerfMonitorsAMD = glDeletePerfMonitorsAMD;
    tbl.glEndPerfMonitorAMD = glEndPerfMonitorAMD;
    tbl.glGenPerfMonitorsAMD = glGenPerfMonitorsAMD;
    tbl.glGetPerfMonitorCounterDataAMD = glGetPerfMonitorCounterDataAMD;
    tbl.glGetPerfMonitorCounterInfoAMD = glGetPerfMonitorCounterInfoAMD;
    tbl.glGetPerfMonitorCounterStringAMD = glGetPerfMonitorCounterStringAMD;
    tbl.glGetPerfMonitorCountersAMD = glGetPerfMonitorCountersAMD;
    tbl.glGetPerfMonitorGroupStringAMD = glGetPerfMonitorGroupStringAMD;
    tbl.glGetPerfMonitorGroupsAMD = glGetPerfMonitorGroupsAMD;
    tbl.glSelectPerfMonitorCountersAMD = glSelectPerfMonitorCountersAMD;

  // GL_AMD_sample_positions

    tbl.glSetMultisamplefvAMD = glSetMultisamplefvAMD;

  // GL_AMD_sparse_texture

    tbl.glTexStorageSparseAMD = glTexStorageSparseAMD;
    tbl.glTextureStorageSparseAMD = glTextureStorageSparseAMD;

  // GL_AMD_stencil_operation_extended

    tbl.glStencilOpValueAMD = glStencilOpValueAMD;

  // GL_AMD_vertex_shader_tessellator

    tbl.glTessellationFactorAMD = glTessellationFactorAMD;
    tbl.glTessellationModeAMD = glTessellationModeAMD;

  // GL_ANGLE_framebuffer_blit

    tbl.glBlitFramebufferANGLE = glBlitFramebufferANGLE;

  // GL_ANGLE_framebuffer_multisample

    tbl.glRenderbufferStorageMultisampleANGLE = glRenderbufferStorageMultisampleANGLE;

  // GL_ANGLE_instanced_arrays

    tbl.glDrawArraysInstancedANGLE = glDrawArraysInstancedANGLE;
    tbl.glDrawElementsInstancedANGLE = glDrawElementsInstancedANGLE;
    tbl.glVertexAttribDivisorANGLE = glVertexAttribDivisorANGLE;

  // GL_ANGLE_timer_query

    tbl.glBeginQueryANGLE = glBeginQueryANGLE;
    tbl.glDeleteQueriesANGLE = glDeleteQueriesANGLE;
    tbl.glEndQueryANGLE = glEndQueryANGLE;
    tbl.glGenQueriesANGLE = glGenQueriesANGLE;
    tbl.glGetQueryObjecti64vANGLE = glGetQueryObjecti64vANGLE;
    tbl.glGetQueryObjectivANGLE = glGetQueryObjectivANGLE;
    tbl.glGetQueryObjectui64vANGLE = glGetQueryObjectui64vANGLE;
    tbl.glGetQueryObjectuivANGLE = glGetQueryObjectuivANGLE;
    tbl.glGetQueryivANGLE = glGetQueryivANGLE;
    tbl.glIsQueryANGLE = glIsQueryANGLE;
    tbl.glQueryCounterANGLE = glQueryCounterANGLE;

  // GL_ANGLE_translated_shader_source

    tbl.glGetTranslatedShaderSourceANGLE = glGetTranslatedShaderSourceANGLE;

  // GL_APPLE_copy_texture_levels

    tbl.glCopyTextureLevelsAPPLE = glCopyTextureLevelsAPPLE;

  // GL_APPLE_element_array

    tbl.glDrawElementArrayAPPLE = glDrawElementArrayAPPLE;
    tbl.glDrawRangeElementArrayAPPLE = glDrawRangeElementArrayAPPLE;
    tbl.glElementPointerAPPLE = glElementPointerAPPLE;
    tbl.glMultiDrawElementArrayAPPLE = glMultiDrawElementArrayAPPLE;
    tbl.glMultiDrawRangeElementArrayAPPLE = glMultiDrawRangeElementArrayAPPLE;

  // GL_APPLE_fence

    tbl.glDeleteFencesAPPLE = glDeleteFencesAPPLE;
    tbl.glFinishFenceAPPLE = glFinishFenceAPPLE;
    tbl.glFinishObjectAPPLE = glFinishObjectAPPLE;
    tbl.glGenFencesAPPLE = glGenFencesAPPLE;
    tbl.glIsFenceAPPLE = glIsFenceAPPLE;
    tbl.glSetFenceAPPLE = glSetFenceAPPLE;
    tbl.glTestFenceAPPLE = glTestFenceAPPLE;
    tbl.glTestObjectAPPLE = glTestObjectAPPLE;

  // GL_APPLE_flush_buffer_range

    tbl.glBufferParameteriAPPLE = glBufferParameteriAPPLE;
    tbl.glFlushMappedBufferRangeAPPLE = glFlushMappedBufferRangeAPPLE;

  // GL_APPLE_flush_render

    tbl.glFinishRenderAPPLE = glFinishRenderAPPLE;
    tbl.glFlushRenderAPPLE = glFlushRenderAPPLE;
    tbl.glSwapAPPLE = glSwapAPPLE;

  // GL_APPLE_framebuffer_multisample

    tbl.glRenderbufferStorageMultisampleAPPLE = glRenderbufferStorageMultisampleAPPLE;
    tbl.glResolveMultisampleFramebufferAPPLE = glResolveMultisampleFramebufferAPPLE;

  // GL_APPLE_object_purgeable

    tbl.glGetObjectParameterivAPPLE = glGetObjectParameterivAPPLE;
    tbl.glObjectPurgeableAPPLE = glObjectPurgeableAPPLE;
    tbl.glObjectUnpurgeableAPPLE = glObjectUnpurgeableAPPLE;

  // GL_APPLE_sync

    tbl.glClientWaitSyncAPPLE = glClientWaitSyncAPPLE;
    tbl.glDeleteSyncAPPLE = glDeleteSyncAPPLE;
    tbl.glFenceSyncAPPLE = glFenceSyncAPPLE;
    tbl.glGetInteger64vAPPLE = glGetInteger64vAPPLE;
    tbl.glGetSyncivAPPLE = glGetSyncivAPPLE;
    tbl.glIsSyncAPPLE = glIsSyncAPPLE;
    tbl.glWaitSyncAPPLE = glWaitSyncAPPLE;

  // GL_APPLE_texture_range

    tbl.glGetTexParameterPointervAPPLE = glGetTexParameterPointervAPPLE;
    tbl.glTextureRangeAPPLE = glTextureRangeAPPLE;

  // GL_APPLE_vertex_array_object

    tbl.glBindVertexArrayAPPLE = glBindVertexArrayAPPLE;
    tbl.glDeleteVertexArraysAPPLE = glDeleteVertexArraysAPPLE;
    tbl.glGenVertexArraysAPPLE = glGenVertexArraysAPPLE;
    tbl.glIsVertexArrayAPPLE = glIsVertexArrayAPPLE;

  // GL_APPLE_vertex_array_range

    tbl.glFlushVertexArrayRangeAPPLE = glFlushVertexArrayRangeAPPLE;
    tbl.glVertexArrayParameteriAPPLE = glVertexArrayParameteriAPPLE;
    tbl.glVertexArrayRangeAPPLE = glVertexArrayRangeAPPLE;

  // GL_APPLE_vertex_program_evaluators

    tbl.glDisableVertexAttribAPPLE = glDisableVertexAttribAPPLE;
    tbl.glEnableVertexAttribAPPLE = glEnableVertexAttribAPPLE;
    tbl.glIsVertexAttribEnabledAPPLE = glIsVertexAttribEnabledAPPLE;
    tbl.glMapVertexAttrib1dAPPLE = glMapVertexAttrib1dAPPLE;
    tbl.glMapVertexAttrib1fAPPLE = glMapVertexAttrib1fAPPLE;
    tbl.glMapVertexAttrib2dAPPLE = glMapVertexAttrib2dAPPLE;
    tbl.glMapVertexAttrib2fAPPLE = glMapVertexAttrib2fAPPLE;

  // GL_ARB_ES2_compatibility

    tbl.glClearDepthf = glClearDepthf;
    tbl.glDepthRangef = glDepthRangef;
    tbl.glGetShaderPrecisionFormat = glGetShaderPrecisionFormat;
    tbl.glReleaseShaderCompiler = glReleaseShaderCompiler;
    tbl.glShaderBinary = glShaderBinary;

  // GL_ARB_base_instance

    tbl.glDrawArraysInstancedBaseInstance = glDrawArraysInstancedBaseInstance;
    tbl.glDrawElementsInstancedBaseInstance = glDrawElementsInstancedBaseInstance;
    tbl.glDrawElementsInstancedBaseVertexBaseInstance = glDrawElementsInstancedBaseVertexBaseInstance;

  // GL_ARB_bindless_texture

    tbl.glGetImageHandleARB = glGetImageHandleARB;
    tbl.glGetTextureHandleARB = glGetTextureHandleARB;
    tbl.glGetTextureSamplerHandleARB = glGetTextureSamplerHandleARB;
    tbl.glGetVertexAttribLui64vARB = glGetVertexAttribLui64vARB;
    tbl.glIsImageHandleResidentARB = glIsImageHandleResidentARB;
    tbl.glIsTextureHandleResidentARB = glIsTextureHandleResidentARB;
    tbl.glMakeImageHandleNonResidentARB = glMakeImageHandleNonResidentARB;
    tbl.glMakeImageHandleResidentARB = glMakeImageHandleResidentARB;
    tbl.glMakeTextureHandleNonResidentARB = glMakeTextureHandleNonResidentARB;
    tbl.glMakeTextureHandleResidentARB = glMakeTextureHandleResidentARB;
    tbl.glProgramUniformHandleui64ARB = glProgramUniformHandleui64ARB;
    tbl.glProgramUniformHandleui64vARB = glProgramUniformHandleui64vARB;
    tbl.glUniformHandleui64ARB = glUniformHandleui64ARB;
    tbl.glUniformHandleui64vARB = glUniformHandleui64vARB;
    tbl.glVertexAttribL1ui64ARB = glVertexAttribL1ui64ARB;
    tbl.glVertexAttribL1ui64vARB = glVertexAttribL1ui64vARB;

  // GL_ARB_blend_func_extended

    tbl.glBindFragDataLocationIndexed = glBindFragDataLocationIndexed;
    tbl.glGetFragDataIndex = glGetFragDataIndex;

  // GL_ARB_buffer_storage

    tbl.glBufferStorage = glBufferStorage;
    tbl.glNamedBufferStorageEXT = glNamedBufferStorageEXT;

  // GL_ARB_cl_event

    tbl.glCreateSyncFromCLeventARB = glCreateSyncFromCLeventARB;

  // GL_ARB_clear_buffer_object

    tbl.glClearBufferData = glClearBufferData;
    tbl.glClearBufferSubData = glClearBufferSubData;
    tbl.glClearNamedBufferDataEXT = glClearNamedBufferDataEXT;
    tbl.glClearNamedBufferSubDataEXT = glClearNamedBufferSubDataEXT;

  // GL_ARB_clear_texture

    tbl.glClearTexImage = glClearTexImage;
    tbl.glClearTexSubImage = glClearTexSubImage;

  // GL_ARB_color_buffer_float

    tbl.glClampColorARB = glClampColorARB;

  // GL_ARB_compute_shader

    tbl.glDispatchCompute = glDispatchCompute;
    tbl.glDispatchComputeIndirect = glDispatchComputeIndirect;

  // GL_ARB_compute_variable_group_size

    tbl.glDispatchComputeGroupSizeARB = glDispatchComputeGroupSizeARB;

  // GL_ARB_copy_buffer

    tbl.glCopyBufferSubData = glCopyBufferSubData;

  // GL_ARB_copy_image

    tbl.glCopyImageSubData = glCopyImageSubData;

  // GL_ARB_debug_output

    tbl.glDebugMessageCallbackARB = glDebugMessageCallbackARB;
    tbl.glDebugMessageControlARB = glDebugMessageControlARB;
    tbl.glDebugMessageInsertARB = glDebugMessageInsertARB;
    tbl.glGetDebugMessageLogARB = glGetDebugMessageLogARB;

  // GL_ARB_draw_buffers

    tbl.glDrawBuffersARB = glDrawBuffersARB;

  // GL_ARB_draw_buffers_blend

    tbl.glBlendEquationSeparateiARB = glBlendEquationSeparateiARB;
    tbl.glBlendEquationiARB = glBlendEquationiARB;
    tbl.glBlendFuncSeparateiARB = glBlendFuncSeparateiARB;
    tbl.glBlendFunciARB = glBlendFunciARB;

  // GL_ARB_draw_elements_base_vertex

    tbl.glDrawElementsBaseVertex = glDrawElementsBaseVertex;
    tbl.glDrawElementsInstancedBaseVertex = glDrawElementsInstancedBaseVertex;
    tbl.glDrawRangeElementsBaseVertex = glDrawRangeElementsBaseVertex;
    tbl.glMultiDrawElementsBaseVertex = glMultiDrawElementsBaseVertex;

  // GL_ARB_draw_indirect

    tbl.glDrawArraysIndirect = glDrawArraysIndirect;
    tbl.glDrawElementsIndirect = glDrawElementsIndirect;

  // GL_ARB_draw_instanced

    tbl.glDrawArraysInstancedARB = glDrawArraysInstancedARB;
    tbl.glDrawElementsInstancedARB = glDrawElementsInstancedARB;

  // GL_ARB_framebuffer_no_attachments

    tbl.glFramebufferParameteri = glFramebufferParameteri;
    tbl.glGetFramebufferParameteriv = glGetFramebufferParameteriv;
    tbl.glGetNamedFramebufferParameterivEXT = glGetNamedFramebufferParameterivEXT;
    tbl.glNamedFramebufferParameteriEXT = glNamedFramebufferParameteriEXT;

  // GL_ARB_framebuffer_object

    tbl.glBindFramebuffer = glBindFramebuffer;
    tbl.glBindRenderbuffer = glBindRenderbuffer;
    tbl.glBlitFramebuffer = glBlitFramebuffer;
    tbl.glCheckFramebufferStatus = glCheckFramebufferStatus;
    tbl.glDeleteFramebuffers = glDeleteFramebuffers;
    tbl.glDeleteRenderbuffers = glDeleteRenderbuffers;
    tbl.glFramebufferRenderbuffer = glFramebufferRenderbuffer;
    tbl.glFramebufferTexture1D = glFramebufferTexture1D;
    tbl.glFramebufferTexture2D = glFramebufferTexture2D;
    tbl.glFramebufferTexture3D = glFramebufferTexture3D;
    tbl.glFramebufferTextureLayer = glFramebufferTextureLayer;
    tbl.glGenFramebuffers = glGenFramebuffers;
    tbl.glGenRenderbuffers = glGenRenderbuffers;
    tbl.glGenerateMipmap = glGenerateMipmap;
    tbl.glGetFramebufferAttachmentParameteriv = glGetFramebufferAttachmentParameteriv;
    tbl.glGetRenderbufferParameteriv = glGetRenderbufferParameteriv;
    tbl.glIsFramebuffer = glIsFramebuffer;
    tbl.glIsRenderbuffer = glIsRenderbuffer;
    tbl.glRenderbufferStorage = glRenderbufferStorage;
    tbl.glRenderbufferStorageMultisample = glRenderbufferStorageMultisample;

  // GL_ARB_geometry_shader4

    tbl.glFramebufferTextureARB = glFramebufferTextureARB;
    tbl.glFramebufferTextureFaceARB = glFramebufferTextureFaceARB;
    tbl.glFramebufferTextureLayerARB = glFramebufferTextureLayerARB;
    tbl.glProgramParameteriARB = glProgramParameteriARB;

  // GL_ARB_get_program_binary

    tbl.glGetProgramBinary = glGetProgramBinary;
    tbl.glProgramBinary = glProgramBinary;
    tbl.glProgramParameteri = glProgramParameteri;

  // GL_ARB_gpu_shader_fp64

    tbl.glGetUniformdv = glGetUniformdv;
    tbl.glUniform1d = glUniform1d;
    tbl.glUniform1dv = glUniform1dv;
    tbl.glUniform2d = glUniform2d;
    tbl.glUniform2dv = glUniform2dv;
    tbl.glUniform3d = glUniform3d;
    tbl.glUniform3dv = glUniform3dv;
    tbl.glUniform4d = glUniform4d;
    tbl.glUniform4dv = glUniform4dv;
    tbl.glUniformMatrix2dv = glUniformMatrix2dv;
    tbl.glUniformMatrix2x3dv = glUniformMatrix2x3dv;
    tbl.glUniformMatrix2x4dv = glUniformMatrix2x4dv;
    tbl.glUniformMatrix3dv = glUniformMatrix3dv;
    tbl.glUniformMatrix3x2dv = glUniformMatrix3x2dv;
    tbl.glUniformMatrix3x4dv = glUniformMatrix3x4dv;
    tbl.glUniformMatrix4dv = glUniformMatrix4dv;
    tbl.glUniformMatrix4x2dv = glUniformMatrix4x2dv;
    tbl.glUniformMatrix4x3dv = glUniformMatrix4x3dv;

  // GL_ARB_imaging

    tbl.glColorSubTable = glColorSubTable;
    tbl.glColorTable = glColorTable;
    tbl.glColorTableParameterfv = glColorTableParameterfv;
    tbl.glColorTableParameteriv = glColorTableParameteriv;
    tbl.glConvolutionFilter1D = glConvolutionFilter1D;
    tbl.glConvolutionFilter2D = glConvolutionFilter2D;
    tbl.glConvolutionParameterf = glConvolutionParameterf;
    tbl.glConvolutionParameterfv = glConvolutionParameterfv;
    tbl.glConvolutionParameteri = glConvolutionParameteri;
    tbl.glConvolutionParameteriv = glConvolutionParameteriv;
    tbl.glCopyColorSubTable = glCopyColorSubTable;
    tbl.glCopyColorTable = glCopyColorTable;
    tbl.glCopyConvolutionFilter1D = glCopyConvolutionFilter1D;
    tbl.glCopyConvolutionFilter2D = glCopyConvolutionFilter2D;
    tbl.glGetColorTable = glGetColorTable;
    tbl.glGetColorTableParameterfv = glGetColorTableParameterfv;
    tbl.glGetColorTableParameteriv = glGetColorTableParameteriv;
    tbl.glGetConvolutionFilter = glGetConvolutionFilter;
    tbl.glGetConvolutionParameterfv = glGetConvolutionParameterfv;
    tbl.glGetConvolutionParameteriv = glGetConvolutionParameteriv;
    tbl.glGetHistogram = glGetHistogram;
    tbl.glGetHistogramParameterfv = glGetHistogramParameterfv;
    tbl.glGetHistogramParameteriv = glGetHistogramParameteriv;
    tbl.glGetMinmax = glGetMinmax;
    tbl.glGetMinmaxParameterfv = glGetMinmaxParameterfv;
    tbl.glGetMinmaxParameteriv = glGetMinmaxParameteriv;
    tbl.glGetSeparableFilter = glGetSeparableFilter;
    tbl.glHistogram = glHistogram;
    tbl.glMinmax = glMinmax;
    tbl.glResetHistogram = glResetHistogram;
    tbl.glResetMinmax = glResetMinmax;
    tbl.glSeparableFilter2D = glSeparableFilter2D;

  // GL_ARB_indirect_parameters

    tbl.glMultiDrawArraysIndirectCountARB = glMultiDrawArraysIndirectCountARB;
    tbl.glMultiDrawElementsIndirectCountARB = glMultiDrawElementsIndirectCountARB;

  // GL_ARB_instanced_arrays

    tbl.glVertexAttribDivisorARB = glVertexAttribDivisorARB;

  // GL_ARB_internalformat_query

    tbl.glGetInternalformativ = glGetInternalformativ;

  // GL_ARB_internalformat_query2

    tbl.glGetInternalformati64v = glGetInternalformati64v;

  // GL_ARB_invalidate_subdata

    tbl.glInvalidateBufferData = glInvalidateBufferData;
    tbl.glInvalidateBufferSubData = glInvalidateBufferSubData;
    tbl.glInvalidateFramebuffer = glInvalidateFramebuffer;
    tbl.glInvalidateSubFramebuffer = glInvalidateSubFramebuffer;
    tbl.glInvalidateTexImage = glInvalidateTexImage;
    tbl.glInvalidateTexSubImage = glInvalidateTexSubImage;

  // GL_ARB_map_buffer_range

    tbl.glFlushMappedBufferRange = glFlushMappedBufferRange;
    tbl.glMapBufferRange = glMapBufferRange;

  // GL_ARB_matrix_palette

    tbl.glCurrentPaletteMatrixARB = glCurrentPaletteMatrixARB;
    tbl.glMatrixIndexPointerARB = glMatrixIndexPointerARB;
    tbl.glMatrixIndexubvARB = glMatrixIndexubvARB;
    tbl.glMatrixIndexuivARB = glMatrixIndexuivARB;
    tbl.glMatrixIndexusvARB = glMatrixIndexusvARB;

  // GL_ARB_multi_bind

    tbl.glBindBuffersBase = glBindBuffersBase;
    tbl.glBindBuffersRange = glBindBuffersRange;
    tbl.glBindImageTextures = glBindImageTextures;
    tbl.glBindSamplers = glBindSamplers;
    tbl.glBindTextures = glBindTextures;
    tbl.glBindVertexBuffers = glBindVertexBuffers;

  // GL_ARB_multi_draw_indirect

    tbl.glMultiDrawArraysIndirect = glMultiDrawArraysIndirect;
    tbl.glMultiDrawElementsIndirect = glMultiDrawElementsIndirect;

  // GL_ARB_multisample

    tbl.glSampleCoverageARB = glSampleCoverageARB;

  // GL_ARB_multitexture

    tbl.glActiveTextureARB = glActiveTextureARB;
    tbl.glClientActiveTextureARB = glClientActiveTextureARB;
    tbl.glMultiTexCoord1dARB = glMultiTexCoord1dARB;
    tbl.glMultiTexCoord1dvARB = glMultiTexCoord1dvARB;
    tbl.glMultiTexCoord1fARB = glMultiTexCoord1fARB;
    tbl.glMultiTexCoord1fvARB = glMultiTexCoord1fvARB;
    tbl.glMultiTexCoord1iARB = glMultiTexCoord1iARB;
    tbl.glMultiTexCoord1ivARB = glMultiTexCoord1ivARB;
    tbl.glMultiTexCoord1sARB = glMultiTexCoord1sARB;
    tbl.glMultiTexCoord1svARB = glMultiTexCoord1svARB;
    tbl.glMultiTexCoord2dARB = glMultiTexCoord2dARB;
    tbl.glMultiTexCoord2dvARB = glMultiTexCoord2dvARB;
    tbl.glMultiTexCoord2fARB = glMultiTexCoord2fARB;
    tbl.glMultiTexCoord2fvARB = glMultiTexCoord2fvARB;
    tbl.glMultiTexCoord2iARB = glMultiTexCoord2iARB;
    tbl.glMultiTexCoord2ivARB = glMultiTexCoord2ivARB;
    tbl.glMultiTexCoord2sARB = glMultiTexCoord2sARB;
    tbl.glMultiTexCoord2svARB = glMultiTexCoord2svARB;
    tbl.glMultiTexCoord3dARB = glMultiTexCoord3dARB;
    tbl.glMultiTexCoord3dvARB = glMultiTexCoord3dvARB;
    tbl.glMultiTexCoord3fARB = glMultiTexCoord3fARB;
    tbl.glMultiTexCoord3fvARB = glMultiTexCoord3fvARB;
    tbl.glMultiTexCoord3iARB = glMultiTexCoord3iARB;
    tbl.glMultiTexCoord3ivARB = glMultiTexCoord3ivARB;
    tbl.glMultiTexCoord3sARB = glMultiTexCoord3sARB;
    tbl.glMultiTexCoord3svARB = glMultiTexCoord3svARB;
    tbl.glMultiTexCoord4dARB = glMultiTexCoord4dARB;
    tbl.glMultiTexCoord4dvARB = glMultiTexCoord4dvARB;
    tbl.glMultiTexCoord4fARB = glMultiTexCoord4fARB;
    tbl.glMultiTexCoord4fvARB = glMultiTexCoord4fvARB;
    tbl.glMultiTexCoord4iARB = glMultiTexCoord4iARB;
    tbl.glMultiTexCoord4ivARB = glMultiTexCoord4ivARB;
    tbl.glMultiTexCoord4sARB = glMultiTexCoord4sARB;
    tbl.glMultiTexCoord4svARB = glMultiTexCoord4svARB;

  // GL_ARB_occlusion_query

    tbl.glBeginQueryARB = glBeginQueryARB;
    tbl.glDeleteQueriesARB = glDeleteQueriesARB;
    tbl.glEndQueryARB = glEndQueryARB;
    tbl.glGenQueriesARB = glGenQueriesARB;
    tbl.glGetQueryObjectivARB = glGetQueryObjectivARB;
    tbl.glGetQueryObjectuivARB = glGetQueryObjectuivARB;
    tbl.glGetQueryivARB = glGetQueryivARB;
    tbl.glIsQueryARB = glIsQueryARB;

  // GL_ARB_point_parameters

    tbl.glPointParameterfARB = glPointParameterfARB;
    tbl.glPointParameterfvARB = glPointParameterfvARB;

  // GL_ARB_program_interface_query

    tbl.glGetProgramInterfaceiv = glGetProgramInterfaceiv;
    tbl.glGetProgramResourceIndex = glGetProgramResourceIndex;
    tbl.glGetProgramResourceLocation = glGetProgramResourceLocation;
    tbl.glGetProgramResourceLocationIndex = glGetProgramResourceLocationIndex;
    tbl.glGetProgramResourceName = glGetProgramResourceName;
    tbl.glGetProgramResourceiv = glGetProgramResourceiv;

  // GL_ARB_provoking_vertex

    tbl.glProvokingVertex = glProvokingVertex;

  // GL_ARB_robustness

    tbl.glGetGraphicsResetStatusARB = glGetGraphicsResetStatusARB;
    tbl.glGetnColorTableARB = glGetnColorTableARB;
    tbl.glGetnCompressedTexImageARB = glGetnCompressedTexImageARB;
    tbl.glGetnConvolutionFilterARB = glGetnConvolutionFilterARB;
    tbl.glGetnHistogramARB = glGetnHistogramARB;
    tbl.glGetnMapdvARB = glGetnMapdvARB;
    tbl.glGetnMapfvARB = glGetnMapfvARB;
    tbl.glGetnMapivARB = glGetnMapivARB;
    tbl.glGetnMinmaxARB = glGetnMinmaxARB;
    tbl.glGetnPixelMapfvARB = glGetnPixelMapfvARB;
    tbl.glGetnPixelMapuivARB = glGetnPixelMapuivARB;
    tbl.glGetnPixelMapusvARB = glGetnPixelMapusvARB;
    tbl.glGetnPolygonStippleARB = glGetnPolygonStippleARB;
    tbl.glGetnSeparableFilterARB = glGetnSeparableFilterARB;
    tbl.glGetnTexImageARB = glGetnTexImageARB;
    tbl.glGetnUniformdvARB = glGetnUniformdvARB;
    tbl.glGetnUniformfvARB = glGetnUniformfvARB;
    tbl.glGetnUniformivARB = glGetnUniformivARB;
    tbl.glGetnUniformuivARB = glGetnUniformuivARB;
    tbl.glReadnPixelsARB = glReadnPixelsARB;

  // GL_ARB_sample_shading

    tbl.glMinSampleShading = glMinSampleShading;
    tbl.glMinSampleShadingARB = glMinSampleShadingARB;

  // GL_ARB_sampler_objects

    tbl.glBindSampler = glBindSampler;
    tbl.glDeleteSamplers = glDeleteSamplers;
    tbl.glGenSamplers = glGenSamplers;
    tbl.glGetSamplerParameterIiv = glGetSamplerParameterIiv;
    tbl.glGetSamplerParameterIuiv = glGetSamplerParameterIuiv;
    tbl.glGetSamplerParameterfv = glGetSamplerParameterfv;
    tbl.glGetSamplerParameteriv = glGetSamplerParameteriv;
    tbl.glIsSampler = glIsSampler;
    tbl.glSamplerParameterIiv = glSamplerParameterIiv;
    tbl.glSamplerParameterIuiv = glSamplerParameterIuiv;
    tbl.glSamplerParameterf = glSamplerParameterf;
    tbl.glSamplerParameterfv = glSamplerParameterfv;
    tbl.glSamplerParameteri = glSamplerParameteri;
    tbl.glSamplerParameteriv = glSamplerParameteriv;

  // GL_ARB_separate_shader_objects

    tbl.glActiveShaderProgram = glActiveShaderProgram;
    tbl.glBindProgramPipeline = glBindProgramPipeline;
    tbl.glCreateShaderProgramv = glCreateShaderProgramv;
    tbl.glDeleteProgramPipelines = glDeleteProgramPipelines;
    tbl.glGenProgramPipelines = glGenProgramPipelines;
    tbl.glGetProgramPipelineInfoLog = glGetProgramPipelineInfoLog;
    tbl.glGetProgramPipelineiv = glGetProgramPipelineiv;
    tbl.glIsProgramPipeline = glIsProgramPipeline;
    tbl.glProgramUniform1d = glProgramUniform1d;
    tbl.glProgramUniform1dv = glProgramUniform1dv;
    tbl.glProgramUniform1f = glProgramUniform1f;
    tbl.glProgramUniform1fv = glProgramUniform1fv;
    tbl.glProgramUniform1i = glProgramUniform1i;
    tbl.glProgramUniform1iv = glProgramUniform1iv;
    tbl.glProgramUniform1ui = glProgramUniform1ui;
    tbl.glProgramUniform1uiv = glProgramUniform1uiv;
    tbl.glProgramUniform2d = glProgramUniform2d;
    tbl.glProgramUniform2dv = glProgramUniform2dv;
    tbl.glProgramUniform2f = glProgramUniform2f;
    tbl.glProgramUniform2fv = glProgramUniform2fv;
    tbl.glProgramUniform2i = glProgramUniform2i;
    tbl.glProgramUniform2iv = glProgramUniform2iv;
    tbl.glProgramUniform2ui = glProgramUniform2ui;
    tbl.glProgramUniform2uiv = glProgramUniform2uiv;
    tbl.glProgramUniform3d = glProgramUniform3d;
    tbl.glProgramUniform3dv = glProgramUniform3dv;
    tbl.glProgramUniform3f = glProgramUniform3f;
    tbl.glProgramUniform3fv = glProgramUniform3fv;
    tbl.glProgramUniform3i = glProgramUniform3i;
    tbl.glProgramUniform3iv = glProgramUniform3iv;
    tbl.glProgramUniform3ui = glProgramUniform3ui;
    tbl.glProgramUniform3uiv = glProgramUniform3uiv;
    tbl.glProgramUniform4d = glProgramUniform4d;
    tbl.glProgramUniform4dv = glProgramUniform4dv;
    tbl.glProgramUniform4f = glProgramUniform4f;
    tbl.glProgramUniform4fv = glProgramUniform4fv;
    tbl.glProgramUniform4i = glProgramUniform4i;
    tbl.glProgramUniform4iv = glProgramUniform4iv;
    tbl.glProgramUniform4ui = glProgramUniform4ui;
    tbl.glProgramUniform4uiv = glProgramUniform4uiv;
    tbl.glProgramUniformMatrix2dv = glProgramUniformMatrix2dv;
    tbl.glProgramUniformMatrix2fv = glProgramUniformMatrix2fv;
    tbl.glProgramUniformMatrix2x3dv = glProgramUniformMatrix2x3dv;
    tbl.glProgramUniformMatrix2x3fv = glProgramUniformMatrix2x3fv;
    tbl.glProgramUniformMatrix2x4dv = glProgramUniformMatrix2x4dv;
    tbl.glProgramUniformMatrix2x4fv = glProgramUniformMatrix2x4fv;
    tbl.glProgramUniformMatrix3dv = glProgramUniformMatrix3dv;
    tbl.glProgramUniformMatrix3fv = glProgramUniformMatrix3fv;
    tbl.glProgramUniformMatrix3x2dv = glProgramUniformMatrix3x2dv;
    tbl.glProgramUniformMatrix3x2fv = glProgramUniformMatrix3x2fv;
    tbl.glProgramUniformMatrix3x4dv = glProgramUniformMatrix3x4dv;
    tbl.glProgramUniformMatrix3x4fv = glProgramUniformMatrix3x4fv;
    tbl.glProgramUniformMatrix4dv = glProgramUniformMatrix4dv;
    tbl.glProgramUniformMatrix4fv = glProgramUniformMatrix4fv;
    tbl.glProgramUniformMatrix4x2dv = glProgramUniformMatrix4x2dv;
    tbl.glProgramUniformMatrix4x2fv = glProgramUniformMatrix4x2fv;
    tbl.glProgramUniformMatrix4x3dv = glProgramUniformMatrix4x3dv;
    tbl.glProgramUniformMatrix4x3fv = glProgramUniformMatrix4x3fv;
    tbl.glUseProgramStages = glUseProgramStages;
    tbl.glValidateProgramPipeline = glValidateProgramPipeline;

  // GL_ARB_shader_atomic_counters

    tbl.glGetActiveAtomicCounterBufferiv = glGetActiveAtomicCounterBufferiv;

  // GL_ARB_shader_image_load_store

    tbl.glBindImageTexture = glBindImageTexture;
    tbl.glMemoryBarrier = glMemoryBarrier;

  // GL_ARB_shader_objects

    tbl.glAttachObjectARB = glAttachObjectARB;
    tbl.glCompileShaderARB = glCompileShaderARB;
    tbl.glCreateProgramObjectARB = glCreateProgramObjectARB;
    tbl.glCreateShaderObjectARB = glCreateShaderObjectARB;
    tbl.glDeleteObjectARB = glDeleteObjectARB;
    tbl.glDetachObjectARB = glDetachObjectARB;
    tbl.glGetActiveUniformARB = glGetActiveUniformARB;
    tbl.glGetAttachedObjectsARB = glGetAttachedObjectsARB;
    tbl.glGetHandleARB = glGetHandleARB;
    tbl.glGetInfoLogARB = glGetInfoLogARB;
    tbl.glGetObjectParameterfvARB = glGetObjectParameterfvARB;
    tbl.glGetObjectParameterivARB = glGetObjectParameterivARB;
    tbl.glGetShaderSourceARB = glGetShaderSourceARB;
    tbl.glGetUniformLocationARB = glGetUniformLocationARB;
    tbl.glGetUniformfvARB = glGetUniformfvARB;
    tbl.glGetUniformivARB = glGetUniformivARB;
    tbl.glLinkProgramARB = glLinkProgramARB;
    tbl.glShaderSourceARB = glShaderSourceARB;
    tbl.glUniform1fARB = glUniform1fARB;
    tbl.glUniform1fvARB = glUniform1fvARB;
    tbl.glUniform1iARB = glUniform1iARB;
    tbl.glUniform1ivARB = glUniform1ivARB;
    tbl.glUniform2fARB = glUniform2fARB;
    tbl.glUniform2fvARB = glUniform2fvARB;
    tbl.glUniform2iARB = glUniform2iARB;
    tbl.glUniform2ivARB = glUniform2ivARB;
    tbl.glUniform3fARB = glUniform3fARB;
    tbl.glUniform3fvARB = glUniform3fvARB;
    tbl.glUniform3iARB = glUniform3iARB;
    tbl.glUniform3ivARB = glUniform3ivARB;
    tbl.glUniform4fARB = glUniform4fARB;
    tbl.glUniform4fvARB = glUniform4fvARB;
    tbl.glUniform4iARB = glUniform4iARB;
    tbl.glUniform4ivARB = glUniform4ivARB;
    tbl.glUniformMatrix2fvARB = glUniformMatrix2fvARB;
    tbl.glUniformMatrix3fvARB = glUniformMatrix3fvARB;
    tbl.glUniformMatrix4fvARB = glUniformMatrix4fvARB;
    tbl.glUseProgramObjectARB = glUseProgramObjectARB;
    tbl.glValidateProgramARB = glValidateProgramARB;

  // GL_ARB_shader_storage_buffer_object

    tbl.glShaderStorageBlockBinding = glShaderStorageBlockBinding;

  // GL_ARB_shader_subroutine

    tbl.glGetActiveSubroutineName = glGetActiveSubroutineName;
    tbl.glGetActiveSubroutineUniformName = glGetActiveSubroutineUniformName;
    tbl.glGetActiveSubroutineUniformiv = glGetActiveSubroutineUniformiv;
    tbl.glGetProgramStageiv = glGetProgramStageiv;
    tbl.glGetProgramSubroutineParameteruivNV = glGetProgramSubroutineParameteruivNV;
    tbl.glGetSubroutineIndex = glGetSubroutineIndex;
    tbl.glGetSubroutineUniformLocation = glGetSubroutineUniformLocation;
    tbl.glGetUniformSubroutineuiv = glGetUniformSubroutineuiv;
    tbl.glProgramSubroutineParametersuivNV = glProgramSubroutineParametersuivNV;
    tbl.glUniformSubroutinesuiv = glUniformSubroutinesuiv;

  // GL_ARB_shading_language_include

    tbl.glCompileShaderIncludeARB = glCompileShaderIncludeARB;
    tbl.glDeleteNamedStringARB = glDeleteNamedStringARB;
    tbl.glGetNamedStringARB = glGetNamedStringARB;
    tbl.glGetNamedStringivARB = glGetNamedStringivARB;
    tbl.glIsNamedStringARB = glIsNamedStringARB;
    tbl.glNamedStringARB = glNamedStringARB;

  // GL_ARB_sparse_texture

    tbl.glTexPageCommitmentARB = glTexPageCommitmentARB;
    tbl.glTexturePageCommitmentEXT = glTexturePageCommitmentEXT;

  // GL_ARB_sync

    tbl.glClientWaitSync = glClientWaitSync;
    tbl.glDeleteSync = glDeleteSync;
    tbl.glFenceSync = glFenceSync;
    tbl.glGetInteger64v = glGetInteger64v;
    tbl.glGetSynciv = glGetSynciv;
    tbl.glIsSync = glIsSync;
    tbl.glWaitSync = glWaitSync;

  // GL_ARB_tessellation_shader

    tbl.glPatchParameterfv = glPatchParameterfv;
    tbl.glPatchParameteri = glPatchParameteri;

  // GL_ARB_texture_buffer_object

    tbl.glTexBufferARB = glTexBufferARB;

  // GL_ARB_texture_buffer_range

    tbl.glTexBufferRange = glTexBufferRange;
    tbl.glTextureBufferRangeEXT = glTextureBufferRangeEXT;

  // GL_ARB_texture_compression

    tbl.glCompressedTexImage1DARB = glCompressedTexImage1DARB;
    tbl.glCompressedTexImage2DARB = glCompressedTexImage2DARB;
    tbl.glCompressedTexImage3DARB = glCompressedTexImage3DARB;
    tbl.glCompressedTexSubImage1DARB = glCompressedTexSubImage1DARB;
    tbl.glCompressedTexSubImage2DARB = glCompressedTexSubImage2DARB;
    tbl.glCompressedTexSubImage3DARB = glCompressedTexSubImage3DARB;
    tbl.glGetCompressedTexImageARB = glGetCompressedTexImageARB;

  // GL_ARB_texture_multisample

    tbl.glGetMultisamplefv = glGetMultisamplefv;
    tbl.glSampleMaski = glSampleMaski;
    tbl.glTexImage2DMultisample = glTexImage2DMultisample;
    tbl.glTexImage3DMultisample = glTexImage3DMultisample;

  // GL_ARB_texture_storage

    tbl.glTexStorage1D = glTexStorage1D;
    tbl.glTexStorage2D = glTexStorage2D;
    tbl.glTexStorage3D = glTexStorage3D;
    tbl.glTextureStorage1DEXT = glTextureStorage1DEXT;
    tbl.glTextureStorage2DEXT = glTextureStorage2DEXT;
    tbl.glTextureStorage3DEXT = glTextureStorage3DEXT;

  // GL_ARB_texture_storage_multisample

    tbl.glTexStorage2DMultisample = glTexStorage2DMultisample;
    tbl.glTexStorage3DMultisample = glTexStorage3DMultisample;
    tbl.glTextureStorage2DMultisampleEXT = glTextureStorage2DMultisampleEXT;
    tbl.glTextureStorage3DMultisampleEXT = glTextureStorage3DMultisampleEXT;

  // GL_ARB_texture_view

    tbl.glTextureView = glTextureView;

  // GL_ARB_timer_query

    tbl.glGetQueryObjecti64v = glGetQueryObjecti64v;
    tbl.glGetQueryObjectui64v = glGetQueryObjectui64v;
    tbl.glQueryCounter = glQueryCounter;

  // GL_ARB_transform_feedback2

    tbl.glBindTransformFeedback = glBindTransformFeedback;
    tbl.glDeleteTransformFeedbacks = glDeleteTransformFeedbacks;
    tbl.glDrawTransformFeedback = glDrawTransformFeedback;
    tbl.glGenTransformFeedbacks = glGenTransformFeedbacks;
    tbl.glIsTransformFeedback = glIsTransformFeedback;
    tbl.glPauseTransformFeedback = glPauseTransformFeedback;
    tbl.glResumeTransformFeedback = glResumeTransformFeedback;

  // GL_ARB_transform_feedback3

    tbl.glBeginQueryIndexed = glBeginQueryIndexed;
    tbl.glDrawTransformFeedbackStream = glDrawTransformFeedbackStream;
    tbl.glEndQueryIndexed = glEndQueryIndexed;
    tbl.glGetQueryIndexediv = glGetQueryIndexediv;

  // GL_ARB_transform_feedback_instanced

    tbl.glDrawTransformFeedbackInstanced = glDrawTransformFeedbackInstanced;
    tbl.glDrawTransformFeedbackStreamInstanced = glDrawTransformFeedbackStreamInstanced;

  // GL_ARB_transpose_matrix

    tbl.glLoadTransposeMatrixdARB = glLoadTransposeMatrixdARB;
    tbl.glLoadTransposeMatrixfARB = glLoadTransposeMatrixfARB;
    tbl.glMultTransposeMatrixdARB = glMultTransposeMatrixdARB;
    tbl.glMultTransposeMatrixfARB = glMultTransposeMatrixfARB;

  // GL_ARB_uniform_buffer_object

    tbl.glBindBufferBase = glBindBufferBase;
    tbl.glBindBufferRange = glBindBufferRange;
    tbl.glGetActiveUniformBlockName = glGetActiveUniformBlockName;
    tbl.glGetActiveUniformBlockiv = glGetActiveUniformBlockiv;
    tbl.glGetActiveUniformName = glGetActiveUniformName;
    tbl.glGetActiveUniformsiv = glGetActiveUniformsiv;
    tbl.glGetIntegeri_v = glGetIntegeri_v;
    tbl.glGetUniformBlockIndex = glGetUniformBlockIndex;
    tbl.glGetUniformIndices = glGetUniformIndices;
    tbl.glUniformBlockBinding = glUniformBlockBinding;

  // GL_ARB_vertex_array_object

    tbl.glBindVertexArray = glBindVertexArray;
    tbl.glDeleteVertexArrays = glDeleteVertexArrays;
    tbl.glGenVertexArrays = glGenVertexArrays;
    tbl.glIsVertexArray = glIsVertexArray;

  // GL_ARB_vertex_attrib_64bit

    tbl.glGetVertexAttribLdv = glGetVertexAttribLdv;
    tbl.glVertexAttribL1d = glVertexAttribL1d;
    tbl.glVertexAttribL1dv = glVertexAttribL1dv;
    tbl.glVertexAttribL2d = glVertexAttribL2d;
    tbl.glVertexAttribL2dv = glVertexAttribL2dv;
    tbl.glVertexAttribL3d = glVertexAttribL3d;
    tbl.glVertexAttribL3dv = glVertexAttribL3dv;
    tbl.glVertexAttribL4d = glVertexAttribL4d;
    tbl.glVertexAttribL4dv = glVertexAttribL4dv;
    tbl.glVertexAttribLPointer = glVertexAttribLPointer;

  // GL_ARB_vertex_attrib_binding

    tbl.glBindVertexBuffer = glBindVertexBuffer;
    tbl.glVertexArrayBindVertexBufferEXT = glVertexArrayBindVertexBufferEXT;
    tbl.glVertexArrayVertexAttribBindingEXT = glVertexArrayVertexAttribBindingEXT;
    tbl.glVertexArrayVertexAttribFormatEXT = glVertexArrayVertexAttribFormatEXT;
    tbl.glVertexArrayVertexAttribIFormatEXT = glVertexArrayVertexAttribIFormatEXT;
    tbl.glVertexArrayVertexAttribLFormatEXT = glVertexArrayVertexAttribLFormatEXT;
    tbl.glVertexArrayVertexBindingDivisorEXT = glVertexArrayVertexBindingDivisorEXT;
    tbl.glVertexAttribBinding = glVertexAttribBinding;
    tbl.glVertexAttribFormat = glVertexAttribFormat;
    tbl.glVertexAttribIFormat = glVertexAttribIFormat;
    tbl.glVertexAttribLFormat = glVertexAttribLFormat;
    tbl.glVertexBindingDivisor = glVertexBindingDivisor;

  // GL_ARB_vertex_blend

    tbl.glVertexBlendARB = glVertexBlendARB;
    tbl.glWeightPointerARB = glWeightPointerARB;
    tbl.glWeightbvARB = glWeightbvARB;
    tbl.glWeightdvARB = glWeightdvARB;
    tbl.glWeightfvARB = glWeightfvARB;
    tbl.glWeightivARB = glWeightivARB;
    tbl.glWeightsvARB = glWeightsvARB;
    tbl.glWeightubvARB = glWeightubvARB;
    tbl.glWeightuivARB = glWeightuivARB;
    tbl.glWeightusvARB = glWeightusvARB;

  // GL_ARB_vertex_buffer_object

    tbl.glBindBufferARB = glBindBufferARB;
    tbl.glBufferDataARB = glBufferDataARB;
    tbl.glBufferSubDataARB = glBufferSubDataARB;
    tbl.glDeleteBuffersARB = glDeleteBuffersARB;
    tbl.glGenBuffersARB = glGenBuffersARB;
    tbl.glGetBufferParameterivARB = glGetBufferParameterivARB;
    tbl.glGetBufferPointervARB = glGetBufferPointervARB;
    tbl.glGetBufferSubDataARB = glGetBufferSubDataARB;
    tbl.glIsBufferARB = glIsBufferARB;
    tbl.glMapBufferARB = glMapBufferARB;
    tbl.glUnmapBufferARB = glUnmapBufferARB;

  // GL_ARB_vertex_program

    tbl.glBindProgramARB = glBindProgramARB;
    tbl.glDeleteProgramsARB = glDeleteProgramsARB;
    tbl.glDisableVertexAttribArrayARB = glDisableVertexAttribArrayARB;
    tbl.glEnableVertexAttribArrayARB = glEnableVertexAttribArrayARB;
    tbl.glGenProgramsARB = glGenProgramsARB;
    tbl.glGetProgramEnvParameterdvARB = glGetProgramEnvParameterdvARB;
    tbl.glGetProgramEnvParameterfvARB = glGetProgramEnvParameterfvARB;
    tbl.glGetProgramLocalParameterdvARB = glGetProgramLocalParameterdvARB;
    tbl.glGetProgramLocalParameterfvARB = glGetProgramLocalParameterfvARB;
    tbl.glGetProgramStringARB = glGetProgramStringARB;
    tbl.glGetProgramivARB = glGetProgramivARB;
    tbl.glGetVertexAttribPointervARB = glGetVertexAttribPointervARB;
    tbl.glGetVertexAttribdvARB = glGetVertexAttribdvARB;
    tbl.glGetVertexAttribfvARB = glGetVertexAttribfvARB;
    tbl.glGetVertexAttribivARB = glGetVertexAttribivARB;
    tbl.glIsProgramARB = glIsProgramARB;
    tbl.glProgramEnvParameter4dARB = glProgramEnvParameter4dARB;
    tbl.glProgramEnvParameter4dvARB = glProgramEnvParameter4dvARB;
    tbl.glProgramEnvParameter4fARB = glProgramEnvParameter4fARB;
    tbl.glProgramEnvParameter4fvARB = glProgramEnvParameter4fvARB;
    tbl.glProgramLocalParameter4dARB = glProgramLocalParameter4dARB;
    tbl.glProgramLocalParameter4dvARB = glProgramLocalParameter4dvARB;
    tbl.glProgramLocalParameter4fARB = glProgramLocalParameter4fARB;
    tbl.glProgramLocalParameter4fvARB = glProgramLocalParameter4fvARB;
    tbl.glProgramStringARB = glProgramStringARB;
    tbl.glVertexAttrib1dARB = glVertexAttrib1dARB;
    tbl.glVertexAttrib1dvARB = glVertexAttrib1dvARB;
    tbl.glVertexAttrib1fARB = glVertexAttrib1fARB;
    tbl.glVertexAttrib1fvARB = glVertexAttrib1fvARB;
    tbl.glVertexAttrib1sARB = glVertexAttrib1sARB;
    tbl.glVertexAttrib1svARB = glVertexAttrib1svARB;
    tbl.glVertexAttrib2dARB = glVertexAttrib2dARB;
    tbl.glVertexAttrib2dvARB = glVertexAttrib2dvARB;
    tbl.glVertexAttrib2fARB = glVertexAttrib2fARB;
    tbl.glVertexAttrib2fvARB = glVertexAttrib2fvARB;
    tbl.glVertexAttrib2sARB = glVertexAttrib2sARB;
    tbl.glVertexAttrib2svARB = glVertexAttrib2svARB;
    tbl.glVertexAttrib3dARB = glVertexAttrib3dARB;
    tbl.glVertexAttrib3dvARB = glVertexAttrib3dvARB;
    tbl.glVertexAttrib3fARB = glVertexAttrib3fARB;
    tbl.glVertexAttrib3fvARB = glVertexAttrib3fvARB;
    tbl.glVertexAttrib3sARB = glVertexAttrib3sARB;
    tbl.glVertexAttrib3svARB = glVertexAttrib3svARB;
    tbl.glVertexAttrib4NbvARB = glVertexAttrib4NbvARB;
    tbl.glVertexAttrib4NivARB = glVertexAttrib4NivARB;
    tbl.glVertexAttrib4NsvARB = glVertexAttrib4NsvARB;
    tbl.glVertexAttrib4NubARB = glVertexAttrib4NubARB;
    tbl.glVertexAttrib4NubvARB = glVertexAttrib4NubvARB;
    tbl.glVertexAttrib4NuivARB = glVertexAttrib4NuivARB;
    tbl.glVertexAttrib4NusvARB = glVertexAttrib4NusvARB;
    tbl.glVertexAttrib4bvARB = glVertexAttrib4bvARB;
    tbl.glVertexAttrib4dARB = glVertexAttrib4dARB;
    tbl.glVertexAttrib4dvARB = glVertexAttrib4dvARB;
    tbl.glVertexAttrib4fARB = glVertexAttrib4fARB;
    tbl.glVertexAttrib4fvARB = glVertexAttrib4fvARB;
    tbl.glVertexAttrib4ivARB = glVertexAttrib4ivARB;
    tbl.glVertexAttrib4sARB = glVertexAttrib4sARB;
    tbl.glVertexAttrib4svARB = glVertexAttrib4svARB;
    tbl.glVertexAttrib4ubvARB = glVertexAttrib4ubvARB;
    tbl.glVertexAttrib4uivARB = glVertexAttrib4uivARB;
    tbl.glVertexAttrib4usvARB = glVertexAttrib4usvARB;
    tbl.glVertexAttribPointerARB = glVertexAttribPointerARB;

  // GL_ARB_vertex_shader

    tbl.glBindAttribLocationARB = glBindAttribLocationARB;
    tbl.glGetActiveAttribARB = glGetActiveAttribARB;
    tbl.glGetAttribLocationARB = glGetAttribLocationARB;

  // GL_ARB_vertex_type_2_10_10_10_rev

    tbl.glColorP3ui = glColorP3ui;
    tbl.glColorP3uiv = glColorP3uiv;
    tbl.glColorP4ui = glColorP4ui;
    tbl.glColorP4uiv = glColorP4uiv;
    tbl.glMultiTexCoordP1ui = glMultiTexCoordP1ui;
    tbl.glMultiTexCoordP1uiv = glMultiTexCoordP1uiv;
    tbl.glMultiTexCoordP2ui = glMultiTexCoordP2ui;
    tbl.glMultiTexCoordP2uiv = glMultiTexCoordP2uiv;
    tbl.glMultiTexCoordP3ui = glMultiTexCoordP3ui;
    tbl.glMultiTexCoordP3uiv = glMultiTexCoordP3uiv;
    tbl.glMultiTexCoordP4ui = glMultiTexCoordP4ui;
    tbl.glMultiTexCoordP4uiv = glMultiTexCoordP4uiv;
    tbl.glNormalP3ui = glNormalP3ui;
    tbl.glNormalP3uiv = glNormalP3uiv;
    tbl.glSecondaryColorP3ui = glSecondaryColorP3ui;
    tbl.glSecondaryColorP3uiv = glSecondaryColorP3uiv;
    tbl.glTexCoordP1ui = glTexCoordP1ui;
    tbl.glTexCoordP1uiv = glTexCoordP1uiv;
    tbl.glTexCoordP2ui = glTexCoordP2ui;
    tbl.glTexCoordP2uiv = glTexCoordP2uiv;
    tbl.glTexCoordP3ui = glTexCoordP3ui;
    tbl.glTexCoordP3uiv = glTexCoordP3uiv;
    tbl.glTexCoordP4ui = glTexCoordP4ui;
    tbl.glTexCoordP4uiv = glTexCoordP4uiv;
    tbl.glVertexAttribP1ui = glVertexAttribP1ui;
    tbl.glVertexAttribP1uiv = glVertexAttribP1uiv;
    tbl.glVertexAttribP2ui = glVertexAttribP2ui;
    tbl.glVertexAttribP2uiv = glVertexAttribP2uiv;
    tbl.glVertexAttribP3ui = glVertexAttribP3ui;
    tbl.glVertexAttribP3uiv = glVertexAttribP3uiv;
    tbl.glVertexAttribP4ui = glVertexAttribP4ui;
    tbl.glVertexAttribP4uiv = glVertexAttribP4uiv;
    tbl.glVertexP2ui = glVertexP2ui;
    tbl.glVertexP2uiv = glVertexP2uiv;
    tbl.glVertexP3ui = glVertexP3ui;
    tbl.glVertexP3uiv = glVertexP3uiv;
    tbl.glVertexP4ui = glVertexP4ui;
    tbl.glVertexP4uiv = glVertexP4uiv;

  // GL_ARB_viewport_array

    tbl.glDepthRangeArrayv = glDepthRangeArrayv;
    tbl.glDepthRangeIndexed = glDepthRangeIndexed;
    tbl.glGetDoublei_v = glGetDoublei_v;
    tbl.glGetFloati_v = glGetFloati_v;
    tbl.glScissorArrayv = glScissorArrayv;
    tbl.glScissorIndexed = glScissorIndexed;
    tbl.glScissorIndexedv = glScissorIndexedv;
    tbl.glViewportArrayv = glViewportArrayv;
    tbl.glViewportIndexedf = glViewportIndexedf;
    tbl.glViewportIndexedfv = glViewportIndexedfv;

  // GL_ARB_window_pos

    tbl.glWindowPos2dARB = glWindowPos2dARB;
    tbl.glWindowPos2dvARB = glWindowPos2dvARB;
    tbl.glWindowPos2fARB = glWindowPos2fARB;
    tbl.glWindowPos2fvARB = glWindowPos2fvARB;
    tbl.glWindowPos2iARB = glWindowPos2iARB;
    tbl.glWindowPos2ivARB = glWindowPos2ivARB;
    tbl.glWindowPos2sARB = glWindowPos2sARB;
    tbl.glWindowPos2svARB = glWindowPos2svARB;
    tbl.glWindowPos3dARB = glWindowPos3dARB;
    tbl.glWindowPos3dvARB = glWindowPos3dvARB;
    tbl.glWindowPos3fARB = glWindowPos3fARB;
    tbl.glWindowPos3fvARB = glWindowPos3fvARB;
    tbl.glWindowPos3iARB = glWindowPos3iARB;
    tbl.glWindowPos3ivARB = glWindowPos3ivARB;
    tbl.glWindowPos3sARB = glWindowPos3sARB;
    tbl.glWindowPos3svARB = glWindowPos3svARB;

  // GL_ATI_draw_buffers

    tbl.glDrawBuffersATI = glDrawBuffersATI;

  // GL_ATI_element_array

    tbl.glDrawElementArrayATI = glDrawElementArrayATI;
    tbl.glDrawRangeElementArrayATI = glDrawRangeElementArrayATI;
    tbl.glElementPointerATI = glElementPointerATI;

  // GL_ATI_envmap_bumpmap

    tbl.glGetTexBumpParameterfvATI = glGetTexBumpParameterfvATI;
    tbl.glGetTexBumpParameterivATI = glGetTexBumpParameterivATI;
    tbl.glTexBumpParameterfvATI = glTexBumpParameterfvATI;
    tbl.glTexBumpParameterivATI = glTexBumpParameterivATI;

  // GL_ATI_fragment_shader

    tbl.glAlphaFragmentOp1ATI = glAlphaFragmentOp1ATI;
    tbl.glAlphaFragmentOp2ATI = glAlphaFragmentOp2ATI;
    tbl.glAlphaFragmentOp3ATI = glAlphaFragmentOp3ATI;
    tbl.glBeginFragmentShaderATI = glBeginFragmentShaderATI;
    tbl.glBindFragmentShaderATI = glBindFragmentShaderATI;
    tbl.glColorFragmentOp1ATI = glColorFragmentOp1ATI;
    tbl.glColorFragmentOp2ATI = glColorFragmentOp2ATI;
    tbl.glColorFragmentOp3ATI = glColorFragmentOp3ATI;
    tbl.glDeleteFragmentShaderATI = glDeleteFragmentShaderATI;
    tbl.glEndFragmentShaderATI = glEndFragmentShaderATI;
    tbl.glGenFragmentShadersATI = glGenFragmentShadersATI;
    tbl.glPassTexCoordATI = glPassTexCoordATI;
    tbl.glSampleMapATI = glSampleMapATI;
    tbl.glSetFragmentShaderConstantATI = glSetFragmentShaderConstantATI;

  // GL_ATI_map_object_buffer

    tbl.glMapObjectBufferATI = glMapObjectBufferATI;
    tbl.glUnmapObjectBufferATI = glUnmapObjectBufferATI;

  // GL_ATI_pn_triangles

    tbl.glPNTrianglesfATI = glPNTrianglesfATI;
    tbl.glPNTrianglesiATI = glPNTrianglesiATI;

  // GL_ATI_separate_stencil

    tbl.glStencilFuncSeparateATI = glStencilFuncSeparateATI;
    tbl.glStencilOpSeparateATI = glStencilOpSeparateATI;

  // GL_ATI_vertex_array_object

    tbl.glArrayObjectATI = glArrayObjectATI;
    tbl.glFreeObjectBufferATI = glFreeObjectBufferATI;
    tbl.glGetArrayObjectfvATI = glGetArrayObjectfvATI;
    tbl.glGetArrayObjectivATI = glGetArrayObjectivATI;
    tbl.glGetObjectBufferfvATI = glGetObjectBufferfvATI;
    tbl.glGetObjectBufferivATI = glGetObjectBufferivATI;
    tbl.glGetVariantArrayObjectfvATI = glGetVariantArrayObjectfvATI;
    tbl.glGetVariantArrayObjectivATI = glGetVariantArrayObjectivATI;
    tbl.glIsObjectBufferATI = glIsObjectBufferATI;
    tbl.glNewObjectBufferATI = glNewObjectBufferATI;
    tbl.glUpdateObjectBufferATI = glUpdateObjectBufferATI;
    tbl.glVariantArrayObjectATI = glVariantArrayObjectATI;

  // GL_ATI_vertex_attrib_array_object

    tbl.glGetVertexAttribArrayObjectfvATI = glGetVertexAttribArrayObjectfvATI;
    tbl.glGetVertexAttribArrayObjectivATI = glGetVertexAttribArrayObjectivATI;
    tbl.glVertexAttribArrayObjectATI = glVertexAttribArrayObjectATI;

  // GL_ATI_vertex_streams

    tbl.glClientActiveVertexStreamATI = glClientActiveVertexStreamATI;
    tbl.glNormalStream3bATI = glNormalStream3bATI;
    tbl.glNormalStream3bvATI = glNormalStream3bvATI;
    tbl.glNormalStream3dATI = glNormalStream3dATI;
    tbl.glNormalStream3dvATI = glNormalStream3dvATI;
    tbl.glNormalStream3fATI = glNormalStream3fATI;
    tbl.glNormalStream3fvATI = glNormalStream3fvATI;
    tbl.glNormalStream3iATI = glNormalStream3iATI;
    tbl.glNormalStream3ivATI = glNormalStream3ivATI;
    tbl.glNormalStream3sATI = glNormalStream3sATI;
    tbl.glNormalStream3svATI = glNormalStream3svATI;
    tbl.glVertexBlendEnvfATI = glVertexBlendEnvfATI;
    tbl.glVertexBlendEnviATI = glVertexBlendEnviATI;
    tbl.glVertexStream1dATI = glVertexStream1dATI;
    tbl.glVertexStream1dvATI = glVertexStream1dvATI;
    tbl.glVertexStream1fATI = glVertexStream1fATI;
    tbl.glVertexStream1fvATI = glVertexStream1fvATI;
    tbl.glVertexStream1iATI = glVertexStream1iATI;
    tbl.glVertexStream1ivATI = glVertexStream1ivATI;
    tbl.glVertexStream1sATI = glVertexStream1sATI;
    tbl.glVertexStream1svATI = glVertexStream1svATI;
    tbl.glVertexStream2dATI = glVertexStream2dATI;
    tbl.glVertexStream2dvATI = glVertexStream2dvATI;
    tbl.glVertexStream2fATI = glVertexStream2fATI;
    tbl.glVertexStream2fvATI = glVertexStream2fvATI;
    tbl.glVertexStream2iATI = glVertexStream2iATI;
    tbl.glVertexStream2ivATI = glVertexStream2ivATI;
    tbl.glVertexStream2sATI = glVertexStream2sATI;
    tbl.glVertexStream2svATI = glVertexStream2svATI;
    tbl.glVertexStream3dATI = glVertexStream3dATI;
    tbl.glVertexStream3dvATI = glVertexStream3dvATI;
    tbl.glVertexStream3fATI = glVertexStream3fATI;
    tbl.glVertexStream3fvATI = glVertexStream3fvATI;
    tbl.glVertexStream3iATI = glVertexStream3iATI;
    tbl.glVertexStream3ivATI = glVertexStream3ivATI;
    tbl.glVertexStream3sATI = glVertexStream3sATI;
    tbl.glVertexStream3svATI = glVertexStream3svATI;
    tbl.glVertexStream4dATI = glVertexStream4dATI;
    tbl.glVertexStream4dvATI = glVertexStream4dvATI;
    tbl.glVertexStream4fATI = glVertexStream4fATI;
    tbl.glVertexStream4fvATI = glVertexStream4fvATI;
    tbl.glVertexStream4iATI = glVertexStream4iATI;
    tbl.glVertexStream4ivATI = glVertexStream4ivATI;
    tbl.glVertexStream4sATI = glVertexStream4sATI;
    tbl.glVertexStream4svATI = glVertexStream4svATI;

  // GL_EXT_bindable_uniform

    tbl.glGetUniformBufferSizeEXT = glGetUniformBufferSizeEXT;
    tbl.glGetUniformOffsetEXT = glGetUniformOffsetEXT;
    tbl.glUniformBufferEXT = glUniformBufferEXT;

  // GL_EXT_blend_color

    tbl.glBlendColorEXT = glBlendColorEXT;

  // GL_EXT_blend_equation_separate

    tbl.glBlendEquationSeparateEXT = glBlendEquationSeparateEXT;

  // GL_EXT_blend_func_separate

    tbl.glBlendFuncSeparateEXT = glBlendFuncSeparateEXT;

  // GL_EXT_blend_minmax

    tbl.glBlendEquationEXT = glBlendEquationEXT;

  // GL_EXT_color_subtable

    tbl.glColorSubTableEXT = glColorSubTableEXT;
    tbl.glCopyColorSubTableEXT = glCopyColorSubTableEXT;

  // GL_EXT_compiled_vertex_array

    tbl.glLockArraysEXT = glLockArraysEXT;
    tbl.glUnlockArraysEXT = glUnlockArraysEXT;

  // GL_EXT_convolution

    tbl.glConvolutionFilter1DEXT = glConvolutionFilter1DEXT;
    tbl.glConvolutionFilter2DEXT = glConvolutionFilter2DEXT;
    tbl.glConvolutionParameterfEXT = glConvolutionParameterfEXT;
    tbl.glConvolutionParameterfvEXT = glConvolutionParameterfvEXT;
    tbl.glConvolutionParameteriEXT = glConvolutionParameteriEXT;
    tbl.glConvolutionParameterivEXT = glConvolutionParameterivEXT;
    tbl.glCopyConvolutionFilter1DEXT = glCopyConvolutionFilter1DEXT;
    tbl.glCopyConvolutionFilter2DEXT = glCopyConvolutionFilter2DEXT;
    tbl.glGetConvolutionFilterEXT = glGetConvolutionFilterEXT;
    tbl.glGetConvolutionParameterfvEXT = glGetConvolutionParameterfvEXT;
    tbl.glGetConvolutionParameterivEXT = glGetConvolutionParameterivEXT;
    tbl.glGetSeparableFilterEXT = glGetSeparableFilterEXT;
    tbl.glSeparableFilter2DEXT = glSeparableFilter2DEXT;

  // GL_EXT_coordinate_frame

    tbl.glBinormal3bEXT = glBinormal3bEXT;
    tbl.glBinormal3bvEXT = glBinormal3bvEXT;
    tbl.glBinormal3dEXT = glBinormal3dEXT;
    tbl.glBinormal3dvEXT = glBinormal3dvEXT;
    tbl.glBinormal3fEXT = glBinormal3fEXT;
    tbl.glBinormal3fvEXT = glBinormal3fvEXT;
    tbl.glBinormal3iEXT = glBinormal3iEXT;
    tbl.glBinormal3ivEXT = glBinormal3ivEXT;
    tbl.glBinormal3sEXT = glBinormal3sEXT;
    tbl.glBinormal3svEXT = glBinormal3svEXT;
    tbl.glBinormalPointerEXT = glBinormalPointerEXT;
    tbl.glTangent3bEXT = glTangent3bEXT;
    tbl.glTangent3bvEXT = glTangent3bvEXT;
    tbl.glTangent3dEXT = glTangent3dEXT;
    tbl.glTangent3dvEXT = glTangent3dvEXT;
    tbl.glTangent3fEXT = glTangent3fEXT;
    tbl.glTangent3fvEXT = glTangent3fvEXT;
    tbl.glTangent3iEXT = glTangent3iEXT;
    tbl.glTangent3ivEXT = glTangent3ivEXT;
    tbl.glTangent3sEXT = glTangent3sEXT;
    tbl.glTangent3svEXT = glTangent3svEXT;
    tbl.glTangentPointerEXT = glTangentPointerEXT;

  // GL_EXT_copy_texture

    tbl.glCopyTexImage1DEXT = glCopyTexImage1DEXT;
    tbl.glCopyTexImage2DEXT = glCopyTexImage2DEXT;
    tbl.glCopyTexSubImage1DEXT = glCopyTexSubImage1DEXT;
    tbl.glCopyTexSubImage2DEXT = glCopyTexSubImage2DEXT;
    tbl.glCopyTexSubImage3DEXT = glCopyTexSubImage3DEXT;

  // GL_EXT_cull_vertex

    tbl.glCullParameterdvEXT = glCullParameterdvEXT;
    tbl.glCullParameterfvEXT = glCullParameterfvEXT;

  // GL_EXT_debug_label

    tbl.glGetObjectLabelEXT = glGetObjectLabelEXT;
    tbl.glLabelObjectEXT = glLabelObjectEXT;

  // GL_EXT_debug_marker

    tbl.glInsertEventMarkerEXT = glInsertEventMarkerEXT;
    tbl.glPopGroupMarkerEXT = glPopGroupMarkerEXT;
    tbl.glPushGroupMarkerEXT = glPushGroupMarkerEXT;

  // GL_EXT_depth_bounds_test

    tbl.glDepthBoundsEXT = glDepthBoundsEXT;

  // GL_EXT_direct_state_access

    tbl.glBindMultiTextureEXT = glBindMultiTextureEXT;
    tbl.glCheckNamedFramebufferStatusEXT = glCheckNamedFramebufferStatusEXT;
    tbl.glClientAttribDefaultEXT = glClientAttribDefaultEXT;
    tbl.glCompressedMultiTexImage1DEXT = glCompressedMultiTexImage1DEXT;
    tbl.glCompressedMultiTexImage2DEXT = glCompressedMultiTexImage2DEXT;
    tbl.glCompressedMultiTexImage3DEXT = glCompressedMultiTexImage3DEXT;
    tbl.glCompressedMultiTexSubImage1DEXT = glCompressedMultiTexSubImage1DEXT;
    tbl.glCompressedMultiTexSubImage2DEXT = glCompressedMultiTexSubImage2DEXT;
    tbl.glCompressedMultiTexSubImage3DEXT = glCompressedMultiTexSubImage3DEXT;
    tbl.glCompressedTextureImage1DEXT = glCompressedTextureImage1DEXT;
    tbl.glCompressedTextureImage2DEXT = glCompressedTextureImage2DEXT;
    tbl.glCompressedTextureImage3DEXT = glCompressedTextureImage3DEXT;
    tbl.glCompressedTextureSubImage1DEXT = glCompressedTextureSubImage1DEXT;
    tbl.glCompressedTextureSubImage2DEXT = glCompressedTextureSubImage2DEXT;
    tbl.glCompressedTextureSubImage3DEXT = glCompressedTextureSubImage3DEXT;
    tbl.glCopyMultiTexImage1DEXT = glCopyMultiTexImage1DEXT;
    tbl.glCopyMultiTexImage2DEXT = glCopyMultiTexImage2DEXT;
    tbl.glCopyMultiTexSubImage1DEXT = glCopyMultiTexSubImage1DEXT;
    tbl.glCopyMultiTexSubImage2DEXT = glCopyMultiTexSubImage2DEXT;
    tbl.glCopyMultiTexSubImage3DEXT = glCopyMultiTexSubImage3DEXT;
    tbl.glCopyTextureImage1DEXT = glCopyTextureImage1DEXT;
    tbl.glCopyTextureImage2DEXT = glCopyTextureImage2DEXT;
    tbl.glCopyTextureSubImage1DEXT = glCopyTextureSubImage1DEXT;
    tbl.glCopyTextureSubImage2DEXT = glCopyTextureSubImage2DEXT;
    tbl.glCopyTextureSubImage3DEXT = glCopyTextureSubImage3DEXT;
    tbl.glDisableClientStateIndexedEXT = glDisableClientStateIndexedEXT;
    tbl.glDisableClientStateiEXT = glDisableClientStateiEXT;
    tbl.glDisableVertexArrayAttribEXT = glDisableVertexArrayAttribEXT;
    tbl.glDisableVertexArrayEXT = glDisableVertexArrayEXT;
    tbl.glEnableClientStateIndexedEXT = glEnableClientStateIndexedEXT;
    tbl.glEnableClientStateiEXT = glEnableClientStateiEXT;
    tbl.glEnableVertexArrayAttribEXT = glEnableVertexArrayAttribEXT;
    tbl.glEnableVertexArrayEXT = glEnableVertexArrayEXT;
    tbl.glFlushMappedNamedBufferRangeEXT = glFlushMappedNamedBufferRangeEXT;
    tbl.glFramebufferDrawBufferEXT = glFramebufferDrawBufferEXT;
    tbl.glFramebufferDrawBuffersEXT = glFramebufferDrawBuffersEXT;
    tbl.glFramebufferReadBufferEXT = glFramebufferReadBufferEXT;
    tbl.glGenerateMultiTexMipmapEXT = glGenerateMultiTexMipmapEXT;
    tbl.glGenerateTextureMipmapEXT = glGenerateTextureMipmapEXT;
    tbl.glGetCompressedMultiTexImageEXT = glGetCompressedMultiTexImageEXT;
    tbl.glGetCompressedTextureImageEXT = glGetCompressedTextureImageEXT;
    tbl.glGetDoubleIndexedvEXT = glGetDoubleIndexedvEXT;
    tbl.glGetDoublei_vEXT = glGetDoublei_vEXT;
    tbl.glGetFloatIndexedvEXT = glGetFloatIndexedvEXT;
    tbl.glGetFloati_vEXT = glGetFloati_vEXT;
    tbl.glGetFramebufferParameterivEXT = glGetFramebufferParameterivEXT;
    tbl.glGetMultiTexEnvfvEXT = glGetMultiTexEnvfvEXT;
    tbl.glGetMultiTexEnvivEXT = glGetMultiTexEnvivEXT;
    tbl.glGetMultiTexGendvEXT = glGetMultiTexGendvEXT;
    tbl.glGetMultiTexGenfvEXT = glGetMultiTexGenfvEXT;
    tbl.glGetMultiTexGenivEXT = glGetMultiTexGenivEXT;
    tbl.glGetMultiTexImageEXT = glGetMultiTexImageEXT;
    tbl.glGetMultiTexLevelParameterfvEXT = glGetMultiTexLevelParameterfvEXT;
    tbl.glGetMultiTexLevelParameterivEXT = glGetMultiTexLevelParameterivEXT;
    tbl.glGetMultiTexParameterIivEXT = glGetMultiTexParameterIivEXT;
    tbl.glGetMultiTexParameterIuivEXT = glGetMultiTexParameterIuivEXT;
    tbl.glGetMultiTexParameterfvEXT = glGetMultiTexParameterfvEXT;
    tbl.glGetMultiTexParameterivEXT = glGetMultiTexParameterivEXT;
    tbl.glGetNamedBufferParameterivEXT = glGetNamedBufferParameterivEXT;
    tbl.glGetNamedBufferPointervEXT = glGetNamedBufferPointervEXT;
    tbl.glGetNamedBufferSubDataEXT = glGetNamedBufferSubDataEXT;
    tbl.glGetNamedFramebufferAttachmentParameterivEXT = glGetNamedFramebufferAttachmentParameterivEXT;
    tbl.glGetNamedProgramLocalParameterIivEXT = glGetNamedProgramLocalParameterIivEXT;
    tbl.glGetNamedProgramLocalParameterIuivEXT = glGetNamedProgramLocalParameterIuivEXT;
    tbl.glGetNamedProgramLocalParameterdvEXT = glGetNamedProgramLocalParameterdvEXT;
    tbl.glGetNamedProgramLocalParameterfvEXT = glGetNamedProgramLocalParameterfvEXT;
    tbl.glGetNamedProgramStringEXT = glGetNamedProgramStringEXT;
    tbl.glGetNamedProgramivEXT = glGetNamedProgramivEXT;
    tbl.glGetNamedRenderbufferParameterivEXT = glGetNamedRenderbufferParameterivEXT;
    tbl.glGetPointerIndexedvEXT = glGetPointerIndexedvEXT;
    tbl.glGetPointeri_vEXT = glGetPointeri_vEXT;
    tbl.glGetTextureImageEXT = glGetTextureImageEXT;
    tbl.glGetTextureLevelParameterfvEXT = glGetTextureLevelParameterfvEXT;
    tbl.glGetTextureLevelParameterivEXT = glGetTextureLevelParameterivEXT;
    tbl.glGetTextureParameterIivEXT = glGetTextureParameterIivEXT;
    tbl.glGetTextureParameterIuivEXT = glGetTextureParameterIuivEXT;
    tbl.glGetTextureParameterfvEXT = glGetTextureParameterfvEXT;
    tbl.glGetTextureParameterivEXT = glGetTextureParameterivEXT;
    tbl.glGetVertexArrayIntegeri_vEXT = glGetVertexArrayIntegeri_vEXT;
    tbl.glGetVertexArrayIntegervEXT = glGetVertexArrayIntegervEXT;
    tbl.glGetVertexArrayPointeri_vEXT = glGetVertexArrayPointeri_vEXT;
    tbl.glGetVertexArrayPointervEXT = glGetVertexArrayPointervEXT;
    tbl.glMapNamedBufferEXT = glMapNamedBufferEXT;
    tbl.glMapNamedBufferRangeEXT = glMapNamedBufferRangeEXT;
    tbl.glMatrixFrustumEXT = glMatrixFrustumEXT;
    tbl.glMatrixLoadIdentityEXT = glMatrixLoadIdentityEXT;
    tbl.glMatrixLoadTransposedEXT = glMatrixLoadTransposedEXT;
    tbl.glMatrixLoadTransposefEXT = glMatrixLoadTransposefEXT;
    tbl.glMatrixLoaddEXT = glMatrixLoaddEXT;
    tbl.glMatrixLoadfEXT = glMatrixLoadfEXT;
    tbl.glMatrixMultTransposedEXT = glMatrixMultTransposedEXT;
    tbl.glMatrixMultTransposefEXT = glMatrixMultTransposefEXT;
    tbl.glMatrixMultdEXT = glMatrixMultdEXT;
    tbl.glMatrixMultfEXT = glMatrixMultfEXT;
    tbl.glMatrixOrthoEXT = glMatrixOrthoEXT;
    tbl.glMatrixPopEXT = glMatrixPopEXT;
    tbl.glMatrixPushEXT = glMatrixPushEXT;
    tbl.glMatrixRotatedEXT = glMatrixRotatedEXT;
    tbl.glMatrixRotatefEXT = glMatrixRotatefEXT;
    tbl.glMatrixScaledEXT = glMatrixScaledEXT;
    tbl.glMatrixScalefEXT = glMatrixScalefEXT;
    tbl.glMatrixTranslatedEXT = glMatrixTranslatedEXT;
    tbl.glMatrixTranslatefEXT = glMatrixTranslatefEXT;
    tbl.glMultiTexBufferEXT = glMultiTexBufferEXT;
    tbl.glMultiTexCoordPointerEXT = glMultiTexCoordPointerEXT;
    tbl.glMultiTexEnvfEXT = glMultiTexEnvfEXT;
    tbl.glMultiTexEnvfvEXT = glMultiTexEnvfvEXT;
    tbl.glMultiTexEnviEXT = glMultiTexEnviEXT;
    tbl.glMultiTexEnvivEXT = glMultiTexEnvivEXT;
    tbl.glMultiTexGendEXT = glMultiTexGendEXT;
    tbl.glMultiTexGendvEXT = glMultiTexGendvEXT;
    tbl.glMultiTexGenfEXT = glMultiTexGenfEXT;
    tbl.glMultiTexGenfvEXT = glMultiTexGenfvEXT;
    tbl.glMultiTexGeniEXT = glMultiTexGeniEXT;
    tbl.glMultiTexGenivEXT = glMultiTexGenivEXT;
    tbl.glMultiTexImage1DEXT = glMultiTexImage1DEXT;
    tbl.glMultiTexImage2DEXT = glMultiTexImage2DEXT;
    tbl.glMultiTexImage3DEXT = glMultiTexImage3DEXT;
    tbl.glMultiTexParameterIivEXT = glMultiTexParameterIivEXT;
    tbl.glMultiTexParameterIuivEXT = glMultiTexParameterIuivEXT;
    tbl.glMultiTexParameterfEXT = glMultiTexParameterfEXT;
    tbl.glMultiTexParameterfvEXT = glMultiTexParameterfvEXT;
    tbl.glMultiTexParameteriEXT = glMultiTexParameteriEXT;
    tbl.glMultiTexParameterivEXT = glMultiTexParameterivEXT;
    tbl.glMultiTexRenderbufferEXT = glMultiTexRenderbufferEXT;
    tbl.glMultiTexSubImage1DEXT = glMultiTexSubImage1DEXT;
    tbl.glMultiTexSubImage2DEXT = glMultiTexSubImage2DEXT;
    tbl.glMultiTexSubImage3DEXT = glMultiTexSubImage3DEXT;
    tbl.glNamedBufferDataEXT = glNamedBufferDataEXT;
    tbl.glNamedBufferSubDataEXT = glNamedBufferSubDataEXT;
    tbl.glNamedCopyBufferSubDataEXT = glNamedCopyBufferSubDataEXT;
    tbl.glNamedFramebufferRenderbufferEXT = glNamedFramebufferRenderbufferEXT;
    tbl.glNamedFramebufferTexture1DEXT = glNamedFramebufferTexture1DEXT;
    tbl.glNamedFramebufferTexture2DEXT = glNamedFramebufferTexture2DEXT;
    tbl.glNamedFramebufferTexture3DEXT = glNamedFramebufferTexture3DEXT;
    tbl.glNamedFramebufferTextureEXT = glNamedFramebufferTextureEXT;
    tbl.glNamedFramebufferTextureFaceEXT = glNamedFramebufferTextureFaceEXT;
    tbl.glNamedFramebufferTextureLayerEXT = glNamedFramebufferTextureLayerEXT;
    tbl.glNamedProgramLocalParameter4dEXT = glNamedProgramLocalParameter4dEXT;
    tbl.glNamedProgramLocalParameter4dvEXT = glNamedProgramLocalParameter4dvEXT;
    tbl.glNamedProgramLocalParameter4fEXT = glNamedProgramLocalParameter4fEXT;
    tbl.glNamedProgramLocalParameter4fvEXT = glNamedProgramLocalParameter4fvEXT;
    tbl.glNamedProgramLocalParameterI4iEXT = glNamedProgramLocalParameterI4iEXT;
    tbl.glNamedProgramLocalParameterI4ivEXT = glNamedProgramLocalParameterI4ivEXT;
    tbl.glNamedProgramLocalParameterI4uiEXT = glNamedProgramLocalParameterI4uiEXT;
    tbl.glNamedProgramLocalParameterI4uivEXT = glNamedProgramLocalParameterI4uivEXT;
    tbl.glNamedProgramLocalParameters4fvEXT = glNamedProgramLocalParameters4fvEXT;
    tbl.glNamedProgramLocalParametersI4ivEXT = glNamedProgramLocalParametersI4ivEXT;
    tbl.glNamedProgramLocalParametersI4uivEXT = glNamedProgramLocalParametersI4uivEXT;
    tbl.glNamedProgramStringEXT = glNamedProgramStringEXT;
    tbl.glNamedRenderbufferStorageEXT = glNamedRenderbufferStorageEXT;
    tbl.glNamedRenderbufferStorageMultisampleCoverageEXT = glNamedRenderbufferStorageMultisampleCoverageEXT;
    tbl.glNamedRenderbufferStorageMultisampleEXT = glNamedRenderbufferStorageMultisampleEXT;
    tbl.glProgramUniform1dEXT = glProgramUniform1dEXT;
    tbl.glProgramUniform1dvEXT = glProgramUniform1dvEXT;
    tbl.glProgramUniform1fEXT = glProgramUniform1fEXT;
    tbl.glProgramUniform1fvEXT = glProgramUniform1fvEXT;
    tbl.glProgramUniform1iEXT = glProgramUniform1iEXT;
    tbl.glProgramUniform1ivEXT = glProgramUniform1ivEXT;
    tbl.glProgramUniform1uiEXT = glProgramUniform1uiEXT;
    tbl.glProgramUniform1uivEXT = glProgramUniform1uivEXT;
    tbl.glProgramUniform2dEXT = glProgramUniform2dEXT;
    tbl.glProgramUniform2dvEXT = glProgramUniform2dvEXT;
    tbl.glProgramUniform2fEXT = glProgramUniform2fEXT;
    tbl.glProgramUniform2fvEXT = glProgramUniform2fvEXT;
    tbl.glProgramUniform2iEXT = glProgramUniform2iEXT;
    tbl.glProgramUniform2ivEXT = glProgramUniform2ivEXT;
    tbl.glProgramUniform2uiEXT = glProgramUniform2uiEXT;
    tbl.glProgramUniform2uivEXT = glProgramUniform2uivEXT;
    tbl.glProgramUniform3dEXT = glProgramUniform3dEXT;
    tbl.glProgramUniform3dvEXT = glProgramUniform3dvEXT;
    tbl.glProgramUniform3fEXT = glProgramUniform3fEXT;
    tbl.glProgramUniform3fvEXT = glProgramUniform3fvEXT;
    tbl.glProgramUniform3iEXT = glProgramUniform3iEXT;
    tbl.glProgramUniform3ivEXT = glProgramUniform3ivEXT;
    tbl.glProgramUniform3uiEXT = glProgramUniform3uiEXT;
    tbl.glProgramUniform3uivEXT = glProgramUniform3uivEXT;
    tbl.glProgramUniform4dEXT = glProgramUniform4dEXT;
    tbl.glProgramUniform4dvEXT = glProgramUniform4dvEXT;
    tbl.glProgramUniform4fEXT = glProgramUniform4fEXT;
    tbl.glProgramUniform4fvEXT = glProgramUniform4fvEXT;
    tbl.glProgramUniform4iEXT = glProgramUniform4iEXT;
    tbl.glProgramUniform4ivEXT = glProgramUniform4ivEXT;
    tbl.glProgramUniform4uiEXT = glProgramUniform4uiEXT;
    tbl.glProgramUniform4uivEXT = glProgramUniform4uivEXT;
    tbl.glProgramUniformMatrix2dvEXT = glProgramUniformMatrix2dvEXT;
    tbl.glProgramUniformMatrix2fvEXT = glProgramUniformMatrix2fvEXT;
    tbl.glProgramUniformMatrix2x3dvEXT = glProgramUniformMatrix2x3dvEXT;
    tbl.glProgramUniformMatrix2x3fvEXT = glProgramUniformMatrix2x3fvEXT;
    tbl.glProgramUniformMatrix2x4dvEXT = glProgramUniformMatrix2x4dvEXT;
    tbl.glProgramUniformMatrix2x4fvEXT = glProgramUniformMatrix2x4fvEXT;
    tbl.glProgramUniformMatrix3dvEXT = glProgramUniformMatrix3dvEXT;
    tbl.glProgramUniformMatrix3fvEXT = glProgramUniformMatrix3fvEXT;
    tbl.glProgramUniformMatrix3x2dvEXT = glProgramUniformMatrix3x2dvEXT;
    tbl.glProgramUniformMatrix3x2fvEXT = glProgramUniformMatrix3x2fvEXT;
    tbl.glProgramUniformMatrix3x4dvEXT = glProgramUniformMatrix3x4dvEXT;
    tbl.glProgramUniformMatrix3x4fvEXT = glProgramUniformMatrix3x4fvEXT;
    tbl.glProgramUniformMatrix4dvEXT = glProgramUniformMatrix4dvEXT;
    tbl.glProgramUniformMatrix4fvEXT = glProgramUniformMatrix4fvEXT;
    tbl.glProgramUniformMatrix4x2dvEXT = glProgramUniformMatrix4x2dvEXT;
    tbl.glProgramUniformMatrix4x2fvEXT = glProgramUniformMatrix4x2fvEXT;
    tbl.glProgramUniformMatrix4x3dvEXT = glProgramUniformMatrix4x3dvEXT;
    tbl.glProgramUniformMatrix4x3fvEXT = glProgramUniformMatrix4x3fvEXT;
    tbl.glPushClientAttribDefaultEXT = glPushClientAttribDefaultEXT;
    tbl.glTextureBufferEXT = glTextureBufferEXT;
    tbl.glTextureImage1DEXT = glTextureImage1DEXT;
    tbl.glTextureImage2DEXT = glTextureImage2DEXT;
    tbl.glTextureImage3DEXT = glTextureImage3DEXT;
    tbl.glTextureParameterIivEXT = glTextureParameterIivEXT;
    tbl.glTextureParameterIuivEXT = glTextureParameterIuivEXT;
    tbl.glTextureParameterfEXT = glTextureParameterfEXT;
    tbl.glTextureParameterfvEXT = glTextureParameterfvEXT;
    tbl.glTextureParameteriEXT = glTextureParameteriEXT;
    tbl.glTextureParameterivEXT = glTextureParameterivEXT;
    tbl.glTextureRenderbufferEXT = glTextureRenderbufferEXT;
    tbl.glTextureSubImage1DEXT = glTextureSubImage1DEXT;
    tbl.glTextureSubImage2DEXT = glTextureSubImage2DEXT;
    tbl.glTextureSubImage3DEXT = glTextureSubImage3DEXT;
    tbl.glUnmapNamedBufferEXT = glUnmapNamedBufferEXT;
    tbl.glVertexArrayColorOffsetEXT = glVertexArrayColorOffsetEXT;
    tbl.glVertexArrayEdgeFlagOffsetEXT = glVertexArrayEdgeFlagOffsetEXT;
    tbl.glVertexArrayFogCoordOffsetEXT = glVertexArrayFogCoordOffsetEXT;
    tbl.glVertexArrayIndexOffsetEXT = glVertexArrayIndexOffsetEXT;
    tbl.glVertexArrayMultiTexCoordOffsetEXT = glVertexArrayMultiTexCoordOffsetEXT;
    tbl.glVertexArrayNormalOffsetEXT = glVertexArrayNormalOffsetEXT;
    tbl.glVertexArraySecondaryColorOffsetEXT = glVertexArraySecondaryColorOffsetEXT;
    tbl.glVertexArrayTexCoordOffsetEXT = glVertexArrayTexCoordOffsetEXT;
    tbl.glVertexArrayVertexAttribIOffsetEXT = glVertexArrayVertexAttribIOffsetEXT;
    tbl.glVertexArrayVertexAttribOffsetEXT = glVertexArrayVertexAttribOffsetEXT;
    tbl.glVertexArrayVertexOffsetEXT = glVertexArrayVertexOffsetEXT;

  // GL_EXT_discard_framebuffer

    tbl.glDiscardFramebufferEXT = glDiscardFramebufferEXT;

  // GL_EXT_disjoint_timer_query

    tbl.glGetQueryObjectivEXT = glGetQueryObjectivEXT;
    tbl.glQueryCounterEXT = glQueryCounterEXT;

  // GL_EXT_draw_buffers2

    tbl.glColorMaskIndexedEXT = glColorMaskIndexedEXT;
    tbl.glDisableIndexedEXT = glDisableIndexedEXT;
    tbl.glEnableIndexedEXT = glEnableIndexedEXT;
    tbl.glGetBooleanIndexedvEXT = glGetBooleanIndexedvEXT;
    tbl.glGetIntegerIndexedvEXT = glGetIntegerIndexedvEXT;
    tbl.glIsEnabledIndexedEXT = glIsEnabledIndexedEXT;

  // GL_EXT_draw_instanced

    tbl.glDrawArraysInstancedEXT = glDrawArraysInstancedEXT;
    tbl.glDrawElementsInstancedEXT = glDrawElementsInstancedEXT;

  // GL_EXT_draw_range_elements

    tbl.glDrawRangeElementsEXT = glDrawRangeElementsEXT;

  // GL_EXT_fog_coord

    tbl.glFogCoordPointerEXT = glFogCoordPointerEXT;
    tbl.glFogCoorddEXT = glFogCoorddEXT;
    tbl.glFogCoorddvEXT = glFogCoorddvEXT;
    tbl.glFogCoordfEXT = glFogCoordfEXT;
    tbl.glFogCoordfvEXT = glFogCoordfvEXT;

  // GL_EXT_fragment_lighting

    tbl.glFragmentColorMaterialEXT = glFragmentColorMaterialEXT;
    tbl.glFragmentLightModelfEXT = glFragmentLightModelfEXT;
    tbl.glFragmentLightModelfvEXT = glFragmentLightModelfvEXT;
    tbl.glFragmentLightModeliEXT = glFragmentLightModeliEXT;
    tbl.glFragmentLightModelivEXT = glFragmentLightModelivEXT;
    tbl.glFragmentLightfEXT = glFragmentLightfEXT;
    tbl.glFragmentLightfvEXT = glFragmentLightfvEXT;
    tbl.glFragmentLightiEXT = glFragmentLightiEXT;
    tbl.glFragmentLightivEXT = glFragmentLightivEXT;
    tbl.glFragmentMaterialfEXT = glFragmentMaterialfEXT;
    tbl.glFragmentMaterialfvEXT = glFragmentMaterialfvEXT;
    tbl.glFragmentMaterialiEXT = glFragmentMaterialiEXT;
    tbl.glFragmentMaterialivEXT = glFragmentMaterialivEXT;
    tbl.glGetFragmentLightfvEXT = glGetFragmentLightfvEXT;
    tbl.glGetFragmentLightivEXT = glGetFragmentLightivEXT;
    tbl.glGetFragmentMaterialfvEXT = glGetFragmentMaterialfvEXT;
    tbl.glGetFragmentMaterialivEXT = glGetFragmentMaterialivEXT;
    tbl.glLightEnviEXT = glLightEnviEXT;

  // GL_EXT_framebuffer_blit

    tbl.glBlitFramebufferEXT = glBlitFramebufferEXT;

  // GL_EXT_framebuffer_multisample

    tbl.glRenderbufferStorageMultisampleEXT = glRenderbufferStorageMultisampleEXT;

  // GL_EXT_framebuffer_object

    tbl.glBindFramebufferEXT = glBindFramebufferEXT;
    tbl.glBindRenderbufferEXT = glBindRenderbufferEXT;
    tbl.glCheckFramebufferStatusEXT = glCheckFramebufferStatusEXT;
    tbl.glDeleteFramebuffersEXT = glDeleteFramebuffersEXT;
    tbl.glDeleteRenderbuffersEXT = glDeleteRenderbuffersEXT;
    tbl.glFramebufferRenderbufferEXT = glFramebufferRenderbufferEXT;
    tbl.glFramebufferTexture1DEXT = glFramebufferTexture1DEXT;
    tbl.glFramebufferTexture2DEXT = glFramebufferTexture2DEXT;
    tbl.glFramebufferTexture3DEXT = glFramebufferTexture3DEXT;
    tbl.glGenFramebuffersEXT = glGenFramebuffersEXT;
    tbl.glGenRenderbuffersEXT = glGenRenderbuffersEXT;
    tbl.glGenerateMipmapEXT = glGenerateMipmapEXT;
    tbl.glGetFramebufferAttachmentParameterivEXT = glGetFramebufferAttachmentParameterivEXT;
    tbl.glGetRenderbufferParameterivEXT = glGetRenderbufferParameterivEXT;
    tbl.glIsFramebufferEXT = glIsFramebufferEXT;
    tbl.glIsRenderbufferEXT = glIsRenderbufferEXT;
    tbl.glRenderbufferStorageEXT = glRenderbufferStorageEXT;

  // GL_EXT_geometry_shader4

    tbl.glFramebufferTextureEXT = glFramebufferTextureEXT;
    tbl.glFramebufferTextureFaceEXT = glFramebufferTextureFaceEXT;
    tbl.glProgramParameteriEXT = glProgramParameteriEXT;

  // GL_EXT_gpu_program_parameters

    tbl.glProgramEnvParameters4fvEXT = glProgramEnvParameters4fvEXT;
    tbl.glProgramLocalParameters4fvEXT = glProgramLocalParameters4fvEXT;

  // GL_EXT_gpu_shader4

    tbl.glBindFragDataLocationEXT = glBindFragDataLocationEXT;
    tbl.glGetFragDataLocationEXT = glGetFragDataLocationEXT;
    tbl.glGetUniformuivEXT = glGetUniformuivEXT;
    tbl.glGetVertexAttribIivEXT = glGetVertexAttribIivEXT;
    tbl.glGetVertexAttribIuivEXT = glGetVertexAttribIuivEXT;
    tbl.glUniform1uiEXT = glUniform1uiEXT;
    tbl.glUniform1uivEXT = glUniform1uivEXT;
    tbl.glUniform2uiEXT = glUniform2uiEXT;
    tbl.glUniform2uivEXT = glUniform2uivEXT;
    tbl.glUniform3uiEXT = glUniform3uiEXT;
    tbl.glUniform3uivEXT = glUniform3uivEXT;
    tbl.glUniform4uiEXT = glUniform4uiEXT;
    tbl.glUniform4uivEXT = glUniform4uivEXT;
    tbl.glVertexAttribI1iEXT = glVertexAttribI1iEXT;
    tbl.glVertexAttribI1ivEXT = glVertexAttribI1ivEXT;
    tbl.glVertexAttribI1uiEXT = glVertexAttribI1uiEXT;
    tbl.glVertexAttribI1uivEXT = glVertexAttribI1uivEXT;
    tbl.glVertexAttribI2iEXT = glVertexAttribI2iEXT;
    tbl.glVertexAttribI2ivEXT = glVertexAttribI2ivEXT;
    tbl.glVertexAttribI2uiEXT = glVertexAttribI2uiEXT;
    tbl.glVertexAttribI2uivEXT = glVertexAttribI2uivEXT;
    tbl.glVertexAttribI3iEXT = glVertexAttribI3iEXT;
    tbl.glVertexAttribI3ivEXT = glVertexAttribI3ivEXT;
    tbl.glVertexAttribI3uiEXT = glVertexAttribI3uiEXT;
    tbl.glVertexAttribI3uivEXT = glVertexAttribI3uivEXT;
    tbl.glVertexAttribI4bvEXT = glVertexAttribI4bvEXT;
    tbl.glVertexAttribI4iEXT = glVertexAttribI4iEXT;
    tbl.glVertexAttribI4ivEXT = glVertexAttribI4ivEXT;
    tbl.glVertexAttribI4svEXT = glVertexAttribI4svEXT;
    tbl.glVertexAttribI4ubvEXT = glVertexAttribI4ubvEXT;
    tbl.glVertexAttribI4uiEXT = glVertexAttribI4uiEXT;
    tbl.glVertexAttribI4uivEXT = glVertexAttribI4uivEXT;
    tbl.glVertexAttribI4usvEXT = glVertexAttribI4usvEXT;
    tbl.glVertexAttribIPointerEXT = glVertexAttribIPointerEXT;

  // GL_EXT_histogram

    tbl.glGetHistogramEXT = glGetHistogramEXT;
    tbl.glGetHistogramParameterfvEXT = glGetHistogramParameterfvEXT;
    tbl.glGetHistogramParameterivEXT = glGetHistogramParameterivEXT;
    tbl.glGetMinmaxEXT = glGetMinmaxEXT;
    tbl.glGetMinmaxParameterfvEXT = glGetMinmaxParameterfvEXT;
    tbl.glGetMinmaxParameterivEXT = glGetMinmaxParameterivEXT;
    tbl.glHistogramEXT = glHistogramEXT;
    tbl.glMinmaxEXT = glMinmaxEXT;
    tbl.glResetHistogramEXT = glResetHistogramEXT;
    tbl.glResetMinmaxEXT = glResetMinmaxEXT;

  // GL_EXT_index_func

    tbl.glIndexFuncEXT = glIndexFuncEXT;

  // GL_EXT_index_material

    tbl.glIndexMaterialEXT = glIndexMaterialEXT;

  // GL_EXT_light_texture

    tbl.glApplyTextureEXT = glApplyTextureEXT;
    tbl.glTextureLightEXT = glTextureLightEXT;
    tbl.glTextureMaterialEXT = glTextureMaterialEXT;

  // GL_EXT_map_buffer_range

    tbl.glFlushMappedBufferRangeEXT = glFlushMappedBufferRangeEXT;
    tbl.glMapBufferRangeEXT = glMapBufferRangeEXT;

  // GL_EXT_multi_draw_arrays

    tbl.glMultiDrawArraysEXT = glMultiDrawArraysEXT;
    tbl.glMultiDrawElementsEXT = glMultiDrawElementsEXT;

  // GL_EXT_multisample

    tbl.glSampleMaskEXT = glSampleMaskEXT;
    tbl.glSamplePatternEXT = glSamplePatternEXT;

  // GL_EXT_multisampled_render_to_texture

    tbl.glFramebufferTexture2DMultisampleEXT = glFramebufferTexture2DMultisampleEXT;

  // GL_EXT_multiview_draw_buffers

    tbl.glDrawBuffersIndexedEXT = glDrawBuffersIndexedEXT;
    tbl.glGetIntegeri_vEXT = glGetIntegeri_vEXT;
    tbl.glReadBufferIndexedEXT = glReadBufferIndexedEXT;

  // GL_EXT_occlusion_query_boolean

    tbl.glBeginQueryEXT = glBeginQueryEXT;
    tbl.glDeleteQueriesEXT = glDeleteQueriesEXT;
    tbl.glEndQueryEXT = glEndQueryEXT;
    tbl.glGenQueriesEXT = glGenQueriesEXT;
    tbl.glGetQueryObjectuivEXT = glGetQueryObjectuivEXT;
    tbl.glGetQueryivEXT = glGetQueryivEXT;
    tbl.glIsQueryEXT = glIsQueryEXT;

  // GL_EXT_paletted_texture

    tbl.glColorTableEXT = glColorTableEXT;
    tbl.glGetColorTableEXT = glGetColorTableEXT;
    tbl.glGetColorTableParameterfvEXT = glGetColorTableParameterfvEXT;
    tbl.glGetColorTableParameterivEXT = glGetColorTableParameterivEXT;

  // GL_EXT_pixel_transform

    tbl.glGetPixelTransformParameterfvEXT = glGetPixelTransformParameterfvEXT;
    tbl.glGetPixelTransformParameterivEXT = glGetPixelTransformParameterivEXT;
    tbl.glPixelTransformParameterfEXT = glPixelTransformParameterfEXT;
    tbl.glPixelTransformParameterfvEXT = glPixelTransformParameterfvEXT;
    tbl.glPixelTransformParameteriEXT = glPixelTransformParameteriEXT;
    tbl.glPixelTransformParameterivEXT = glPixelTransformParameterivEXT;

  // GL_EXT_point_parameters

    tbl.glPointParameterfEXT = glPointParameterfEXT;
    tbl.glPointParameterfvEXT = glPointParameterfvEXT;

  // GL_EXT_polygon_offset

    tbl.glPolygonOffsetEXT = glPolygonOffsetEXT;

  // GL_EXT_provoking_vertex

    tbl.glProvokingVertexEXT = glProvokingVertexEXT;

  // GL_EXT_robustness

    tbl.glGetnUniformfvEXT = glGetnUniformfvEXT;
    tbl.glGetnUniformivEXT = glGetnUniformivEXT;
    tbl.glReadnPixelsEXT = glReadnPixelsEXT;

  // GL_EXT_scene_marker

    tbl.glBeginSceneEXT = glBeginSceneEXT;
    tbl.glEndSceneEXT = glEndSceneEXT;

  // GL_EXT_secondary_color

    tbl.glSecondaryColor3bEXT = glSecondaryColor3bEXT;
    tbl.glSecondaryColor3bvEXT = glSecondaryColor3bvEXT;
    tbl.glSecondaryColor3dEXT = glSecondaryColor3dEXT;
    tbl.glSecondaryColor3dvEXT = glSecondaryColor3dvEXT;
    tbl.glSecondaryColor3fEXT = glSecondaryColor3fEXT;
    tbl.glSecondaryColor3fvEXT = glSecondaryColor3fvEXT;
    tbl.glSecondaryColor3iEXT = glSecondaryColor3iEXT;
    tbl.glSecondaryColor3ivEXT = glSecondaryColor3ivEXT;
    tbl.glSecondaryColor3sEXT = glSecondaryColor3sEXT;
    tbl.glSecondaryColor3svEXT = glSecondaryColor3svEXT;
    tbl.glSecondaryColor3ubEXT = glSecondaryColor3ubEXT;
    tbl.glSecondaryColor3ubvEXT = glSecondaryColor3ubvEXT;
    tbl.glSecondaryColor3uiEXT = glSecondaryColor3uiEXT;
    tbl.glSecondaryColor3uivEXT = glSecondaryColor3uivEXT;
    tbl.glSecondaryColor3usEXT = glSecondaryColor3usEXT;
    tbl.glSecondaryColor3usvEXT = glSecondaryColor3usvEXT;
    tbl.glSecondaryColorPointerEXT = glSecondaryColorPointerEXT;

  // GL_EXT_separate_shader_objects

    tbl.glActiveProgramEXT = glActiveProgramEXT;
    tbl.glCreateShaderProgramEXT = glCreateShaderProgramEXT;
    tbl.glUseShaderProgramEXT = glUseShaderProgramEXT;

  // GL_EXT_shader_image_load_store

    tbl.glBindImageTextureEXT = glBindImageTextureEXT;
    tbl.glMemoryBarrierEXT = glMemoryBarrierEXT;

  // GL_EXT_stencil_clear_tag

    tbl.glStencilClearTagEXT = glStencilClearTagEXT;

  // GL_EXT_stencil_two_side

    tbl.glActiveStencilFaceEXT = glActiveStencilFaceEXT;

  // GL_EXT_subtexture

    tbl.glTexSubImage1DEXT = glTexSubImage1DEXT;
    tbl.glTexSubImage2DEXT = glTexSubImage2DEXT;
    tbl.glTexSubImage3DEXT = glTexSubImage3DEXT;

  // GL_EXT_texture3D

    tbl.glTexImage3DEXT = glTexImage3DEXT;

  // GL_EXT_texture_array

    tbl.glFramebufferTextureLayerEXT = glFramebufferTextureLayerEXT;

  // GL_EXT_texture_buffer_object

    tbl.glTexBufferEXT = glTexBufferEXT;

  // GL_EXT_texture_integer

    tbl.glClearColorIiEXT = glClearColorIiEXT;
    tbl.glClearColorIuiEXT = glClearColorIuiEXT;
    tbl.glGetTexParameterIivEXT = glGetTexParameterIivEXT;
    tbl.glGetTexParameterIuivEXT = glGetTexParameterIuivEXT;
    tbl.glTexParameterIivEXT = glTexParameterIivEXT;
    tbl.glTexParameterIuivEXT = glTexParameterIuivEXT;

  // GL_EXT_texture_object

    tbl.glAreTexturesResidentEXT = glAreTexturesResidentEXT;
    tbl.glBindTextureEXT = glBindTextureEXT;
    tbl.glDeleteTexturesEXT = glDeleteTexturesEXT;
    tbl.glGenTexturesEXT = glGenTexturesEXT;
    tbl.glIsTextureEXT = glIsTextureEXT;
    tbl.glPrioritizeTexturesEXT = glPrioritizeTexturesEXT;

  // GL_EXT_texture_perturb_normal

    tbl.glTextureNormalEXT = glTextureNormalEXT;

  // GL_EXT_texture_storage

    tbl.glTexStorage1DEXT = glTexStorage1DEXT;
    tbl.glTexStorage2DEXT = glTexStorage2DEXT;
    tbl.glTexStorage3DEXT = glTexStorage3DEXT;

  // GL_EXT_timer_query

    tbl.glGetQueryObjecti64vEXT = glGetQueryObjecti64vEXT;
    tbl.glGetQueryObjectui64vEXT = glGetQueryObjectui64vEXT;

  // GL_EXT_transform_feedback

    tbl.glBeginTransformFeedbackEXT = glBeginTransformFeedbackEXT;
    tbl.glBindBufferBaseEXT = glBindBufferBaseEXT;
    tbl.glBindBufferOffsetEXT = glBindBufferOffsetEXT;
    tbl.glBindBufferRangeEXT = glBindBufferRangeEXT;
    tbl.glEndTransformFeedbackEXT = glEndTransformFeedbackEXT;
    tbl.glGetTransformFeedbackVaryingEXT = glGetTransformFeedbackVaryingEXT;
    tbl.glTransformFeedbackVaryingsEXT = glTransformFeedbackVaryingsEXT;

  // GL_EXT_vertex_array

    tbl.glArrayElementEXT = glArrayElementEXT;
    tbl.glColorPointerEXT = glColorPointerEXT;
    tbl.glDrawArraysEXT = glDrawArraysEXT;
    tbl.glEdgeFlagPointerEXT = glEdgeFlagPointerEXT;
    tbl.glGetPointervEXT = glGetPointervEXT;
    tbl.glIndexPointerEXT = glIndexPointerEXT;
    tbl.glNormalPointerEXT = glNormalPointerEXT;
    tbl.glTexCoordPointerEXT = glTexCoordPointerEXT;
    tbl.glVertexPointerEXT = glVertexPointerEXT;

  // GL_EXT_vertex_attrib_64bit

    tbl.glGetVertexAttribLdvEXT = glGetVertexAttribLdvEXT;
    tbl.glVertexArrayVertexAttribLOffsetEXT = glVertexArrayVertexAttribLOffsetEXT;
    tbl.glVertexAttribL1dEXT = glVertexAttribL1dEXT;
    tbl.glVertexAttribL1dvEXT = glVertexAttribL1dvEXT;
    tbl.glVertexAttribL2dEXT = glVertexAttribL2dEXT;
    tbl.glVertexAttribL2dvEXT = glVertexAttribL2dvEXT;
    tbl.glVertexAttribL3dEXT = glVertexAttribL3dEXT;
    tbl.glVertexAttribL3dvEXT = glVertexAttribL3dvEXT;
    tbl.glVertexAttribL4dEXT = glVertexAttribL4dEXT;
    tbl.glVertexAttribL4dvEXT = glVertexAttribL4dvEXT;
    tbl.glVertexAttribLPointerEXT = glVertexAttribLPointerEXT;

  // GL_EXT_vertex_shader

    tbl.glBeginVertexShaderEXT = glBeginVertexShaderEXT;
    tbl.glBindLightParameterEXT = glBindLightParameterEXT;
    tbl.glBindMaterialParameterEXT = glBindMaterialParameterEXT;
    tbl.glBindParameterEXT = glBindParameterEXT;
    tbl.glBindTexGenParameterEXT = glBindTexGenParameterEXT;
    tbl.glBindTextureUnitParameterEXT = glBindTextureUnitParameterEXT;
    tbl.glBindVertexShaderEXT = glBindVertexShaderEXT;
    tbl.glDeleteVertexShaderEXT = glDeleteVertexShaderEXT;
    tbl.glDisableVariantClientStateEXT = glDisableVariantClientStateEXT;
    tbl.glEnableVariantClientStateEXT = glEnableVariantClientStateEXT;
    tbl.glEndVertexShaderEXT = glEndVertexShaderEXT;
    tbl.glExtractComponentEXT = glExtractComponentEXT;
    tbl.glGenSymbolsEXT = glGenSymbolsEXT;
    tbl.glGenVertexShadersEXT = glGenVertexShadersEXT;
    tbl.glGetInvariantBooleanvEXT = glGetInvariantBooleanvEXT;
    tbl.glGetInvariantFloatvEXT = glGetInvariantFloatvEXT;
    tbl.glGetInvariantIntegervEXT = glGetInvariantIntegervEXT;
    tbl.glGetLocalConstantBooleanvEXT = glGetLocalConstantBooleanvEXT;
    tbl.glGetLocalConstantFloatvEXT = glGetLocalConstantFloatvEXT;
    tbl.glGetLocalConstantIntegervEXT = glGetLocalConstantIntegervEXT;
    tbl.glGetVariantBooleanvEXT = glGetVariantBooleanvEXT;
    tbl.glGetVariantFloatvEXT = glGetVariantFloatvEXT;
    tbl.glGetVariantIntegervEXT = glGetVariantIntegervEXT;
    tbl.glGetVariantPointervEXT = glGetVariantPointervEXT;
    tbl.glInsertComponentEXT = glInsertComponentEXT;
    tbl.glIsVariantEnabledEXT = glIsVariantEnabledEXT;
    tbl.glSetInvariantEXT = glSetInvariantEXT;
    tbl.glSetLocalConstantEXT = glSetLocalConstantEXT;
    tbl.glShaderOp1EXT = glShaderOp1EXT;
    tbl.glShaderOp2EXT = glShaderOp2EXT;
    tbl.glShaderOp3EXT = glShaderOp3EXT;
    tbl.glSwizzleEXT = glSwizzleEXT;
    tbl.glVariantPointerEXT = glVariantPointerEXT;
    tbl.glVariantbvEXT = glVariantbvEXT;
    tbl.glVariantdvEXT = glVariantdvEXT;
    tbl.glVariantfvEXT = glVariantfvEXT;
    tbl.glVariantivEXT = glVariantivEXT;
    tbl.glVariantsvEXT = glVariantsvEXT;
    tbl.glVariantubvEXT = glVariantubvEXT;
    tbl.glVariantuivEXT = glVariantuivEXT;
    tbl.glVariantusvEXT = glVariantusvEXT;
    tbl.glWriteMaskEXT = glWriteMaskEXT;

  // GL_EXT_vertex_weighting

    tbl.glVertexWeightPointerEXT = glVertexWeightPointerEXT;
    tbl.glVertexWeightfEXT = glVertexWeightfEXT;
    tbl.glVertexWeightfvEXT = glVertexWeightfvEXT;

  // GL_EXT_x11_sync_object

    tbl.glImportSyncEXT = glImportSyncEXT;

  // GL_GREMEDY_frame_terminator

    tbl.glFrameTerminatorGREMEDY = glFrameTerminatorGREMEDY;

  // GL_GREMEDY_string_marker

    tbl.glStringMarkerGREMEDY = glStringMarkerGREMEDY;

  // GL_HP_image_transform

    tbl.glGetImageTransformParameterfvHP = glGetImageTransformParameterfvHP;
    tbl.glGetImageTransformParameterivHP = glGetImageTransformParameterivHP;
    tbl.glImageTransformParameterfHP = glImageTransformParameterfHP;
    tbl.glImageTransformParameterfvHP = glImageTransformParameterfvHP;
    tbl.glImageTransformParameteriHP = glImageTransformParameteriHP;
    tbl.glImageTransformParameterivHP = glImageTransformParameterivHP;

  // GL_IBM_multimode_draw_arrays

    tbl.glMultiModeDrawArraysIBM = glMultiModeDrawArraysIBM;
    tbl.glMultiModeDrawElementsIBM = glMultiModeDrawElementsIBM;

  // GL_IBM_vertex_array_lists

    tbl.glColorPointerListIBM = glColorPointerListIBM;
    tbl.glEdgeFlagPointerListIBM = glEdgeFlagPointerListIBM;
    tbl.glFogCoordPointerListIBM = glFogCoordPointerListIBM;
    tbl.glIndexPointerListIBM = glIndexPointerListIBM;
    tbl.glNormalPointerListIBM = glNormalPointerListIBM;
    tbl.glSecondaryColorPointerListIBM = glSecondaryColorPointerListIBM;
    tbl.glTexCoordPointerListIBM = glTexCoordPointerListIBM;
    tbl.glVertexPointerListIBM = glVertexPointerListIBM;

  // GL_IMG_multisampled_render_to_texture

    tbl.glFramebufferTexture2DMultisampleIMG = glFramebufferTexture2DMultisampleIMG;
    tbl.glRenderbufferStorageMultisampleIMG = glRenderbufferStorageMultisampleIMG;

  // GL_INGR_blend_func_separate

    tbl.glBlendFuncSeparateINGR = glBlendFuncSeparateINGR;

  // GL_INTEL_map_texture

    tbl.glMapTexture2DINTEL = glMapTexture2DINTEL;
    tbl.glSyncTextureINTEL = glSyncTextureINTEL;
    tbl.glUnmapTexture2DINTEL = glUnmapTexture2DINTEL;

  // GL_INTEL_parallel_arrays

    tbl.glColorPointervINTEL = glColorPointervINTEL;
    tbl.glNormalPointervINTEL = glNormalPointervINTEL;
    tbl.glTexCoordPointervINTEL = glTexCoordPointervINTEL;
    tbl.glVertexPointervINTEL = glVertexPointervINTEL;

  // GL_INTEL_texture_scissor

    tbl.glTexScissorFuncINTEL = glTexScissorFuncINTEL;
    tbl.glTexScissorINTEL = glTexScissorINTEL;

  // GL_KHR_debug

    tbl.glDebugMessageCallback = glDebugMessageCallback;
    tbl.glDebugMessageControl = glDebugMessageControl;
    tbl.glDebugMessageInsert = glDebugMessageInsert;
    tbl.glGetDebugMessageLog = glGetDebugMessageLog;
    tbl.glGetObjectLabel = glGetObjectLabel;
    tbl.glGetObjectPtrLabel = glGetObjectPtrLabel;
    tbl.glObjectLabel = glObjectLabel;
    tbl.glObjectPtrLabel = glObjectPtrLabel;
    tbl.glPopDebugGroup = glPopDebugGroup;
    tbl.glPushDebugGroup = glPushDebugGroup;

  // GL_KTX_buffer_region

    tbl.glBufferRegionEnabled = glBufferRegionEnabled;
    tbl.glDeleteBufferRegion = glDeleteBufferRegion;
    tbl.glDrawBufferRegion = glDrawBufferRegion;
    tbl.glNewBufferRegion = glNewBufferRegion;
    tbl.glReadBufferRegion = glReadBufferRegion;

  // GL_MESA_resize_buffers

    tbl.glResizeBuffersMESA = glResizeBuffersMESA;

  // GL_MESA_window_pos

    tbl.glWindowPos2dMESA = glWindowPos2dMESA;
    tbl.glWindowPos2dvMESA = glWindowPos2dvMESA;
    tbl.glWindowPos2fMESA = glWindowPos2fMESA;
    tbl.glWindowPos2fvMESA = glWindowPos2fvMESA;
    tbl.glWindowPos2iMESA = glWindowPos2iMESA;
    tbl.glWindowPos2ivMESA = glWindowPos2ivMESA;
    tbl.glWindowPos2sMESA = glWindowPos2sMESA;
    tbl.glWindowPos2svMESA = glWindowPos2svMESA;
    tbl.glWindowPos3dMESA = glWindowPos3dMESA;
    tbl.glWindowPos3dvMESA = glWindowPos3dvMESA;
    tbl.glWindowPos3fMESA = glWindowPos3fMESA;
    tbl.glWindowPos3fvMESA = glWindowPos3fvMESA;
    tbl.glWindowPos3iMESA = glWindowPos3iMESA;
    tbl.glWindowPos3ivMESA = glWindowPos3ivMESA;
    tbl.glWindowPos3sMESA = glWindowPos3sMESA;
    tbl.glWindowPos3svMESA = glWindowPos3svMESA;
    tbl.glWindowPos4dMESA = glWindowPos4dMESA;
    tbl.glWindowPos4dvMESA = glWindowPos4dvMESA;
    tbl.glWindowPos4fMESA = glWindowPos4fMESA;
    tbl.glWindowPos4fvMESA = glWindowPos4fvMESA;
    tbl.glWindowPos4iMESA = glWindowPos4iMESA;
    tbl.glWindowPos4ivMESA = glWindowPos4ivMESA;
    tbl.glWindowPos4sMESA = glWindowPos4sMESA;
    tbl.glWindowPos4svMESA = glWindowPos4svMESA;

  // GL_NVX_conditional_render

    tbl.glBeginConditionalRenderNVX = glBeginConditionalRenderNVX;
    tbl.glEndConditionalRenderNVX = glEndConditionalRenderNVX;

  // GL_NV_bindless_texture

    tbl.glGetImageHandleNV = glGetImageHandleNV;
    tbl.glGetTextureHandleNV = glGetTextureHandleNV;
    tbl.glGetTextureSamplerHandleNV = glGetTextureSamplerHandleNV;
    tbl.glIsImageHandleResidentNV = glIsImageHandleResidentNV;
    tbl.glIsTextureHandleResidentNV = glIsTextureHandleResidentNV;
    tbl.glMakeImageHandleNonResidentNV = glMakeImageHandleNonResidentNV;
    tbl.glMakeImageHandleResidentNV = glMakeImageHandleResidentNV;
    tbl.glMakeTextureHandleNonResidentNV = glMakeTextureHandleNonResidentNV;
    tbl.glMakeTextureHandleResidentNV = glMakeTextureHandleResidentNV;
    tbl.glProgramUniformHandleui64NV = glProgramUniformHandleui64NV;
    tbl.glProgramUniformHandleui64vNV = glProgramUniformHandleui64vNV;
    tbl.glUniformHandleui64NV = glUniformHandleui64NV;
    tbl.glUniformHandleui64vNV = glUniformHandleui64vNV;

  // GL_NV_blend_equation_advanced

    tbl.glBlendBarrierNV = glBlendBarrierNV;
    tbl.glBlendParameteriNV = glBlendParameteriNV;

  // GL_NV_conditional_render

    tbl.glBeginConditionalRenderNV = glBeginConditionalRenderNV;
    tbl.glEndConditionalRenderNV = glEndConditionalRenderNV;

  // GL_NV_copy_buffer

    tbl.glCopyBufferSubDataNV = glCopyBufferSubDataNV;

  // GL_NV_copy_image

    tbl.glCopyImageSubDataNV = glCopyImageSubDataNV;

  // GL_NV_coverage_sample

    tbl.glCoverageMaskNV = glCoverageMaskNV;
    tbl.glCoverageOperationNV = glCoverageOperationNV;

  // GL_NV_depth_buffer_float

    tbl.glClearDepthdNV = glClearDepthdNV;
    tbl.glDepthBoundsdNV = glDepthBoundsdNV;
    tbl.glDepthRangedNV = glDepthRangedNV;

  // GL_NV_draw_buffers

    tbl.glDrawBuffersNV = glDrawBuffersNV;

  // GL_NV_draw_texture

    tbl.glDrawTextureNV = glDrawTextureNV;

  // GL_NV_evaluators

    tbl.glEvalMapsNV = glEvalMapsNV;
    tbl.glGetMapAttribParameterfvNV = glGetMapAttribParameterfvNV;
    tbl.glGetMapAttribParameterivNV = glGetMapAttribParameterivNV;
    tbl.glGetMapControlPointsNV = glGetMapControlPointsNV;
    tbl.glGetMapParameterfvNV = glGetMapParameterfvNV;
    tbl.glGetMapParameterivNV = glGetMapParameterivNV;
    tbl.glMapControlPointsNV = glMapControlPointsNV;
    tbl.glMapParameterfvNV = glMapParameterfvNV;
    tbl.glMapParameterivNV = glMapParameterivNV;

  // GL_NV_explicit_multisample

    tbl.glGetMultisamplefvNV = glGetMultisamplefvNV;
    tbl.glSampleMaskIndexedNV = glSampleMaskIndexedNV;
    tbl.glTexRenderbufferNV = glTexRenderbufferNV;

  // GL_NV_fence

    tbl.glDeleteFencesNV = glDeleteFencesNV;
    tbl.glFinishFenceNV = glFinishFenceNV;
    tbl.glGenFencesNV = glGenFencesNV;
    tbl.glGetFenceivNV = glGetFenceivNV;
    tbl.glIsFenceNV = glIsFenceNV;
    tbl.glSetFenceNV = glSetFenceNV;
    tbl.glTestFenceNV = glTestFenceNV;

  // GL_NV_fragment_program

    tbl.glGetProgramNamedParameterdvNV = glGetProgramNamedParameterdvNV;
    tbl.glGetProgramNamedParameterfvNV = glGetProgramNamedParameterfvNV;
    tbl.glProgramNamedParameter4dNV = glProgramNamedParameter4dNV;
    tbl.glProgramNamedParameter4dvNV = glProgramNamedParameter4dvNV;
    tbl.glProgramNamedParameter4fNV = glProgramNamedParameter4fNV;
    tbl.glProgramNamedParameter4fvNV = glProgramNamedParameter4fvNV;

  // GL_NV_framebuffer_blit

    tbl.glBlitFramebufferNV = glBlitFramebufferNV;

  // GL_NV_framebuffer_multisample_coverage

    tbl.glRenderbufferStorageMultisampleCoverageNV = glRenderbufferStorageMultisampleCoverageNV;

  // GL_NV_geometry_program4

    tbl.glProgramVertexLimitNV = glProgramVertexLimitNV;

  // GL_NV_gpu_program4

    tbl.glGetProgramEnvParameterIivNV = glGetProgramEnvParameterIivNV;
    tbl.glGetProgramEnvParameterIuivNV = glGetProgramEnvParameterIuivNV;
    tbl.glGetProgramLocalParameterIivNV = glGetProgramLocalParameterIivNV;
    tbl.glGetProgramLocalParameterIuivNV = glGetProgramLocalParameterIuivNV;
    tbl.glProgramEnvParameterI4iNV = glProgramEnvParameterI4iNV;
    tbl.glProgramEnvParameterI4ivNV = glProgramEnvParameterI4ivNV;
    tbl.glProgramEnvParameterI4uiNV = glProgramEnvParameterI4uiNV;
    tbl.glProgramEnvParameterI4uivNV = glProgramEnvParameterI4uivNV;
    tbl.glProgramEnvParametersI4ivNV = glProgramEnvParametersI4ivNV;
    tbl.glProgramEnvParametersI4uivNV = glProgramEnvParametersI4uivNV;
    tbl.glProgramLocalParameterI4iNV = glProgramLocalParameterI4iNV;
    tbl.glProgramLocalParameterI4ivNV = glProgramLocalParameterI4ivNV;
    tbl.glProgramLocalParameterI4uiNV = glProgramLocalParameterI4uiNV;
    tbl.glProgramLocalParameterI4uivNV = glProgramLocalParameterI4uivNV;
    tbl.glProgramLocalParametersI4ivNV = glProgramLocalParametersI4ivNV;
    tbl.glProgramLocalParametersI4uivNV = glProgramLocalParametersI4uivNV;

  // GL_NV_gpu_shader5

    tbl.glGetUniformi64vNV = glGetUniformi64vNV;
    tbl.glProgramUniform1i64NV = glProgramUniform1i64NV;
    tbl.glProgramUniform1i64vNV = glProgramUniform1i64vNV;
    tbl.glProgramUniform1ui64NV = glProgramUniform1ui64NV;
    tbl.glProgramUniform1ui64vNV = glProgramUniform1ui64vNV;
    tbl.glProgramUniform2i64NV = glProgramUniform2i64NV;
    tbl.glProgramUniform2i64vNV = glProgramUniform2i64vNV;
    tbl.glProgramUniform2ui64NV = glProgramUniform2ui64NV;
    tbl.glProgramUniform2ui64vNV = glProgramUniform2ui64vNV;
    tbl.glProgramUniform3i64NV = glProgramUniform3i64NV;
    tbl.glProgramUniform3i64vNV = glProgramUniform3i64vNV;
    tbl.glProgramUniform3ui64NV = glProgramUniform3ui64NV;
    tbl.glProgramUniform3ui64vNV = glProgramUniform3ui64vNV;
    tbl.glProgramUniform4i64NV = glProgramUniform4i64NV;
    tbl.glProgramUniform4i64vNV = glProgramUniform4i64vNV;
    tbl.glProgramUniform4ui64NV = glProgramUniform4ui64NV;
    tbl.glProgramUniform4ui64vNV = glProgramUniform4ui64vNV;
    tbl.glUniform1i64NV = glUniform1i64NV;
    tbl.glUniform1i64vNV = glUniform1i64vNV;
    tbl.glUniform1ui64NV = glUniform1ui64NV;
    tbl.glUniform1ui64vNV = glUniform1ui64vNV;
    tbl.glUniform2i64NV = glUniform2i64NV;
    tbl.glUniform2i64vNV = glUniform2i64vNV;
    tbl.glUniform2ui64NV = glUniform2ui64NV;
    tbl.glUniform2ui64vNV = glUniform2ui64vNV;
    tbl.glUniform3i64NV = glUniform3i64NV;
    tbl.glUniform3i64vNV = glUniform3i64vNV;
    tbl.glUniform3ui64NV = glUniform3ui64NV;
    tbl.glUniform3ui64vNV = glUniform3ui64vNV;
    tbl.glUniform4i64NV = glUniform4i64NV;
    tbl.glUniform4i64vNV = glUniform4i64vNV;
    tbl.glUniform4ui64NV = glUniform4ui64NV;
    tbl.glUniform4ui64vNV = glUniform4ui64vNV;

  // GL_NV_half_float

    tbl.glColor3hNV = glColor3hNV;
    tbl.glColor3hvNV = glColor3hvNV;
    tbl.glColor4hNV = glColor4hNV;
    tbl.glColor4hvNV = glColor4hvNV;
    tbl.glFogCoordhNV = glFogCoordhNV;
    tbl.glFogCoordhvNV = glFogCoordhvNV;
    tbl.glMultiTexCoord1hNV = glMultiTexCoord1hNV;
    tbl.glMultiTexCoord1hvNV = glMultiTexCoord1hvNV;
    tbl.glMultiTexCoord2hNV = glMultiTexCoord2hNV;
    tbl.glMultiTexCoord2hvNV = glMultiTexCoord2hvNV;
    tbl.glMultiTexCoord3hNV = glMultiTexCoord3hNV;
    tbl.glMultiTexCoord3hvNV = glMultiTexCoord3hvNV;
    tbl.glMultiTexCoord4hNV = glMultiTexCoord4hNV;
    tbl.glMultiTexCoord4hvNV = glMultiTexCoord4hvNV;
    tbl.glNormal3hNV = glNormal3hNV;
    tbl.glNormal3hvNV = glNormal3hvNV;
    tbl.glSecondaryColor3hNV = glSecondaryColor3hNV;
    tbl.glSecondaryColor3hvNV = glSecondaryColor3hvNV;
    tbl.glTexCoord1hNV = glTexCoord1hNV;
    tbl.glTexCoord1hvNV = glTexCoord1hvNV;
    tbl.glTexCoord2hNV = glTexCoord2hNV;
    tbl.glTexCoord2hvNV = glTexCoord2hvNV;
    tbl.glTexCoord3hNV = glTexCoord3hNV;
    tbl.glTexCoord3hvNV = glTexCoord3hvNV;
    tbl.glTexCoord4hNV = glTexCoord4hNV;
    tbl.glTexCoord4hvNV = glTexCoord4hvNV;
    tbl.glVertex2hNV = glVertex2hNV;
    tbl.glVertex2hvNV = glVertex2hvNV;
    tbl.glVertex3hNV = glVertex3hNV;
    tbl.glVertex3hvNV = glVertex3hvNV;
    tbl.glVertex4hNV = glVertex4hNV;
    tbl.glVertex4hvNV = glVertex4hvNV;
    tbl.glVertexAttrib1hNV = glVertexAttrib1hNV;
    tbl.glVertexAttrib1hvNV = glVertexAttrib1hvNV;
    tbl.glVertexAttrib2hNV = glVertexAttrib2hNV;
    tbl.glVertexAttrib2hvNV = glVertexAttrib2hvNV;
    tbl.glVertexAttrib3hNV = glVertexAttrib3hNV;
    tbl.glVertexAttrib3hvNV = glVertexAttrib3hvNV;
    tbl.glVertexAttrib4hNV = glVertexAttrib4hNV;
    tbl.glVertexAttrib4hvNV = glVertexAttrib4hvNV;
    tbl.glVertexAttribs1hvNV = glVertexAttribs1hvNV;
    tbl.glVertexAttribs2hvNV = glVertexAttribs2hvNV;
    tbl.glVertexAttribs3hvNV = glVertexAttribs3hvNV;
    tbl.glVertexAttribs4hvNV = glVertexAttribs4hvNV;
    tbl.glVertexWeighthNV = glVertexWeighthNV;
    tbl.glVertexWeighthvNV = glVertexWeighthvNV;

  // GL_NV_non_square_matrices

    tbl.glUniformMatrix2x3fvNV = glUniformMatrix2x3fvNV;
    tbl.glUniformMatrix2x4fvNV = glUniformMatrix2x4fvNV;
    tbl.glUniformMatrix3x2fvNV = glUniformMatrix3x2fvNV;
    tbl.glUniformMatrix3x4fvNV = glUniformMatrix3x4fvNV;
    tbl.glUniformMatrix4x2fvNV = glUniformMatrix4x2fvNV;
    tbl.glUniformMatrix4x3fvNV = glUniformMatrix4x3fvNV;

  // GL_NV_occlusion_query

    tbl.glBeginOcclusionQueryNV = glBeginOcclusionQueryNV;
    tbl.glDeleteOcclusionQueriesNV = glDeleteOcclusionQueriesNV;
    tbl.glEndOcclusionQueryNV = glEndOcclusionQueryNV;
    tbl.glGenOcclusionQueriesNV = glGenOcclusionQueriesNV;
    tbl.glGetOcclusionQueryivNV = glGetOcclusionQueryivNV;
    tbl.glGetOcclusionQueryuivNV = glGetOcclusionQueryuivNV;
    tbl.glIsOcclusionQueryNV = glIsOcclusionQueryNV;

  // GL_NV_parameter_buffer_object

    tbl.glProgramBufferParametersIivNV = glProgramBufferParametersIivNV;
    tbl.glProgramBufferParametersIuivNV = glProgramBufferParametersIuivNV;
    tbl.glProgramBufferParametersfvNV = glProgramBufferParametersfvNV;

  // GL_NV_path_rendering

    tbl.glCopyPathNV = glCopyPathNV;
    tbl.glCoverFillPathInstancedNV = glCoverFillPathInstancedNV;
    tbl.glCoverFillPathNV = glCoverFillPathNV;
    tbl.glCoverStrokePathInstancedNV = glCoverStrokePathInstancedNV;
    tbl.glCoverStrokePathNV = glCoverStrokePathNV;
    tbl.glDeletePathsNV = glDeletePathsNV;
    tbl.glGenPathsNV = glGenPathsNV;
    tbl.glGetPathColorGenfvNV = glGetPathColorGenfvNV;
    tbl.glGetPathColorGenivNV = glGetPathColorGenivNV;
    tbl.glGetPathCommandsNV = glGetPathCommandsNV;
    tbl.glGetPathCoordsNV = glGetPathCoordsNV;
    tbl.glGetPathDashArrayNV = glGetPathDashArrayNV;
    tbl.glGetPathLengthNV = glGetPathLengthNV;
    tbl.glGetPathMetricRangeNV = glGetPathMetricRangeNV;
    tbl.glGetPathMetricsNV = glGetPathMetricsNV;
    tbl.glGetPathParameterfvNV = glGetPathParameterfvNV;
    tbl.glGetPathParameterivNV = glGetPathParameterivNV;
    tbl.glGetPathSpacingNV = glGetPathSpacingNV;
    tbl.glGetPathTexGenfvNV = glGetPathTexGenfvNV;
    tbl.glGetPathTexGenivNV = glGetPathTexGenivNV;
    tbl.glInterpolatePathsNV = glInterpolatePathsNV;
    tbl.glIsPathNV = glIsPathNV;
    tbl.glIsPointInFillPathNV = glIsPointInFillPathNV;
    tbl.glIsPointInStrokePathNV = glIsPointInStrokePathNV;
    tbl.glPathColorGenNV = glPathColorGenNV;
    tbl.glPathCommandsNV = glPathCommandsNV;
    tbl.glPathCoordsNV = glPathCoordsNV;
    tbl.glPathCoverDepthFuncNV = glPathCoverDepthFuncNV;
    tbl.glPathDashArrayNV = glPathDashArrayNV;
    tbl.glPathFogGenNV = glPathFogGenNV;
    tbl.glPathGlyphRangeNV = glPathGlyphRangeNV;
    tbl.glPathGlyphsNV = glPathGlyphsNV;
    tbl.glPathParameterfNV = glPathParameterfNV;
    tbl.glPathParameterfvNV = glPathParameterfvNV;
    tbl.glPathParameteriNV = glPathParameteriNV;
    tbl.glPathParameterivNV = glPathParameterivNV;
    tbl.glPathStencilDepthOffsetNV = glPathStencilDepthOffsetNV;
    tbl.glPathStencilFuncNV = glPathStencilFuncNV;
    tbl.glPathStringNV = glPathStringNV;
    tbl.glPathSubCommandsNV = glPathSubCommandsNV;
    tbl.glPathSubCoordsNV = glPathSubCoordsNV;
    tbl.glPathTexGenNV = glPathTexGenNV;
    tbl.glPointAlongPathNV = glPointAlongPathNV;
    tbl.glStencilFillPathInstancedNV = glStencilFillPathInstancedNV;
    tbl.glStencilFillPathNV = glStencilFillPathNV;
    tbl.glStencilStrokePathInstancedNV = glStencilStrokePathInstancedNV;
    tbl.glStencilStrokePathNV = glStencilStrokePathNV;
    tbl.glTransformPathNV = glTransformPathNV;
    tbl.glWeightPathsNV = glWeightPathsNV;

  // GL_NV_pixel_data_range

    tbl.glFlushPixelDataRangeNV = glFlushPixelDataRangeNV;
    tbl.glPixelDataRangeNV = glPixelDataRangeNV;

  // GL_NV_point_sprite

    tbl.glPointParameteriNV = glPointParameteriNV;
    tbl.glPointParameterivNV = glPointParameterivNV;

  // GL_NV_present_video

    tbl.glGetVideoi64vNV = glGetVideoi64vNV;
    tbl.glGetVideoivNV = glGetVideoivNV;
    tbl.glGetVideoui64vNV = glGetVideoui64vNV;
    tbl.glGetVideouivNV = glGetVideouivNV;
    tbl.glPresentFrameDualFillNV = glPresentFrameDualFillNV;
    tbl.glPresentFrameKeyedNV = glPresentFrameKeyedNV;

  // GL_NV_primitive_restart

    tbl.glPrimitiveRestartIndexNV = glPrimitiveRestartIndexNV;
    tbl.glPrimitiveRestartNV = glPrimitiveRestartNV;

  // GL_NV_read_buffer

    tbl.glReadBufferNV = glReadBufferNV;

  // GL_NV_register_combiners

    tbl.glCombinerInputNV = glCombinerInputNV;
    tbl.glCombinerOutputNV = glCombinerOutputNV;
    tbl.glCombinerParameterfNV = glCombinerParameterfNV;
    tbl.glCombinerParameterfvNV = glCombinerParameterfvNV;
    tbl.glCombinerParameteriNV = glCombinerParameteriNV;
    tbl.glCombinerParameterivNV = glCombinerParameterivNV;
    tbl.glFinalCombinerInputNV = glFinalCombinerInputNV;
    tbl.glGetCombinerInputParameterfvNV = glGetCombinerInputParameterfvNV;
    tbl.glGetCombinerInputParameterivNV = glGetCombinerInputParameterivNV;
    tbl.glGetCombinerOutputParameterfvNV = glGetCombinerOutputParameterfvNV;
    tbl.glGetCombinerOutputParameterivNV = glGetCombinerOutputParameterivNV;
    tbl.glGetFinalCombinerInputParameterfvNV = glGetFinalCombinerInputParameterfvNV;
    tbl.glGetFinalCombinerInputParameterivNV = glGetFinalCombinerInputParameterivNV;

  // GL_NV_register_combiners2

    tbl.glCombinerStageParameterfvNV = glCombinerStageParameterfvNV;
    tbl.glGetCombinerStageParameterfvNV = glGetCombinerStageParameterfvNV;

  // GL_NV_shader_buffer_load

    tbl.glGetBufferParameterui64vNV = glGetBufferParameterui64vNV;
    tbl.glGetIntegerui64vNV = glGetIntegerui64vNV;
    tbl.glGetNamedBufferParameterui64vNV = glGetNamedBufferParameterui64vNV;
    tbl.glGetUniformui64vNV = glGetUniformui64vNV;
    tbl.glIsBufferResidentNV = glIsBufferResidentNV;
    tbl.glIsNamedBufferResidentNV = glIsNamedBufferResidentNV;
    tbl.glMakeBufferNonResidentNV = glMakeBufferNonResidentNV;
    tbl.glMakeBufferResidentNV = glMakeBufferResidentNV;
    tbl.glMakeNamedBufferNonResidentNV = glMakeNamedBufferNonResidentNV;
    tbl.glMakeNamedBufferResidentNV = glMakeNamedBufferResidentNV;
    tbl.glProgramUniformui64NV = glProgramUniformui64NV;
    tbl.glProgramUniformui64vNV = glProgramUniformui64vNV;
    tbl.glUniformui64NV = glUniformui64NV;
    tbl.glUniformui64vNV = glUniformui64vNV;

  // GL_NV_texture_barrier

    tbl.glTextureBarrierNV = glTextureBarrierNV;

  // GL_NV_texture_multisample

    tbl.glTexImage2DMultisampleCoverageNV = glTexImage2DMultisampleCoverageNV;
    tbl.glTexImage3DMultisampleCoverageNV = glTexImage3DMultisampleCoverageNV;
    tbl.glTextureImage2DMultisampleCoverageNV = glTextureImage2DMultisampleCoverageNV;
    tbl.glTextureImage2DMultisampleNV = glTextureImage2DMultisampleNV;
    tbl.glTextureImage3DMultisampleCoverageNV = glTextureImage3DMultisampleCoverageNV;
    tbl.glTextureImage3DMultisampleNV = glTextureImage3DMultisampleNV;

  // GL_NV_transform_feedback

    tbl.glActiveVaryingNV = glActiveVaryingNV;
    tbl.glBeginTransformFeedbackNV = glBeginTransformFeedbackNV;
    tbl.glBindBufferBaseNV = glBindBufferBaseNV;
    tbl.glBindBufferOffsetNV = glBindBufferOffsetNV;
    tbl.glBindBufferRangeNV = glBindBufferRangeNV;
    tbl.glEndTransformFeedbackNV = glEndTransformFeedbackNV;
    tbl.glGetActiveVaryingNV = glGetActiveVaryingNV;
    tbl.glGetTransformFeedbackVaryingNV = glGetTransformFeedbackVaryingNV;
    tbl.glGetVaryingLocationNV = glGetVaryingLocationNV;
    tbl.glTransformFeedbackAttribsNV = glTransformFeedbackAttribsNV;
    tbl.glTransformFeedbackVaryingsNV = glTransformFeedbackVaryingsNV;

  // GL_NV_transform_feedback2

    tbl.glBindTransformFeedbackNV = glBindTransformFeedbackNV;
    tbl.glDeleteTransformFeedbacksNV = glDeleteTransformFeedbacksNV;
    tbl.glDrawTransformFeedbackNV = glDrawTransformFeedbackNV;
    tbl.glGenTransformFeedbacksNV = glGenTransformFeedbacksNV;
    tbl.glIsTransformFeedbackNV = glIsTransformFeedbackNV;
    tbl.glPauseTransformFeedbackNV = glPauseTransformFeedbackNV;
    tbl.glResumeTransformFeedbackNV = glResumeTransformFeedbackNV;

  // GL_NV_vdpau_interop

    tbl.glVDPAUFiniNV = glVDPAUFiniNV;
    tbl.glVDPAUGetSurfaceivNV = glVDPAUGetSurfaceivNV;
    tbl.glVDPAUInitNV = glVDPAUInitNV;
    tbl.glVDPAUIsSurfaceNV = glVDPAUIsSurfaceNV;
    tbl.glVDPAUMapSurfacesNV = glVDPAUMapSurfacesNV;
    tbl.glVDPAURegisterOutputSurfaceNV = glVDPAURegisterOutputSurfaceNV;
    tbl.glVDPAURegisterVideoSurfaceNV = glVDPAURegisterVideoSurfaceNV;
    tbl.glVDPAUSurfaceAccessNV = glVDPAUSurfaceAccessNV;
    tbl.glVDPAUUnmapSurfacesNV = glVDPAUUnmapSurfacesNV;
    tbl.glVDPAUUnregisterSurfaceNV = glVDPAUUnregisterSurfaceNV;

  // GL_NV_vertex_array_range

    tbl.glFlushVertexArrayRangeNV = glFlushVertexArrayRangeNV;
    tbl.glVertexArrayRangeNV = glVertexArrayRangeNV;

  // GL_NV_vertex_attrib_integer_64bit

    tbl.glGetVertexAttribLi64vNV = glGetVertexAttribLi64vNV;
    tbl.glGetVertexAttribLui64vNV = glGetVertexAttribLui64vNV;
    tbl.glVertexAttribL1i64NV = glVertexAttribL1i64NV;
    tbl.glVertexAttribL1i64vNV = glVertexAttribL1i64vNV;
    tbl.glVertexAttribL1ui64NV = glVertexAttribL1ui64NV;
    tbl.glVertexAttribL1ui64vNV = glVertexAttribL1ui64vNV;
    tbl.glVertexAttribL2i64NV = glVertexAttribL2i64NV;
    tbl.glVertexAttribL2i64vNV = glVertexAttribL2i64vNV;
    tbl.glVertexAttribL2ui64NV = glVertexAttribL2ui64NV;
    tbl.glVertexAttribL2ui64vNV = glVertexAttribL2ui64vNV;
    tbl.glVertexAttribL3i64NV = glVertexAttribL3i64NV;
    tbl.glVertexAttribL3i64vNV = glVertexAttribL3i64vNV;
    tbl.glVertexAttribL3ui64NV = glVertexAttribL3ui64NV;
    tbl.glVertexAttribL3ui64vNV = glVertexAttribL3ui64vNV;
    tbl.glVertexAttribL4i64NV = glVertexAttribL4i64NV;
    tbl.glVertexAttribL4i64vNV = glVertexAttribL4i64vNV;
    tbl.glVertexAttribL4ui64NV = glVertexAttribL4ui64NV;
    tbl.glVertexAttribL4ui64vNV = glVertexAttribL4ui64vNV;
    tbl.glVertexAttribLFormatNV = glVertexAttribLFormatNV;

  // GL_NV_vertex_buffer_unified_memory

    tbl.glBufferAddressRangeNV = glBufferAddressRangeNV;
    tbl.glColorFormatNV = glColorFormatNV;
    tbl.glEdgeFlagFormatNV = glEdgeFlagFormatNV;
    tbl.glFogCoordFormatNV = glFogCoordFormatNV;
    tbl.glGetIntegerui64i_vNV = glGetIntegerui64i_vNV;
    tbl.glIndexFormatNV = glIndexFormatNV;
    tbl.glNormalFormatNV = glNormalFormatNV;
    tbl.glSecondaryColorFormatNV = glSecondaryColorFormatNV;
    tbl.glTexCoordFormatNV = glTexCoordFormatNV;
    tbl.glVertexAttribFormatNV = glVertexAttribFormatNV;
    tbl.glVertexAttribIFormatNV = glVertexAttribIFormatNV;
    tbl.glVertexFormatNV = glVertexFormatNV;

  // GL_NV_vertex_program

    tbl.glAreProgramsResidentNV = glAreProgramsResidentNV;
    tbl.glBindProgramNV = glBindProgramNV;
    tbl.glDeleteProgramsNV = glDeleteProgramsNV;
    tbl.glExecuteProgramNV = glExecuteProgramNV;
    tbl.glGenProgramsNV = glGenProgramsNV;
    tbl.glGetProgramParameterdvNV = glGetProgramParameterdvNV;
    tbl.glGetProgramParameterfvNV = glGetProgramParameterfvNV;
    tbl.glGetProgramStringNV = glGetProgramStringNV;
    tbl.glGetProgramivNV = glGetProgramivNV;
    tbl.glGetTrackMatrixivNV = glGetTrackMatrixivNV;
    tbl.glGetVertexAttribPointervNV = glGetVertexAttribPointervNV;
    tbl.glGetVertexAttribdvNV = glGetVertexAttribdvNV;
    tbl.glGetVertexAttribfvNV = glGetVertexAttribfvNV;
    tbl.glGetVertexAttribivNV = glGetVertexAttribivNV;
    tbl.glIsProgramNV = glIsProgramNV;
    tbl.glLoadProgramNV = glLoadProgramNV;
    tbl.glProgramParameter4dNV = glProgramParameter4dNV;
    tbl.glProgramParameter4dvNV = glProgramParameter4dvNV;
    tbl.glProgramParameter4fNV = glProgramParameter4fNV;
    tbl.glProgramParameter4fvNV = glProgramParameter4fvNV;
    tbl.glProgramParameters4dvNV = glProgramParameters4dvNV;
    tbl.glProgramParameters4fvNV = glProgramParameters4fvNV;
    tbl.glRequestResidentProgramsNV = glRequestResidentProgramsNV;
    tbl.glTrackMatrixNV = glTrackMatrixNV;
    tbl.glVertexAttrib1dNV = glVertexAttrib1dNV;
    tbl.glVertexAttrib1dvNV = glVertexAttrib1dvNV;
    tbl.glVertexAttrib1fNV = glVertexAttrib1fNV;
    tbl.glVertexAttrib1fvNV = glVertexAttrib1fvNV;
    tbl.glVertexAttrib1sNV = glVertexAttrib1sNV;
    tbl.glVertexAttrib1svNV = glVertexAttrib1svNV;
    tbl.glVertexAttrib2dNV = glVertexAttrib2dNV;
    tbl.glVertexAttrib2dvNV = glVertexAttrib2dvNV;
    tbl.glVertexAttrib2fNV = glVertexAttrib2fNV;
    tbl.glVertexAttrib2fvNV = glVertexAttrib2fvNV;
    tbl.glVertexAttrib2sNV = glVertexAttrib2sNV;
    tbl.glVertexAttrib2svNV = glVertexAttrib2svNV;
    tbl.glVertexAttrib3dNV = glVertexAttrib3dNV;
    tbl.glVertexAttrib3dvNV = glVertexAttrib3dvNV;
    tbl.glVertexAttrib3fNV = glVertexAttrib3fNV;
    tbl.glVertexAttrib3fvNV = glVertexAttrib3fvNV;
    tbl.glVertexAttrib3sNV = glVertexAttrib3sNV;
    tbl.glVertexAttrib3svNV = glVertexAttrib3svNV;
    tbl.glVertexAttrib4dNV = glVertexAttrib4dNV;
    tbl.glVertexAttrib4dvNV = glVertexAttrib4dvNV;
    tbl.glVertexAttrib4fNV = glVertexAttrib4fNV;
    tbl.glVertexAttrib4fvNV = glVertexAttrib4fvNV;
    tbl.glVertexAttrib4sNV = glVertexAttrib4sNV;
    tbl.glVertexAttrib4svNV = glVertexAttrib4svNV;
    tbl.glVertexAttrib4ubNV = glVertexAttrib4ubNV;
    tbl.glVertexAttrib4ubvNV = glVertexAttrib4ubvNV;
    tbl.glVertexAttribPointerNV = glVertexAttribPointerNV;
    tbl.glVertexAttribs1dvNV = glVertexAttribs1dvNV;
    tbl.glVertexAttribs1fvNV = glVertexAttribs1fvNV;
    tbl.glVertexAttribs1svNV = glVertexAttribs1svNV;
    tbl.glVertexAttribs2dvNV = glVertexAttribs2dvNV;
    tbl.glVertexAttribs2fvNV = glVertexAttribs2fvNV;
    tbl.glVertexAttribs2svNV = glVertexAttribs2svNV;
    tbl.glVertexAttribs3dvNV = glVertexAttribs3dvNV;
    tbl.glVertexAttribs3fvNV = glVertexAttribs3fvNV;
    tbl.glVertexAttribs3svNV = glVertexAttribs3svNV;
    tbl.glVertexAttribs4dvNV = glVertexAttribs4dvNV;
    tbl.glVertexAttribs4fvNV = glVertexAttribs4fvNV;
    tbl.glVertexAttribs4svNV = glVertexAttribs4svNV;
    tbl.glVertexAttribs4ubvNV = glVertexAttribs4ubvNV;

  // GL_NV_video_capture

    tbl.glBeginVideoCaptureNV = glBeginVideoCaptureNV;
    tbl.glBindVideoCaptureStreamBufferNV = glBindVideoCaptureStreamBufferNV;
    tbl.glBindVideoCaptureStreamTextureNV = glBindVideoCaptureStreamTextureNV;
    tbl.glEndVideoCaptureNV = glEndVideoCaptureNV;
    tbl.glGetVideoCaptureStreamdvNV = glGetVideoCaptureStreamdvNV;
    tbl.glGetVideoCaptureStreamfvNV = glGetVideoCaptureStreamfvNV;
    tbl.glGetVideoCaptureStreamivNV = glGetVideoCaptureStreamivNV;
    tbl.glGetVideoCaptureivNV = glGetVideoCaptureivNV;
    tbl.glVideoCaptureNV = glVideoCaptureNV;
    tbl.glVideoCaptureStreamParameterdvNV = glVideoCaptureStreamParameterdvNV;
    tbl.glVideoCaptureStreamParameterfvNV = glVideoCaptureStreamParameterfvNV;
    tbl.glVideoCaptureStreamParameterivNV = glVideoCaptureStreamParameterivNV;

  // GL_OES_blend_equation_separate

    tbl.glBlendEquationSeparateOES = glBlendEquationSeparateOES;

  // GL_OES_blend_func_separate

    tbl.glBlendFuncSeparateOES = glBlendFuncSeparateOES;

  // GL_OES_blend_subtract

    tbl.glBlendEquationOES = glBlendEquationOES;

  // GL_OES_framebuffer_object

    tbl.glBindFramebufferOES = glBindFramebufferOES;
    tbl.glBindRenderbufferOES = glBindRenderbufferOES;
    tbl.glCheckFramebufferStatusOES = glCheckFramebufferStatusOES;
    tbl.glDeleteFramebuffersOES = glDeleteFramebuffersOES;
    tbl.glDeleteRenderbuffersOES = glDeleteRenderbuffersOES;
    tbl.glFramebufferRenderbufferOES = glFramebufferRenderbufferOES;
    tbl.glFramebufferTexture2DOES = glFramebufferTexture2DOES;
    tbl.glGenFramebuffersOES = glGenFramebuffersOES;
    tbl.glGenRenderbuffersOES = glGenRenderbuffersOES;
    tbl.glGenerateMipmapOES = glGenerateMipmapOES;
    tbl.glGetFramebufferAttachmentParameterivOES = glGetFramebufferAttachmentParameterivOES;
    tbl.glGetRenderbufferParameterivOES = glGetRenderbufferParameterivOES;
    tbl.glIsFramebufferOES = glIsFramebufferOES;
    tbl.glIsRenderbufferOES = glIsRenderbufferOES;
    tbl.glRenderbufferStorageOES = glRenderbufferStorageOES;

  // GL_OES_get_program_binary

    tbl.glGetProgramBinaryOES = glGetProgramBinaryOES;
    tbl.glProgramBinaryOES = glProgramBinaryOES;

  // GL_OES_mapbuffer

    tbl.glGetBufferPointervOES = glGetBufferPointervOES;
    tbl.glMapBufferOES = glMapBufferOES;
    tbl.glUnmapBufferOES = glUnmapBufferOES;

  // GL_OES_matrix_palette

    tbl.glCurrentPaletteMatrixOES = glCurrentPaletteMatrixOES;
    tbl.glMatrixIndexPointerOES = glMatrixIndexPointerOES;
    tbl.glWeightPointerOES = glWeightPointerOES;

  // GL_OES_single_precision

    tbl.glClearDepthfOES = glClearDepthfOES;
    tbl.glClipPlanefOES = glClipPlanefOES;
    tbl.glDepthRangefOES = glDepthRangefOES;
    tbl.glFrustumfOES = glFrustumfOES;
    tbl.glGetClipPlanefOES = glGetClipPlanefOES;
    tbl.glOrthofOES = glOrthofOES;

  // GL_OES_texture_3D

    tbl.glCompressedTexImage3DOES = glCompressedTexImage3DOES;
    tbl.glCompressedTexSubImage3DOES = glCompressedTexSubImage3DOES;
    tbl.glCopyTexSubImage3DOES = glCopyTexSubImage3DOES;
    tbl.glFramebufferTexture3DOES = glFramebufferTexture3DOES;
    tbl.glTexImage3DOES = glTexImage3DOES;
    tbl.glTexSubImage3DOES = glTexSubImage3DOES;

  // GL_OES_texture_cube_map

    tbl.glGetTexGenfvOES = glGetTexGenfvOES;
    tbl.glGetTexGenivOES = glGetTexGenivOES;
    tbl.glGetTexGenxvOES = glGetTexGenxvOES;
    tbl.glTexGenfOES = glTexGenfOES;
    tbl.glTexGenfvOES = glTexGenfvOES;
    tbl.glTexGeniOES = glTexGeniOES;
    tbl.glTexGenivOES = glTexGenivOES;
    tbl.glTexGenxOES = glTexGenxOES;
    tbl.glTexGenxvOES = glTexGenxvOES;

  // GL_OES_vertex_array_object

    tbl.glBindVertexArrayOES = glBindVertexArrayOES;
    tbl.glDeleteVertexArraysOES = glDeleteVertexArraysOES;
    tbl.glGenVertexArraysOES = glGenVertexArraysOES;
    tbl.glIsVertexArrayOES = glIsVertexArrayOES;

  // GL_PGI_misc_hints

    tbl.glHintPGI = glHintPGI;

  // GL_QCOM_alpha_test

    tbl.glAlphaFuncQCOM = glAlphaFuncQCOM;

  // GL_QCOM_driver_control

    tbl.glDisableDriverControlQCOM = glDisableDriverControlQCOM;
    tbl.glEnableDriverControlQCOM = glEnableDriverControlQCOM;
    tbl.glGetDriverControlStringQCOM = glGetDriverControlStringQCOM;
    tbl.glGetDriverControlsQCOM = glGetDriverControlsQCOM;

  // GL_QCOM_extended_get

    tbl.glExtGetBufferPointervQCOM = glExtGetBufferPointervQCOM;
    tbl.glExtGetBuffersQCOM = glExtGetBuffersQCOM;
    tbl.glExtGetFramebuffersQCOM = glExtGetFramebuffersQCOM;
    tbl.glExtGetRenderbuffersQCOM = glExtGetRenderbuffersQCOM;
    tbl.glExtGetTexLevelParameterivQCOM = glExtGetTexLevelParameterivQCOM;
    tbl.glExtGetTexSubImageQCOM = glExtGetTexSubImageQCOM;
    tbl.glExtGetTexturesQCOM = glExtGetTexturesQCOM;
    tbl.glExtTexObjectStateOverrideiQCOM = glExtTexObjectStateOverrideiQCOM;

  // GL_QCOM_extended_get2

    tbl.glExtGetProgramBinarySourceQCOM = glExtGetProgramBinarySourceQCOM;
    tbl.glExtGetProgramsQCOM = glExtGetProgramsQCOM;
    tbl.glExtGetShadersQCOM = glExtGetShadersQCOM;
    tbl.glExtIsProgramBinaryQCOM = glExtIsProgramBinaryQCOM;

  // GL_QCOM_tiled_rendering

    tbl.glEndTilingQCOM = glEndTilingQCOM;
    tbl.glStartTilingQCOM = glStartTilingQCOM;

  // GL_REGAL_ES1_0_compatibility

    tbl.glAlphaFuncx = glAlphaFuncx;
    tbl.glClearColorx = glClearColorx;
    tbl.glClearDepthx = glClearDepthx;
    tbl.glColor4x = glColor4x;
    tbl.glDepthRangex = glDepthRangex;
    tbl.glFogx = glFogx;
    tbl.glFogxv = glFogxv;
    tbl.glFrustumf = glFrustumf;
    tbl.glFrustumx = glFrustumx;
    tbl.glLightModelx = glLightModelx;
    tbl.glLightModelxv = glLightModelxv;
    tbl.glLightx = glLightx;
    tbl.glLightxv = glLightxv;
    tbl.glLineWidthx = glLineWidthx;
    tbl.glLoadMatrixx = glLoadMatrixx;
    tbl.glMaterialx = glMaterialx;
    tbl.glMaterialxv = glMaterialxv;
    tbl.glMultMatrixx = glMultMatrixx;
    tbl.glMultiTexCoord4x = glMultiTexCoord4x;
    tbl.glNormal3x = glNormal3x;
    tbl.glOrthof = glOrthof;
    tbl.glOrthox = glOrthox;
    tbl.glPointSizex = glPointSizex;
    tbl.glPolygonOffsetx = glPolygonOffsetx;
    tbl.glRotatex = glRotatex;
    tbl.glSampleCoveragex = glSampleCoveragex;
    tbl.glScalex = glScalex;
    tbl.glTexEnvx = glTexEnvx;
    tbl.glTexEnvxv = glTexEnvxv;
    tbl.glTexParameterx = glTexParameterx;
    tbl.glTranslatex = glTranslatex;

  // GL_REGAL_ES1_1_compatibility

    tbl.glClipPlanef = glClipPlanef;
    tbl.glClipPlanex = glClipPlanex;
    tbl.glGetClipPlanef = glGetClipPlanef;
    tbl.glGetClipPlanex = glGetClipPlanex;
    tbl.glGetFixedv = glGetFixedv;
    tbl.glGetLightxv = glGetLightxv;
    tbl.glGetMaterialxv = glGetMaterialxv;
    tbl.glGetTexEnvxv = glGetTexEnvxv;
    tbl.glGetTexParameterxv = glGetTexParameterxv;
    tbl.glPointParameterx = glPointParameterx;
    tbl.glPointParameterxv = glPointParameterxv;
    tbl.glPointSizePointerOES = glPointSizePointerOES;
    tbl.glTexParameterxv = glTexParameterxv;

  // GL_REGAL_log

    tbl.glLogMessageCallbackREGAL = glLogMessageCallbackREGAL;

  // GL_SGIS_detail_texture

    tbl.glDetailTexFuncSGIS = glDetailTexFuncSGIS;
    tbl.glGetDetailTexFuncSGIS = glGetDetailTexFuncSGIS;

  // GL_SGIS_fog_function

    tbl.glFogFuncSGIS = glFogFuncSGIS;
    tbl.glGetFogFuncSGIS = glGetFogFuncSGIS;

  // GL_SGIS_multisample

    tbl.glSampleMaskSGIS = glSampleMaskSGIS;
    tbl.glSamplePatternSGIS = glSamplePatternSGIS;

  // GL_SGIS_pixel_texture

    tbl.glGetPixelTexGenParameterfvSGIS = glGetPixelTexGenParameterfvSGIS;
    tbl.glGetPixelTexGenParameterivSGIS = glGetPixelTexGenParameterivSGIS;
    tbl.glPixelTexGenParameterfSGIS = glPixelTexGenParameterfSGIS;
    tbl.glPixelTexGenParameterfvSGIS = glPixelTexGenParameterfvSGIS;
    tbl.glPixelTexGenParameteriSGIS = glPixelTexGenParameteriSGIS;
    tbl.glPixelTexGenParameterivSGIS = glPixelTexGenParameterivSGIS;

  // GL_SGIS_point_parameters

    tbl.glPointParameterfSGIS = glPointParameterfSGIS;
    tbl.glPointParameterfvSGIS = glPointParameterfvSGIS;

  // GL_SGIS_sharpen_texture

    tbl.glGetSharpenTexFuncSGIS = glGetSharpenTexFuncSGIS;
    tbl.glSharpenTexFuncSGIS = glSharpenTexFuncSGIS;

  // GL_SGIS_texture4D

    tbl.glTexImage4DSGIS = glTexImage4DSGIS;
    tbl.glTexSubImage4DSGIS = glTexSubImage4DSGIS;

  // GL_SGIS_texture_color_mask

    tbl.glTextureColorMaskSGIS = glTextureColorMaskSGIS;

  // GL_SGIS_texture_filter4

    tbl.glGetTexFilterFuncSGIS = glGetTexFilterFuncSGIS;
    tbl.glTexFilterFuncSGIS = glTexFilterFuncSGIS;

  // GL_SGIX_async

    tbl.glAsyncMarkerSGIX = glAsyncMarkerSGIX;
    tbl.glDeleteAsyncMarkersSGIX = glDeleteAsyncMarkersSGIX;
    tbl.glFinishAsyncSGIX = glFinishAsyncSGIX;
    tbl.glGenAsyncMarkersSGIX = glGenAsyncMarkersSGIX;
    tbl.glIsAsyncMarkerSGIX = glIsAsyncMarkerSGIX;
    tbl.glPollAsyncSGIX = glPollAsyncSGIX;

  // GL_SGIX_flush_raster

    tbl.glFlushRasterSGIX = glFlushRasterSGIX;

  // GL_SGIX_fog_texture

    tbl.glTextureFogSGIX = glTextureFogSGIX;

  // GL_SGIX_fragment_lighting

    tbl.glFragmentColorMaterialSGIX = glFragmentColorMaterialSGIX;
    tbl.glFragmentLightModelfSGIX = glFragmentLightModelfSGIX;
    tbl.glFragmentLightModelfvSGIX = glFragmentLightModelfvSGIX;
    tbl.glFragmentLightModeliSGIX = glFragmentLightModeliSGIX;
    tbl.glFragmentLightModelivSGIX = glFragmentLightModelivSGIX;
    tbl.glFragmentLightfSGIX = glFragmentLightfSGIX;
    tbl.glFragmentLightfvSGIX = glFragmentLightfvSGIX;
    tbl.glFragmentLightiSGIX = glFragmentLightiSGIX;
    tbl.glFragmentLightivSGIX = glFragmentLightivSGIX;
    tbl.glFragmentMaterialfSGIX = glFragmentMaterialfSGIX;
    tbl.glFragmentMaterialfvSGIX = glFragmentMaterialfvSGIX;
    tbl.glFragmentMaterialiSGIX = glFragmentMaterialiSGIX;
    tbl.glFragmentMaterialivSGIX = glFragmentMaterialivSGIX;
    tbl.glGetFragmentLightfvSGIX = glGetFragmentLightfvSGIX;
    tbl.glGetFragmentLightivSGIX = glGetFragmentLightivSGIX;
    tbl.glGetFragmentMaterialfvSGIX = glGetFragmentMaterialfvSGIX;
    tbl.glGetFragmentMaterialivSGIX = glGetFragmentMaterialivSGIX;
    tbl.glLightEnviSGIX = glLightEnviSGIX;

  // GL_SGIX_framezoom

    tbl.glFrameZoomSGIX = glFrameZoomSGIX;

  // GL_SGIX_igloo_interface

    tbl.glIglooInterfaceSGIX = glIglooInterfaceSGIX;

  // GL_SGIX_instruments

    tbl.glGetInstrumentsSGIX = glGetInstrumentsSGIX;
    tbl.glInstrumentsBufferSGIX = glInstrumentsBufferSGIX;
    tbl.glPollInstrumentsSGIX = glPollInstrumentsSGIX;
    tbl.glReadInstrumentsSGIX = glReadInstrumentsSGIX;
    tbl.glStartInstrumentsSGIX = glStartInstrumentsSGIX;
    tbl.glStopInstrumentsSGIX = glStopInstrumentsSGIX;

  // GL_SGIX_list_priority

    tbl.glGetListParameterfvSGIX = glGetListParameterfvSGIX;
    tbl.glGetListParameterivSGIX = glGetListParameterivSGIX;
    tbl.glListParameterfSGIX = glListParameterfSGIX;
    tbl.glListParameterfvSGIX = glListParameterfvSGIX;
    tbl.glListParameteriSGIX = glListParameteriSGIX;
    tbl.glListParameterivSGIX = glListParameterivSGIX;

  // GL_SGIX_pixel_texture

    tbl.glPixelTexGenSGIX = glPixelTexGenSGIX;

  // GL_SGIX_polynomial_ffd

    tbl.glDeformSGIX = glDeformSGIX;
    tbl.glDeformationMap3dSGIX = glDeformationMap3dSGIX;
    tbl.glDeformationMap3fSGIX = glDeformationMap3fSGIX;
    tbl.glLoadIdentityDeformationMapSGIX = glLoadIdentityDeformationMapSGIX;

  // GL_SGIX_reference_plane

    tbl.glReferencePlaneSGIX = glReferencePlaneSGIX;

  // GL_SGIX_sprite

    tbl.glSpriteParameterfSGIX = glSpriteParameterfSGIX;
    tbl.glSpriteParameterfvSGIX = glSpriteParameterfvSGIX;
    tbl.glSpriteParameteriSGIX = glSpriteParameteriSGIX;
    tbl.glSpriteParameterivSGIX = glSpriteParameterivSGIX;

  // GL_SGIX_tag_sample_buffer

    tbl.glTagSampleBufferSGIX = glTagSampleBufferSGIX;

  // GL_SGI_color_table

    tbl.glColorTableParameterfvSGI = glColorTableParameterfvSGI;
    tbl.glColorTableParameterivSGI = glColorTableParameterivSGI;
    tbl.glColorTableSGI = glColorTableSGI;
    tbl.glCopyColorTableSGI = glCopyColorTableSGI;
    tbl.glGetColorTableParameterfvSGI = glGetColorTableParameterfvSGI;
    tbl.glGetColorTableParameterivSGI = glGetColorTableParameterivSGI;
    tbl.glGetColorTableSGI = glGetColorTableSGI;

  // GL_SUNX_constant_data

    tbl.glFinishTextureSUNX = glFinishTextureSUNX;

  // GL_SUN_global_alpha

    tbl.glGlobalAlphaFactorbSUN = glGlobalAlphaFactorbSUN;
    tbl.glGlobalAlphaFactordSUN = glGlobalAlphaFactordSUN;
    tbl.glGlobalAlphaFactorfSUN = glGlobalAlphaFactorfSUN;
    tbl.glGlobalAlphaFactoriSUN = glGlobalAlphaFactoriSUN;
    tbl.glGlobalAlphaFactorsSUN = glGlobalAlphaFactorsSUN;
    tbl.glGlobalAlphaFactorubSUN = glGlobalAlphaFactorubSUN;
    tbl.glGlobalAlphaFactoruiSUN = glGlobalAlphaFactoruiSUN;
    tbl.glGlobalAlphaFactorusSUN = glGlobalAlphaFactorusSUN;

  // GL_SUN_mesh_array

    tbl.glDrawMeshArraysSUN = glDrawMeshArraysSUN;

  // GL_SUN_read_video_pixels

    tbl.glReadVideoPixelsSUN = glReadVideoPixelsSUN;

  // GL_SUN_triangle_list

    tbl.glReplacementCodePointerSUN = glReplacementCodePointerSUN;
    tbl.glReplacementCodeubSUN = glReplacementCodeubSUN;
    tbl.glReplacementCodeubvSUN = glReplacementCodeubvSUN;
    tbl.glReplacementCodeuiSUN = glReplacementCodeuiSUN;
    tbl.glReplacementCodeuivSUN = glReplacementCodeuivSUN;
    tbl.glReplacementCodeusSUN = glReplacementCodeusSUN;
    tbl.glReplacementCodeusvSUN = glReplacementCodeusvSUN;

  // GL_SUN_vertex

    tbl.glColor3fVertex3fSUN = glColor3fVertex3fSUN;
    tbl.glColor3fVertex3fvSUN = glColor3fVertex3fvSUN;
    tbl.glColor4fNormal3fVertex3fSUN = glColor4fNormal3fVertex3fSUN;
    tbl.glColor4fNormal3fVertex3fvSUN = glColor4fNormal3fVertex3fvSUN;
    tbl.glColor4ubVertex2fSUN = glColor4ubVertex2fSUN;
    tbl.glColor4ubVertex2fvSUN = glColor4ubVertex2fvSUN;
    tbl.glColor4ubVertex3fSUN = glColor4ubVertex3fSUN;
    tbl.glColor4ubVertex3fvSUN = glColor4ubVertex3fvSUN;
    tbl.glNormal3fVertex3fSUN = glNormal3fVertex3fSUN;
    tbl.glNormal3fVertex3fvSUN = glNormal3fVertex3fvSUN;
    tbl.glReplacementCodeuiColor3fVertex3fSUN = glReplacementCodeuiColor3fVertex3fSUN;
    tbl.glReplacementCodeuiColor3fVertex3fvSUN = glReplacementCodeuiColor3fVertex3fvSUN;
    tbl.glReplacementCodeuiColor4fNormal3fVertex3fSUN = glReplacementCodeuiColor4fNormal3fVertex3fSUN;
    tbl.glReplacementCodeuiColor4fNormal3fVertex3fvSUN = glReplacementCodeuiColor4fNormal3fVertex3fvSUN;
    tbl.glReplacementCodeuiColor4ubVertex3fSUN = glReplacementCodeuiColor4ubVertex3fSUN;
    tbl.glReplacementCodeuiColor4ubVertex3fvSUN = glReplacementCodeuiColor4ubVertex3fvSUN;
    tbl.glReplacementCodeuiNormal3fVertex3fSUN = glReplacementCodeuiNormal3fVertex3fSUN;
    tbl.glReplacementCodeuiNormal3fVertex3fvSUN = glReplacementCodeuiNormal3fVertex3fvSUN;
    tbl.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN = glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN;
    tbl.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN = glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN;
    tbl.glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN = glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN;
    tbl.glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN = glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN;
    tbl.glReplacementCodeuiTexCoord2fVertex3fSUN = glReplacementCodeuiTexCoord2fVertex3fSUN;
    tbl.glReplacementCodeuiTexCoord2fVertex3fvSUN = glReplacementCodeuiTexCoord2fVertex3fvSUN;
    tbl.glReplacementCodeuiVertex3fSUN = glReplacementCodeuiVertex3fSUN;
    tbl.glReplacementCodeuiVertex3fvSUN = glReplacementCodeuiVertex3fvSUN;
    tbl.glTexCoord2fColor3fVertex3fSUN = glTexCoord2fColor3fVertex3fSUN;
    tbl.glTexCoord2fColor3fVertex3fvSUN = glTexCoord2fColor3fVertex3fvSUN;
    tbl.glTexCoord2fColor4fNormal3fVertex3fSUN = glTexCoord2fColor4fNormal3fVertex3fSUN;
    tbl.glTexCoord2fColor4fNormal3fVertex3fvSUN = glTexCoord2fColor4fNormal3fVertex3fvSUN;
    tbl.glTexCoord2fColor4ubVertex3fSUN = glTexCoord2fColor4ubVertex3fSUN;
    tbl.glTexCoord2fColor4ubVertex3fvSUN = glTexCoord2fColor4ubVertex3fvSUN;
    tbl.glTexCoord2fNormal3fVertex3fSUN = glTexCoord2fNormal3fVertex3fSUN;
    tbl.glTexCoord2fNormal3fVertex3fvSUN = glTexCoord2fNormal3fVertex3fvSUN;
    tbl.glTexCoord2fVertex3fSUN = glTexCoord2fVertex3fSUN;
    tbl.glTexCoord2fVertex3fvSUN = glTexCoord2fVertex3fvSUN;
    tbl.glTexCoord4fColor4fNormal3fVertex4fSUN = glTexCoord4fColor4fNormal3fVertex4fSUN;
    tbl.glTexCoord4fColor4fNormal3fVertex4fvSUN = glTexCoord4fColor4fNormal3fVertex4fvSUN;
    tbl.glTexCoord4fVertex4fSUN = glTexCoord4fVertex4fSUN;
    tbl.glTexCoord4fVertex4fvSUN = glTexCoord4fVertex4fvSUN;

  // GL_WIN_swap_hint

    tbl.glAddSwapHintRectWIN = glAddSwapHintRectWIN;

  }

void Init(DispatchTableGlobal &tbl)
{

#if REGAL_SYS_WGL
  // WGL_3DL_stereo_control

    tbl.wglSetStereoEmitterState3DL = wglSetStereoEmitterState3DL;

  // WGL_AMD_gpu_association

    tbl.wglBlitContextFramebufferAMD = wglBlitContextFramebufferAMD;
    tbl.wglCreateAssociatedContextAMD = wglCreateAssociatedContextAMD;
    tbl.wglCreateAssociatedContextAttribsAMD = wglCreateAssociatedContextAttribsAMD;
    tbl.wglDeleteAssociatedContextAMD = wglDeleteAssociatedContextAMD;
    tbl.wglGetContextGPUIDAMD = wglGetContextGPUIDAMD;
    tbl.wglGetCurrentAssociatedContextAMD = wglGetCurrentAssociatedContextAMD;
    tbl.wglGetGPUIDsAMD = wglGetGPUIDsAMD;
    tbl.wglGetGPUInfoAMD = wglGetGPUInfoAMD;
    tbl.wglMakeAssociatedContextCurrentAMD = wglMakeAssociatedContextCurrentAMD;

  // WGL_ARB_buffer_region

    tbl.wglCreateBufferRegionARB = wglCreateBufferRegionARB;
    tbl.wglDeleteBufferRegionARB = wglDeleteBufferRegionARB;
    tbl.wglRestoreBufferRegionARB = wglRestoreBufferRegionARB;
    tbl.wglSaveBufferRegionARB = wglSaveBufferRegionARB;

  // WGL_ARB_create_context

    tbl.wglCreateContextAttribsARB = wglCreateContextAttribsARB;

  // WGL_ARB_extensions_string

    tbl.wglGetExtensionsStringARB = wglGetExtensionsStringARB;

  // WGL_ARB_make_current_read

    tbl.wglGetCurrentReadDCARB = wglGetCurrentReadDCARB;
    tbl.wglMakeContextCurrentARB = wglMakeContextCurrentARB;

  // WGL_ARB_pbuffer

    tbl.wglCreatePbufferARB = wglCreatePbufferARB;
    tbl.wglDestroyPbufferARB = wglDestroyPbufferARB;
    tbl.wglGetPbufferDCARB = wglGetPbufferDCARB;
    tbl.wglQueryPbufferARB = wglQueryPbufferARB;
    tbl.wglReleasePbufferDCARB = wglReleasePbufferDCARB;

  // WGL_ARB_pixel_format

    tbl.wglChoosePixelFormatARB = wglChoosePixelFormatARB;
    tbl.wglGetPixelFormatAttribfvARB = wglGetPixelFormatAttribfvARB;
    tbl.wglGetPixelFormatAttribivARB = wglGetPixelFormatAttribivARB;

  // WGL_ARB_render_texture

    tbl.wglBindTexImageARB = wglBindTexImageARB;
    tbl.wglReleaseTexImageARB = wglReleaseTexImageARB;
    tbl.wglSetPbufferAttribARB = wglSetPbufferAttribARB;

  // WGL_EXT_display_color_table

    tbl.wglBindDisplayColorTableEXT = wglBindDisplayColorTableEXT;
    tbl.wglCreateDisplayColorTableEXT = wglCreateDisplayColorTableEXT;
    tbl.wglDestroyDisplayColorTableEXT = wglDestroyDisplayColorTableEXT;
    tbl.wglLoadDisplayColorTableEXT = wglLoadDisplayColorTableEXT;

  // WGL_EXT_extensions_string

    tbl.wglGetExtensionsStringEXT = wglGetExtensionsStringEXT;

  // WGL_EXT_make_current_read

    tbl.wglGetCurrentReadDCEXT = wglGetCurrentReadDCEXT;
    tbl.wglMakeContextCurrentEXT = wglMakeContextCurrentEXT;

  // WGL_EXT_pbuffer

    tbl.wglCreatePbufferEXT = wglCreatePbufferEXT;
    tbl.wglDestroyPbufferEXT = wglDestroyPbufferEXT;
    tbl.wglGetPbufferDCEXT = wglGetPbufferDCEXT;
    tbl.wglQueryPbufferEXT = wglQueryPbufferEXT;
    tbl.wglReleasePbufferDCEXT = wglReleasePbufferDCEXT;

  // WGL_EXT_pixel_format

    tbl.wglChoosePixelFormatEXT = wglChoosePixelFormatEXT;
    tbl.wglGetPixelFormatAttribfvEXT = wglGetPixelFormatAttribfvEXT;
    tbl.wglGetPixelFormatAttribivEXT = wglGetPixelFormatAttribivEXT;

  // WGL_EXT_swap_control

    tbl.wglGetSwapIntervalEXT = wglGetSwapIntervalEXT;
    tbl.wglSwapIntervalEXT = wglSwapIntervalEXT;

  // WGL_GDI

    tbl.wglChoosePixelFormat = wglChoosePixelFormat;
    tbl.wglDescribePixelFormat = wglDescribePixelFormat;
    tbl.wglGetPixelFormat = wglGetPixelFormat;
    tbl.wglSetPixelFormat = wglSetPixelFormat;
    tbl.wglSwapBuffers = wglSwapBuffers;

  // WGL_I3D_digital_video_control

    tbl.wglGetDigitalVideoParametersI3D = wglGetDigitalVideoParametersI3D;
    tbl.wglSetDigitalVideoParametersI3D = wglSetDigitalVideoParametersI3D;

  // WGL_I3D_gamma

    tbl.wglGetGammaTableI3D = wglGetGammaTableI3D;
    tbl.wglGetGammaTableParametersI3D = wglGetGammaTableParametersI3D;
    tbl.wglSetGammaTableI3D = wglSetGammaTableI3D;
    tbl.wglSetGammaTableParametersI3D = wglSetGammaTableParametersI3D;

  // WGL_I3D_genlock

    tbl.wglDisableGenlockI3D = wglDisableGenlockI3D;
    tbl.wglEnableGenlockI3D = wglEnableGenlockI3D;
    tbl.wglGenlockSampleRateI3D = wglGenlockSampleRateI3D;
    tbl.wglGenlockSourceDelayI3D = wglGenlockSourceDelayI3D;
    tbl.wglGenlockSourceEdgeI3D = wglGenlockSourceEdgeI3D;
    tbl.wglGenlockSourceI3D = wglGenlockSourceI3D;
    tbl.wglGetGenlockSampleRateI3D = wglGetGenlockSampleRateI3D;
    tbl.wglGetGenlockSourceDelayI3D = wglGetGenlockSourceDelayI3D;
    tbl.wglGetGenlockSourceEdgeI3D = wglGetGenlockSourceEdgeI3D;
    tbl.wglGetGenlockSourceI3D = wglGetGenlockSourceI3D;
    tbl.wglIsEnabledGenlockI3D = wglIsEnabledGenlockI3D;
    tbl.wglQueryGenlockMaxSourceDelayI3D = wglQueryGenlockMaxSourceDelayI3D;

  // WGL_I3D_image_buffer

    tbl.wglAssociateImageBufferEventsI3D = wglAssociateImageBufferEventsI3D;
    tbl.wglCreateImageBufferI3D = wglCreateImageBufferI3D;
    tbl.wglDestroyImageBufferI3D = wglDestroyImageBufferI3D;
    tbl.wglReleaseImageBufferEventsI3D = wglReleaseImageBufferEventsI3D;

  // WGL_I3D_swap_frame_lock

    tbl.wglDisableFrameLockI3D = wglDisableFrameLockI3D;
    tbl.wglEnableFrameLockI3D = wglEnableFrameLockI3D;
    tbl.wglIsEnabledFrameLockI3D = wglIsEnabledFrameLockI3D;
    tbl.wglQueryFrameLockMasterI3D = wglQueryFrameLockMasterI3D;

  // WGL_I3D_swap_frame_usage

    tbl.wglBeginFrameTrackingI3D = wglBeginFrameTrackingI3D;
    tbl.wglEndFrameTrackingI3D = wglEndFrameTrackingI3D;
    tbl.wglGetFrameUsageI3D = wglGetFrameUsageI3D;
    tbl.wglQueryFrameTrackingI3D = wglQueryFrameTrackingI3D;

  // WGL_NV_DX_interop

    tbl.wglDXCloseDeviceNV = wglDXCloseDeviceNV;
    tbl.wglDXLockObjectsNV = wglDXLockObjectsNV;
    tbl.wglDXObjectAccessNV = wglDXObjectAccessNV;
    tbl.wglDXOpenDeviceNV = wglDXOpenDeviceNV;
    tbl.wglDXRegisterObjectNV = wglDXRegisterObjectNV;
    tbl.wglDXSetResourceShareHandleNV = wglDXSetResourceShareHandleNV;
    tbl.wglDXUnlockObjectsNV = wglDXUnlockObjectsNV;
    tbl.wglDXUnregisterObjectNV = wglDXUnregisterObjectNV;

  // WGL_NV_copy_image

    tbl.wglCopyImageSubDataNV = wglCopyImageSubDataNV;

  // WGL_NV_gpu_affinity

    tbl.wglCreateAffinityDCNV = wglCreateAffinityDCNV;
    tbl.wglDeleteDCNV = wglDeleteDCNV;
    tbl.wglEnumGpuDevicesNV = wglEnumGpuDevicesNV;
    tbl.wglEnumGpusFromAffinityDCNV = wglEnumGpusFromAffinityDCNV;
    tbl.wglEnumGpusNV = wglEnumGpusNV;

  // WGL_NV_present_video

    tbl.wglBindVideoDeviceNV = wglBindVideoDeviceNV;
    tbl.wglEnumerateVideoDevicesNV = wglEnumerateVideoDevicesNV;
    tbl.wglQueryCurrentContextNV = wglQueryCurrentContextNV;

  // WGL_NV_swap_group

    tbl.wglBindSwapBarrierNV = wglBindSwapBarrierNV;
    tbl.wglJoinSwapGroupNV = wglJoinSwapGroupNV;
    tbl.wglQueryFrameCountNV = wglQueryFrameCountNV;
    tbl.wglQueryMaxSwapGroupsNV = wglQueryMaxSwapGroupsNV;
    tbl.wglQuerySwapGroupNV = wglQuerySwapGroupNV;
    tbl.wglResetFrameCountNV = wglResetFrameCountNV;

  // WGL_NV_vertex_array_range

    tbl.wglAllocateMemoryNV = wglAllocateMemoryNV;
    tbl.wglFreeMemoryNV = wglFreeMemoryNV;

  // WGL_NV_video_capture

    tbl.wglBindVideoCaptureDeviceNV = wglBindVideoCaptureDeviceNV;
    tbl.wglEnumerateVideoCaptureDevicesNV = wglEnumerateVideoCaptureDevicesNV;
    tbl.wglLockVideoCaptureDeviceNV = wglLockVideoCaptureDeviceNV;
    tbl.wglQueryVideoCaptureDeviceNV = wglQueryVideoCaptureDeviceNV;
    tbl.wglReleaseVideoCaptureDeviceNV = wglReleaseVideoCaptureDeviceNV;

  // WGL_NV_video_output

    tbl.wglBindVideoImageNV = wglBindVideoImageNV;
    tbl.wglGetVideoDeviceNV = wglGetVideoDeviceNV;
    tbl.wglGetVideoInfoNV = wglGetVideoInfoNV;
    tbl.wglReleaseVideoDeviceNV = wglReleaseVideoDeviceNV;
    tbl.wglReleaseVideoImageNV = wglReleaseVideoImageNV;
    tbl.wglSendPbufferToVideoNV = wglSendPbufferToVideoNV;

  // WGL_OML_sync_control

    tbl.wglGetMscRateOML = wglGetMscRateOML;
    tbl.wglGetSyncValuesOML = wglGetSyncValuesOML;
    tbl.wglSwapBuffersMscOML = wglSwapBuffersMscOML;
    tbl.wglSwapLayerBuffersMscOML = wglSwapLayerBuffersMscOML;
    tbl.wglWaitForMscOML = wglWaitForMscOML;
    tbl.wglWaitForSbcOML = wglWaitForSbcOML;

  // WGL_core

    tbl.wglCopyContext = wglCopyContext;
    tbl.wglCreateContext = wglCreateContext;
    tbl.wglCreateLayerContext = wglCreateLayerContext;
    tbl.wglDeleteContext = wglDeleteContext;
    tbl.wglDescribeLayerPlane = wglDescribeLayerPlane;
    tbl.wglGetCurrentContext = wglGetCurrentContext;
    tbl.wglGetCurrentDC = wglGetCurrentDC;
    tbl.wglGetDefaultProcAddress = wglGetDefaultProcAddress;
    tbl.wglGetLayerPaletteEntries = wglGetLayerPaletteEntries;
    tbl.wglGetProcAddress = wglGetProcAddress;
    tbl.wglMakeCurrent = wglMakeCurrent;
    tbl.wglRealizeLayerPalette = wglRealizeLayerPalette;
    tbl.wglSetLayerPaletteEntries = wglSetLayerPaletteEntries;
    tbl.wglShareLists = wglShareLists;
    tbl.wglSwapLayerBuffers = wglSwapLayerBuffers;
    tbl.wglSwapMultipleBuffers = wglSwapMultipleBuffers;
    tbl.wglUseFontBitmapsA = wglUseFontBitmapsA;
    tbl.wglUseFontBitmapsW = wglUseFontBitmapsW;
    tbl.wglUseFontOutlinesA = wglUseFontOutlinesA;
    tbl.wglUseFontOutlinesW = wglUseFontOutlinesW;
#endif // REGAL_SYS_WGL

#if REGAL_SYS_GLX

  // GLX_VERSION_1_0

    tbl.glXChooseVisual = glXChooseVisual;
    tbl.glXCopyContext = glXCopyContext;
    tbl.glXCreateContext = glXCreateContext;
    tbl.glXCreateGLXPixmap = glXCreateGLXPixmap;
    tbl.glXDestroyContext = glXDestroyContext;
    tbl.glXDestroyGLXPixmap = glXDestroyGLXPixmap;
    tbl.glXGetConfig = glXGetConfig;
    tbl.glXGetCurrentContext = glXGetCurrentContext;
    tbl.glXGetCurrentDrawable = glXGetCurrentDrawable;
    tbl.glXIsDirect = glXIsDirect;
    tbl.glXMakeCurrent = glXMakeCurrent;
    tbl.glXQueryExtension = glXQueryExtension;
    tbl.glXQueryVersion = glXQueryVersion;
    tbl.glXSwapBuffers = glXSwapBuffers;
    tbl.glXUseXFont = glXUseXFont;
    tbl.glXWaitGL = glXWaitGL;
    tbl.glXWaitX = glXWaitX;

  // GLX_VERSION_1_1

    tbl.glXGetClientString = glXGetClientString;
    tbl.glXQueryExtensionsString = glXQueryExtensionsString;
    tbl.glXQueryServerString = glXQueryServerString;

  // GLX_VERSION_1_2

    tbl.glXGetCurrentDisplay = glXGetCurrentDisplay;

  // GLX_VERSION_1_3

    tbl.glXChooseFBConfig = glXChooseFBConfig;
    tbl.glXCreateNewContext = glXCreateNewContext;
    tbl.glXCreatePbuffer = glXCreatePbuffer;
    tbl.glXCreatePixmap = glXCreatePixmap;
    tbl.glXCreateWindow = glXCreateWindow;
    tbl.glXDestroyPbuffer = glXDestroyPbuffer;
    tbl.glXDestroyPixmap = glXDestroyPixmap;
    tbl.glXDestroyWindow = glXDestroyWindow;
    tbl.glXGetCurrentReadDrawable = glXGetCurrentReadDrawable;
    tbl.glXGetFBConfigAttrib = glXGetFBConfigAttrib;
    tbl.glXGetFBConfigs = glXGetFBConfigs;
    tbl.glXGetSelectedEvent = glXGetSelectedEvent;
    tbl.glXGetVisualFromFBConfig = glXGetVisualFromFBConfig;
    tbl.glXMakeContextCurrent = glXMakeContextCurrent;
    tbl.glXQueryContext = glXQueryContext;
    tbl.glXQueryDrawable = glXQueryDrawable;
    tbl.glXSelectEvent = glXSelectEvent;

  // GLX_VERSION_1_4

    tbl.glXGetProcAddress = glXGetProcAddress;

  // GLX_AMD_gpu_association

    tbl.glXBlitContextFramebufferAMD = glXBlitContextFramebufferAMD;
    tbl.glXCreateAssociatedContextAMD = glXCreateAssociatedContextAMD;
    tbl.glXCreateAssociatedContextAttribsAMD = glXCreateAssociatedContextAttribsAMD;
    tbl.glXDeleteAssociatedContextAMD = glXDeleteAssociatedContextAMD;
    tbl.glXGetContextGPUIDAMD = glXGetContextGPUIDAMD;
    tbl.glXGetCurrentAssociatedContextAMD = glXGetCurrentAssociatedContextAMD;
    tbl.glXGetGPUIDsAMD = glXGetGPUIDsAMD;
    tbl.glXGetGPUInfoAMD = glXGetGPUInfoAMD;
    tbl.glXMakeAssociatedContextCurrentAMD = glXMakeAssociatedContextCurrentAMD;

  // GLX_ARB_create_context

    tbl.glXCreateContextAttribsARB = glXCreateContextAttribsARB;

  // GLX_ARB_get_proc_address

    tbl.glXGetProcAddressARB = glXGetProcAddressARB;

  // GLX_ATI_render_texture

    tbl.glXBindTexImageATI = glXBindTexImageATI;
    tbl.glXDrawableAttribATI = glXDrawableAttribATI;
    tbl.glXReleaseTexImageATI = glXReleaseTexImageATI;

  // GLX_EXT_import_context

    tbl.glXFreeContextEXT = glXFreeContextEXT;
    tbl.glXGetContextIDEXT = glXGetContextIDEXT;
    tbl.glXImportContextEXT = glXImportContextEXT;
    tbl.glXQueryContextInfoEXT = glXQueryContextInfoEXT;

  // GLX_EXT_swap_control

    tbl.glXSwapIntervalEXT = glXSwapIntervalEXT;

  // GLX_EXT_texture_from_pixmap

    tbl.glXBindTexImageEXT = glXBindTexImageEXT;
    tbl.glXReleaseTexImageEXT = glXReleaseTexImageEXT;

  // GLX_MESA_agp_offset

    tbl.glXGetAGPOffsetMESA = glXGetAGPOffsetMESA;

  // GLX_MESA_copy_sub_buffer

    tbl.glXCopySubBufferMESA = glXCopySubBufferMESA;

  // GLX_MESA_pixmap_colormap

    tbl.glXCreateGLXPixmapMESA = glXCreateGLXPixmapMESA;

  // GLX_MESA_release_buffers

    tbl.glXReleaseBuffersMESA = glXReleaseBuffersMESA;

  // GLX_MESA_set_3dfx_mode

    tbl.glXSet3DfxModeMESA = glXSet3DfxModeMESA;

  // GLX_MESA_swap_control

    tbl.glXGetSwapIntervalMESA = glXGetSwapIntervalMESA;
    tbl.glXSwapIntervalMESA = glXSwapIntervalMESA;

  // GLX_NV_copy_image

    tbl.glXCopyImageSubDataNV = glXCopyImageSubDataNV;

  // GLX_NV_present_video

    tbl.glXBindVideoDeviceNV = glXBindVideoDeviceNV;
    tbl.glXEnumerateVideoDevicesNV = glXEnumerateVideoDevicesNV;

  // GLX_NV_swap_group

    tbl.glXBindSwapBarrierNV = glXBindSwapBarrierNV;
    tbl.glXJoinSwapGroupNV = glXJoinSwapGroupNV;
    tbl.glXQueryFrameCountNV = glXQueryFrameCountNV;
    tbl.glXQueryMaxSwapGroupsNV = glXQueryMaxSwapGroupsNV;
    tbl.glXQuerySwapGroupNV = glXQuerySwapGroupNV;
    tbl.glXResetFrameCountNV = glXResetFrameCountNV;

  // GLX_NV_vertex_array_range

    tbl.glXAllocateMemoryNV = glXAllocateMemoryNV;
    tbl.glXFreeMemoryNV = glXFreeMemoryNV;

  // GLX_NV_video_capture

    tbl.glXBindVideoCaptureDeviceNV = glXBindVideoCaptureDeviceNV;
    tbl.glXEnumerateVideoCaptureDevicesNV = glXEnumerateVideoCaptureDevicesNV;
    tbl.glXLockVideoCaptureDeviceNV = glXLockVideoCaptureDeviceNV;
    tbl.glXQueryVideoCaptureDeviceNV = glXQueryVideoCaptureDeviceNV;
    tbl.glXReleaseVideoCaptureDeviceNV = glXReleaseVideoCaptureDeviceNV;

  // GLX_NV_video_output

    tbl.glXBindVideoImageNV = glXBindVideoImageNV;
    tbl.glXGetVideoDeviceNV = glXGetVideoDeviceNV;
    tbl.glXGetVideoInfoNV = glXGetVideoInfoNV;
    tbl.glXReleaseVideoDeviceNV = glXReleaseVideoDeviceNV;
    tbl.glXReleaseVideoImageNV = glXReleaseVideoImageNV;
    tbl.glXSendPbufferToVideoNV = glXSendPbufferToVideoNV;

  // GLX_OML_sync_control

    tbl.glXGetMscRateOML = glXGetMscRateOML;
    tbl.glXGetSyncValuesOML = glXGetSyncValuesOML;
    tbl.glXSwapBuffersMscOML = glXSwapBuffersMscOML;
    tbl.glXWaitForMscOML = glXWaitForMscOML;
    tbl.glXWaitForSbcOML = glXWaitForSbcOML;

  // GLX_SGIX_fbconfig

    tbl.glXChooseFBConfigSGIX = glXChooseFBConfigSGIX;
    tbl.glXCreateContextWithConfigSGIX = glXCreateContextWithConfigSGIX;
    tbl.glXCreateGLXPixmapWithConfigSGIX = glXCreateGLXPixmapWithConfigSGIX;
    tbl.glXGetFBConfigAttribSGIX = glXGetFBConfigAttribSGIX;
    tbl.glXGetFBConfigFromVisualSGIX = glXGetFBConfigFromVisualSGIX;
    tbl.glXGetVisualFromFBConfigSGIX = glXGetVisualFromFBConfigSGIX;

  // GLX_SGIX_pbuffer

    tbl.glXCreateGLXPbufferSGIX = glXCreateGLXPbufferSGIX;
    tbl.glXDestroyGLXPbufferSGIX = glXDestroyGLXPbufferSGIX;
    tbl.glXGetSelectedEventSGIX = glXGetSelectedEventSGIX;
    tbl.glXQueryGLXPbufferSGIX = glXQueryGLXPbufferSGIX;
    tbl.glXSelectEventSGIX = glXSelectEventSGIX;

  // GLX_SGIX_swap_barrier

    tbl.glXBindSwapBarrierSGIX = glXBindSwapBarrierSGIX;
    tbl.glXQueryMaxSwapBarriersSGIX = glXQueryMaxSwapBarriersSGIX;

  // GLX_SGIX_swap_group

    tbl.glXJoinSwapGroupSGIX = glXJoinSwapGroupSGIX;

  // GLX_SGIX_video_resize

    tbl.glXBindChannelToWindowSGIX = glXBindChannelToWindowSGIX;
    tbl.glXChannelRectSGIX = glXChannelRectSGIX;
    tbl.glXChannelRectSyncSGIX = glXChannelRectSyncSGIX;
    tbl.glXQueryChannelDeltasSGIX = glXQueryChannelDeltasSGIX;
    tbl.glXQueryChannelRectSGIX = glXQueryChannelRectSGIX;

  // GLX_SGI_cushion

    tbl.glXCushionSGI = glXCushionSGI;

  // GLX_SGI_make_current_read

    tbl.glXGetCurrentReadDrawableSGI = glXGetCurrentReadDrawableSGI;
    tbl.glXMakeCurrentReadSGI = glXMakeCurrentReadSGI;

  // GLX_SGI_swap_control

    tbl.glXSwapIntervalSGI = glXSwapIntervalSGI;

  // GLX_SGI_video_sync

    tbl.glXGetVideoSyncSGI = glXGetVideoSyncSGI;
    tbl.glXWaitVideoSyncSGI = glXWaitVideoSyncSGI;

  // GLX_SUN_get_transparent_index

    tbl.glXGetTransparentIndexSUN = glXGetTransparentIndexSUN;

  // GLX_SUN_video_resize

    tbl.glXGetVideoResizeSUN = glXGetVideoResizeSUN;
    tbl.glXVideoResizeSUN = glXVideoResizeSUN;
#endif // REGAL_SYS_GLX

#if REGAL_SYS_OSX

  // CGL_VERSION_1_0

    tbl.CGLChoosePixelFormat = CGLChoosePixelFormat;
    tbl.CGLClearDrawable = CGLClearDrawable;
    tbl.CGLCopyContext = CGLCopyContext;
    tbl.CGLCreateContext = CGLCreateContext;
    tbl.CGLDescribePixelFormat = CGLDescribePixelFormat;
    tbl.CGLDescribeRenderer = CGLDescribeRenderer;
    tbl.CGLDestroyContext = CGLDestroyContext;
    tbl.CGLDestroyPixelFormat = CGLDestroyPixelFormat;
    tbl.CGLDestroyRendererInfo = CGLDestroyRendererInfo;
    tbl.CGLDisable = CGLDisable;
    tbl.CGLEnable = CGLEnable;
    tbl.CGLErrorString = CGLErrorString;
    tbl.CGLFlushDrawable = CGLFlushDrawable;
    tbl.CGLGetOffScreen = CGLGetOffScreen;
    tbl.CGLGetOption = CGLGetOption;
    tbl.CGLGetParameter = CGLGetParameter;
    tbl.CGLGetVersion = CGLGetVersion;
    tbl.CGLGetVirtualScreen = CGLGetVirtualScreen;
    tbl.CGLIsEnabled = CGLIsEnabled;
    tbl.CGLQueryRendererInfo = CGLQueryRendererInfo;
    tbl.CGLSetFullScreen = CGLSetFullScreen;
    tbl.CGLSetOffScreen = CGLSetOffScreen;
    tbl.CGLSetOption = CGLSetOption;
    tbl.CGLSetParameter = CGLSetParameter;
    tbl.CGLSetVirtualScreen = CGLSetVirtualScreen;

  // CGL_VERSION_1_1

    tbl.CGLCreatePBuffer = CGLCreatePBuffer;
    tbl.CGLDescribePBuffer = CGLDescribePBuffer;
    tbl.CGLDestroyPBuffer = CGLDestroyPBuffer;
    tbl.CGLGetPBuffer = CGLGetPBuffer;
    tbl.CGLSetPBuffer = CGLSetPBuffer;
    tbl.CGLTexImagePBuffer = CGLTexImagePBuffer;

  // CGL_VERSION_1_2

    tbl.CGLGetContextRetainCount = CGLGetContextRetainCount;
    tbl.CGLGetGlobalOption = CGLGetGlobalOption;
    tbl.CGLGetPBufferRetainCount = CGLGetPBufferRetainCount;
    tbl.CGLGetPixelFormat = CGLGetPixelFormat;
    tbl.CGLGetPixelFormatRetainCount = CGLGetPixelFormatRetainCount;
    tbl.CGLLockContext = CGLLockContext;
    tbl.CGLReleaseContext = CGLReleaseContext;
    tbl.CGLReleasePBuffer = CGLReleasePBuffer;
    tbl.CGLReleasePixelFormat = CGLReleasePixelFormat;
    tbl.CGLRetainContext = CGLRetainContext;
    tbl.CGLRetainPBuffer = CGLRetainPBuffer;
    tbl.CGLRetainPixelFormat = CGLRetainPixelFormat;
    tbl.CGLSetGlobalOption = CGLSetGlobalOption;
    tbl.CGLUnlockContext = CGLUnlockContext;

  // CGL_VERSION_1_3

    tbl.CGLGetCurrentContext = CGLGetCurrentContext;
    tbl.CGLGetShareGroup = CGLGetShareGroup;
    tbl.CGLGetSurface = CGLGetSurface;
    tbl.CGLSetCurrentContext = CGLSetCurrentContext;
    tbl.CGLSetSurface = CGLSetSurface;
    tbl.CGLTexImageIOSurface2D = CGLTexImageIOSurface2D;
    tbl.CGLUpdateContext = CGLUpdateContext;
#endif // REGAL_SYS_OSX

#if REGAL_SYS_EGL

  // EGL_ANGLE_query_surface_pointer

    tbl.eglQuerySurfacePointerANGLE = eglQuerySurfacePointerANGLE;

  // EGL_KHR_fence_sync

    tbl.eglClientWaitSyncKHR = eglClientWaitSyncKHR;
    tbl.eglCreateSyncKHR = eglCreateSyncKHR;
    tbl.eglDestroySyncKHR = eglDestroySyncKHR;
    tbl.eglGetSyncAttribKHR = eglGetSyncAttribKHR;

  // EGL_KHR_image_base

    tbl.eglCreateImageKHR = eglCreateImageKHR;
    tbl.eglDestroyImageKHR = eglDestroyImageKHR;

  // EGL_KHR_lock_surface

    tbl.eglLockSurfaceKHR = eglLockSurfaceKHR;
    tbl.eglUnlockSurfaceKHR = eglUnlockSurfaceKHR;

  // EGL_KHR_stream_consumer_gltexture

    tbl.eglStreamConsumerAcquireKHR = eglStreamConsumerAcquireKHR;
    tbl.eglStreamConsumerGLTextureExternalKHR = eglStreamConsumerGLTextureExternalKHR;
    tbl.eglStreamConsumerReleaseKHR = eglStreamConsumerReleaseKHR;

  // EGL_KHR_stream_cross_process_fd

    tbl.eglCreateStreamFromFileDescriptorKHR = eglCreateStreamFromFileDescriptorKHR;
    tbl.eglGetStreamFileDescriptorKHR = eglGetStreamFileDescriptorKHR;

  // EGL_KHR_stream_producer_eglsurface

    tbl.eglCreateStreamProducerSurfaceKHR = eglCreateStreamProducerSurfaceKHR;

  // EGL_KHR_wait_sync

    tbl.eglWaitSyncKHR = eglWaitSyncKHR;

  // EGL_MESA_drm_image

    tbl.eglCreateDRMImageMESA = eglCreateDRMImageMESA;
    tbl.eglExportDRMImageMESA = eglExportDRMImageMESA;

  // EGL_NV_coverage_sample

    tbl.eglCoverageMaskNV = eglCoverageMaskNV;
    tbl.eglCoverageOperationNV = eglCoverageOperationNV;

  // EGL_NV_post_sub_buffer

    tbl.eglPostSubBufferNV = eglPostSubBufferNV;

  // EGL_NV_sync

    tbl.eglClientWaitSyncNV = eglClientWaitSyncNV;
    tbl.eglCreateFenceSyncNV = eglCreateFenceSyncNV;
    tbl.eglDestroySyncNV = eglDestroySyncNV;
    tbl.eglFenceNV = eglFenceNV;
    tbl.eglGetSyncAttribNV = eglGetSyncAttribNV;
    tbl.eglSignalSyncNV = eglSignalSyncNV;

  // EGL_NV_system_time

    tbl.eglGetSystemTimeFrequencyNV = eglGetSystemTimeFrequencyNV;
    tbl.eglGetSystemTimeNV = eglGetSystemTimeNV;

  // EGL_VERSION_1_0

    tbl.eglChooseConfig = eglChooseConfig;
    tbl.eglCopyBuffers = eglCopyBuffers;
    tbl.eglCreateContext = eglCreateContext;
    tbl.eglCreatePbufferSurface = eglCreatePbufferSurface;
    tbl.eglCreatePixmapSurface = eglCreatePixmapSurface;
    tbl.eglCreateWindowSurface = eglCreateWindowSurface;
    tbl.eglDestroyContext = eglDestroyContext;
    tbl.eglDestroySurface = eglDestroySurface;
    tbl.eglGetConfigAttrib = eglGetConfigAttrib;
    tbl.eglGetConfigs = eglGetConfigs;
    tbl.eglGetCurrentContext = eglGetCurrentContext;
    tbl.eglGetCurrentDisplay = eglGetCurrentDisplay;
    tbl.eglGetCurrentSurface = eglGetCurrentSurface;
    tbl.eglGetDisplay = eglGetDisplay;
    tbl.eglGetError = eglGetError;
    tbl.eglGetProcAddress = eglGetProcAddress;
    tbl.eglInitialize = eglInitialize;
    tbl.eglMakeCurrent = eglMakeCurrent;
    tbl.eglQueryContext = eglQueryContext;
    tbl.eglQueryString = eglQueryString;
    tbl.eglQuerySurface = eglQuerySurface;
    tbl.eglSwapBuffers = eglSwapBuffers;
    tbl.eglTerminate = eglTerminate;
    tbl.eglWaitGL = eglWaitGL;
    tbl.eglWaitNative = eglWaitNative;

  // EGL_VERSION_1_1

    tbl.eglBindTexImage = eglBindTexImage;
    tbl.eglReleaseTexImage = eglReleaseTexImage;

  // EGL_VERSION_1_2

    tbl.eglBindAPI = eglBindAPI;
    tbl.eglCreatePbufferFromClientBuffer = eglCreatePbufferFromClientBuffer;
    tbl.eglQueryAPI = eglQueryAPI;
    tbl.eglReleaseThread = eglReleaseThread;
    tbl.eglSurfaceAttrib = eglSurfaceAttrib;
    tbl.eglSwapInterval = eglSwapInterval;
    tbl.eglWaitClient = eglWaitClient;
#endif // REGAL_SYS_EGL

}

} // namespace Loader

REGAL_NAMESPACE_END

#endif
