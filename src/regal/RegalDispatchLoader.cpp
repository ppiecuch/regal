/* NOTE: Do not edit this file, it is generated by a script:
   Export.py --api gl 4.2 --api wgl 4.0 --api glx 4.0 --api cgl 1.4 --api egl 1.0 --outdir .
*/

/*
  Copyright (c) 2011 NVIDIA Corporation
  Copyright (c) 2011-2012 Cass Everitt
  Copyright (c) 2012 Scott Nations
  Copyright (c) 2012 Mathias Schott
  Copyright (c) 2012 Nigel Stewart
  Copyright (c) 2012 Google Inc.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without modification,
  are permitted provided that the following conditions are met:

    Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.

    Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
  OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
  Intended formatting conventions:
  $ astyle --style=allman --indent=spaces=2 --indent-switches
*/

#include "pch.h" /* For MS precompiled header support */

#include "RegalUtil.h"

#if REGAL_DRIVER && !REGAL_SYS_PPAPI

REGAL_GLOBAL_BEGIN

#include <string>
using namespace std;

#include "RegalLog.h"
#include "RegalPush.h"
#include "RegalToken.h"
#include "RegalHelper.h"
#include "RegalPrivate.h"
#include "RegalContext.h"

REGAL_GLOBAL_END

REGAL_NAMESPACE_BEGIN

using namespace ::REGAL_NAMESPACE_INTERNAL::Logging;
using namespace ::REGAL_NAMESPACE_INTERNAL::Token;

// GL_VERSION_1_0

static void REGAL_CALL loader_glAccum(GLenum op, GLfloat value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glAccum, "glAccum");
  if (_driver.glAccum) {
    _driver.glAccum(op, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glAccum)(op, value);
}

static void REGAL_CALL loader_glAlphaFunc(GLenum func, GLclampf ref)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glAlphaFunc, "glAlphaFunc");
  if (_driver.glAlphaFunc) {
    _driver.glAlphaFunc(func, ref);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glAlphaFunc)(func, ref);
}

static void REGAL_CALL loader_glBegin(GLenum mode)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBegin, "glBegin");
  if (_driver.glBegin) {
    _driver.glBegin(mode);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBegin)(mode);
}

static void REGAL_CALL loader_glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBitmap, "glBitmap");
  if (_driver.glBitmap) {
    _driver.glBitmap(width, height, xorig, yorig, xmove, ymove, bitmap);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBitmap)(width, height, xorig, yorig, xmove, ymove, bitmap);
}

static void REGAL_CALL loader_glBlendFunc(GLenum sfactor, GLenum dfactor)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBlendFunc, "glBlendFunc");
  if (_driver.glBlendFunc) {
    _driver.glBlendFunc(sfactor, dfactor);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBlendFunc)(sfactor, dfactor);
}

static void REGAL_CALL loader_glCallList(GLuint list)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCallList, "glCallList");
  if (_driver.glCallList) {
    _driver.glCallList(list);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCallList)(list);
}

static void REGAL_CALL loader_glCallLists(GLsizei n, GLenum type, const GLvoid *lists)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCallLists, "glCallLists");
  if (_driver.glCallLists) {
    _driver.glCallLists(n, type, lists);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCallLists)(n, type, lists);
}

static void REGAL_CALL loader_glClear(GLbitfield mask)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glClear, "glClear");
  if (_driver.glClear) {
    _driver.glClear(mask);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glClear)(mask);
}

static void REGAL_CALL loader_glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glClearAccum, "glClearAccum");
  if (_driver.glClearAccum) {
    _driver.glClearAccum(red, green, blue, alpha);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glClearAccum)(red, green, blue, alpha);
}

static void REGAL_CALL loader_glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glClearColor, "glClearColor");
  if (_driver.glClearColor) {
    _driver.glClearColor(red, green, blue, alpha);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glClearColor)(red, green, blue, alpha);
}

static void REGAL_CALL loader_glClearDepth(GLclampd depth)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glClearDepth, "glClearDepth");
  if (_driver.glClearDepth) {
    _driver.glClearDepth(depth);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glClearDepth)(depth);
}

static void REGAL_CALL loader_glClearIndex(GLfloat c)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glClearIndex, "glClearIndex");
  if (_driver.glClearIndex) {
    _driver.glClearIndex(c);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glClearIndex)(c);
}

static void REGAL_CALL loader_glClearStencil(GLint s)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glClearStencil, "glClearStencil");
  if (_driver.glClearStencil) {
    _driver.glClearStencil(s);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glClearStencil)(s);
}

static void REGAL_CALL loader_glClipPlane(GLenum plane, const GLdouble *equation)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glClipPlane, "glClipPlane");
  if (_driver.glClipPlane) {
    _driver.glClipPlane(plane, equation);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glClipPlane)(plane, equation);
}

static void REGAL_CALL loader_glColor3b(GLbyte red, GLbyte green, GLbyte blue)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColor3b, "glColor3b");
  if (_driver.glColor3b) {
    _driver.glColor3b(red, green, blue);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColor3b)(red, green, blue);
}

static void REGAL_CALL loader_glColor3bv(const GLbyte *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColor3bv, "glColor3bv");
  if (_driver.glColor3bv) {
    _driver.glColor3bv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColor3bv)(v);
}

static void REGAL_CALL loader_glColor3d(GLdouble red, GLdouble green, GLdouble blue)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColor3d, "glColor3d");
  if (_driver.glColor3d) {
    _driver.glColor3d(red, green, blue);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColor3d)(red, green, blue);
}

static void REGAL_CALL loader_glColor3dv(const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColor3dv, "glColor3dv");
  if (_driver.glColor3dv) {
    _driver.glColor3dv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColor3dv)(v);
}

static void REGAL_CALL loader_glColor3f(GLfloat red, GLfloat green, GLfloat blue)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColor3f, "glColor3f");
  if (_driver.glColor3f) {
    _driver.glColor3f(red, green, blue);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColor3f)(red, green, blue);
}

static void REGAL_CALL loader_glColor3fv(const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColor3fv, "glColor3fv");
  if (_driver.glColor3fv) {
    _driver.glColor3fv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColor3fv)(v);
}

static void REGAL_CALL loader_glColor3i(GLint red, GLint green, GLint blue)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColor3i, "glColor3i");
  if (_driver.glColor3i) {
    _driver.glColor3i(red, green, blue);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColor3i)(red, green, blue);
}

static void REGAL_CALL loader_glColor3iv(const GLint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColor3iv, "glColor3iv");
  if (_driver.glColor3iv) {
    _driver.glColor3iv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColor3iv)(v);
}

static void REGAL_CALL loader_glColor3s(GLshort red, GLshort green, GLshort blue)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColor3s, "glColor3s");
  if (_driver.glColor3s) {
    _driver.glColor3s(red, green, blue);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColor3s)(red, green, blue);
}

static void REGAL_CALL loader_glColor3sv(const GLshort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColor3sv, "glColor3sv");
  if (_driver.glColor3sv) {
    _driver.glColor3sv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColor3sv)(v);
}

static void REGAL_CALL loader_glColor3ub(GLubyte red, GLubyte green, GLubyte blue)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColor3ub, "glColor3ub");
  if (_driver.glColor3ub) {
    _driver.glColor3ub(red, green, blue);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColor3ub)(red, green, blue);
}

static void REGAL_CALL loader_glColor3ubv(const GLubyte *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColor3ubv, "glColor3ubv");
  if (_driver.glColor3ubv) {
    _driver.glColor3ubv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColor3ubv)(v);
}

static void REGAL_CALL loader_glColor3ui(GLuint red, GLuint green, GLuint blue)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColor3ui, "glColor3ui");
  if (_driver.glColor3ui) {
    _driver.glColor3ui(red, green, blue);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColor3ui)(red, green, blue);
}

static void REGAL_CALL loader_glColor3uiv(const GLuint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColor3uiv, "glColor3uiv");
  if (_driver.glColor3uiv) {
    _driver.glColor3uiv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColor3uiv)(v);
}

static void REGAL_CALL loader_glColor3us(GLushort red, GLushort green, GLushort blue)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColor3us, "glColor3us");
  if (_driver.glColor3us) {
    _driver.glColor3us(red, green, blue);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColor3us)(red, green, blue);
}

static void REGAL_CALL loader_glColor3usv(const GLushort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColor3usv, "glColor3usv");
  if (_driver.glColor3usv) {
    _driver.glColor3usv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColor3usv)(v);
}

static void REGAL_CALL loader_glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColor4b, "glColor4b");
  if (_driver.glColor4b) {
    _driver.glColor4b(red, green, blue, alpha);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColor4b)(red, green, blue, alpha);
}

static void REGAL_CALL loader_glColor4bv(const GLbyte *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColor4bv, "glColor4bv");
  if (_driver.glColor4bv) {
    _driver.glColor4bv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColor4bv)(v);
}

static void REGAL_CALL loader_glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColor4d, "glColor4d");
  if (_driver.glColor4d) {
    _driver.glColor4d(red, green, blue, alpha);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColor4d)(red, green, blue, alpha);
}

static void REGAL_CALL loader_glColor4dv(const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColor4dv, "glColor4dv");
  if (_driver.glColor4dv) {
    _driver.glColor4dv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColor4dv)(v);
}

static void REGAL_CALL loader_glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColor4f, "glColor4f");
  if (_driver.glColor4f) {
    _driver.glColor4f(red, green, blue, alpha);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColor4f)(red, green, blue, alpha);
}

static void REGAL_CALL loader_glColor4fv(const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColor4fv, "glColor4fv");
  if (_driver.glColor4fv) {
    _driver.glColor4fv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColor4fv)(v);
}

static void REGAL_CALL loader_glColor4i(GLint red, GLint green, GLint blue, GLint alpha)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColor4i, "glColor4i");
  if (_driver.glColor4i) {
    _driver.glColor4i(red, green, blue, alpha);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColor4i)(red, green, blue, alpha);
}

static void REGAL_CALL loader_glColor4iv(const GLint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColor4iv, "glColor4iv");
  if (_driver.glColor4iv) {
    _driver.glColor4iv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColor4iv)(v);
}

static void REGAL_CALL loader_glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColor4s, "glColor4s");
  if (_driver.glColor4s) {
    _driver.glColor4s(red, green, blue, alpha);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColor4s)(red, green, blue, alpha);
}

static void REGAL_CALL loader_glColor4sv(const GLshort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColor4sv, "glColor4sv");
  if (_driver.glColor4sv) {
    _driver.glColor4sv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColor4sv)(v);
}

static void REGAL_CALL loader_glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColor4ub, "glColor4ub");
  if (_driver.glColor4ub) {
    _driver.glColor4ub(red, green, blue, alpha);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColor4ub)(red, green, blue, alpha);
}

static void REGAL_CALL loader_glColor4ubv(const GLubyte *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColor4ubv, "glColor4ubv");
  if (_driver.glColor4ubv) {
    _driver.glColor4ubv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColor4ubv)(v);
}

static void REGAL_CALL loader_glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColor4ui, "glColor4ui");
  if (_driver.glColor4ui) {
    _driver.glColor4ui(red, green, blue, alpha);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColor4ui)(red, green, blue, alpha);
}

static void REGAL_CALL loader_glColor4uiv(const GLuint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColor4uiv, "glColor4uiv");
  if (_driver.glColor4uiv) {
    _driver.glColor4uiv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColor4uiv)(v);
}

static void REGAL_CALL loader_glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColor4us, "glColor4us");
  if (_driver.glColor4us) {
    _driver.glColor4us(red, green, blue, alpha);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColor4us)(red, green, blue, alpha);
}

static void REGAL_CALL loader_glColor4usv(const GLushort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColor4usv, "glColor4usv");
  if (_driver.glColor4usv) {
    _driver.glColor4usv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColor4usv)(v);
}

static void REGAL_CALL loader_glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColorMask, "glColorMask");
  if (_driver.glColorMask) {
    _driver.glColorMask(red, green, blue, alpha);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColorMask)(red, green, blue, alpha);
}

static void REGAL_CALL loader_glColorMaterial(GLenum face, GLenum mode)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColorMaterial, "glColorMaterial");
  if (_driver.glColorMaterial) {
    _driver.glColorMaterial(face, mode);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColorMaterial)(face, mode);
}

static void REGAL_CALL loader_glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCopyPixels, "glCopyPixels");
  if (_driver.glCopyPixels) {
    _driver.glCopyPixels(x, y, width, height, type);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCopyPixels)(x, y, width, height, type);
}

static void REGAL_CALL loader_glCullFace(GLenum mode)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCullFace, "glCullFace");
  if (_driver.glCullFace) {
    _driver.glCullFace(mode);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCullFace)(mode);
}

static void REGAL_CALL loader_glDeleteLists(GLuint list, GLsizei range)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDeleteLists, "glDeleteLists");
  if (_driver.glDeleteLists) {
    _driver.glDeleteLists(list, range);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDeleteLists)(list, range);
}

static void REGAL_CALL loader_glDepthFunc(GLenum func)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDepthFunc, "glDepthFunc");
  if (_driver.glDepthFunc) {
    _driver.glDepthFunc(func);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDepthFunc)(func);
}

static void REGAL_CALL loader_glDepthMask(GLboolean flag)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDepthMask, "glDepthMask");
  if (_driver.glDepthMask) {
    _driver.glDepthMask(flag);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDepthMask)(flag);
}

static void REGAL_CALL loader_glDepthRange(GLclampd zNear, GLclampd zFar)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDepthRange, "glDepthRange");
  if (_driver.glDepthRange) {
    _driver.glDepthRange(zNear, zFar);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDepthRange)(zNear, zFar);
}

static void REGAL_CALL loader_glDisable(GLenum cap)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDisable, "glDisable");
  if (_driver.glDisable) {
    _driver.glDisable(cap);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDisable)(cap);
}

static void REGAL_CALL loader_glDrawBuffer(GLenum mode)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDrawBuffer, "glDrawBuffer");
  if (_driver.glDrawBuffer) {
    _driver.glDrawBuffer(mode);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDrawBuffer)(mode);
}

static void REGAL_CALL loader_glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDrawPixels, "glDrawPixels");
  if (_driver.glDrawPixels) {
    _driver.glDrawPixels(width, height, format, type, pixels);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDrawPixels)(width, height, format, type, pixels);
}

static void REGAL_CALL loader_glEdgeFlag(GLboolean flag)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glEdgeFlag, "glEdgeFlag");
  if (_driver.glEdgeFlag) {
    _driver.glEdgeFlag(flag);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glEdgeFlag)(flag);
}

static void REGAL_CALL loader_glEdgeFlagv(const GLboolean *flag)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glEdgeFlagv, "glEdgeFlagv");
  if (_driver.glEdgeFlagv) {
    _driver.glEdgeFlagv(flag);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glEdgeFlagv)(flag);
}

static void REGAL_CALL loader_glEnable(GLenum cap)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glEnable, "glEnable");
  if (_driver.glEnable) {
    _driver.glEnable(cap);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glEnable)(cap);
}

static void REGAL_CALL loader_glEnd(void)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glEnd, "glEnd");
  if (_driver.glEnd) {
    _driver.glEnd();
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glEnd)();
}

static void REGAL_CALL loader_glEndList(void)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glEndList, "glEndList");
  if (_driver.glEndList) {
    _driver.glEndList();
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glEndList)();
}

static void REGAL_CALL loader_glEvalCoord1d(GLdouble u)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glEvalCoord1d, "glEvalCoord1d");
  if (_driver.glEvalCoord1d) {
    _driver.glEvalCoord1d(u);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glEvalCoord1d)(u);
}

static void REGAL_CALL loader_glEvalCoord1dv(const GLdouble *u)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glEvalCoord1dv, "glEvalCoord1dv");
  if (_driver.glEvalCoord1dv) {
    _driver.glEvalCoord1dv(u);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glEvalCoord1dv)(u);
}

static void REGAL_CALL loader_glEvalCoord1f(GLfloat u)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glEvalCoord1f, "glEvalCoord1f");
  if (_driver.glEvalCoord1f) {
    _driver.glEvalCoord1f(u);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glEvalCoord1f)(u);
}

static void REGAL_CALL loader_glEvalCoord1fv(const GLfloat *u)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glEvalCoord1fv, "glEvalCoord1fv");
  if (_driver.glEvalCoord1fv) {
    _driver.glEvalCoord1fv(u);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glEvalCoord1fv)(u);
}

static void REGAL_CALL loader_glEvalCoord2d(GLdouble u, GLdouble v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glEvalCoord2d, "glEvalCoord2d");
  if (_driver.glEvalCoord2d) {
    _driver.glEvalCoord2d(u, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glEvalCoord2d)(u, v);
}

static void REGAL_CALL loader_glEvalCoord2dv(const GLdouble *u)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glEvalCoord2dv, "glEvalCoord2dv");
  if (_driver.glEvalCoord2dv) {
    _driver.glEvalCoord2dv(u);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glEvalCoord2dv)(u);
}

static void REGAL_CALL loader_glEvalCoord2f(GLfloat u, GLfloat v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glEvalCoord2f, "glEvalCoord2f");
  if (_driver.glEvalCoord2f) {
    _driver.glEvalCoord2f(u, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glEvalCoord2f)(u, v);
}

static void REGAL_CALL loader_glEvalCoord2fv(const GLfloat *u)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glEvalCoord2fv, "glEvalCoord2fv");
  if (_driver.glEvalCoord2fv) {
    _driver.glEvalCoord2fv(u);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glEvalCoord2fv)(u);
}

static void REGAL_CALL loader_glEvalMesh1(GLenum mode, GLint i1, GLint i2)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glEvalMesh1, "glEvalMesh1");
  if (_driver.glEvalMesh1) {
    _driver.glEvalMesh1(mode, i1, i2);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glEvalMesh1)(mode, i1, i2);
}

static void REGAL_CALL loader_glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glEvalMesh2, "glEvalMesh2");
  if (_driver.glEvalMesh2) {
    _driver.glEvalMesh2(mode, i1, i2, j1, j2);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glEvalMesh2)(mode, i1, i2, j1, j2);
}

static void REGAL_CALL loader_glEvalPoint1(GLint i)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glEvalPoint1, "glEvalPoint1");
  if (_driver.glEvalPoint1) {
    _driver.glEvalPoint1(i);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glEvalPoint1)(i);
}

static void REGAL_CALL loader_glEvalPoint2(GLint i, GLint j)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glEvalPoint2, "glEvalPoint2");
  if (_driver.glEvalPoint2) {
    _driver.glEvalPoint2(i, j);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glEvalPoint2)(i, j);
}

static void REGAL_CALL loader_glFeedbackBuffer(GLsizei size, GLenum type, GLfloat *buffer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFeedbackBuffer, "glFeedbackBuffer");
  if (_driver.glFeedbackBuffer) {
    _driver.glFeedbackBuffer(size, type, buffer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFeedbackBuffer)(size, type, buffer);
}

static void REGAL_CALL loader_glFinish(void)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFinish, "glFinish");
  if (_driver.glFinish) {
    _driver.glFinish();
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFinish)();
}

static void REGAL_CALL loader_glFlush(void)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFlush, "glFlush");
  if (_driver.glFlush) {
    _driver.glFlush();
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFlush)();
}

static void REGAL_CALL loader_glFogf(GLenum pname, GLfloat param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFogf, "glFogf");
  if (_driver.glFogf) {
    _driver.glFogf(pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFogf)(pname, param);
}

static void REGAL_CALL loader_glFogfv(GLenum pname, const GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFogfv, "glFogfv");
  if (_driver.glFogfv) {
    _driver.glFogfv(pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFogfv)(pname, params);
}

static void REGAL_CALL loader_glFogi(GLenum pname, GLint param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFogi, "glFogi");
  if (_driver.glFogi) {
    _driver.glFogi(pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFogi)(pname, param);
}

static void REGAL_CALL loader_glFogiv(GLenum pname, const GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFogiv, "glFogiv");
  if (_driver.glFogiv) {
    _driver.glFogiv(pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFogiv)(pname, params);
}

static void REGAL_CALL loader_glFrontFace(GLenum mode)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFrontFace, "glFrontFace");
  if (_driver.glFrontFace) {
    _driver.glFrontFace(mode);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFrontFace)(mode);
}

static void REGAL_CALL loader_glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFrustum, "glFrustum");
  if (_driver.glFrustum) {
    _driver.glFrustum(left, right, bottom, top, zNear, zFar);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFrustum)(left, right, bottom, top, zNear, zFar);
}

static GLuint REGAL_CALL loader_glGenLists(GLsizei range)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGenLists, "glGenLists");
  if (_driver.glGenLists) {
    return _driver.glGenLists(range);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glGenLists)(range);
}

static void REGAL_CALL loader_glGetBooleanv(GLenum pname, GLboolean *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetBooleanv, "glGetBooleanv");
  if (_driver.glGetBooleanv) {
    _driver.glGetBooleanv(pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetBooleanv)(pname, params);
}

static void REGAL_CALL loader_glGetClipPlane(GLenum plane, GLdouble *equation)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetClipPlane, "glGetClipPlane");
  if (_driver.glGetClipPlane) {
    _driver.glGetClipPlane(plane, equation);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetClipPlane)(plane, equation);
}

static void REGAL_CALL loader_glGetDoublev(GLenum pname, GLdouble *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetDoublev, "glGetDoublev");
  if (_driver.glGetDoublev) {
    _driver.glGetDoublev(pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetDoublev)(pname, params);
}

static GLenum REGAL_CALL loader_glGetError(void)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetError, "glGetError");
  if (_driver.glGetError) {
    return _driver.glGetError();
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glGetError)();
}

static void REGAL_CALL loader_glGetFloatv(GLenum pname, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetFloatv, "glGetFloatv");
  if (_driver.glGetFloatv) {
    _driver.glGetFloatv(pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetFloatv)(pname, params);
}

static void REGAL_CALL loader_glGetIntegerv(GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetIntegerv, "glGetIntegerv");
  if (_driver.glGetIntegerv) {
    _driver.glGetIntegerv(pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetIntegerv)(pname, params);
}

static void REGAL_CALL loader_glGetLightfv(GLenum light, GLenum pname, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetLightfv, "glGetLightfv");
  if (_driver.glGetLightfv) {
    _driver.glGetLightfv(light, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetLightfv)(light, pname, params);
}

static void REGAL_CALL loader_glGetLightiv(GLenum light, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetLightiv, "glGetLightiv");
  if (_driver.glGetLightiv) {
    _driver.glGetLightiv(light, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetLightiv)(light, pname, params);
}

static void REGAL_CALL loader_glGetMapdv(GLenum target, GLenum query, GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetMapdv, "glGetMapdv");
  if (_driver.glGetMapdv) {
    _driver.glGetMapdv(target, query, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetMapdv)(target, query, v);
}

static void REGAL_CALL loader_glGetMapfv(GLenum target, GLenum query, GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetMapfv, "glGetMapfv");
  if (_driver.glGetMapfv) {
    _driver.glGetMapfv(target, query, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetMapfv)(target, query, v);
}

static void REGAL_CALL loader_glGetMapiv(GLenum target, GLenum query, GLint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetMapiv, "glGetMapiv");
  if (_driver.glGetMapiv) {
    _driver.glGetMapiv(target, query, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetMapiv)(target, query, v);
}

static void REGAL_CALL loader_glGetMaterialfv(GLenum face, GLenum pname, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetMaterialfv, "glGetMaterialfv");
  if (_driver.glGetMaterialfv) {
    _driver.glGetMaterialfv(face, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetMaterialfv)(face, pname, params);
}

static void REGAL_CALL loader_glGetMaterialiv(GLenum face, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetMaterialiv, "glGetMaterialiv");
  if (_driver.glGetMaterialiv) {
    _driver.glGetMaterialiv(face, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetMaterialiv)(face, pname, params);
}

static void REGAL_CALL loader_glGetPixelMapfv(GLenum map, GLfloat *values)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetPixelMapfv, "glGetPixelMapfv");
  if (_driver.glGetPixelMapfv) {
    _driver.glGetPixelMapfv(map, values);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetPixelMapfv)(map, values);
}

static void REGAL_CALL loader_glGetPixelMapuiv(GLenum map, GLuint *values)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetPixelMapuiv, "glGetPixelMapuiv");
  if (_driver.glGetPixelMapuiv) {
    _driver.glGetPixelMapuiv(map, values);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetPixelMapuiv)(map, values);
}

static void REGAL_CALL loader_glGetPixelMapusv(GLenum map, GLushort *values)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetPixelMapusv, "glGetPixelMapusv");
  if (_driver.glGetPixelMapusv) {
    _driver.glGetPixelMapusv(map, values);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetPixelMapusv)(map, values);
}

static void REGAL_CALL loader_glGetPolygonStipple(GLubyte *mask)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetPolygonStipple, "glGetPolygonStipple");
  if (_driver.glGetPolygonStipple) {
    _driver.glGetPolygonStipple(mask);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetPolygonStipple)(mask);
}

static const GLubyte *REGAL_CALL loader_glGetString(GLenum name)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetString, "glGetString");
  if (_driver.glGetString) {
    return _driver.glGetString(name);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glGetString)(name);
}

static void REGAL_CALL loader_glGetTexEnvfv(GLenum target, GLenum pname, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetTexEnvfv, "glGetTexEnvfv");
  if (_driver.glGetTexEnvfv) {
    _driver.glGetTexEnvfv(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetTexEnvfv)(target, pname, params);
}

static void REGAL_CALL loader_glGetTexEnviv(GLenum target, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetTexEnviv, "glGetTexEnviv");
  if (_driver.glGetTexEnviv) {
    _driver.glGetTexEnviv(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetTexEnviv)(target, pname, params);
}

static void REGAL_CALL loader_glGetTexGendv(GLenum coord, GLenum pname, GLdouble *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetTexGendv, "glGetTexGendv");
  if (_driver.glGetTexGendv) {
    _driver.glGetTexGendv(coord, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetTexGendv)(coord, pname, params);
}

static void REGAL_CALL loader_glGetTexGenfv(GLenum coord, GLenum pname, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetTexGenfv, "glGetTexGenfv");
  if (_driver.glGetTexGenfv) {
    _driver.glGetTexGenfv(coord, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetTexGenfv)(coord, pname, params);
}

static void REGAL_CALL loader_glGetTexGeniv(GLenum coord, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetTexGeniv, "glGetTexGeniv");
  if (_driver.glGetTexGeniv) {
    _driver.glGetTexGeniv(coord, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetTexGeniv)(coord, pname, params);
}

static void REGAL_CALL loader_glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetTexImage, "glGetTexImage");
  if (_driver.glGetTexImage) {
    _driver.glGetTexImage(target, level, format, type, pixels);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetTexImage)(target, level, format, type, pixels);
}

static void REGAL_CALL loader_glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetTexLevelParameterfv, "glGetTexLevelParameterfv");
  if (_driver.glGetTexLevelParameterfv) {
    _driver.glGetTexLevelParameterfv(target, level, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetTexLevelParameterfv)(target, level, pname, params);
}

static void REGAL_CALL loader_glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetTexLevelParameteriv, "glGetTexLevelParameteriv");
  if (_driver.glGetTexLevelParameteriv) {
    _driver.glGetTexLevelParameteriv(target, level, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetTexLevelParameteriv)(target, level, pname, params);
}

static void REGAL_CALL loader_glGetTexParameterfv(GLenum target, GLenum pname, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetTexParameterfv, "glGetTexParameterfv");
  if (_driver.glGetTexParameterfv) {
    _driver.glGetTexParameterfv(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetTexParameterfv)(target, pname, params);
}

static void REGAL_CALL loader_glGetTexParameteriv(GLenum target, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetTexParameteriv, "glGetTexParameteriv");
  if (_driver.glGetTexParameteriv) {
    _driver.glGetTexParameteriv(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetTexParameteriv)(target, pname, params);
}

static void REGAL_CALL loader_glHint(GLenum target, GLenum mode)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glHint, "glHint");
  if (_driver.glHint) {
    _driver.glHint(target, mode);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glHint)(target, mode);
}

static void REGAL_CALL loader_glIndexMask(GLuint mask)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIndexMask, "glIndexMask");
  if (_driver.glIndexMask) {
    _driver.glIndexMask(mask);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glIndexMask)(mask);
}

static void REGAL_CALL loader_glIndexd(GLdouble c)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIndexd, "glIndexd");
  if (_driver.glIndexd) {
    _driver.glIndexd(c);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glIndexd)(c);
}

static void REGAL_CALL loader_glIndexdv(const GLdouble *c)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIndexdv, "glIndexdv");
  if (_driver.glIndexdv) {
    _driver.glIndexdv(c);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glIndexdv)(c);
}

static void REGAL_CALL loader_glIndexf(GLfloat c)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIndexf, "glIndexf");
  if (_driver.glIndexf) {
    _driver.glIndexf(c);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glIndexf)(c);
}

static void REGAL_CALL loader_glIndexfv(const GLfloat *c)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIndexfv, "glIndexfv");
  if (_driver.glIndexfv) {
    _driver.glIndexfv(c);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glIndexfv)(c);
}

static void REGAL_CALL loader_glIndexi(GLint c)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIndexi, "glIndexi");
  if (_driver.glIndexi) {
    _driver.glIndexi(c);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glIndexi)(c);
}

static void REGAL_CALL loader_glIndexiv(const GLint *c)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIndexiv, "glIndexiv");
  if (_driver.glIndexiv) {
    _driver.glIndexiv(c);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glIndexiv)(c);
}

static void REGAL_CALL loader_glIndexs(GLshort c)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIndexs, "glIndexs");
  if (_driver.glIndexs) {
    _driver.glIndexs(c);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glIndexs)(c);
}

static void REGAL_CALL loader_glIndexsv(const GLshort *c)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIndexsv, "glIndexsv");
  if (_driver.glIndexsv) {
    _driver.glIndexsv(c);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glIndexsv)(c);
}

static void REGAL_CALL loader_glInitNames(void)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glInitNames, "glInitNames");
  if (_driver.glInitNames) {
    _driver.glInitNames();
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glInitNames)();
}

static GLboolean REGAL_CALL loader_glIsEnabled(GLenum cap)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIsEnabled, "glIsEnabled");
  if (_driver.glIsEnabled) {
    return _driver.glIsEnabled(cap);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glIsEnabled)(cap);
}

static GLboolean REGAL_CALL loader_glIsList(GLuint list)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIsList, "glIsList");
  if (_driver.glIsList) {
    return _driver.glIsList(list);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glIsList)(list);
}

static void REGAL_CALL loader_glLightModelf(GLenum pname, GLfloat param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glLightModelf, "glLightModelf");
  if (_driver.glLightModelf) {
    _driver.glLightModelf(pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glLightModelf)(pname, param);
}

static void REGAL_CALL loader_glLightModelfv(GLenum pname, const GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glLightModelfv, "glLightModelfv");
  if (_driver.glLightModelfv) {
    _driver.glLightModelfv(pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glLightModelfv)(pname, params);
}

static void REGAL_CALL loader_glLightModeli(GLenum pname, GLint param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glLightModeli, "glLightModeli");
  if (_driver.glLightModeli) {
    _driver.glLightModeli(pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glLightModeli)(pname, param);
}

static void REGAL_CALL loader_glLightModeliv(GLenum pname, const GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glLightModeliv, "glLightModeliv");
  if (_driver.glLightModeliv) {
    _driver.glLightModeliv(pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glLightModeliv)(pname, params);
}

static void REGAL_CALL loader_glLightf(GLenum light, GLenum pname, GLfloat param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glLightf, "glLightf");
  if (_driver.glLightf) {
    _driver.glLightf(light, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glLightf)(light, pname, param);
}

static void REGAL_CALL loader_glLightfv(GLenum light, GLenum pname, const GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glLightfv, "glLightfv");
  if (_driver.glLightfv) {
    _driver.glLightfv(light, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glLightfv)(light, pname, params);
}

static void REGAL_CALL loader_glLighti(GLenum light, GLenum pname, GLint param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glLighti, "glLighti");
  if (_driver.glLighti) {
    _driver.glLighti(light, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glLighti)(light, pname, param);
}

static void REGAL_CALL loader_glLightiv(GLenum light, GLenum pname, const GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glLightiv, "glLightiv");
  if (_driver.glLightiv) {
    _driver.glLightiv(light, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glLightiv)(light, pname, params);
}

static void REGAL_CALL loader_glLineStipple(GLint factor, GLushort pattern)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glLineStipple, "glLineStipple");
  if (_driver.glLineStipple) {
    _driver.glLineStipple(factor, pattern);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glLineStipple)(factor, pattern);
}

static void REGAL_CALL loader_glLineWidth(GLfloat width)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glLineWidth, "glLineWidth");
  if (_driver.glLineWidth) {
    _driver.glLineWidth(width);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glLineWidth)(width);
}

static void REGAL_CALL loader_glListBase(GLuint base)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glListBase, "glListBase");
  if (_driver.glListBase) {
    _driver.glListBase(base);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glListBase)(base);
}

static void REGAL_CALL loader_glLoadIdentity(void)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glLoadIdentity, "glLoadIdentity");
  if (_driver.glLoadIdentity) {
    _driver.glLoadIdentity();
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glLoadIdentity)();
}

static void REGAL_CALL loader_glLoadMatrixd(const GLdouble *m)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glLoadMatrixd, "glLoadMatrixd");
  if (_driver.glLoadMatrixd) {
    _driver.glLoadMatrixd(m);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glLoadMatrixd)(m);
}

static void REGAL_CALL loader_glLoadMatrixf(const GLfloat *m)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glLoadMatrixf, "glLoadMatrixf");
  if (_driver.glLoadMatrixf) {
    _driver.glLoadMatrixf(m);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glLoadMatrixf)(m);
}

static void REGAL_CALL loader_glLoadName(GLuint name)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glLoadName, "glLoadName");
  if (_driver.glLoadName) {
    _driver.glLoadName(name);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glLoadName)(name);
}

static void REGAL_CALL loader_glLogicOp(GLenum opcode)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glLogicOp, "glLogicOp");
  if (_driver.glLogicOp) {
    _driver.glLogicOp(opcode);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glLogicOp)(opcode);
}

static void REGAL_CALL loader_glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMap1d, "glMap1d");
  if (_driver.glMap1d) {
    _driver.glMap1d(target, u1, u2, stride, order, points);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMap1d)(target, u1, u2, stride, order, points);
}

static void REGAL_CALL loader_glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMap1f, "glMap1f");
  if (_driver.glMap1f) {
    _driver.glMap1f(target, u1, u2, stride, order, points);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMap1f)(target, u1, u2, stride, order, points);
}

static void REGAL_CALL loader_glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMap2d, "glMap2d");
  if (_driver.glMap2d) {
    _driver.glMap2d(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMap2d)(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
}

static void REGAL_CALL loader_glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMap2f, "glMap2f");
  if (_driver.glMap2f) {
    _driver.glMap2f(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMap2f)(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
}

static void REGAL_CALL loader_glMapGrid1d(GLint un, GLdouble u1, GLdouble u2)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMapGrid1d, "glMapGrid1d");
  if (_driver.glMapGrid1d) {
    _driver.glMapGrid1d(un, u1, u2);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMapGrid1d)(un, u1, u2);
}

static void REGAL_CALL loader_glMapGrid1f(GLint un, GLfloat u1, GLfloat u2)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMapGrid1f, "glMapGrid1f");
  if (_driver.glMapGrid1f) {
    _driver.glMapGrid1f(un, u1, u2);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMapGrid1f)(un, u1, u2);
}

static void REGAL_CALL loader_glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMapGrid2d, "glMapGrid2d");
  if (_driver.glMapGrid2d) {
    _driver.glMapGrid2d(un, u1, u2, vn, v1, v2);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMapGrid2d)(un, u1, u2, vn, v1, v2);
}

static void REGAL_CALL loader_glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMapGrid2f, "glMapGrid2f");
  if (_driver.glMapGrid2f) {
    _driver.glMapGrid2f(un, u1, u2, vn, v1, v2);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMapGrid2f)(un, u1, u2, vn, v1, v2);
}

static void REGAL_CALL loader_glMaterialf(GLenum face, GLenum pname, GLfloat param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMaterialf, "glMaterialf");
  if (_driver.glMaterialf) {
    _driver.glMaterialf(face, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMaterialf)(face, pname, param);
}

static void REGAL_CALL loader_glMaterialfv(GLenum face, GLenum pname, const GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMaterialfv, "glMaterialfv");
  if (_driver.glMaterialfv) {
    _driver.glMaterialfv(face, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMaterialfv)(face, pname, params);
}

static void REGAL_CALL loader_glMateriali(GLenum face, GLenum pname, GLint param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMateriali, "glMateriali");
  if (_driver.glMateriali) {
    _driver.glMateriali(face, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMateriali)(face, pname, param);
}

static void REGAL_CALL loader_glMaterialiv(GLenum face, GLenum pname, const GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMaterialiv, "glMaterialiv");
  if (_driver.glMaterialiv) {
    _driver.glMaterialiv(face, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMaterialiv)(face, pname, params);
}

static void REGAL_CALL loader_glMatrixMode(GLenum mode)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMatrixMode, "glMatrixMode");
  if (_driver.glMatrixMode) {
    _driver.glMatrixMode(mode);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMatrixMode)(mode);
}

static void REGAL_CALL loader_glMultMatrixd(const GLdouble *m)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultMatrixd, "glMultMatrixd");
  if (_driver.glMultMatrixd) {
    _driver.glMultMatrixd(m);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultMatrixd)(m);
}

static void REGAL_CALL loader_glMultMatrixf(const GLfloat *m)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultMatrixf, "glMultMatrixf");
  if (_driver.glMultMatrixf) {
    _driver.glMultMatrixf(m);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultMatrixf)(m);
}

static void REGAL_CALL loader_glNewList(GLuint list, GLenum mode)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNewList, "glNewList");
  if (_driver.glNewList) {
    _driver.glNewList(list, mode);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNewList)(list, mode);
}

static void REGAL_CALL loader_glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNormal3b, "glNormal3b");
  if (_driver.glNormal3b) {
    _driver.glNormal3b(nx, ny, nz);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNormal3b)(nx, ny, nz);
}

static void REGAL_CALL loader_glNormal3bv(const GLbyte *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNormal3bv, "glNormal3bv");
  if (_driver.glNormal3bv) {
    _driver.glNormal3bv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNormal3bv)(v);
}

static void REGAL_CALL loader_glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNormal3d, "glNormal3d");
  if (_driver.glNormal3d) {
    _driver.glNormal3d(nx, ny, nz);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNormal3d)(nx, ny, nz);
}

static void REGAL_CALL loader_glNormal3dv(const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNormal3dv, "glNormal3dv");
  if (_driver.glNormal3dv) {
    _driver.glNormal3dv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNormal3dv)(v);
}

static void REGAL_CALL loader_glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNormal3f, "glNormal3f");
  if (_driver.glNormal3f) {
    _driver.glNormal3f(nx, ny, nz);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNormal3f)(nx, ny, nz);
}

static void REGAL_CALL loader_glNormal3fv(const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNormal3fv, "glNormal3fv");
  if (_driver.glNormal3fv) {
    _driver.glNormal3fv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNormal3fv)(v);
}

static void REGAL_CALL loader_glNormal3i(GLint nx, GLint ny, GLint nz)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNormal3i, "glNormal3i");
  if (_driver.glNormal3i) {
    _driver.glNormal3i(nx, ny, nz);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNormal3i)(nx, ny, nz);
}

static void REGAL_CALL loader_glNormal3iv(const GLint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNormal3iv, "glNormal3iv");
  if (_driver.glNormal3iv) {
    _driver.glNormal3iv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNormal3iv)(v);
}

static void REGAL_CALL loader_glNormal3s(GLshort nx, GLshort ny, GLshort nz)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNormal3s, "glNormal3s");
  if (_driver.glNormal3s) {
    _driver.glNormal3s(nx, ny, nz);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNormal3s)(nx, ny, nz);
}

static void REGAL_CALL loader_glNormal3sv(const GLshort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNormal3sv, "glNormal3sv");
  if (_driver.glNormal3sv) {
    _driver.glNormal3sv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNormal3sv)(v);
}

static void REGAL_CALL loader_glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glOrtho, "glOrtho");
  if (_driver.glOrtho) {
    _driver.glOrtho(left, right, bottom, top, zNear, zFar);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glOrtho)(left, right, bottom, top, zNear, zFar);
}

static void REGAL_CALL loader_glPassThrough(GLfloat token)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPassThrough, "glPassThrough");
  if (_driver.glPassThrough) {
    _driver.glPassThrough(token);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPassThrough)(token);
}

static void REGAL_CALL loader_glPixelMapfv(GLenum map, GLsizei mapsize, const GLfloat *values)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPixelMapfv, "glPixelMapfv");
  if (_driver.glPixelMapfv) {
    _driver.glPixelMapfv(map, mapsize, values);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPixelMapfv)(map, mapsize, values);
}

static void REGAL_CALL loader_glPixelMapuiv(GLenum map, GLsizei mapsize, const GLuint *values)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPixelMapuiv, "glPixelMapuiv");
  if (_driver.glPixelMapuiv) {
    _driver.glPixelMapuiv(map, mapsize, values);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPixelMapuiv)(map, mapsize, values);
}

static void REGAL_CALL loader_glPixelMapusv(GLenum map, GLsizei mapsize, const GLushort *values)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPixelMapusv, "glPixelMapusv");
  if (_driver.glPixelMapusv) {
    _driver.glPixelMapusv(map, mapsize, values);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPixelMapusv)(map, mapsize, values);
}

static void REGAL_CALL loader_glPixelStoref(GLenum pname, GLfloat param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPixelStoref, "glPixelStoref");
  if (_driver.glPixelStoref) {
    _driver.glPixelStoref(pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPixelStoref)(pname, param);
}

static void REGAL_CALL loader_glPixelStorei(GLenum pname, GLint param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPixelStorei, "glPixelStorei");
  if (_driver.glPixelStorei) {
    _driver.glPixelStorei(pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPixelStorei)(pname, param);
}

static void REGAL_CALL loader_glPixelTransferf(GLenum pname, GLfloat param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPixelTransferf, "glPixelTransferf");
  if (_driver.glPixelTransferf) {
    _driver.glPixelTransferf(pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPixelTransferf)(pname, param);
}

static void REGAL_CALL loader_glPixelTransferi(GLenum pname, GLint param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPixelTransferi, "glPixelTransferi");
  if (_driver.glPixelTransferi) {
    _driver.glPixelTransferi(pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPixelTransferi)(pname, param);
}

static void REGAL_CALL loader_glPixelZoom(GLfloat xfactor, GLfloat yfactor)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPixelZoom, "glPixelZoom");
  if (_driver.glPixelZoom) {
    _driver.glPixelZoom(xfactor, yfactor);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPixelZoom)(xfactor, yfactor);
}

static void REGAL_CALL loader_glPointSize(GLfloat size)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPointSize, "glPointSize");
  if (_driver.glPointSize) {
    _driver.glPointSize(size);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPointSize)(size);
}

static void REGAL_CALL loader_glPolygonMode(GLenum face, GLenum mode)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPolygonMode, "glPolygonMode");
  if (_driver.glPolygonMode) {
    _driver.glPolygonMode(face, mode);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPolygonMode)(face, mode);
}

static void REGAL_CALL loader_glPolygonStipple(const GLubyte *mask)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPolygonStipple, "glPolygonStipple");
  if (_driver.glPolygonStipple) {
    _driver.glPolygonStipple(mask);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPolygonStipple)(mask);
}

static void REGAL_CALL loader_glPopAttrib(void)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPopAttrib, "glPopAttrib");
  if (_driver.glPopAttrib) {
    _driver.glPopAttrib();
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPopAttrib)();
}

static void REGAL_CALL loader_glPopMatrix(void)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPopMatrix, "glPopMatrix");
  if (_driver.glPopMatrix) {
    _driver.glPopMatrix();
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPopMatrix)();
}

static void REGAL_CALL loader_glPopName(void)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPopName, "glPopName");
  if (_driver.glPopName) {
    _driver.glPopName();
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPopName)();
}

static void REGAL_CALL loader_glPushAttrib(GLbitfield mask)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPushAttrib, "glPushAttrib");
  if (_driver.glPushAttrib) {
    _driver.glPushAttrib(mask);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPushAttrib)(mask);
}

static void REGAL_CALL loader_glPushMatrix(void)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPushMatrix, "glPushMatrix");
  if (_driver.glPushMatrix) {
    _driver.glPushMatrix();
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPushMatrix)();
}

static void REGAL_CALL loader_glPushName(GLuint name)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPushName, "glPushName");
  if (_driver.glPushName) {
    _driver.glPushName(name);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPushName)(name);
}

static void REGAL_CALL loader_glRasterPos2d(GLdouble x, GLdouble y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glRasterPos2d, "glRasterPos2d");
  if (_driver.glRasterPos2d) {
    _driver.glRasterPos2d(x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glRasterPos2d)(x, y);
}

static void REGAL_CALL loader_glRasterPos2dv(const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glRasterPos2dv, "glRasterPos2dv");
  if (_driver.glRasterPos2dv) {
    _driver.glRasterPos2dv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glRasterPos2dv)(v);
}

static void REGAL_CALL loader_glRasterPos2f(GLfloat x, GLfloat y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glRasterPos2f, "glRasterPos2f");
  if (_driver.glRasterPos2f) {
    _driver.glRasterPos2f(x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glRasterPos2f)(x, y);
}

static void REGAL_CALL loader_glRasterPos2fv(const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glRasterPos2fv, "glRasterPos2fv");
  if (_driver.glRasterPos2fv) {
    _driver.glRasterPos2fv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glRasterPos2fv)(v);
}

static void REGAL_CALL loader_glRasterPos2i(GLint x, GLint y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glRasterPos2i, "glRasterPos2i");
  if (_driver.glRasterPos2i) {
    _driver.glRasterPos2i(x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glRasterPos2i)(x, y);
}

static void REGAL_CALL loader_glRasterPos2iv(const GLint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glRasterPos2iv, "glRasterPos2iv");
  if (_driver.glRasterPos2iv) {
    _driver.glRasterPos2iv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glRasterPos2iv)(v);
}

static void REGAL_CALL loader_glRasterPos2s(GLshort x, GLshort y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glRasterPos2s, "glRasterPos2s");
  if (_driver.glRasterPos2s) {
    _driver.glRasterPos2s(x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glRasterPos2s)(x, y);
}

static void REGAL_CALL loader_glRasterPos2sv(const GLshort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glRasterPos2sv, "glRasterPos2sv");
  if (_driver.glRasterPos2sv) {
    _driver.glRasterPos2sv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glRasterPos2sv)(v);
}

static void REGAL_CALL loader_glRasterPos3d(GLdouble x, GLdouble y, GLdouble z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glRasterPos3d, "glRasterPos3d");
  if (_driver.glRasterPos3d) {
    _driver.glRasterPos3d(x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glRasterPos3d)(x, y, z);
}

static void REGAL_CALL loader_glRasterPos3dv(const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glRasterPos3dv, "glRasterPos3dv");
  if (_driver.glRasterPos3dv) {
    _driver.glRasterPos3dv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glRasterPos3dv)(v);
}

static void REGAL_CALL loader_glRasterPos3f(GLfloat x, GLfloat y, GLfloat z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glRasterPos3f, "glRasterPos3f");
  if (_driver.glRasterPos3f) {
    _driver.glRasterPos3f(x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glRasterPos3f)(x, y, z);
}

static void REGAL_CALL loader_glRasterPos3fv(const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glRasterPos3fv, "glRasterPos3fv");
  if (_driver.glRasterPos3fv) {
    _driver.glRasterPos3fv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glRasterPos3fv)(v);
}

static void REGAL_CALL loader_glRasterPos3i(GLint x, GLint y, GLint z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glRasterPos3i, "glRasterPos3i");
  if (_driver.glRasterPos3i) {
    _driver.glRasterPos3i(x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glRasterPos3i)(x, y, z);
}

static void REGAL_CALL loader_glRasterPos3iv(const GLint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glRasterPos3iv, "glRasterPos3iv");
  if (_driver.glRasterPos3iv) {
    _driver.glRasterPos3iv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glRasterPos3iv)(v);
}

static void REGAL_CALL loader_glRasterPos3s(GLshort x, GLshort y, GLshort z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glRasterPos3s, "glRasterPos3s");
  if (_driver.glRasterPos3s) {
    _driver.glRasterPos3s(x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glRasterPos3s)(x, y, z);
}

static void REGAL_CALL loader_glRasterPos3sv(const GLshort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glRasterPos3sv, "glRasterPos3sv");
  if (_driver.glRasterPos3sv) {
    _driver.glRasterPos3sv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glRasterPos3sv)(v);
}

static void REGAL_CALL loader_glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glRasterPos4d, "glRasterPos4d");
  if (_driver.glRasterPos4d) {
    _driver.glRasterPos4d(x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glRasterPos4d)(x, y, z, w);
}

static void REGAL_CALL loader_glRasterPos4dv(const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glRasterPos4dv, "glRasterPos4dv");
  if (_driver.glRasterPos4dv) {
    _driver.glRasterPos4dv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glRasterPos4dv)(v);
}

static void REGAL_CALL loader_glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glRasterPos4f, "glRasterPos4f");
  if (_driver.glRasterPos4f) {
    _driver.glRasterPos4f(x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glRasterPos4f)(x, y, z, w);
}

static void REGAL_CALL loader_glRasterPos4fv(const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glRasterPos4fv, "glRasterPos4fv");
  if (_driver.glRasterPos4fv) {
    _driver.glRasterPos4fv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glRasterPos4fv)(v);
}

static void REGAL_CALL loader_glRasterPos4i(GLint x, GLint y, GLint z, GLint w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glRasterPos4i, "glRasterPos4i");
  if (_driver.glRasterPos4i) {
    _driver.glRasterPos4i(x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glRasterPos4i)(x, y, z, w);
}

static void REGAL_CALL loader_glRasterPos4iv(const GLint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glRasterPos4iv, "glRasterPos4iv");
  if (_driver.glRasterPos4iv) {
    _driver.glRasterPos4iv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glRasterPos4iv)(v);
}

static void REGAL_CALL loader_glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glRasterPos4s, "glRasterPos4s");
  if (_driver.glRasterPos4s) {
    _driver.glRasterPos4s(x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glRasterPos4s)(x, y, z, w);
}

static void REGAL_CALL loader_glRasterPos4sv(const GLshort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glRasterPos4sv, "glRasterPos4sv");
  if (_driver.glRasterPos4sv) {
    _driver.glRasterPos4sv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glRasterPos4sv)(v);
}

static void REGAL_CALL loader_glReadBuffer(GLenum mode)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glReadBuffer, "glReadBuffer");
  if (_driver.glReadBuffer) {
    _driver.glReadBuffer(mode);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glReadBuffer)(mode);
}

static void REGAL_CALL loader_glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glReadPixels, "glReadPixels");
  if (_driver.glReadPixels) {
    _driver.glReadPixels(x, y, width, height, format, type, pixels);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glReadPixels)(x, y, width, height, format, type, pixels);
}

static void REGAL_CALL loader_glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glRectd, "glRectd");
  if (_driver.glRectd) {
    _driver.glRectd(x1, y1, x2, y2);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glRectd)(x1, y1, x2, y2);
}

static void REGAL_CALL loader_glRectdv(const GLdouble *v1, const GLdouble *v2)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glRectdv, "glRectdv");
  if (_driver.glRectdv) {
    _driver.glRectdv(v1, v2);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glRectdv)(v1, v2);
}

static void REGAL_CALL loader_glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glRectf, "glRectf");
  if (_driver.glRectf) {
    _driver.glRectf(x1, y1, x2, y2);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glRectf)(x1, y1, x2, y2);
}

static void REGAL_CALL loader_glRectfv(const GLfloat *v1, const GLfloat *v2)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glRectfv, "glRectfv");
  if (_driver.glRectfv) {
    _driver.glRectfv(v1, v2);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glRectfv)(v1, v2);
}

static void REGAL_CALL loader_glRecti(GLint x1, GLint y1, GLint x2, GLint y2)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glRecti, "glRecti");
  if (_driver.glRecti) {
    _driver.glRecti(x1, y1, x2, y2);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glRecti)(x1, y1, x2, y2);
}

static void REGAL_CALL loader_glRectiv(const GLint *v1, const GLint *v2)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glRectiv, "glRectiv");
  if (_driver.glRectiv) {
    _driver.glRectiv(v1, v2);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glRectiv)(v1, v2);
}

static void REGAL_CALL loader_glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glRects, "glRects");
  if (_driver.glRects) {
    _driver.glRects(x1, y1, x2, y2);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glRects)(x1, y1, x2, y2);
}

static void REGAL_CALL loader_glRectsv(const GLshort *v1, const GLshort *v2)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glRectsv, "glRectsv");
  if (_driver.glRectsv) {
    _driver.glRectsv(v1, v2);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glRectsv)(v1, v2);
}

static GLint REGAL_CALL loader_glRenderMode(GLenum mode)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glRenderMode, "glRenderMode");
  if (_driver.glRenderMode) {
    return _driver.glRenderMode(mode);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glRenderMode)(mode);
}

static void REGAL_CALL loader_glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glRotated, "glRotated");
  if (_driver.glRotated) {
    _driver.glRotated(angle, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glRotated)(angle, x, y, z);
}

static void REGAL_CALL loader_glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glRotatef, "glRotatef");
  if (_driver.glRotatef) {
    _driver.glRotatef(angle, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glRotatef)(angle, x, y, z);
}

static void REGAL_CALL loader_glScaled(GLdouble x, GLdouble y, GLdouble z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glScaled, "glScaled");
  if (_driver.glScaled) {
    _driver.glScaled(x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glScaled)(x, y, z);
}

static void REGAL_CALL loader_glScalef(GLfloat x, GLfloat y, GLfloat z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glScalef, "glScalef");
  if (_driver.glScalef) {
    _driver.glScalef(x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glScalef)(x, y, z);
}

static void REGAL_CALL loader_glScissor(GLint x, GLint y, GLsizei width, GLsizei height)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glScissor, "glScissor");
  if (_driver.glScissor) {
    _driver.glScissor(x, y, width, height);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glScissor)(x, y, width, height);
}

static void REGAL_CALL loader_glSelectBuffer(GLsizei size, GLuint *buffer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSelectBuffer, "glSelectBuffer");
  if (_driver.glSelectBuffer) {
    _driver.glSelectBuffer(size, buffer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSelectBuffer)(size, buffer);
}

static void REGAL_CALL loader_glShadeModel(GLenum mode)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glShadeModel, "glShadeModel");
  if (_driver.glShadeModel) {
    _driver.glShadeModel(mode);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glShadeModel)(mode);
}

static void REGAL_CALL loader_glStencilFunc(GLenum func, GLint ref, GLuint mask)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glStencilFunc, "glStencilFunc");
  if (_driver.glStencilFunc) {
    _driver.glStencilFunc(func, ref, mask);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glStencilFunc)(func, ref, mask);
}

static void REGAL_CALL loader_glStencilMask(GLuint mask)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glStencilMask, "glStencilMask");
  if (_driver.glStencilMask) {
    _driver.glStencilMask(mask);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glStencilMask)(mask);
}

static void REGAL_CALL loader_glStencilOp(GLenum fail, GLenum zfail, GLenum zpass)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glStencilOp, "glStencilOp");
  if (_driver.glStencilOp) {
    _driver.glStencilOp(fail, zfail, zpass);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glStencilOp)(fail, zfail, zpass);
}

static void REGAL_CALL loader_glTexCoord1d(GLdouble s)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord1d, "glTexCoord1d");
  if (_driver.glTexCoord1d) {
    _driver.glTexCoord1d(s);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord1d)(s);
}

static void REGAL_CALL loader_glTexCoord1dv(const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord1dv, "glTexCoord1dv");
  if (_driver.glTexCoord1dv) {
    _driver.glTexCoord1dv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord1dv)(v);
}

static void REGAL_CALL loader_glTexCoord1f(GLfloat s)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord1f, "glTexCoord1f");
  if (_driver.glTexCoord1f) {
    _driver.glTexCoord1f(s);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord1f)(s);
}

static void REGAL_CALL loader_glTexCoord1fv(const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord1fv, "glTexCoord1fv");
  if (_driver.glTexCoord1fv) {
    _driver.glTexCoord1fv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord1fv)(v);
}

static void REGAL_CALL loader_glTexCoord1i(GLint s)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord1i, "glTexCoord1i");
  if (_driver.glTexCoord1i) {
    _driver.glTexCoord1i(s);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord1i)(s);
}

static void REGAL_CALL loader_glTexCoord1iv(const GLint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord1iv, "glTexCoord1iv");
  if (_driver.glTexCoord1iv) {
    _driver.glTexCoord1iv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord1iv)(v);
}

static void REGAL_CALL loader_glTexCoord1s(GLshort s)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord1s, "glTexCoord1s");
  if (_driver.glTexCoord1s) {
    _driver.glTexCoord1s(s);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord1s)(s);
}

static void REGAL_CALL loader_glTexCoord1sv(const GLshort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord1sv, "glTexCoord1sv");
  if (_driver.glTexCoord1sv) {
    _driver.glTexCoord1sv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord1sv)(v);
}

static void REGAL_CALL loader_glTexCoord2d(GLdouble s, GLdouble t)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord2d, "glTexCoord2d");
  if (_driver.glTexCoord2d) {
    _driver.glTexCoord2d(s, t);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord2d)(s, t);
}

static void REGAL_CALL loader_glTexCoord2dv(const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord2dv, "glTexCoord2dv");
  if (_driver.glTexCoord2dv) {
    _driver.glTexCoord2dv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord2dv)(v);
}

static void REGAL_CALL loader_glTexCoord2f(GLfloat s, GLfloat t)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord2f, "glTexCoord2f");
  if (_driver.glTexCoord2f) {
    _driver.glTexCoord2f(s, t);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord2f)(s, t);
}

static void REGAL_CALL loader_glTexCoord2fv(const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord2fv, "glTexCoord2fv");
  if (_driver.glTexCoord2fv) {
    _driver.glTexCoord2fv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord2fv)(v);
}

static void REGAL_CALL loader_glTexCoord2i(GLint s, GLint t)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord2i, "glTexCoord2i");
  if (_driver.glTexCoord2i) {
    _driver.glTexCoord2i(s, t);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord2i)(s, t);
}

static void REGAL_CALL loader_glTexCoord2iv(const GLint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord2iv, "glTexCoord2iv");
  if (_driver.glTexCoord2iv) {
    _driver.glTexCoord2iv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord2iv)(v);
}

static void REGAL_CALL loader_glTexCoord2s(GLshort s, GLshort t)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord2s, "glTexCoord2s");
  if (_driver.glTexCoord2s) {
    _driver.glTexCoord2s(s, t);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord2s)(s, t);
}

static void REGAL_CALL loader_glTexCoord2sv(const GLshort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord2sv, "glTexCoord2sv");
  if (_driver.glTexCoord2sv) {
    _driver.glTexCoord2sv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord2sv)(v);
}

static void REGAL_CALL loader_glTexCoord3d(GLdouble s, GLdouble t, GLdouble r)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord3d, "glTexCoord3d");
  if (_driver.glTexCoord3d) {
    _driver.glTexCoord3d(s, t, r);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord3d)(s, t, r);
}

static void REGAL_CALL loader_glTexCoord3dv(const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord3dv, "glTexCoord3dv");
  if (_driver.glTexCoord3dv) {
    _driver.glTexCoord3dv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord3dv)(v);
}

static void REGAL_CALL loader_glTexCoord3f(GLfloat s, GLfloat t, GLfloat r)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord3f, "glTexCoord3f");
  if (_driver.glTexCoord3f) {
    _driver.glTexCoord3f(s, t, r);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord3f)(s, t, r);
}

static void REGAL_CALL loader_glTexCoord3fv(const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord3fv, "glTexCoord3fv");
  if (_driver.glTexCoord3fv) {
    _driver.glTexCoord3fv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord3fv)(v);
}

static void REGAL_CALL loader_glTexCoord3i(GLint s, GLint t, GLint r)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord3i, "glTexCoord3i");
  if (_driver.glTexCoord3i) {
    _driver.glTexCoord3i(s, t, r);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord3i)(s, t, r);
}

static void REGAL_CALL loader_glTexCoord3iv(const GLint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord3iv, "glTexCoord3iv");
  if (_driver.glTexCoord3iv) {
    _driver.glTexCoord3iv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord3iv)(v);
}

static void REGAL_CALL loader_glTexCoord3s(GLshort s, GLshort t, GLshort r)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord3s, "glTexCoord3s");
  if (_driver.glTexCoord3s) {
    _driver.glTexCoord3s(s, t, r);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord3s)(s, t, r);
}

static void REGAL_CALL loader_glTexCoord3sv(const GLshort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord3sv, "glTexCoord3sv");
  if (_driver.glTexCoord3sv) {
    _driver.glTexCoord3sv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord3sv)(v);
}

static void REGAL_CALL loader_glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord4d, "glTexCoord4d");
  if (_driver.glTexCoord4d) {
    _driver.glTexCoord4d(s, t, r, q);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord4d)(s, t, r, q);
}

static void REGAL_CALL loader_glTexCoord4dv(const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord4dv, "glTexCoord4dv");
  if (_driver.glTexCoord4dv) {
    _driver.glTexCoord4dv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord4dv)(v);
}

static void REGAL_CALL loader_glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord4f, "glTexCoord4f");
  if (_driver.glTexCoord4f) {
    _driver.glTexCoord4f(s, t, r, q);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord4f)(s, t, r, q);
}

static void REGAL_CALL loader_glTexCoord4fv(const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord4fv, "glTexCoord4fv");
  if (_driver.glTexCoord4fv) {
    _driver.glTexCoord4fv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord4fv)(v);
}

static void REGAL_CALL loader_glTexCoord4i(GLint s, GLint t, GLint r, GLint q)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord4i, "glTexCoord4i");
  if (_driver.glTexCoord4i) {
    _driver.glTexCoord4i(s, t, r, q);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord4i)(s, t, r, q);
}

static void REGAL_CALL loader_glTexCoord4iv(const GLint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord4iv, "glTexCoord4iv");
  if (_driver.glTexCoord4iv) {
    _driver.glTexCoord4iv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord4iv)(v);
}

static void REGAL_CALL loader_glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord4s, "glTexCoord4s");
  if (_driver.glTexCoord4s) {
    _driver.glTexCoord4s(s, t, r, q);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord4s)(s, t, r, q);
}

static void REGAL_CALL loader_glTexCoord4sv(const GLshort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord4sv, "glTexCoord4sv");
  if (_driver.glTexCoord4sv) {
    _driver.glTexCoord4sv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord4sv)(v);
}

static void REGAL_CALL loader_glTexEnvf(GLenum target, GLenum pname, GLfloat param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexEnvf, "glTexEnvf");
  if (_driver.glTexEnvf) {
    _driver.glTexEnvf(target, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexEnvf)(target, pname, param);
}

static void REGAL_CALL loader_glTexEnvfv(GLenum target, GLenum pname, const GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexEnvfv, "glTexEnvfv");
  if (_driver.glTexEnvfv) {
    _driver.glTexEnvfv(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexEnvfv)(target, pname, params);
}

static void REGAL_CALL loader_glTexEnvi(GLenum target, GLenum pname, GLint param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexEnvi, "glTexEnvi");
  if (_driver.glTexEnvi) {
    _driver.glTexEnvi(target, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexEnvi)(target, pname, param);
}

static void REGAL_CALL loader_glTexEnviv(GLenum target, GLenum pname, const GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexEnviv, "glTexEnviv");
  if (_driver.glTexEnviv) {
    _driver.glTexEnviv(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexEnviv)(target, pname, params);
}

static void REGAL_CALL loader_glTexGend(GLenum coord, GLenum pname, GLdouble param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexGend, "glTexGend");
  if (_driver.glTexGend) {
    _driver.glTexGend(coord, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexGend)(coord, pname, param);
}

static void REGAL_CALL loader_glTexGendv(GLenum coord, GLenum pname, const GLdouble *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexGendv, "glTexGendv");
  if (_driver.glTexGendv) {
    _driver.glTexGendv(coord, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexGendv)(coord, pname, params);
}

static void REGAL_CALL loader_glTexGenf(GLenum coord, GLenum pname, GLfloat param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexGenf, "glTexGenf");
  if (_driver.glTexGenf) {
    _driver.glTexGenf(coord, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexGenf)(coord, pname, param);
}

static void REGAL_CALL loader_glTexGenfv(GLenum coord, GLenum pname, const GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexGenfv, "glTexGenfv");
  if (_driver.glTexGenfv) {
    _driver.glTexGenfv(coord, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexGenfv)(coord, pname, params);
}

static void REGAL_CALL loader_glTexGeni(GLenum coord, GLenum pname, GLint param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexGeni, "glTexGeni");
  if (_driver.glTexGeni) {
    _driver.glTexGeni(coord, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexGeni)(coord, pname, param);
}

static void REGAL_CALL loader_glTexGeniv(GLenum coord, GLenum pname, const GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexGeniv, "glTexGeniv");
  if (_driver.glTexGeniv) {
    _driver.glTexGeniv(coord, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexGeniv)(coord, pname, params);
}

static void REGAL_CALL loader_glTexImage1D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexImage1D, "glTexImage1D");
  if (_driver.glTexImage1D) {
    _driver.glTexImage1D(target, level, internalformat, width, border, format, type, pixels);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexImage1D)(target, level, internalformat, width, border, format, type, pixels);
}

static void REGAL_CALL loader_glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexImage2D, "glTexImage2D");
  if (_driver.glTexImage2D) {
    _driver.glTexImage2D(target, level, internalformat, width, height, border, format, type, pixels);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexImage2D)(target, level, internalformat, width, height, border, format, type, pixels);
}

static void REGAL_CALL loader_glTexParameterf(GLenum target, GLenum pname, GLfloat param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexParameterf, "glTexParameterf");
  if (_driver.glTexParameterf) {
    _driver.glTexParameterf(target, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexParameterf)(target, pname, param);
}

static void REGAL_CALL loader_glTexParameterfv(GLenum target, GLenum pname, const GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexParameterfv, "glTexParameterfv");
  if (_driver.glTexParameterfv) {
    _driver.glTexParameterfv(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexParameterfv)(target, pname, params);
}

static void REGAL_CALL loader_glTexParameteri(GLenum target, GLenum pname, GLint param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexParameteri, "glTexParameteri");
  if (_driver.glTexParameteri) {
    _driver.glTexParameteri(target, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexParameteri)(target, pname, param);
}

static void REGAL_CALL loader_glTexParameteriv(GLenum target, GLenum pname, const GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexParameteriv, "glTexParameteriv");
  if (_driver.glTexParameteriv) {
    _driver.glTexParameteriv(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexParameteriv)(target, pname, params);
}

static void REGAL_CALL loader_glTranslated(GLdouble x, GLdouble y, GLdouble z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTranslated, "glTranslated");
  if (_driver.glTranslated) {
    _driver.glTranslated(x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTranslated)(x, y, z);
}

static void REGAL_CALL loader_glTranslatef(GLfloat x, GLfloat y, GLfloat z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTranslatef, "glTranslatef");
  if (_driver.glTranslatef) {
    _driver.glTranslatef(x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTranslatef)(x, y, z);
}

static void REGAL_CALL loader_glVertex2d(GLdouble x, GLdouble y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertex2d, "glVertex2d");
  if (_driver.glVertex2d) {
    _driver.glVertex2d(x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertex2d)(x, y);
}

static void REGAL_CALL loader_glVertex2dv(const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertex2dv, "glVertex2dv");
  if (_driver.glVertex2dv) {
    _driver.glVertex2dv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertex2dv)(v);
}

static void REGAL_CALL loader_glVertex2f(GLfloat x, GLfloat y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertex2f, "glVertex2f");
  if (_driver.glVertex2f) {
    _driver.glVertex2f(x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertex2f)(x, y);
}

static void REGAL_CALL loader_glVertex2fv(const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertex2fv, "glVertex2fv");
  if (_driver.glVertex2fv) {
    _driver.glVertex2fv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertex2fv)(v);
}

static void REGAL_CALL loader_glVertex2i(GLint x, GLint y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertex2i, "glVertex2i");
  if (_driver.glVertex2i) {
    _driver.glVertex2i(x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertex2i)(x, y);
}

static void REGAL_CALL loader_glVertex2iv(const GLint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertex2iv, "glVertex2iv");
  if (_driver.glVertex2iv) {
    _driver.glVertex2iv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertex2iv)(v);
}

static void REGAL_CALL loader_glVertex2s(GLshort x, GLshort y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertex2s, "glVertex2s");
  if (_driver.glVertex2s) {
    _driver.glVertex2s(x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertex2s)(x, y);
}

static void REGAL_CALL loader_glVertex2sv(const GLshort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertex2sv, "glVertex2sv");
  if (_driver.glVertex2sv) {
    _driver.glVertex2sv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertex2sv)(v);
}

static void REGAL_CALL loader_glVertex3d(GLdouble x, GLdouble y, GLdouble z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertex3d, "glVertex3d");
  if (_driver.glVertex3d) {
    _driver.glVertex3d(x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertex3d)(x, y, z);
}

static void REGAL_CALL loader_glVertex3dv(const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertex3dv, "glVertex3dv");
  if (_driver.glVertex3dv) {
    _driver.glVertex3dv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertex3dv)(v);
}

static void REGAL_CALL loader_glVertex3f(GLfloat x, GLfloat y, GLfloat z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertex3f, "glVertex3f");
  if (_driver.glVertex3f) {
    _driver.glVertex3f(x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertex3f)(x, y, z);
}

static void REGAL_CALL loader_glVertex3fv(const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertex3fv, "glVertex3fv");
  if (_driver.glVertex3fv) {
    _driver.glVertex3fv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertex3fv)(v);
}

static void REGAL_CALL loader_glVertex3i(GLint x, GLint y, GLint z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertex3i, "glVertex3i");
  if (_driver.glVertex3i) {
    _driver.glVertex3i(x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertex3i)(x, y, z);
}

static void REGAL_CALL loader_glVertex3iv(const GLint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertex3iv, "glVertex3iv");
  if (_driver.glVertex3iv) {
    _driver.glVertex3iv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertex3iv)(v);
}

static void REGAL_CALL loader_glVertex3s(GLshort x, GLshort y, GLshort z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertex3s, "glVertex3s");
  if (_driver.glVertex3s) {
    _driver.glVertex3s(x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertex3s)(x, y, z);
}

static void REGAL_CALL loader_glVertex3sv(const GLshort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertex3sv, "glVertex3sv");
  if (_driver.glVertex3sv) {
    _driver.glVertex3sv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertex3sv)(v);
}

static void REGAL_CALL loader_glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertex4d, "glVertex4d");
  if (_driver.glVertex4d) {
    _driver.glVertex4d(x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertex4d)(x, y, z, w);
}

static void REGAL_CALL loader_glVertex4dv(const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertex4dv, "glVertex4dv");
  if (_driver.glVertex4dv) {
    _driver.glVertex4dv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertex4dv)(v);
}

static void REGAL_CALL loader_glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertex4f, "glVertex4f");
  if (_driver.glVertex4f) {
    _driver.glVertex4f(x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertex4f)(x, y, z, w);
}

static void REGAL_CALL loader_glVertex4fv(const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertex4fv, "glVertex4fv");
  if (_driver.glVertex4fv) {
    _driver.glVertex4fv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertex4fv)(v);
}

static void REGAL_CALL loader_glVertex4i(GLint x, GLint y, GLint z, GLint w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertex4i, "glVertex4i");
  if (_driver.glVertex4i) {
    _driver.glVertex4i(x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertex4i)(x, y, z, w);
}

static void REGAL_CALL loader_glVertex4iv(const GLint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertex4iv, "glVertex4iv");
  if (_driver.glVertex4iv) {
    _driver.glVertex4iv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertex4iv)(v);
}

static void REGAL_CALL loader_glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertex4s, "glVertex4s");
  if (_driver.glVertex4s) {
    _driver.glVertex4s(x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertex4s)(x, y, z, w);
}

static void REGAL_CALL loader_glVertex4sv(const GLshort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertex4sv, "glVertex4sv");
  if (_driver.glVertex4sv) {
    _driver.glVertex4sv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertex4sv)(v);
}

static void REGAL_CALL loader_glViewport(GLint x, GLint y, GLsizei width, GLsizei height)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glViewport, "glViewport");
  if (_driver.glViewport) {
    _driver.glViewport(x, y, width, height);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glViewport)(x, y, width, height);
}

// GL_VERSION_1_1

static GLboolean REGAL_CALL loader_glAreTexturesResident(GLsizei n, const GLuint *textures, GLboolean *residences)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glAreTexturesResident, "glAreTexturesResident");
  if (_driver.glAreTexturesResident) {
    return _driver.glAreTexturesResident(n, textures, residences);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glAreTexturesResident)(n, textures, residences);
}

static void REGAL_CALL loader_glArrayElement(GLint index)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glArrayElement, "glArrayElement");
  if (_driver.glArrayElement) {
    _driver.glArrayElement(index);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glArrayElement)(index);
}

static void REGAL_CALL loader_glBindTexture(GLenum target, GLuint texture)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBindTexture, "glBindTexture");
  if (_driver.glBindTexture) {
    _driver.glBindTexture(target, texture);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBindTexture)(target, texture);
}

static void REGAL_CALL loader_glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColorPointer, "glColorPointer");
  if (_driver.glColorPointer) {
    _driver.glColorPointer(size, type, stride, pointer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColorPointer)(size, type, stride, pointer);
}

static void REGAL_CALL loader_glCopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCopyTexImage1D, "glCopyTexImage1D");
  if (_driver.glCopyTexImage1D) {
    _driver.glCopyTexImage1D(target, level, internalformat, x, y, width, border);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCopyTexImage1D)(target, level, internalformat, x, y, width, border);
}

static void REGAL_CALL loader_glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCopyTexImage2D, "glCopyTexImage2D");
  if (_driver.glCopyTexImage2D) {
    _driver.glCopyTexImage2D(target, level, internalformat, x, y, width, height, border);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCopyTexImage2D)(target, level, internalformat, x, y, width, height, border);
}

static void REGAL_CALL loader_glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCopyTexSubImage1D, "glCopyTexSubImage1D");
  if (_driver.glCopyTexSubImage1D) {
    _driver.glCopyTexSubImage1D(target, level, xoffset, x, y, width);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCopyTexSubImage1D)(target, level, xoffset, x, y, width);
}

static void REGAL_CALL loader_glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCopyTexSubImage2D, "glCopyTexSubImage2D");
  if (_driver.glCopyTexSubImage2D) {
    _driver.glCopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCopyTexSubImage2D)(target, level, xoffset, yoffset, x, y, width, height);
}

static void REGAL_CALL loader_glDeleteTextures(GLsizei n, const GLuint *textures)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDeleteTextures, "glDeleteTextures");
  if (_driver.glDeleteTextures) {
    _driver.glDeleteTextures(n, textures);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDeleteTextures)(n, textures);
}

static void REGAL_CALL loader_glDisableClientState(GLenum cap)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDisableClientState, "glDisableClientState");
  if (_driver.glDisableClientState) {
    _driver.glDisableClientState(cap);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDisableClientState)(cap);
}

static void REGAL_CALL loader_glDrawArrays(GLenum mode, GLint first, GLsizei count)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDrawArrays, "glDrawArrays");
  if (_driver.glDrawArrays) {
    _driver.glDrawArrays(mode, first, count);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDrawArrays)(mode, first, count);
}

static void REGAL_CALL loader_glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDrawElements, "glDrawElements");
  if (_driver.glDrawElements) {
    _driver.glDrawElements(mode, count, type, indices);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDrawElements)(mode, count, type, indices);
}

static void REGAL_CALL loader_glEdgeFlagPointer(GLsizei stride, const GLvoid *pointer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glEdgeFlagPointer, "glEdgeFlagPointer");
  if (_driver.glEdgeFlagPointer) {
    _driver.glEdgeFlagPointer(stride, pointer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glEdgeFlagPointer)(stride, pointer);
}

static void REGAL_CALL loader_glEnableClientState(GLenum cap)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glEnableClientState, "glEnableClientState");
  if (_driver.glEnableClientState) {
    _driver.glEnableClientState(cap);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glEnableClientState)(cap);
}

static void REGAL_CALL loader_glGenTextures(GLsizei n, GLuint *textures)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGenTextures, "glGenTextures");
  if (_driver.glGenTextures) {
    _driver.glGenTextures(n, textures);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGenTextures)(n, textures);
}

static void REGAL_CALL loader_glGetPointerv(GLenum pname, GLvoid **params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetPointerv, "glGetPointerv");
  if (_driver.glGetPointerv) {
    _driver.glGetPointerv(pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetPointerv)(pname, params);
}

static void REGAL_CALL loader_glIndexPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIndexPointer, "glIndexPointer");
  if (_driver.glIndexPointer) {
    _driver.glIndexPointer(type, stride, pointer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glIndexPointer)(type, stride, pointer);
}

static void REGAL_CALL loader_glIndexub(GLubyte c)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIndexub, "glIndexub");
  if (_driver.glIndexub) {
    _driver.glIndexub(c);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glIndexub)(c);
}

static void REGAL_CALL loader_glIndexubv(const GLubyte *c)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIndexubv, "glIndexubv");
  if (_driver.glIndexubv) {
    _driver.glIndexubv(c);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glIndexubv)(c);
}

static void REGAL_CALL loader_glInterleavedArrays(GLenum format, GLsizei stride, const GLvoid *pointer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glInterleavedArrays, "glInterleavedArrays");
  if (_driver.glInterleavedArrays) {
    _driver.glInterleavedArrays(format, stride, pointer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glInterleavedArrays)(format, stride, pointer);
}

static GLboolean REGAL_CALL loader_glIsTexture(GLuint texture)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIsTexture, "glIsTexture");
  if (_driver.glIsTexture) {
    return _driver.glIsTexture(texture);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glIsTexture)(texture);
}

static void REGAL_CALL loader_glNormalPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNormalPointer, "glNormalPointer");
  if (_driver.glNormalPointer) {
    _driver.glNormalPointer(type, stride, pointer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNormalPointer)(type, stride, pointer);
}

static void REGAL_CALL loader_glPolygonOffset(GLfloat factor, GLfloat units)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPolygonOffset, "glPolygonOffset");
  if (_driver.glPolygonOffset) {
    _driver.glPolygonOffset(factor, units);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPolygonOffset)(factor, units);
}

static void REGAL_CALL loader_glPopClientAttrib(void)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPopClientAttrib, "glPopClientAttrib");
  if (_driver.glPopClientAttrib) {
    _driver.glPopClientAttrib();
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPopClientAttrib)();
}

static void REGAL_CALL loader_glPrioritizeTextures(GLsizei n, const GLuint *textures, const GLclampf *priorities)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPrioritizeTextures, "glPrioritizeTextures");
  if (_driver.glPrioritizeTextures) {
    _driver.glPrioritizeTextures(n, textures, priorities);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPrioritizeTextures)(n, textures, priorities);
}

static void REGAL_CALL loader_glPushClientAttrib(GLbitfield mask)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPushClientAttrib, "glPushClientAttrib");
  if (_driver.glPushClientAttrib) {
    _driver.glPushClientAttrib(mask);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPushClientAttrib)(mask);
}

static void REGAL_CALL loader_glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoordPointer, "glTexCoordPointer");
  if (_driver.glTexCoordPointer) {
    _driver.glTexCoordPointer(size, type, stride, pointer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoordPointer)(size, type, stride, pointer);
}

static void REGAL_CALL loader_glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexSubImage1D, "glTexSubImage1D");
  if (_driver.glTexSubImage1D) {
    _driver.glTexSubImage1D(target, level, xoffset, width, format, type, pixels);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexSubImage1D)(target, level, xoffset, width, format, type, pixels);
}

static void REGAL_CALL loader_glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexSubImage2D, "glTexSubImage2D");
  if (_driver.glTexSubImage2D) {
    _driver.glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexSubImage2D)(target, level, xoffset, yoffset, width, height, format, type, pixels);
}

static void REGAL_CALL loader_glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexPointer, "glVertexPointer");
  if (_driver.glVertexPointer) {
    _driver.glVertexPointer(size, type, stride, pointer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexPointer)(size, type, stride, pointer);
}

// GL_VERSION_1_2

static void REGAL_CALL loader_glBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBlendColor, "glBlendColor");
  if (_driver.glBlendColor) {
    _driver.glBlendColor(red, green, blue, alpha);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBlendColor)(red, green, blue, alpha);
}

static void REGAL_CALL loader_glBlendEquation(GLenum mode)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBlendEquation, "glBlendEquation");
  if (_driver.glBlendEquation) {
    _driver.glBlendEquation(mode);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBlendEquation)(mode);
}

static void REGAL_CALL loader_glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCopyTexSubImage3D, "glCopyTexSubImage3D");
  if (_driver.glCopyTexSubImage3D) {
    _driver.glCopyTexSubImage3D(target, level, xoffset, yoffset, zoffset, x, y, width, height);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCopyTexSubImage3D)(target, level, xoffset, yoffset, zoffset, x, y, width, height);
}

static void REGAL_CALL loader_glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDrawRangeElements, "glDrawRangeElements");
  if (_driver.glDrawRangeElements) {
    _driver.glDrawRangeElements(mode, start, end, count, type, indices);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDrawRangeElements)(mode, start, end, count, type, indices);
}

static void REGAL_CALL loader_glTexImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexImage3D, "glTexImage3D");
  if (_driver.glTexImage3D) {
    _driver.glTexImage3D(target, level, internalformat, width, height, depth, border, format, type, pixels);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexImage3D)(target, level, internalformat, width, height, depth, border, format, type, pixels);
}

static void REGAL_CALL loader_glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexSubImage3D, "glTexSubImage3D");
  if (_driver.glTexSubImage3D) {
    _driver.glTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexSubImage3D)(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
}

// GL_VERSION_1_3

static void REGAL_CALL loader_glActiveTexture(GLenum texture)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glActiveTexture, "glActiveTexture");
  if (_driver.glActiveTexture) {
    _driver.glActiveTexture(texture);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glActiveTexture)(texture);
}

static void REGAL_CALL loader_glClientActiveTexture(GLenum texture)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glClientActiveTexture, "glClientActiveTexture");
  if (_driver.glClientActiveTexture) {
    _driver.glClientActiveTexture(texture);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glClientActiveTexture)(texture);
}

static void REGAL_CALL loader_glCompressedTexImage1D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCompressedTexImage1D, "glCompressedTexImage1D");
  if (_driver.glCompressedTexImage1D) {
    _driver.glCompressedTexImage1D(target, level, internalformat, width, border, imageSize, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCompressedTexImage1D)(target, level, internalformat, width, border, imageSize, data);
}

static void REGAL_CALL loader_glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCompressedTexImage2D, "glCompressedTexImage2D");
  if (_driver.glCompressedTexImage2D) {
    _driver.glCompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCompressedTexImage2D)(target, level, internalformat, width, height, border, imageSize, data);
}

static void REGAL_CALL loader_glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCompressedTexImage3D, "glCompressedTexImage3D");
  if (_driver.glCompressedTexImage3D) {
    _driver.glCompressedTexImage3D(target, level, internalformat, width, height, depth, border, imageSize, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCompressedTexImage3D)(target, level, internalformat, width, height, depth, border, imageSize, data);
}

static void REGAL_CALL loader_glCompressedTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCompressedTexSubImage1D, "glCompressedTexSubImage1D");
  if (_driver.glCompressedTexSubImage1D) {
    _driver.glCompressedTexSubImage1D(target, level, xoffset, width, format, imageSize, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCompressedTexSubImage1D)(target, level, xoffset, width, format, imageSize, data);
}

static void REGAL_CALL loader_glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCompressedTexSubImage2D, "glCompressedTexSubImage2D");
  if (_driver.glCompressedTexSubImage2D) {
    _driver.glCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCompressedTexSubImage2D)(target, level, xoffset, yoffset, width, height, format, imageSize, data);
}

static void REGAL_CALL loader_glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCompressedTexSubImage3D, "glCompressedTexSubImage3D");
  if (_driver.glCompressedTexSubImage3D) {
    _driver.glCompressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCompressedTexSubImage3D)(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
}

static void REGAL_CALL loader_glGetCompressedTexImage(GLenum target, GLint lod, GLvoid *img)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetCompressedTexImage, "glGetCompressedTexImage");
  if (_driver.glGetCompressedTexImage) {
    _driver.glGetCompressedTexImage(target, lod, img);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetCompressedTexImage)(target, lod, img);
}

static void REGAL_CALL loader_glLoadTransposeMatrixd(const GLdouble *m)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glLoadTransposeMatrixd, "glLoadTransposeMatrixd");
  if (_driver.glLoadTransposeMatrixd) {
    _driver.glLoadTransposeMatrixd(m);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glLoadTransposeMatrixd)(m);
}

static void REGAL_CALL loader_glLoadTransposeMatrixf(const GLfloat *m)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glLoadTransposeMatrixf, "glLoadTransposeMatrixf");
  if (_driver.glLoadTransposeMatrixf) {
    _driver.glLoadTransposeMatrixf(m);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glLoadTransposeMatrixf)(m);
}

static void REGAL_CALL loader_glMultTransposeMatrixd(const GLdouble *m)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultTransposeMatrixd, "glMultTransposeMatrixd");
  if (_driver.glMultTransposeMatrixd) {
    _driver.glMultTransposeMatrixd(m);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultTransposeMatrixd)(m);
}

static void REGAL_CALL loader_glMultTransposeMatrixf(const GLfloat *m)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultTransposeMatrixf, "glMultTransposeMatrixf");
  if (_driver.glMultTransposeMatrixf) {
    _driver.glMultTransposeMatrixf(m);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultTransposeMatrixf)(m);
}

static void REGAL_CALL loader_glMultiTexCoord1d(GLenum target, GLdouble s)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord1d, "glMultiTexCoord1d");
  if (_driver.glMultiTexCoord1d) {
    _driver.glMultiTexCoord1d(target, s);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord1d)(target, s);
}

static void REGAL_CALL loader_glMultiTexCoord1dv(GLenum target, const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord1dv, "glMultiTexCoord1dv");
  if (_driver.glMultiTexCoord1dv) {
    _driver.glMultiTexCoord1dv(target, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord1dv)(target, v);
}

static void REGAL_CALL loader_glMultiTexCoord1f(GLenum target, GLfloat s)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord1f, "glMultiTexCoord1f");
  if (_driver.glMultiTexCoord1f) {
    _driver.glMultiTexCoord1f(target, s);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord1f)(target, s);
}

static void REGAL_CALL loader_glMultiTexCoord1fv(GLenum target, const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord1fv, "glMultiTexCoord1fv");
  if (_driver.glMultiTexCoord1fv) {
    _driver.glMultiTexCoord1fv(target, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord1fv)(target, v);
}

static void REGAL_CALL loader_glMultiTexCoord1i(GLenum target, GLint s)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord1i, "glMultiTexCoord1i");
  if (_driver.glMultiTexCoord1i) {
    _driver.glMultiTexCoord1i(target, s);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord1i)(target, s);
}

static void REGAL_CALL loader_glMultiTexCoord1iv(GLenum target, const GLint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord1iv, "glMultiTexCoord1iv");
  if (_driver.glMultiTexCoord1iv) {
    _driver.glMultiTexCoord1iv(target, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord1iv)(target, v);
}

static void REGAL_CALL loader_glMultiTexCoord1s(GLenum target, GLshort s)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord1s, "glMultiTexCoord1s");
  if (_driver.glMultiTexCoord1s) {
    _driver.glMultiTexCoord1s(target, s);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord1s)(target, s);
}

static void REGAL_CALL loader_glMultiTexCoord1sv(GLenum target, const GLshort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord1sv, "glMultiTexCoord1sv");
  if (_driver.glMultiTexCoord1sv) {
    _driver.glMultiTexCoord1sv(target, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord1sv)(target, v);
}

static void REGAL_CALL loader_glMultiTexCoord2d(GLenum target, GLdouble s, GLdouble t)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord2d, "glMultiTexCoord2d");
  if (_driver.glMultiTexCoord2d) {
    _driver.glMultiTexCoord2d(target, s, t);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord2d)(target, s, t);
}

static void REGAL_CALL loader_glMultiTexCoord2dv(GLenum target, const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord2dv, "glMultiTexCoord2dv");
  if (_driver.glMultiTexCoord2dv) {
    _driver.glMultiTexCoord2dv(target, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord2dv)(target, v);
}

static void REGAL_CALL loader_glMultiTexCoord2f(GLenum target, GLfloat s, GLfloat t)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord2f, "glMultiTexCoord2f");
  if (_driver.glMultiTexCoord2f) {
    _driver.glMultiTexCoord2f(target, s, t);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord2f)(target, s, t);
}

static void REGAL_CALL loader_glMultiTexCoord2fv(GLenum target, const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord2fv, "glMultiTexCoord2fv");
  if (_driver.glMultiTexCoord2fv) {
    _driver.glMultiTexCoord2fv(target, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord2fv)(target, v);
}

static void REGAL_CALL loader_glMultiTexCoord2i(GLenum target, GLint s, GLint t)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord2i, "glMultiTexCoord2i");
  if (_driver.glMultiTexCoord2i) {
    _driver.glMultiTexCoord2i(target, s, t);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord2i)(target, s, t);
}

static void REGAL_CALL loader_glMultiTexCoord2iv(GLenum target, const GLint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord2iv, "glMultiTexCoord2iv");
  if (_driver.glMultiTexCoord2iv) {
    _driver.glMultiTexCoord2iv(target, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord2iv)(target, v);
}

static void REGAL_CALL loader_glMultiTexCoord2s(GLenum target, GLshort s, GLshort t)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord2s, "glMultiTexCoord2s");
  if (_driver.glMultiTexCoord2s) {
    _driver.glMultiTexCoord2s(target, s, t);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord2s)(target, s, t);
}

static void REGAL_CALL loader_glMultiTexCoord2sv(GLenum target, const GLshort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord2sv, "glMultiTexCoord2sv");
  if (_driver.glMultiTexCoord2sv) {
    _driver.glMultiTexCoord2sv(target, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord2sv)(target, v);
}

static void REGAL_CALL loader_glMultiTexCoord3d(GLenum target, GLdouble s, GLdouble t, GLdouble r)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord3d, "glMultiTexCoord3d");
  if (_driver.glMultiTexCoord3d) {
    _driver.glMultiTexCoord3d(target, s, t, r);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord3d)(target, s, t, r);
}

static void REGAL_CALL loader_glMultiTexCoord3dv(GLenum target, const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord3dv, "glMultiTexCoord3dv");
  if (_driver.glMultiTexCoord3dv) {
    _driver.glMultiTexCoord3dv(target, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord3dv)(target, v);
}

static void REGAL_CALL loader_glMultiTexCoord3f(GLenum target, GLfloat s, GLfloat t, GLfloat r)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord3f, "glMultiTexCoord3f");
  if (_driver.glMultiTexCoord3f) {
    _driver.glMultiTexCoord3f(target, s, t, r);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord3f)(target, s, t, r);
}

static void REGAL_CALL loader_glMultiTexCoord3fv(GLenum target, const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord3fv, "glMultiTexCoord3fv");
  if (_driver.glMultiTexCoord3fv) {
    _driver.glMultiTexCoord3fv(target, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord3fv)(target, v);
}

static void REGAL_CALL loader_glMultiTexCoord3i(GLenum target, GLint s, GLint t, GLint r)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord3i, "glMultiTexCoord3i");
  if (_driver.glMultiTexCoord3i) {
    _driver.glMultiTexCoord3i(target, s, t, r);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord3i)(target, s, t, r);
}

static void REGAL_CALL loader_glMultiTexCoord3iv(GLenum target, const GLint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord3iv, "glMultiTexCoord3iv");
  if (_driver.glMultiTexCoord3iv) {
    _driver.glMultiTexCoord3iv(target, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord3iv)(target, v);
}

static void REGAL_CALL loader_glMultiTexCoord3s(GLenum target, GLshort s, GLshort t, GLshort r)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord3s, "glMultiTexCoord3s");
  if (_driver.glMultiTexCoord3s) {
    _driver.glMultiTexCoord3s(target, s, t, r);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord3s)(target, s, t, r);
}

static void REGAL_CALL loader_glMultiTexCoord3sv(GLenum target, const GLshort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord3sv, "glMultiTexCoord3sv");
  if (_driver.glMultiTexCoord3sv) {
    _driver.glMultiTexCoord3sv(target, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord3sv)(target, v);
}

static void REGAL_CALL loader_glMultiTexCoord4d(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord4d, "glMultiTexCoord4d");
  if (_driver.glMultiTexCoord4d) {
    _driver.glMultiTexCoord4d(target, s, t, r, q);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord4d)(target, s, t, r, q);
}

static void REGAL_CALL loader_glMultiTexCoord4dv(GLenum target, const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord4dv, "glMultiTexCoord4dv");
  if (_driver.glMultiTexCoord4dv) {
    _driver.glMultiTexCoord4dv(target, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord4dv)(target, v);
}

static void REGAL_CALL loader_glMultiTexCoord4f(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord4f, "glMultiTexCoord4f");
  if (_driver.glMultiTexCoord4f) {
    _driver.glMultiTexCoord4f(target, s, t, r, q);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord4f)(target, s, t, r, q);
}

static void REGAL_CALL loader_glMultiTexCoord4fv(GLenum target, const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord4fv, "glMultiTexCoord4fv");
  if (_driver.glMultiTexCoord4fv) {
    _driver.glMultiTexCoord4fv(target, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord4fv)(target, v);
}

static void REGAL_CALL loader_glMultiTexCoord4i(GLenum target, GLint s, GLint t, GLint r, GLint q)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord4i, "glMultiTexCoord4i");
  if (_driver.glMultiTexCoord4i) {
    _driver.glMultiTexCoord4i(target, s, t, r, q);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord4i)(target, s, t, r, q);
}

static void REGAL_CALL loader_glMultiTexCoord4iv(GLenum target, const GLint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord4iv, "glMultiTexCoord4iv");
  if (_driver.glMultiTexCoord4iv) {
    _driver.glMultiTexCoord4iv(target, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord4iv)(target, v);
}

static void REGAL_CALL loader_glMultiTexCoord4s(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord4s, "glMultiTexCoord4s");
  if (_driver.glMultiTexCoord4s) {
    _driver.glMultiTexCoord4s(target, s, t, r, q);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord4s)(target, s, t, r, q);
}

static void REGAL_CALL loader_glMultiTexCoord4sv(GLenum target, const GLshort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord4sv, "glMultiTexCoord4sv");
  if (_driver.glMultiTexCoord4sv) {
    _driver.glMultiTexCoord4sv(target, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord4sv)(target, v);
}

static void REGAL_CALL loader_glSampleCoverage(GLclampf value, GLboolean invert)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSampleCoverage, "glSampleCoverage");
  if (_driver.glSampleCoverage) {
    _driver.glSampleCoverage(value, invert);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSampleCoverage)(value, invert);
}

// GL_VERSION_1_4

static void REGAL_CALL loader_glBlendFuncSeparate(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBlendFuncSeparate, "glBlendFuncSeparate");
  if (_driver.glBlendFuncSeparate) {
    _driver.glBlendFuncSeparate(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBlendFuncSeparate)(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
}

static void REGAL_CALL loader_glFogCoordPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFogCoordPointer, "glFogCoordPointer");
  if (_driver.glFogCoordPointer) {
    _driver.glFogCoordPointer(type, stride, pointer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFogCoordPointer)(type, stride, pointer);
}

static void REGAL_CALL loader_glFogCoordd(GLdouble coord)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFogCoordd, "glFogCoordd");
  if (_driver.glFogCoordd) {
    _driver.glFogCoordd(coord);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFogCoordd)(coord);
}

static void REGAL_CALL loader_glFogCoorddv(const GLdouble *coord)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFogCoorddv, "glFogCoorddv");
  if (_driver.glFogCoorddv) {
    _driver.glFogCoorddv(coord);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFogCoorddv)(coord);
}

static void REGAL_CALL loader_glFogCoordf(GLfloat coord)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFogCoordf, "glFogCoordf");
  if (_driver.glFogCoordf) {
    _driver.glFogCoordf(coord);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFogCoordf)(coord);
}

static void REGAL_CALL loader_glFogCoordfv(const GLfloat *coord)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFogCoordfv, "glFogCoordfv");
  if (_driver.glFogCoordfv) {
    _driver.glFogCoordfv(coord);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFogCoordfv)(coord);
}

static void REGAL_CALL loader_glMultiDrawArrays(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiDrawArrays, "glMultiDrawArrays");
  if (_driver.glMultiDrawArrays) {
    _driver.glMultiDrawArrays(mode, first, count, primcount);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiDrawArrays)(mode, first, count, primcount);
}

static void REGAL_CALL loader_glMultiDrawElements(GLenum mode, const GLsizei *count, GLenum type, const GLvoid **indices, GLsizei primcount)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiDrawElements, "glMultiDrawElements");
  if (_driver.glMultiDrawElements) {
    _driver.glMultiDrawElements(mode, count, type, indices, primcount);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiDrawElements)(mode, count, type, indices, primcount);
}

static void REGAL_CALL loader_glPointParameterf(GLenum pname, GLfloat param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPointParameterf, "glPointParameterf");
  if (_driver.glPointParameterf) {
    _driver.glPointParameterf(pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPointParameterf)(pname, param);
}

static void REGAL_CALL loader_glPointParameterfv(GLenum pname, const GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPointParameterfv, "glPointParameterfv");
  if (_driver.glPointParameterfv) {
    _driver.glPointParameterfv(pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPointParameterfv)(pname, params);
}

static void REGAL_CALL loader_glPointParameteri(GLenum pname, GLint param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPointParameteri, "glPointParameteri");
  if (_driver.glPointParameteri) {
    _driver.glPointParameteri(pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPointParameteri)(pname, param);
}

static void REGAL_CALL loader_glPointParameteriv(GLenum pname, const GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPointParameteriv, "glPointParameteriv");
  if (_driver.glPointParameteriv) {
    _driver.glPointParameteriv(pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPointParameteriv)(pname, params);
}

static void REGAL_CALL loader_glSecondaryColor3b(GLbyte red, GLbyte green, GLbyte blue)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSecondaryColor3b, "glSecondaryColor3b");
  if (_driver.glSecondaryColor3b) {
    _driver.glSecondaryColor3b(red, green, blue);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSecondaryColor3b)(red, green, blue);
}

static void REGAL_CALL loader_glSecondaryColor3bv(const GLbyte *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSecondaryColor3bv, "glSecondaryColor3bv");
  if (_driver.glSecondaryColor3bv) {
    _driver.glSecondaryColor3bv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSecondaryColor3bv)(v);
}

static void REGAL_CALL loader_glSecondaryColor3d(GLdouble red, GLdouble green, GLdouble blue)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSecondaryColor3d, "glSecondaryColor3d");
  if (_driver.glSecondaryColor3d) {
    _driver.glSecondaryColor3d(red, green, blue);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSecondaryColor3d)(red, green, blue);
}

static void REGAL_CALL loader_glSecondaryColor3dv(const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSecondaryColor3dv, "glSecondaryColor3dv");
  if (_driver.glSecondaryColor3dv) {
    _driver.glSecondaryColor3dv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSecondaryColor3dv)(v);
}

static void REGAL_CALL loader_glSecondaryColor3f(GLfloat red, GLfloat green, GLfloat blue)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSecondaryColor3f, "glSecondaryColor3f");
  if (_driver.glSecondaryColor3f) {
    _driver.glSecondaryColor3f(red, green, blue);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSecondaryColor3f)(red, green, blue);
}

static void REGAL_CALL loader_glSecondaryColor3fv(const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSecondaryColor3fv, "glSecondaryColor3fv");
  if (_driver.glSecondaryColor3fv) {
    _driver.glSecondaryColor3fv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSecondaryColor3fv)(v);
}

static void REGAL_CALL loader_glSecondaryColor3i(GLint red, GLint green, GLint blue)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSecondaryColor3i, "glSecondaryColor3i");
  if (_driver.glSecondaryColor3i) {
    _driver.glSecondaryColor3i(red, green, blue);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSecondaryColor3i)(red, green, blue);
}

static void REGAL_CALL loader_glSecondaryColor3iv(const GLint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSecondaryColor3iv, "glSecondaryColor3iv");
  if (_driver.glSecondaryColor3iv) {
    _driver.glSecondaryColor3iv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSecondaryColor3iv)(v);
}

static void REGAL_CALL loader_glSecondaryColor3s(GLshort red, GLshort green, GLshort blue)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSecondaryColor3s, "glSecondaryColor3s");
  if (_driver.glSecondaryColor3s) {
    _driver.glSecondaryColor3s(red, green, blue);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSecondaryColor3s)(red, green, blue);
}

static void REGAL_CALL loader_glSecondaryColor3sv(const GLshort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSecondaryColor3sv, "glSecondaryColor3sv");
  if (_driver.glSecondaryColor3sv) {
    _driver.glSecondaryColor3sv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSecondaryColor3sv)(v);
}

static void REGAL_CALL loader_glSecondaryColor3ub(GLubyte red, GLubyte green, GLubyte blue)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSecondaryColor3ub, "glSecondaryColor3ub");
  if (_driver.glSecondaryColor3ub) {
    _driver.glSecondaryColor3ub(red, green, blue);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSecondaryColor3ub)(red, green, blue);
}

static void REGAL_CALL loader_glSecondaryColor3ubv(const GLubyte *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSecondaryColor3ubv, "glSecondaryColor3ubv");
  if (_driver.glSecondaryColor3ubv) {
    _driver.glSecondaryColor3ubv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSecondaryColor3ubv)(v);
}

static void REGAL_CALL loader_glSecondaryColor3ui(GLuint red, GLuint green, GLuint blue)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSecondaryColor3ui, "glSecondaryColor3ui");
  if (_driver.glSecondaryColor3ui) {
    _driver.glSecondaryColor3ui(red, green, blue);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSecondaryColor3ui)(red, green, blue);
}

static void REGAL_CALL loader_glSecondaryColor3uiv(const GLuint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSecondaryColor3uiv, "glSecondaryColor3uiv");
  if (_driver.glSecondaryColor3uiv) {
    _driver.glSecondaryColor3uiv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSecondaryColor3uiv)(v);
}

static void REGAL_CALL loader_glSecondaryColor3us(GLushort red, GLushort green, GLushort blue)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSecondaryColor3us, "glSecondaryColor3us");
  if (_driver.glSecondaryColor3us) {
    _driver.glSecondaryColor3us(red, green, blue);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSecondaryColor3us)(red, green, blue);
}

static void REGAL_CALL loader_glSecondaryColor3usv(const GLushort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSecondaryColor3usv, "glSecondaryColor3usv");
  if (_driver.glSecondaryColor3usv) {
    _driver.glSecondaryColor3usv(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSecondaryColor3usv)(v);
}

static void REGAL_CALL loader_glSecondaryColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSecondaryColorPointer, "glSecondaryColorPointer");
  if (_driver.glSecondaryColorPointer) {
    _driver.glSecondaryColorPointer(size, type, stride, pointer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSecondaryColorPointer)(size, type, stride, pointer);
}

static void REGAL_CALL loader_glWindowPos2d(GLdouble x, GLdouble y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos2d, "glWindowPos2d");
  if (_driver.glWindowPos2d) {
    _driver.glWindowPos2d(x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos2d)(x, y);
}

static void REGAL_CALL loader_glWindowPos2dv(const GLdouble *p)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos2dv, "glWindowPos2dv");
  if (_driver.glWindowPos2dv) {
    _driver.glWindowPos2dv(p);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos2dv)(p);
}

static void REGAL_CALL loader_glWindowPos2f(GLfloat x, GLfloat y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos2f, "glWindowPos2f");
  if (_driver.glWindowPos2f) {
    _driver.glWindowPos2f(x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos2f)(x, y);
}

static void REGAL_CALL loader_glWindowPos2fv(const GLfloat *p)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos2fv, "glWindowPos2fv");
  if (_driver.glWindowPos2fv) {
    _driver.glWindowPos2fv(p);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos2fv)(p);
}

static void REGAL_CALL loader_glWindowPos2i(GLint x, GLint y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos2i, "glWindowPos2i");
  if (_driver.glWindowPos2i) {
    _driver.glWindowPos2i(x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos2i)(x, y);
}

static void REGAL_CALL loader_glWindowPos2iv(const GLint *p)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos2iv, "glWindowPos2iv");
  if (_driver.glWindowPos2iv) {
    _driver.glWindowPos2iv(p);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos2iv)(p);
}

static void REGAL_CALL loader_glWindowPos2s(GLshort x, GLshort y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos2s, "glWindowPos2s");
  if (_driver.glWindowPos2s) {
    _driver.glWindowPos2s(x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos2s)(x, y);
}

static void REGAL_CALL loader_glWindowPos2sv(const GLshort *p)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos2sv, "glWindowPos2sv");
  if (_driver.glWindowPos2sv) {
    _driver.glWindowPos2sv(p);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos2sv)(p);
}

static void REGAL_CALL loader_glWindowPos3d(GLdouble x, GLdouble y, GLdouble z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos3d, "glWindowPos3d");
  if (_driver.glWindowPos3d) {
    _driver.glWindowPos3d(x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos3d)(x, y, z);
}

static void REGAL_CALL loader_glWindowPos3dv(const GLdouble *p)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos3dv, "glWindowPos3dv");
  if (_driver.glWindowPos3dv) {
    _driver.glWindowPos3dv(p);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos3dv)(p);
}

static void REGAL_CALL loader_glWindowPos3f(GLfloat x, GLfloat y, GLfloat z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos3f, "glWindowPos3f");
  if (_driver.glWindowPos3f) {
    _driver.glWindowPos3f(x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos3f)(x, y, z);
}

static void REGAL_CALL loader_glWindowPos3fv(const GLfloat *p)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos3fv, "glWindowPos3fv");
  if (_driver.glWindowPos3fv) {
    _driver.glWindowPos3fv(p);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos3fv)(p);
}

static void REGAL_CALL loader_glWindowPos3i(GLint x, GLint y, GLint z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos3i, "glWindowPos3i");
  if (_driver.glWindowPos3i) {
    _driver.glWindowPos3i(x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos3i)(x, y, z);
}

static void REGAL_CALL loader_glWindowPos3iv(const GLint *p)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos3iv, "glWindowPos3iv");
  if (_driver.glWindowPos3iv) {
    _driver.glWindowPos3iv(p);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos3iv)(p);
}

static void REGAL_CALL loader_glWindowPos3s(GLshort x, GLshort y, GLshort z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos3s, "glWindowPos3s");
  if (_driver.glWindowPos3s) {
    _driver.glWindowPos3s(x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos3s)(x, y, z);
}

static void REGAL_CALL loader_glWindowPos3sv(const GLshort *p)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos3sv, "glWindowPos3sv");
  if (_driver.glWindowPos3sv) {
    _driver.glWindowPos3sv(p);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos3sv)(p);
}

// GL_VERSION_1_5

static void REGAL_CALL loader_glBeginQuery(GLenum target, GLuint id)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBeginQuery, "glBeginQuery");
  if (_driver.glBeginQuery) {
    _driver.glBeginQuery(target, id);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBeginQuery)(target, id);
}

static void REGAL_CALL loader_glBindBuffer(GLenum target, GLuint buffer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBindBuffer, "glBindBuffer");
  if (_driver.glBindBuffer) {
    _driver.glBindBuffer(target, buffer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBindBuffer)(target, buffer);
}

static void REGAL_CALL loader_glBufferData(GLenum target, GLsizeiptr size, const GLvoid *data, GLenum usage)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBufferData, "glBufferData");
  if (_driver.glBufferData) {
    _driver.glBufferData(target, size, data, usage);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBufferData)(target, size, data, usage);
}

static void REGAL_CALL loader_glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBufferSubData, "glBufferSubData");
  if (_driver.glBufferSubData) {
    _driver.glBufferSubData(target, offset, size, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBufferSubData)(target, offset, size, data);
}

static void REGAL_CALL loader_glDeleteBuffers(GLsizei n, const GLuint *buffers)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDeleteBuffers, "glDeleteBuffers");
  if (_driver.glDeleteBuffers) {
    _driver.glDeleteBuffers(n, buffers);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDeleteBuffers)(n, buffers);
}

static void REGAL_CALL loader_glDeleteQueries(GLsizei n, const GLuint *ids)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDeleteQueries, "glDeleteQueries");
  if (_driver.glDeleteQueries) {
    _driver.glDeleteQueries(n, ids);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDeleteQueries)(n, ids);
}

static void REGAL_CALL loader_glEndQuery(GLenum target)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glEndQuery, "glEndQuery");
  if (_driver.glEndQuery) {
    _driver.glEndQuery(target);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glEndQuery)(target);
}

static void REGAL_CALL loader_glGenBuffers(GLsizei n, GLuint *buffers)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGenBuffers, "glGenBuffers");
  if (_driver.glGenBuffers) {
    _driver.glGenBuffers(n, buffers);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGenBuffers)(n, buffers);
}

static void REGAL_CALL loader_glGenQueries(GLsizei n, GLuint *ids)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGenQueries, "glGenQueries");
  if (_driver.glGenQueries) {
    _driver.glGenQueries(n, ids);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGenQueries)(n, ids);
}

static void REGAL_CALL loader_glGetBufferParameteriv(GLenum target, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetBufferParameteriv, "glGetBufferParameteriv");
  if (_driver.glGetBufferParameteriv) {
    _driver.glGetBufferParameteriv(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetBufferParameteriv)(target, pname, params);
}

static void REGAL_CALL loader_glGetBufferPointerv(GLenum target, GLenum pname, GLvoid **params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetBufferPointerv, "glGetBufferPointerv");
  if (_driver.glGetBufferPointerv) {
    _driver.glGetBufferPointerv(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetBufferPointerv)(target, pname, params);
}

static void REGAL_CALL loader_glGetBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, GLvoid *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetBufferSubData, "glGetBufferSubData");
  if (_driver.glGetBufferSubData) {
    _driver.glGetBufferSubData(target, offset, size, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetBufferSubData)(target, offset, size, data);
}

static void REGAL_CALL loader_glGetQueryObjectiv(GLuint id, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetQueryObjectiv, "glGetQueryObjectiv");
  if (_driver.glGetQueryObjectiv) {
    _driver.glGetQueryObjectiv(id, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetQueryObjectiv)(id, pname, params);
}

static void REGAL_CALL loader_glGetQueryObjectuiv(GLuint id, GLenum pname, GLuint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetQueryObjectuiv, "glGetQueryObjectuiv");
  if (_driver.glGetQueryObjectuiv) {
    _driver.glGetQueryObjectuiv(id, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetQueryObjectuiv)(id, pname, params);
}

static void REGAL_CALL loader_glGetQueryiv(GLenum target, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetQueryiv, "glGetQueryiv");
  if (_driver.glGetQueryiv) {
    _driver.glGetQueryiv(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetQueryiv)(target, pname, params);
}

static GLboolean REGAL_CALL loader_glIsBuffer(GLuint buffer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIsBuffer, "glIsBuffer");
  if (_driver.glIsBuffer) {
    return _driver.glIsBuffer(buffer);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glIsBuffer)(buffer);
}

static GLboolean REGAL_CALL loader_glIsQuery(GLuint id)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIsQuery, "glIsQuery");
  if (_driver.glIsQuery) {
    return _driver.glIsQuery(id);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glIsQuery)(id);
}

static GLvoid *REGAL_CALL loader_glMapBuffer(GLenum target, GLenum access)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMapBuffer, "glMapBuffer");
  if (_driver.glMapBuffer) {
    return _driver.glMapBuffer(target, access);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glMapBuffer)(target, access);
}

static GLboolean REGAL_CALL loader_glUnmapBuffer(GLenum target)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUnmapBuffer, "glUnmapBuffer");
  if (_driver.glUnmapBuffer) {
    return _driver.glUnmapBuffer(target);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glUnmapBuffer)(target);
}

// GL_VERSION_2_0

static void REGAL_CALL loader_glAttachShader(GLuint program, GLuint shader)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glAttachShader, "glAttachShader");
  if (_driver.glAttachShader) {
    _driver.glAttachShader(program, shader);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glAttachShader)(program, shader);
}

static void REGAL_CALL loader_glBindAttribLocation(GLuint program, GLuint index, const GLchar *name)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBindAttribLocation, "glBindAttribLocation");
  if (_driver.glBindAttribLocation) {
    _driver.glBindAttribLocation(program, index, name);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBindAttribLocation)(program, index, name);
}

static void REGAL_CALL loader_glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBlendEquationSeparate, "glBlendEquationSeparate");
  if (_driver.glBlendEquationSeparate) {
    _driver.glBlendEquationSeparate(modeRGB, modeAlpha);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBlendEquationSeparate)(modeRGB, modeAlpha);
}

static void REGAL_CALL loader_glCompileShader(GLuint shader)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCompileShader, "glCompileShader");
  if (_driver.glCompileShader) {
    _driver.glCompileShader(shader);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCompileShader)(shader);
}

static GLuint REGAL_CALL loader_glCreateProgram(void)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCreateProgram, "glCreateProgram");
  if (_driver.glCreateProgram) {
    return _driver.glCreateProgram();
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glCreateProgram)();
}

static GLuint REGAL_CALL loader_glCreateShader(GLenum type)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCreateShader, "glCreateShader");
  if (_driver.glCreateShader) {
    return _driver.glCreateShader(type);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glCreateShader)(type);
}

static void REGAL_CALL loader_glDeleteProgram(GLuint program)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDeleteProgram, "glDeleteProgram");
  if (_driver.glDeleteProgram) {
    _driver.glDeleteProgram(program);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDeleteProgram)(program);
}

static void REGAL_CALL loader_glDeleteShader(GLuint shader)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDeleteShader, "glDeleteShader");
  if (_driver.glDeleteShader) {
    _driver.glDeleteShader(shader);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDeleteShader)(shader);
}

static void REGAL_CALL loader_glDetachShader(GLuint program, GLuint shader)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDetachShader, "glDetachShader");
  if (_driver.glDetachShader) {
    _driver.glDetachShader(program, shader);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDetachShader)(program, shader);
}

static void REGAL_CALL loader_glDisableVertexAttribArray(GLuint index)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDisableVertexAttribArray, "glDisableVertexAttribArray");
  if (_driver.glDisableVertexAttribArray) {
    _driver.glDisableVertexAttribArray(index);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDisableVertexAttribArray)(index);
}

static void REGAL_CALL loader_glDrawBuffers(GLsizei n, const GLenum *bufs)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDrawBuffers, "glDrawBuffers");
  if (_driver.glDrawBuffers) {
    _driver.glDrawBuffers(n, bufs);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDrawBuffers)(n, bufs);
}

static void REGAL_CALL loader_glEnableVertexAttribArray(GLuint index)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glEnableVertexAttribArray, "glEnableVertexAttribArray");
  if (_driver.glEnableVertexAttribArray) {
    _driver.glEnableVertexAttribArray(index);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glEnableVertexAttribArray)(index);
}

static void REGAL_CALL loader_glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetActiveAttrib, "glGetActiveAttrib");
  if (_driver.glGetActiveAttrib) {
    _driver.glGetActiveAttrib(program, index, bufSize, length, size, type, name);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetActiveAttrib)(program, index, bufSize, length, size, type, name);
}

static void REGAL_CALL loader_glGetActiveUniform(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetActiveUniform, "glGetActiveUniform");
  if (_driver.glGetActiveUniform) {
    _driver.glGetActiveUniform(program, index, bufSize, length, size, type, name);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetActiveUniform)(program, index, bufSize, length, size, type, name);
}

static void REGAL_CALL loader_glGetAttachedShaders(GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetAttachedShaders, "glGetAttachedShaders");
  if (_driver.glGetAttachedShaders) {
    _driver.glGetAttachedShaders(program, maxCount, count, shaders);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetAttachedShaders)(program, maxCount, count, shaders);
}

static GLint REGAL_CALL loader_glGetAttribLocation(GLuint program, const GLchar *name)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetAttribLocation, "glGetAttribLocation");
  if (_driver.glGetAttribLocation) {
    return _driver.glGetAttribLocation(program, name);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glGetAttribLocation)(program, name);
}

static void REGAL_CALL loader_glGetProgramInfoLog(GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetProgramInfoLog, "glGetProgramInfoLog");
  if (_driver.glGetProgramInfoLog) {
    _driver.glGetProgramInfoLog(program, bufSize, length, infoLog);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetProgramInfoLog)(program, bufSize, length, infoLog);
}

static void REGAL_CALL loader_glGetProgramiv(GLuint program, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetProgramiv, "glGetProgramiv");
  if (_driver.glGetProgramiv) {
    _driver.glGetProgramiv(program, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetProgramiv)(program, pname, params);
}

static void REGAL_CALL loader_glGetShaderInfoLog(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetShaderInfoLog, "glGetShaderInfoLog");
  if (_driver.glGetShaderInfoLog) {
    _driver.glGetShaderInfoLog(shader, bufSize, length, infoLog);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetShaderInfoLog)(shader, bufSize, length, infoLog);
}

static void REGAL_CALL loader_glGetShaderSource(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetShaderSource, "glGetShaderSource");
  if (_driver.glGetShaderSource) {
    _driver.glGetShaderSource(shader, bufSize, length, source);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetShaderSource)(shader, bufSize, length, source);
}

static void REGAL_CALL loader_glGetShaderiv(GLuint shader, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetShaderiv, "glGetShaderiv");
  if (_driver.glGetShaderiv) {
    _driver.glGetShaderiv(shader, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetShaderiv)(shader, pname, params);
}

static GLint REGAL_CALL loader_glGetUniformLocation(GLuint program, const GLchar *name)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetUniformLocation, "glGetUniformLocation");
  if (_driver.glGetUniformLocation) {
    return _driver.glGetUniformLocation(program, name);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glGetUniformLocation)(program, name);
}

static void REGAL_CALL loader_glGetUniformfv(GLuint program, GLint location, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetUniformfv, "glGetUniformfv");
  if (_driver.glGetUniformfv) {
    _driver.glGetUniformfv(program, location, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetUniformfv)(program, location, params);
}

static void REGAL_CALL loader_glGetUniformiv(GLuint program, GLint location, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetUniformiv, "glGetUniformiv");
  if (_driver.glGetUniformiv) {
    _driver.glGetUniformiv(program, location, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetUniformiv)(program, location, params);
}

static void REGAL_CALL loader_glGetVertexAttribPointerv(GLuint index, GLenum pname, GLvoid **pointer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetVertexAttribPointerv, "glGetVertexAttribPointerv");
  if (_driver.glGetVertexAttribPointerv) {
    _driver.glGetVertexAttribPointerv(index, pname, pointer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetVertexAttribPointerv)(index, pname, pointer);
}

static void REGAL_CALL loader_glGetVertexAttribdv(GLuint index, GLenum pname, GLdouble *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetVertexAttribdv, "glGetVertexAttribdv");
  if (_driver.glGetVertexAttribdv) {
    _driver.glGetVertexAttribdv(index, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetVertexAttribdv)(index, pname, params);
}

static void REGAL_CALL loader_glGetVertexAttribfv(GLuint index, GLenum pname, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetVertexAttribfv, "glGetVertexAttribfv");
  if (_driver.glGetVertexAttribfv) {
    _driver.glGetVertexAttribfv(index, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetVertexAttribfv)(index, pname, params);
}

static void REGAL_CALL loader_glGetVertexAttribiv(GLuint index, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetVertexAttribiv, "glGetVertexAttribiv");
  if (_driver.glGetVertexAttribiv) {
    _driver.glGetVertexAttribiv(index, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetVertexAttribiv)(index, pname, params);
}

static GLboolean REGAL_CALL loader_glIsProgram(GLuint program)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIsProgram, "glIsProgram");
  if (_driver.glIsProgram) {
    return _driver.glIsProgram(program);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glIsProgram)(program);
}

static GLboolean REGAL_CALL loader_glIsShader(GLuint shader)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIsShader, "glIsShader");
  if (_driver.glIsShader) {
    return _driver.glIsShader(shader);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glIsShader)(shader);
}

static void REGAL_CALL loader_glLinkProgram(GLuint program)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glLinkProgram, "glLinkProgram");
  if (_driver.glLinkProgram) {
    _driver.glLinkProgram(program);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glLinkProgram)(program);
}

static void REGAL_CALL loader_glShaderSource(GLuint shader, GLsizei count, const GLchar **string, const GLint *length)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glShaderSource, "glShaderSource");
  if (_driver.glShaderSource) {
    _driver.glShaderSource(shader, count, string, length);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glShaderSource)(shader, count, string, length);
}

static void REGAL_CALL loader_glStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glStencilFuncSeparate, "glStencilFuncSeparate");
  if (_driver.glStencilFuncSeparate) {
    _driver.glStencilFuncSeparate(face, func, ref, mask);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glStencilFuncSeparate)(face, func, ref, mask);
}

static void REGAL_CALL loader_glStencilMaskSeparate(GLenum face, GLuint mask)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glStencilMaskSeparate, "glStencilMaskSeparate");
  if (_driver.glStencilMaskSeparate) {
    _driver.glStencilMaskSeparate(face, mask);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glStencilMaskSeparate)(face, mask);
}

static void REGAL_CALL loader_glStencilOpSeparate(GLenum face, GLenum fail, GLenum zfail, GLenum zpass)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glStencilOpSeparate, "glStencilOpSeparate");
  if (_driver.glStencilOpSeparate) {
    _driver.glStencilOpSeparate(face, fail, zfail, zpass);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glStencilOpSeparate)(face, fail, zfail, zpass);
}

static void REGAL_CALL loader_glUniform1f(GLint location, GLfloat v0)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform1f, "glUniform1f");
  if (_driver.glUniform1f) {
    _driver.glUniform1f(location, v0);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform1f)(location, v0);
}

static void REGAL_CALL loader_glUniform1fv(GLint location, GLsizei count, const GLfloat *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform1fv, "glUniform1fv");
  if (_driver.glUniform1fv) {
    _driver.glUniform1fv(location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform1fv)(location, count, value);
}

static void REGAL_CALL loader_glUniform1i(GLint location, GLint v0)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform1i, "glUniform1i");
  if (_driver.glUniform1i) {
    _driver.glUniform1i(location, v0);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform1i)(location, v0);
}

static void REGAL_CALL loader_glUniform1iv(GLint location, GLsizei count, const GLint *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform1iv, "glUniform1iv");
  if (_driver.glUniform1iv) {
    _driver.glUniform1iv(location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform1iv)(location, count, value);
}

static void REGAL_CALL loader_glUniform2f(GLint location, GLfloat v0, GLfloat v1)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform2f, "glUniform2f");
  if (_driver.glUniform2f) {
    _driver.glUniform2f(location, v0, v1);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform2f)(location, v0, v1);
}

static void REGAL_CALL loader_glUniform2fv(GLint location, GLsizei count, const GLfloat *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform2fv, "glUniform2fv");
  if (_driver.glUniform2fv) {
    _driver.glUniform2fv(location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform2fv)(location, count, value);
}

static void REGAL_CALL loader_glUniform2i(GLint location, GLint v0, GLint v1)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform2i, "glUniform2i");
  if (_driver.glUniform2i) {
    _driver.glUniform2i(location, v0, v1);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform2i)(location, v0, v1);
}

static void REGAL_CALL loader_glUniform2iv(GLint location, GLsizei count, const GLint *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform2iv, "glUniform2iv");
  if (_driver.glUniform2iv) {
    _driver.glUniform2iv(location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform2iv)(location, count, value);
}

static void REGAL_CALL loader_glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform3f, "glUniform3f");
  if (_driver.glUniform3f) {
    _driver.glUniform3f(location, v0, v1, v2);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform3f)(location, v0, v1, v2);
}

static void REGAL_CALL loader_glUniform3fv(GLint location, GLsizei count, const GLfloat *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform3fv, "glUniform3fv");
  if (_driver.glUniform3fv) {
    _driver.glUniform3fv(location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform3fv)(location, count, value);
}

static void REGAL_CALL loader_glUniform3i(GLint location, GLint v0, GLint v1, GLint v2)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform3i, "glUniform3i");
  if (_driver.glUniform3i) {
    _driver.glUniform3i(location, v0, v1, v2);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform3i)(location, v0, v1, v2);
}

static void REGAL_CALL loader_glUniform3iv(GLint location, GLsizei count, const GLint *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform3iv, "glUniform3iv");
  if (_driver.glUniform3iv) {
    _driver.glUniform3iv(location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform3iv)(location, count, value);
}

static void REGAL_CALL loader_glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform4f, "glUniform4f");
  if (_driver.glUniform4f) {
    _driver.glUniform4f(location, v0, v1, v2, v3);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform4f)(location, v0, v1, v2, v3);
}

static void REGAL_CALL loader_glUniform4fv(GLint location, GLsizei count, const GLfloat *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform4fv, "glUniform4fv");
  if (_driver.glUniform4fv) {
    _driver.glUniform4fv(location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform4fv)(location, count, value);
}

static void REGAL_CALL loader_glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform4i, "glUniform4i");
  if (_driver.glUniform4i) {
    _driver.glUniform4i(location, v0, v1, v2, v3);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform4i)(location, v0, v1, v2, v3);
}

static void REGAL_CALL loader_glUniform4iv(GLint location, GLsizei count, const GLint *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform4iv, "glUniform4iv");
  if (_driver.glUniform4iv) {
    _driver.glUniform4iv(location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform4iv)(location, count, value);
}

static void REGAL_CALL loader_glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniformMatrix2fv, "glUniformMatrix2fv");
  if (_driver.glUniformMatrix2fv) {
    _driver.glUniformMatrix2fv(location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniformMatrix2fv)(location, count, transpose, value);
}

static void REGAL_CALL loader_glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniformMatrix3fv, "glUniformMatrix3fv");
  if (_driver.glUniformMatrix3fv) {
    _driver.glUniformMatrix3fv(location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniformMatrix3fv)(location, count, transpose, value);
}

static void REGAL_CALL loader_glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniformMatrix4fv, "glUniformMatrix4fv");
  if (_driver.glUniformMatrix4fv) {
    _driver.glUniformMatrix4fv(location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniformMatrix4fv)(location, count, transpose, value);
}

static void REGAL_CALL loader_glUseProgram(GLuint program)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUseProgram, "glUseProgram");
  if (_driver.glUseProgram) {
    _driver.glUseProgram(program);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUseProgram)(program);
}

static void REGAL_CALL loader_glValidateProgram(GLuint program)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glValidateProgram, "glValidateProgram");
  if (_driver.glValidateProgram) {
    _driver.glValidateProgram(program);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glValidateProgram)(program);
}

static void REGAL_CALL loader_glVertexAttrib1d(GLuint index, GLdouble x)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib1d, "glVertexAttrib1d");
  if (_driver.glVertexAttrib1d) {
    _driver.glVertexAttrib1d(index, x);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib1d)(index, x);
}

static void REGAL_CALL loader_glVertexAttrib1dv(GLuint index, const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib1dv, "glVertexAttrib1dv");
  if (_driver.glVertexAttrib1dv) {
    _driver.glVertexAttrib1dv(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib1dv)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib1f(GLuint index, GLfloat x)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib1f, "glVertexAttrib1f");
  if (_driver.glVertexAttrib1f) {
    _driver.glVertexAttrib1f(index, x);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib1f)(index, x);
}

static void REGAL_CALL loader_glVertexAttrib1fv(GLuint index, const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib1fv, "glVertexAttrib1fv");
  if (_driver.glVertexAttrib1fv) {
    _driver.glVertexAttrib1fv(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib1fv)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib1s(GLuint index, GLshort x)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib1s, "glVertexAttrib1s");
  if (_driver.glVertexAttrib1s) {
    _driver.glVertexAttrib1s(index, x);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib1s)(index, x);
}

static void REGAL_CALL loader_glVertexAttrib1sv(GLuint index, const GLshort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib1sv, "glVertexAttrib1sv");
  if (_driver.glVertexAttrib1sv) {
    _driver.glVertexAttrib1sv(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib1sv)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib2d(GLuint index, GLdouble x, GLdouble y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib2d, "glVertexAttrib2d");
  if (_driver.glVertexAttrib2d) {
    _driver.glVertexAttrib2d(index, x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib2d)(index, x, y);
}

static void REGAL_CALL loader_glVertexAttrib2dv(GLuint index, const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib2dv, "glVertexAttrib2dv");
  if (_driver.glVertexAttrib2dv) {
    _driver.glVertexAttrib2dv(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib2dv)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib2f(GLuint index, GLfloat x, GLfloat y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib2f, "glVertexAttrib2f");
  if (_driver.glVertexAttrib2f) {
    _driver.glVertexAttrib2f(index, x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib2f)(index, x, y);
}

static void REGAL_CALL loader_glVertexAttrib2fv(GLuint index, const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib2fv, "glVertexAttrib2fv");
  if (_driver.glVertexAttrib2fv) {
    _driver.glVertexAttrib2fv(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib2fv)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib2s(GLuint index, GLshort x, GLshort y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib2s, "glVertexAttrib2s");
  if (_driver.glVertexAttrib2s) {
    _driver.glVertexAttrib2s(index, x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib2s)(index, x, y);
}

static void REGAL_CALL loader_glVertexAttrib2sv(GLuint index, const GLshort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib2sv, "glVertexAttrib2sv");
  if (_driver.glVertexAttrib2sv) {
    _driver.glVertexAttrib2sv(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib2sv)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib3d(GLuint index, GLdouble x, GLdouble y, GLdouble z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib3d, "glVertexAttrib3d");
  if (_driver.glVertexAttrib3d) {
    _driver.glVertexAttrib3d(index, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib3d)(index, x, y, z);
}

static void REGAL_CALL loader_glVertexAttrib3dv(GLuint index, const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib3dv, "glVertexAttrib3dv");
  if (_driver.glVertexAttrib3dv) {
    _driver.glVertexAttrib3dv(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib3dv)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib3f(GLuint index, GLfloat x, GLfloat y, GLfloat z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib3f, "glVertexAttrib3f");
  if (_driver.glVertexAttrib3f) {
    _driver.glVertexAttrib3f(index, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib3f)(index, x, y, z);
}

static void REGAL_CALL loader_glVertexAttrib3fv(GLuint index, const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib3fv, "glVertexAttrib3fv");
  if (_driver.glVertexAttrib3fv) {
    _driver.glVertexAttrib3fv(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib3fv)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib3s(GLuint index, GLshort x, GLshort y, GLshort z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib3s, "glVertexAttrib3s");
  if (_driver.glVertexAttrib3s) {
    _driver.glVertexAttrib3s(index, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib3s)(index, x, y, z);
}

static void REGAL_CALL loader_glVertexAttrib3sv(GLuint index, const GLshort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib3sv, "glVertexAttrib3sv");
  if (_driver.glVertexAttrib3sv) {
    _driver.glVertexAttrib3sv(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib3sv)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib4Nbv(GLuint index, const GLbyte *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib4Nbv, "glVertexAttrib4Nbv");
  if (_driver.glVertexAttrib4Nbv) {
    _driver.glVertexAttrib4Nbv(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib4Nbv)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib4Niv(GLuint index, const GLint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib4Niv, "glVertexAttrib4Niv");
  if (_driver.glVertexAttrib4Niv) {
    _driver.glVertexAttrib4Niv(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib4Niv)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib4Nsv(GLuint index, const GLshort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib4Nsv, "glVertexAttrib4Nsv");
  if (_driver.glVertexAttrib4Nsv) {
    _driver.glVertexAttrib4Nsv(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib4Nsv)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib4Nub(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib4Nub, "glVertexAttrib4Nub");
  if (_driver.glVertexAttrib4Nub) {
    _driver.glVertexAttrib4Nub(index, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib4Nub)(index, x, y, z, w);
}

static void REGAL_CALL loader_glVertexAttrib4Nubv(GLuint index, const GLubyte *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib4Nubv, "glVertexAttrib4Nubv");
  if (_driver.glVertexAttrib4Nubv) {
    _driver.glVertexAttrib4Nubv(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib4Nubv)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib4Nuiv(GLuint index, const GLuint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib4Nuiv, "glVertexAttrib4Nuiv");
  if (_driver.glVertexAttrib4Nuiv) {
    _driver.glVertexAttrib4Nuiv(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib4Nuiv)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib4Nusv(GLuint index, const GLushort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib4Nusv, "glVertexAttrib4Nusv");
  if (_driver.glVertexAttrib4Nusv) {
    _driver.glVertexAttrib4Nusv(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib4Nusv)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib4bv(GLuint index, const GLbyte *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib4bv, "glVertexAttrib4bv");
  if (_driver.glVertexAttrib4bv) {
    _driver.glVertexAttrib4bv(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib4bv)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib4d(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib4d, "glVertexAttrib4d");
  if (_driver.glVertexAttrib4d) {
    _driver.glVertexAttrib4d(index, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib4d)(index, x, y, z, w);
}

static void REGAL_CALL loader_glVertexAttrib4dv(GLuint index, const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib4dv, "glVertexAttrib4dv");
  if (_driver.glVertexAttrib4dv) {
    _driver.glVertexAttrib4dv(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib4dv)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib4f(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib4f, "glVertexAttrib4f");
  if (_driver.glVertexAttrib4f) {
    _driver.glVertexAttrib4f(index, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib4f)(index, x, y, z, w);
}

static void REGAL_CALL loader_glVertexAttrib4fv(GLuint index, const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib4fv, "glVertexAttrib4fv");
  if (_driver.glVertexAttrib4fv) {
    _driver.glVertexAttrib4fv(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib4fv)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib4iv(GLuint index, const GLint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib4iv, "glVertexAttrib4iv");
  if (_driver.glVertexAttrib4iv) {
    _driver.glVertexAttrib4iv(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib4iv)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib4s(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib4s, "glVertexAttrib4s");
  if (_driver.glVertexAttrib4s) {
    _driver.glVertexAttrib4s(index, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib4s)(index, x, y, z, w);
}

static void REGAL_CALL loader_glVertexAttrib4sv(GLuint index, const GLshort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib4sv, "glVertexAttrib4sv");
  if (_driver.glVertexAttrib4sv) {
    _driver.glVertexAttrib4sv(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib4sv)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib4ubv(GLuint index, const GLubyte *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib4ubv, "glVertexAttrib4ubv");
  if (_driver.glVertexAttrib4ubv) {
    _driver.glVertexAttrib4ubv(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib4ubv)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib4uiv(GLuint index, const GLuint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib4uiv, "glVertexAttrib4uiv");
  if (_driver.glVertexAttrib4uiv) {
    _driver.glVertexAttrib4uiv(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib4uiv)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib4usv(GLuint index, const GLushort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib4usv, "glVertexAttrib4usv");
  if (_driver.glVertexAttrib4usv) {
    _driver.glVertexAttrib4usv(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib4usv)(index, v);
}

static void REGAL_CALL loader_glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribPointer, "glVertexAttribPointer");
  if (_driver.glVertexAttribPointer) {
    _driver.glVertexAttribPointer(index, size, type, normalized, stride, pointer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribPointer)(index, size, type, normalized, stride, pointer);
}

// GL_VERSION_2_1

static void REGAL_CALL loader_glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniformMatrix2x3fv, "glUniformMatrix2x3fv");
  if (_driver.glUniformMatrix2x3fv) {
    _driver.glUniformMatrix2x3fv(location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniformMatrix2x3fv)(location, count, transpose, value);
}

static void REGAL_CALL loader_glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniformMatrix2x4fv, "glUniformMatrix2x4fv");
  if (_driver.glUniformMatrix2x4fv) {
    _driver.glUniformMatrix2x4fv(location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniformMatrix2x4fv)(location, count, transpose, value);
}

static void REGAL_CALL loader_glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniformMatrix3x2fv, "glUniformMatrix3x2fv");
  if (_driver.glUniformMatrix3x2fv) {
    _driver.glUniformMatrix3x2fv(location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniformMatrix3x2fv)(location, count, transpose, value);
}

static void REGAL_CALL loader_glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniformMatrix3x4fv, "glUniformMatrix3x4fv");
  if (_driver.glUniformMatrix3x4fv) {
    _driver.glUniformMatrix3x4fv(location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniformMatrix3x4fv)(location, count, transpose, value);
}

static void REGAL_CALL loader_glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniformMatrix4x2fv, "glUniformMatrix4x2fv");
  if (_driver.glUniformMatrix4x2fv) {
    _driver.glUniformMatrix4x2fv(location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniformMatrix4x2fv)(location, count, transpose, value);
}

static void REGAL_CALL loader_glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniformMatrix4x3fv, "glUniformMatrix4x3fv");
  if (_driver.glUniformMatrix4x3fv) {
    _driver.glUniformMatrix4x3fv(location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniformMatrix4x3fv)(location, count, transpose, value);
}

// GL_VERSION_3_0

static void REGAL_CALL loader_glBeginConditionalRender(GLuint id, GLenum mode)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBeginConditionalRender, "glBeginConditionalRender");
  if (_driver.glBeginConditionalRender) {
    _driver.glBeginConditionalRender(id, mode);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBeginConditionalRender)(id, mode);
}

static void REGAL_CALL loader_glBeginTransformFeedback(GLenum primitiveMode)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBeginTransformFeedback, "glBeginTransformFeedback");
  if (_driver.glBeginTransformFeedback) {
    _driver.glBeginTransformFeedback(primitiveMode);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBeginTransformFeedback)(primitiveMode);
}

static void REGAL_CALL loader_glBindFragDataLocation(GLuint program, GLuint color, const GLchar *name)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBindFragDataLocation, "glBindFragDataLocation");
  if (_driver.glBindFragDataLocation) {
    _driver.glBindFragDataLocation(program, color, name);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBindFragDataLocation)(program, color, name);
}

static void REGAL_CALL loader_glClampColor(GLenum target, GLenum clamp)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glClampColor, "glClampColor");
  if (_driver.glClampColor) {
    _driver.glClampColor(target, clamp);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glClampColor)(target, clamp);
}

static void REGAL_CALL loader_glClearBufferfi(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glClearBufferfi, "glClearBufferfi");
  if (_driver.glClearBufferfi) {
    _driver.glClearBufferfi(buffer, drawbuffer, depth, stencil);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glClearBufferfi)(buffer, drawbuffer, depth, stencil);
}

static void REGAL_CALL loader_glClearBufferfv(GLenum buffer, GLint drawbuffer, const GLfloat *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glClearBufferfv, "glClearBufferfv");
  if (_driver.glClearBufferfv) {
    _driver.glClearBufferfv(buffer, drawbuffer, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glClearBufferfv)(buffer, drawbuffer, value);
}

static void REGAL_CALL loader_glClearBufferiv(GLenum buffer, GLint drawbuffer, const GLint *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glClearBufferiv, "glClearBufferiv");
  if (_driver.glClearBufferiv) {
    _driver.glClearBufferiv(buffer, drawbuffer, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glClearBufferiv)(buffer, drawbuffer, value);
}

static void REGAL_CALL loader_glClearBufferuiv(GLenum buffer, GLint drawbuffer, const GLuint *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glClearBufferuiv, "glClearBufferuiv");
  if (_driver.glClearBufferuiv) {
    _driver.glClearBufferuiv(buffer, drawbuffer, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glClearBufferuiv)(buffer, drawbuffer, value);
}

static void REGAL_CALL loader_glColorMaski(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColorMaski, "glColorMaski");
  if (_driver.glColorMaski) {
    _driver.glColorMaski(index, r, g, b, a);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColorMaski)(index, r, g, b, a);
}

static void REGAL_CALL loader_glDisablei(GLenum cap, GLuint index)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDisablei, "glDisablei");
  if (_driver.glDisablei) {
    _driver.glDisablei(cap, index);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDisablei)(cap, index);
}

static void REGAL_CALL loader_glEnablei(GLenum cap, GLuint index)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glEnablei, "glEnablei");
  if (_driver.glEnablei) {
    _driver.glEnablei(cap, index);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glEnablei)(cap, index);
}

static void REGAL_CALL loader_glEndConditionalRender(void)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glEndConditionalRender, "glEndConditionalRender");
  if (_driver.glEndConditionalRender) {
    _driver.glEndConditionalRender();
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glEndConditionalRender)();
}

static void REGAL_CALL loader_glEndTransformFeedback(void)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glEndTransformFeedback, "glEndTransformFeedback");
  if (_driver.glEndTransformFeedback) {
    _driver.glEndTransformFeedback();
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glEndTransformFeedback)();
}

static void REGAL_CALL loader_glGetBooleani_v(GLenum target, GLuint index, GLboolean *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetBooleani_v, "glGetBooleani_v");
  if (_driver.glGetBooleani_v) {
    _driver.glGetBooleani_v(target, index, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetBooleani_v)(target, index, data);
}

static GLint REGAL_CALL loader_glGetFragDataLocation(GLuint program, const GLchar *name)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetFragDataLocation, "glGetFragDataLocation");
  if (_driver.glGetFragDataLocation) {
    return _driver.glGetFragDataLocation(program, name);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glGetFragDataLocation)(program, name);
}

static const GLubyte *REGAL_CALL loader_glGetStringi(GLenum name, GLuint index)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetStringi, "glGetStringi");
  if (_driver.glGetStringi) {
    return _driver.glGetStringi(name, index);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glGetStringi)(name, index);
}

static void REGAL_CALL loader_glGetTexParameterIiv(GLenum target, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetTexParameterIiv, "glGetTexParameterIiv");
  if (_driver.glGetTexParameterIiv) {
    _driver.glGetTexParameterIiv(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetTexParameterIiv)(target, pname, params);
}

static void REGAL_CALL loader_glGetTexParameterIuiv(GLenum target, GLenum pname, GLuint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetTexParameterIuiv, "glGetTexParameterIuiv");
  if (_driver.glGetTexParameterIuiv) {
    _driver.glGetTexParameterIuiv(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetTexParameterIuiv)(target, pname, params);
}

static void REGAL_CALL loader_glGetTransformFeedbackVarying(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetTransformFeedbackVarying, "glGetTransformFeedbackVarying");
  if (_driver.glGetTransformFeedbackVarying) {
    _driver.glGetTransformFeedbackVarying(program, index, bufSize, length, size, type, name);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetTransformFeedbackVarying)(program, index, bufSize, length, size, type, name);
}

static void REGAL_CALL loader_glGetUniformuiv(GLuint program, GLint location, GLuint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetUniformuiv, "glGetUniformuiv");
  if (_driver.glGetUniformuiv) {
    _driver.glGetUniformuiv(program, location, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetUniformuiv)(program, location, params);
}

static void REGAL_CALL loader_glGetVertexAttribIiv(GLuint index, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetVertexAttribIiv, "glGetVertexAttribIiv");
  if (_driver.glGetVertexAttribIiv) {
    _driver.glGetVertexAttribIiv(index, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetVertexAttribIiv)(index, pname, params);
}

static void REGAL_CALL loader_glGetVertexAttribIuiv(GLuint index, GLenum pname, GLuint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetVertexAttribIuiv, "glGetVertexAttribIuiv");
  if (_driver.glGetVertexAttribIuiv) {
    _driver.glGetVertexAttribIuiv(index, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetVertexAttribIuiv)(index, pname, params);
}

static GLboolean REGAL_CALL loader_glIsEnabledi(GLenum target, GLuint index)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIsEnabledi, "glIsEnabledi");
  if (_driver.glIsEnabledi) {
    return _driver.glIsEnabledi(target, index);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glIsEnabledi)(target, index);
}

static void REGAL_CALL loader_glTexParameterIiv(GLenum target, GLenum pname, const GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexParameterIiv, "glTexParameterIiv");
  if (_driver.glTexParameterIiv) {
    _driver.glTexParameterIiv(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexParameterIiv)(target, pname, params);
}

static void REGAL_CALL loader_glTexParameterIuiv(GLenum target, GLenum pname, const GLuint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexParameterIuiv, "glTexParameterIuiv");
  if (_driver.glTexParameterIuiv) {
    _driver.glTexParameterIuiv(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexParameterIuiv)(target, pname, params);
}

static void REGAL_CALL loader_glTransformFeedbackVaryings(GLuint program, GLsizei count, const GLchar **varyings, GLenum bufferMode)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTransformFeedbackVaryings, "glTransformFeedbackVaryings");
  if (_driver.glTransformFeedbackVaryings) {
    _driver.glTransformFeedbackVaryings(program, count, varyings, bufferMode);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTransformFeedbackVaryings)(program, count, varyings, bufferMode);
}

static void REGAL_CALL loader_glUniform1ui(GLint location, GLuint v0)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform1ui, "glUniform1ui");
  if (_driver.glUniform1ui) {
    _driver.glUniform1ui(location, v0);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform1ui)(location, v0);
}

static void REGAL_CALL loader_glUniform1uiv(GLint location, GLsizei count, const GLuint *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform1uiv, "glUniform1uiv");
  if (_driver.glUniform1uiv) {
    _driver.glUniform1uiv(location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform1uiv)(location, count, value);
}

static void REGAL_CALL loader_glUniform2ui(GLint location, GLuint v0, GLuint v1)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform2ui, "glUniform2ui");
  if (_driver.glUniform2ui) {
    _driver.glUniform2ui(location, v0, v1);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform2ui)(location, v0, v1);
}

static void REGAL_CALL loader_glUniform2uiv(GLint location, GLsizei count, const GLuint *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform2uiv, "glUniform2uiv");
  if (_driver.glUniform2uiv) {
    _driver.glUniform2uiv(location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform2uiv)(location, count, value);
}

static void REGAL_CALL loader_glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform3ui, "glUniform3ui");
  if (_driver.glUniform3ui) {
    _driver.glUniform3ui(location, v0, v1, v2);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform3ui)(location, v0, v1, v2);
}

static void REGAL_CALL loader_glUniform3uiv(GLint location, GLsizei count, const GLuint *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform3uiv, "glUniform3uiv");
  if (_driver.glUniform3uiv) {
    _driver.glUniform3uiv(location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform3uiv)(location, count, value);
}

static void REGAL_CALL loader_glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform4ui, "glUniform4ui");
  if (_driver.glUniform4ui) {
    _driver.glUniform4ui(location, v0, v1, v2, v3);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform4ui)(location, v0, v1, v2, v3);
}

static void REGAL_CALL loader_glUniform4uiv(GLint location, GLsizei count, const GLuint *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform4uiv, "glUniform4uiv");
  if (_driver.glUniform4uiv) {
    _driver.glUniform4uiv(location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform4uiv)(location, count, value);
}

static void REGAL_CALL loader_glVertexAttribI1i(GLuint index, GLint x)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribI1i, "glVertexAttribI1i");
  if (_driver.glVertexAttribI1i) {
    _driver.glVertexAttribI1i(index, x);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribI1i)(index, x);
}

static void REGAL_CALL loader_glVertexAttribI1iv(GLuint index, const GLint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribI1iv, "glVertexAttribI1iv");
  if (_driver.glVertexAttribI1iv) {
    _driver.glVertexAttribI1iv(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribI1iv)(index, v);
}

static void REGAL_CALL loader_glVertexAttribI1ui(GLuint index, GLuint x)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribI1ui, "glVertexAttribI1ui");
  if (_driver.glVertexAttribI1ui) {
    _driver.glVertexAttribI1ui(index, x);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribI1ui)(index, x);
}

static void REGAL_CALL loader_glVertexAttribI1uiv(GLuint index, const GLuint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribI1uiv, "glVertexAttribI1uiv");
  if (_driver.glVertexAttribI1uiv) {
    _driver.glVertexAttribI1uiv(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribI1uiv)(index, v);
}

static void REGAL_CALL loader_glVertexAttribI2i(GLuint index, GLint x, GLint y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribI2i, "glVertexAttribI2i");
  if (_driver.glVertexAttribI2i) {
    _driver.glVertexAttribI2i(index, x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribI2i)(index, x, y);
}

static void REGAL_CALL loader_glVertexAttribI2iv(GLuint index, const GLint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribI2iv, "glVertexAttribI2iv");
  if (_driver.glVertexAttribI2iv) {
    _driver.glVertexAttribI2iv(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribI2iv)(index, v);
}

static void REGAL_CALL loader_glVertexAttribI2ui(GLuint index, GLuint x, GLuint y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribI2ui, "glVertexAttribI2ui");
  if (_driver.glVertexAttribI2ui) {
    _driver.glVertexAttribI2ui(index, x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribI2ui)(index, x, y);
}

static void REGAL_CALL loader_glVertexAttribI2uiv(GLuint index, const GLuint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribI2uiv, "glVertexAttribI2uiv");
  if (_driver.glVertexAttribI2uiv) {
    _driver.glVertexAttribI2uiv(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribI2uiv)(index, v);
}

static void REGAL_CALL loader_glVertexAttribI3i(GLuint index, GLint x, GLint y, GLint z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribI3i, "glVertexAttribI3i");
  if (_driver.glVertexAttribI3i) {
    _driver.glVertexAttribI3i(index, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribI3i)(index, x, y, z);
}

static void REGAL_CALL loader_glVertexAttribI3iv(GLuint index, const GLint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribI3iv, "glVertexAttribI3iv");
  if (_driver.glVertexAttribI3iv) {
    _driver.glVertexAttribI3iv(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribI3iv)(index, v);
}

static void REGAL_CALL loader_glVertexAttribI3ui(GLuint index, GLuint x, GLuint y, GLuint z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribI3ui, "glVertexAttribI3ui");
  if (_driver.glVertexAttribI3ui) {
    _driver.glVertexAttribI3ui(index, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribI3ui)(index, x, y, z);
}

static void REGAL_CALL loader_glVertexAttribI3uiv(GLuint index, const GLuint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribI3uiv, "glVertexAttribI3uiv");
  if (_driver.glVertexAttribI3uiv) {
    _driver.glVertexAttribI3uiv(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribI3uiv)(index, v);
}

static void REGAL_CALL loader_glVertexAttribI4bv(GLuint index, const GLbyte *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribI4bv, "glVertexAttribI4bv");
  if (_driver.glVertexAttribI4bv) {
    _driver.glVertexAttribI4bv(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribI4bv)(index, v);
}

static void REGAL_CALL loader_glVertexAttribI4i(GLuint index, GLint x, GLint y, GLint z, GLint w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribI4i, "glVertexAttribI4i");
  if (_driver.glVertexAttribI4i) {
    _driver.glVertexAttribI4i(index, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribI4i)(index, x, y, z, w);
}

static void REGAL_CALL loader_glVertexAttribI4iv(GLuint index, const GLint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribI4iv, "glVertexAttribI4iv");
  if (_driver.glVertexAttribI4iv) {
    _driver.glVertexAttribI4iv(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribI4iv)(index, v);
}

static void REGAL_CALL loader_glVertexAttribI4sv(GLuint index, const GLshort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribI4sv, "glVertexAttribI4sv");
  if (_driver.glVertexAttribI4sv) {
    _driver.glVertexAttribI4sv(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribI4sv)(index, v);
}

static void REGAL_CALL loader_glVertexAttribI4ubv(GLuint index, const GLubyte *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribI4ubv, "glVertexAttribI4ubv");
  if (_driver.glVertexAttribI4ubv) {
    _driver.glVertexAttribI4ubv(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribI4ubv)(index, v);
}

static void REGAL_CALL loader_glVertexAttribI4ui(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribI4ui, "glVertexAttribI4ui");
  if (_driver.glVertexAttribI4ui) {
    _driver.glVertexAttribI4ui(index, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribI4ui)(index, x, y, z, w);
}

static void REGAL_CALL loader_glVertexAttribI4uiv(GLuint index, const GLuint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribI4uiv, "glVertexAttribI4uiv");
  if (_driver.glVertexAttribI4uiv) {
    _driver.glVertexAttribI4uiv(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribI4uiv)(index, v);
}

static void REGAL_CALL loader_glVertexAttribI4usv(GLuint index, const GLushort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribI4usv, "glVertexAttribI4usv");
  if (_driver.glVertexAttribI4usv) {
    _driver.glVertexAttribI4usv(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribI4usv)(index, v);
}

static void REGAL_CALL loader_glVertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribIPointer, "glVertexAttribIPointer");
  if (_driver.glVertexAttribIPointer) {
    _driver.glVertexAttribIPointer(index, size, type, stride, pointer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribIPointer)(index, size, type, stride, pointer);
}

// GL_VERSION_3_1

static void REGAL_CALL loader_glDrawArraysInstanced(GLenum mode, GLint start, GLsizei count, GLsizei primcount)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDrawArraysInstanced, "glDrawArraysInstanced");
  if (_driver.glDrawArraysInstanced) {
    _driver.glDrawArraysInstanced(mode, start, count, primcount);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDrawArraysInstanced)(mode, start, count, primcount);
}

static void REGAL_CALL loader_glDrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDrawElementsInstanced, "glDrawElementsInstanced");
  if (_driver.glDrawElementsInstanced) {
    _driver.glDrawElementsInstanced(mode, count, type, indices, primcount);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDrawElementsInstanced)(mode, count, type, indices, primcount);
}

static void REGAL_CALL loader_glPrimitiveRestartIndex(GLuint index)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPrimitiveRestartIndex, "glPrimitiveRestartIndex");
  if (_driver.glPrimitiveRestartIndex) {
    _driver.glPrimitiveRestartIndex(index);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPrimitiveRestartIndex)(index);
}

static void REGAL_CALL loader_glTexBuffer(GLenum target, GLenum internalformat, GLuint buffer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexBuffer, "glTexBuffer");
  if (_driver.glTexBuffer) {
    _driver.glTexBuffer(target, internalformat, buffer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexBuffer)(target, internalformat, buffer);
}

// GL_VERSION_3_2

static void REGAL_CALL loader_glFramebufferTexture(GLenum target, GLenum attachment, GLuint texture, GLint level)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFramebufferTexture, "glFramebufferTexture");
  if (_driver.glFramebufferTexture) {
    _driver.glFramebufferTexture(target, attachment, texture, level);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFramebufferTexture)(target, attachment, texture, level);
}

static void REGAL_CALL loader_glFramebufferTextureFace(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFramebufferTextureFace, "glFramebufferTextureFace");
  if (_driver.glFramebufferTextureFace) {
    _driver.glFramebufferTextureFace(target, attachment, texture, level, face);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFramebufferTextureFace)(target, attachment, texture, level, face);
}

static void REGAL_CALL loader_glGetBufferParameteri64v(GLenum target, GLenum pname, GLint64 *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetBufferParameteri64v, "glGetBufferParameteri64v");
  if (_driver.glGetBufferParameteri64v) {
    _driver.glGetBufferParameteri64v(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetBufferParameteri64v)(target, pname, params);
}

static void REGAL_CALL loader_glGetInteger64i_v(GLenum target, GLuint index, GLint64 *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetInteger64i_v, "glGetInteger64i_v");
  if (_driver.glGetInteger64i_v) {
    _driver.glGetInteger64i_v(target, index, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetInteger64i_v)(target, index, data);
}

// GL_VERSION_3_3

static void REGAL_CALL loader_glVertexAttribDivisor(GLuint index, GLuint divisor)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribDivisor, "glVertexAttribDivisor");
  if (_driver.glVertexAttribDivisor) {
    _driver.glVertexAttribDivisor(index, divisor);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribDivisor)(index, divisor);
}

// GL_VERSION_4_0

static void REGAL_CALL loader_glBlendEquationSeparatei(GLuint buf, GLenum modeRGB, GLenum modeAlpha)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBlendEquationSeparatei, "glBlendEquationSeparatei");
  if (_driver.glBlendEquationSeparatei) {
    _driver.glBlendEquationSeparatei(buf, modeRGB, modeAlpha);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBlendEquationSeparatei)(buf, modeRGB, modeAlpha);
}

static void REGAL_CALL loader_glBlendEquationi(GLuint buf, GLenum mode)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBlendEquationi, "glBlendEquationi");
  if (_driver.glBlendEquationi) {
    _driver.glBlendEquationi(buf, mode);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBlendEquationi)(buf, mode);
}

static void REGAL_CALL loader_glBlendFuncSeparatei(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBlendFuncSeparatei, "glBlendFuncSeparatei");
  if (_driver.glBlendFuncSeparatei) {
    _driver.glBlendFuncSeparatei(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBlendFuncSeparatei)(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
}

static void REGAL_CALL loader_glBlendFunci(GLuint buf, GLenum src, GLenum dst)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBlendFunci, "glBlendFunci");
  if (_driver.glBlendFunci) {
    _driver.glBlendFunci(buf, src, dst);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBlendFunci)(buf, src, dst);
}

// GL_3DFX_tbuffer

static void REGAL_CALL loader_glTbufferMask3DFX(GLuint mask)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTbufferMask3DFX, "glTbufferMask3DFX");
  if (_driver.glTbufferMask3DFX) {
    _driver.glTbufferMask3DFX(mask);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTbufferMask3DFX)(mask);
}

// GL_AMD_debug_output

static void REGAL_CALL loader_glDebugMessageCallbackAMD(GLDEBUGPROCAMD callback, GLvoid *userParam)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDebugMessageCallbackAMD, "glDebugMessageCallbackAMD");
  if (_driver.glDebugMessageCallbackAMD) {
    _driver.glDebugMessageCallbackAMD(callback, userParam);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDebugMessageCallbackAMD)(callback, userParam);
}

static void REGAL_CALL loader_glDebugMessageEnableAMD(GLenum category, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDebugMessageEnableAMD, "glDebugMessageEnableAMD");
  if (_driver.glDebugMessageEnableAMD) {
    _driver.glDebugMessageEnableAMD(category, severity, count, ids, enabled);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDebugMessageEnableAMD)(category, severity, count, ids, enabled);
}

static void REGAL_CALL loader_glDebugMessageInsertAMD(GLenum category, GLenum severity, GLuint id, GLsizei length, const GLchar *buf)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDebugMessageInsertAMD, "glDebugMessageInsertAMD");
  if (_driver.glDebugMessageInsertAMD) {
    _driver.glDebugMessageInsertAMD(category, severity, id, length, buf);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDebugMessageInsertAMD)(category, severity, id, length, buf);
}

static GLuint REGAL_CALL loader_glGetDebugMessageLogAMD(GLuint count, GLsizei bufsize, GLenum *categories, GLuint *severities, GLuint *ids, GLsizei *lengths, GLchar *message)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetDebugMessageLogAMD, "glGetDebugMessageLogAMD");
  if (_driver.glGetDebugMessageLogAMD) {
    return _driver.glGetDebugMessageLogAMD(count, bufsize, categories, severities, ids, lengths, message);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glGetDebugMessageLogAMD)(count, bufsize, categories, severities, ids, lengths, message);
}

// GL_AMD_draw_buffers_blend

static void REGAL_CALL loader_glBlendEquationIndexedAMD(GLuint buf, GLenum mode)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBlendEquationIndexedAMD, "glBlendEquationIndexedAMD");
  if (_driver.glBlendEquationIndexedAMD) {
    _driver.glBlendEquationIndexedAMD(buf, mode);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBlendEquationIndexedAMD)(buf, mode);
}

static void REGAL_CALL loader_glBlendEquationSeparateIndexedAMD(GLuint buf, GLenum modeRGB, GLenum modeAlpha)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBlendEquationSeparateIndexedAMD, "glBlendEquationSeparateIndexedAMD");
  if (_driver.glBlendEquationSeparateIndexedAMD) {
    _driver.glBlendEquationSeparateIndexedAMD(buf, modeRGB, modeAlpha);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBlendEquationSeparateIndexedAMD)(buf, modeRGB, modeAlpha);
}

static void REGAL_CALL loader_glBlendFuncIndexedAMD(GLuint buf, GLenum src, GLenum dst)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBlendFuncIndexedAMD, "glBlendFuncIndexedAMD");
  if (_driver.glBlendFuncIndexedAMD) {
    _driver.glBlendFuncIndexedAMD(buf, src, dst);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBlendFuncIndexedAMD)(buf, src, dst);
}

static void REGAL_CALL loader_glBlendFuncSeparateIndexedAMD(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBlendFuncSeparateIndexedAMD, "glBlendFuncSeparateIndexedAMD");
  if (_driver.glBlendFuncSeparateIndexedAMD) {
    _driver.glBlendFuncSeparateIndexedAMD(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBlendFuncSeparateIndexedAMD)(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
}

// GL_AMD_multi_draw_indirect

static void REGAL_CALL loader_glMultiDrawArraysIndirectAMD(GLenum mode, const GLvoid *indirect, GLsizei primcount, GLsizei stride)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiDrawArraysIndirectAMD, "glMultiDrawArraysIndirectAMD");
  if (_driver.glMultiDrawArraysIndirectAMD) {
    _driver.glMultiDrawArraysIndirectAMD(mode, indirect, primcount, stride);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiDrawArraysIndirectAMD)(mode, indirect, primcount, stride);
}

static void REGAL_CALL loader_glMultiDrawElementsIndirectAMD(GLenum mode, GLenum type, const GLvoid *indirect, GLsizei primcount, GLsizei stride)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiDrawElementsIndirectAMD, "glMultiDrawElementsIndirectAMD");
  if (_driver.glMultiDrawElementsIndirectAMD) {
    _driver.glMultiDrawElementsIndirectAMD(mode, type, indirect, primcount, stride);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiDrawElementsIndirectAMD)(mode, type, indirect, primcount, stride);
}

// GL_AMD_name_gen_delete

static void REGAL_CALL loader_glDeleteNamesAMD(GLenum identifier, GLuint num, const GLuint *names)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDeleteNamesAMD, "glDeleteNamesAMD");
  if (_driver.glDeleteNamesAMD) {
    _driver.glDeleteNamesAMD(identifier, num, names);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDeleteNamesAMD)(identifier, num, names);
}

static void REGAL_CALL loader_glGenNamesAMD(GLenum identifier, GLuint num, GLuint *names)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGenNamesAMD, "glGenNamesAMD");
  if (_driver.glGenNamesAMD) {
    _driver.glGenNamesAMD(identifier, num, names);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGenNamesAMD)(identifier, num, names);
}

static GLboolean REGAL_CALL loader_glIsNameAMD(GLenum identifier, GLuint name)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIsNameAMD, "glIsNameAMD");
  if (_driver.glIsNameAMD) {
    return _driver.glIsNameAMD(identifier, name);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glIsNameAMD)(identifier, name);
}

// GL_AMD_performance_monitor

static void REGAL_CALL loader_glBeginPerfMonitorAMD(GLuint monitor)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBeginPerfMonitorAMD, "glBeginPerfMonitorAMD");
  if (_driver.glBeginPerfMonitorAMD) {
    _driver.glBeginPerfMonitorAMD(monitor);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBeginPerfMonitorAMD)(monitor);
}

static void REGAL_CALL loader_glDeletePerfMonitorsAMD(GLsizei n, GLuint *monitors)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDeletePerfMonitorsAMD, "glDeletePerfMonitorsAMD");
  if (_driver.glDeletePerfMonitorsAMD) {
    _driver.glDeletePerfMonitorsAMD(n, monitors);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDeletePerfMonitorsAMD)(n, monitors);
}

static void REGAL_CALL loader_glEndPerfMonitorAMD(GLuint monitor)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glEndPerfMonitorAMD, "glEndPerfMonitorAMD");
  if (_driver.glEndPerfMonitorAMD) {
    _driver.glEndPerfMonitorAMD(monitor);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glEndPerfMonitorAMD)(monitor);
}

static void REGAL_CALL loader_glGenPerfMonitorsAMD(GLsizei n, GLuint *monitors)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGenPerfMonitorsAMD, "glGenPerfMonitorsAMD");
  if (_driver.glGenPerfMonitorsAMD) {
    _driver.glGenPerfMonitorsAMD(n, monitors);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGenPerfMonitorsAMD)(n, monitors);
}

static void REGAL_CALL loader_glGetPerfMonitorCounterDataAMD(GLuint monitor, GLenum pname, GLsizei dataSize, GLuint *data, GLint *bytesWritten)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetPerfMonitorCounterDataAMD, "glGetPerfMonitorCounterDataAMD");
  if (_driver.glGetPerfMonitorCounterDataAMD) {
    _driver.glGetPerfMonitorCounterDataAMD(monitor, pname, dataSize, data, bytesWritten);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetPerfMonitorCounterDataAMD)(monitor, pname, dataSize, data, bytesWritten);
}

static void REGAL_CALL loader_glGetPerfMonitorCounterInfoAMD(GLuint group, GLuint counter, GLenum pname, GLvoid *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetPerfMonitorCounterInfoAMD, "glGetPerfMonitorCounterInfoAMD");
  if (_driver.glGetPerfMonitorCounterInfoAMD) {
    _driver.glGetPerfMonitorCounterInfoAMD(group, counter, pname, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetPerfMonitorCounterInfoAMD)(group, counter, pname, data);
}

static void REGAL_CALL loader_glGetPerfMonitorCounterStringAMD(GLuint group, GLuint counter, GLsizei bufSize, GLsizei *length, GLchar *counterString)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetPerfMonitorCounterStringAMD, "glGetPerfMonitorCounterStringAMD");
  if (_driver.glGetPerfMonitorCounterStringAMD) {
    _driver.glGetPerfMonitorCounterStringAMD(group, counter, bufSize, length, counterString);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetPerfMonitorCounterStringAMD)(group, counter, bufSize, length, counterString);
}

static void REGAL_CALL loader_glGetPerfMonitorCountersAMD(GLuint group, GLint *numCounters, GLint *maxActiveCounters, GLsizei countersSize, GLuint *counters)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetPerfMonitorCountersAMD, "glGetPerfMonitorCountersAMD");
  if (_driver.glGetPerfMonitorCountersAMD) {
    _driver.glGetPerfMonitorCountersAMD(group, numCounters, maxActiveCounters, countersSize, counters);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetPerfMonitorCountersAMD)(group, numCounters, maxActiveCounters, countersSize, counters);
}

static void REGAL_CALL loader_glGetPerfMonitorGroupStringAMD(GLuint group, GLsizei bufSize, GLsizei *length, GLchar *groupString)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetPerfMonitorGroupStringAMD, "glGetPerfMonitorGroupStringAMD");
  if (_driver.glGetPerfMonitorGroupStringAMD) {
    _driver.glGetPerfMonitorGroupStringAMD(group, bufSize, length, groupString);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetPerfMonitorGroupStringAMD)(group, bufSize, length, groupString);
}

static void REGAL_CALL loader_glGetPerfMonitorGroupsAMD(GLint *numGroups, GLsizei groupsSize, GLuint *groups)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetPerfMonitorGroupsAMD, "glGetPerfMonitorGroupsAMD");
  if (_driver.glGetPerfMonitorGroupsAMD) {
    _driver.glGetPerfMonitorGroupsAMD(numGroups, groupsSize, groups);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetPerfMonitorGroupsAMD)(numGroups, groupsSize, groups);
}

static void REGAL_CALL loader_glSelectPerfMonitorCountersAMD(GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint *counterList)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSelectPerfMonitorCountersAMD, "glSelectPerfMonitorCountersAMD");
  if (_driver.glSelectPerfMonitorCountersAMD) {
    _driver.glSelectPerfMonitorCountersAMD(monitor, enable, group, numCounters, counterList);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSelectPerfMonitorCountersAMD)(monitor, enable, group, numCounters, counterList);
}

// GL_AMD_sample_positions

static void REGAL_CALL loader_glSetMultisamplefvAMD(GLenum pname, GLuint index, const GLfloat *val)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSetMultisamplefvAMD, "glSetMultisamplefvAMD");
  if (_driver.glSetMultisamplefvAMD) {
    _driver.glSetMultisamplefvAMD(pname, index, val);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSetMultisamplefvAMD)(pname, index, val);
}

// GL_AMD_stencil_operation_extended

static void REGAL_CALL loader_glStencilOpValueAMD(GLenum face, GLuint value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glStencilOpValueAMD, "glStencilOpValueAMD");
  if (_driver.glStencilOpValueAMD) {
    _driver.glStencilOpValueAMD(face, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glStencilOpValueAMD)(face, value);
}

// GL_AMD_vertex_shader_tessellator

static void REGAL_CALL loader_glTessellationFactorAMD(GLfloat factor)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTessellationFactorAMD, "glTessellationFactorAMD");
  if (_driver.glTessellationFactorAMD) {
    _driver.glTessellationFactorAMD(factor);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTessellationFactorAMD)(factor);
}

static void REGAL_CALL loader_glTessellationModeAMD(GLenum mode)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTessellationModeAMD, "glTessellationModeAMD");
  if (_driver.glTessellationModeAMD) {
    _driver.glTessellationModeAMD(mode);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTessellationModeAMD)(mode);
}

// GL_ANGLE_framebuffer_blit

static void REGAL_CALL loader_glBlitFramebufferANGLE(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBlitFramebufferANGLE, "glBlitFramebufferANGLE");
  if (_driver.glBlitFramebufferANGLE) {
    _driver.glBlitFramebufferANGLE(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBlitFramebufferANGLE)(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
}

// GL_ANGLE_framebuffer_multisample

static void REGAL_CALL loader_glRenderbufferStorageMultisampleANGLE(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glRenderbufferStorageMultisampleANGLE, "glRenderbufferStorageMultisampleANGLE");
  if (_driver.glRenderbufferStorageMultisampleANGLE) {
    _driver.glRenderbufferStorageMultisampleANGLE(target, samples, internalformat, width, height);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glRenderbufferStorageMultisampleANGLE)(target, samples, internalformat, width, height);
}

// GL_ANGLE_instanced_arrays

static void REGAL_CALL loader_glDrawArraysInstancedANGLE(GLenum mode, GLint first, GLsizei count, GLsizei primcount)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDrawArraysInstancedANGLE, "glDrawArraysInstancedANGLE");
  if (_driver.glDrawArraysInstancedANGLE) {
    _driver.glDrawArraysInstancedANGLE(mode, first, count, primcount);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDrawArraysInstancedANGLE)(mode, first, count, primcount);
}

static void REGAL_CALL loader_glDrawElementsInstancedANGLE(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDrawElementsInstancedANGLE, "glDrawElementsInstancedANGLE");
  if (_driver.glDrawElementsInstancedANGLE) {
    _driver.glDrawElementsInstancedANGLE(mode, count, type, indices, primcount);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDrawElementsInstancedANGLE)(mode, count, type, indices, primcount);
}

static void REGAL_CALL loader_glVertexAttribDivisorANGLE(GLuint index, GLuint divisor)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribDivisorANGLE, "glVertexAttribDivisorANGLE");
  if (_driver.glVertexAttribDivisorANGLE) {
    _driver.glVertexAttribDivisorANGLE(index, divisor);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribDivisorANGLE)(index, divisor);
}

// GL_ANGLE_translated_shader_source

static void REGAL_CALL loader_glGetTranslatedShaderSourceANGLE(GLuint shader, GLsizei bufsize, GLsizei *length, GLchar *source)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetTranslatedShaderSourceANGLE, "glGetTranslatedShaderSourceANGLE");
  if (_driver.glGetTranslatedShaderSourceANGLE) {
    _driver.glGetTranslatedShaderSourceANGLE(shader, bufsize, length, source);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetTranslatedShaderSourceANGLE)(shader, bufsize, length, source);
}

// GL_APPLE_copy_texture_levels

static void REGAL_CALL loader_glCopyTextureLevelsAPPLE(GLuint destinationTexture, GLuint sourceTexture, GLint sourceBaseLevel, GLsizei sourceLevelCount)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCopyTextureLevelsAPPLE, "glCopyTextureLevelsAPPLE");
  if (_driver.glCopyTextureLevelsAPPLE) {
    _driver.glCopyTextureLevelsAPPLE(destinationTexture, sourceTexture, sourceBaseLevel, sourceLevelCount);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCopyTextureLevelsAPPLE)(destinationTexture, sourceTexture, sourceBaseLevel, sourceLevelCount);
}

// GL_APPLE_element_array

static void REGAL_CALL loader_glDrawElementArrayAPPLE(GLenum mode, GLint first, GLsizei count)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDrawElementArrayAPPLE, "glDrawElementArrayAPPLE");
  if (_driver.glDrawElementArrayAPPLE) {
    _driver.glDrawElementArrayAPPLE(mode, first, count);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDrawElementArrayAPPLE)(mode, first, count);
}

static void REGAL_CALL loader_glDrawRangeElementArrayAPPLE(GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDrawRangeElementArrayAPPLE, "glDrawRangeElementArrayAPPLE");
  if (_driver.glDrawRangeElementArrayAPPLE) {
    _driver.glDrawRangeElementArrayAPPLE(mode, start, end, first, count);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDrawRangeElementArrayAPPLE)(mode, start, end, first, count);
}

static void REGAL_CALL loader_glElementPointerAPPLE(GLenum type, const GLvoid *pointer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glElementPointerAPPLE, "glElementPointerAPPLE");
  if (_driver.glElementPointerAPPLE) {
    _driver.glElementPointerAPPLE(type, pointer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glElementPointerAPPLE)(type, pointer);
}

static void REGAL_CALL loader_glMultiDrawElementArrayAPPLE(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiDrawElementArrayAPPLE, "glMultiDrawElementArrayAPPLE");
  if (_driver.glMultiDrawElementArrayAPPLE) {
    _driver.glMultiDrawElementArrayAPPLE(mode, first, count, primcount);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiDrawElementArrayAPPLE)(mode, first, count, primcount);
}

static void REGAL_CALL loader_glMultiDrawRangeElementArrayAPPLE(GLenum mode, GLuint start, GLuint end, const GLint *first, const GLsizei *count, GLsizei primcount)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiDrawRangeElementArrayAPPLE, "glMultiDrawRangeElementArrayAPPLE");
  if (_driver.glMultiDrawRangeElementArrayAPPLE) {
    _driver.glMultiDrawRangeElementArrayAPPLE(mode, start, end, first, count, primcount);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiDrawRangeElementArrayAPPLE)(mode, start, end, first, count, primcount);
}

// GL_APPLE_fence

static void REGAL_CALL loader_glDeleteFencesAPPLE(GLsizei n, const GLuint *fences)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDeleteFencesAPPLE, "glDeleteFencesAPPLE");
  if (_driver.glDeleteFencesAPPLE) {
    _driver.glDeleteFencesAPPLE(n, fences);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDeleteFencesAPPLE)(n, fences);
}

static void REGAL_CALL loader_glFinishFenceAPPLE(GLuint fence)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFinishFenceAPPLE, "glFinishFenceAPPLE");
  if (_driver.glFinishFenceAPPLE) {
    _driver.glFinishFenceAPPLE(fence);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFinishFenceAPPLE)(fence);
}

static void REGAL_CALL loader_glFinishObjectAPPLE(GLenum object, GLint name)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFinishObjectAPPLE, "glFinishObjectAPPLE");
  if (_driver.glFinishObjectAPPLE) {
    _driver.glFinishObjectAPPLE(object, name);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFinishObjectAPPLE)(object, name);
}

static void REGAL_CALL loader_glGenFencesAPPLE(GLsizei n, GLuint *fences)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGenFencesAPPLE, "glGenFencesAPPLE");
  if (_driver.glGenFencesAPPLE) {
    _driver.glGenFencesAPPLE(n, fences);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGenFencesAPPLE)(n, fences);
}

static GLboolean REGAL_CALL loader_glIsFenceAPPLE(GLuint fence)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIsFenceAPPLE, "glIsFenceAPPLE");
  if (_driver.glIsFenceAPPLE) {
    return _driver.glIsFenceAPPLE(fence);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glIsFenceAPPLE)(fence);
}

static void REGAL_CALL loader_glSetFenceAPPLE(GLuint fence)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSetFenceAPPLE, "glSetFenceAPPLE");
  if (_driver.glSetFenceAPPLE) {
    _driver.glSetFenceAPPLE(fence);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSetFenceAPPLE)(fence);
}

static GLboolean REGAL_CALL loader_glTestFenceAPPLE(GLuint fence)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTestFenceAPPLE, "glTestFenceAPPLE");
  if (_driver.glTestFenceAPPLE) {
    return _driver.glTestFenceAPPLE(fence);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glTestFenceAPPLE)(fence);
}

static GLboolean REGAL_CALL loader_glTestObjectAPPLE(GLenum object, GLuint name)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTestObjectAPPLE, "glTestObjectAPPLE");
  if (_driver.glTestObjectAPPLE) {
    return _driver.glTestObjectAPPLE(object, name);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glTestObjectAPPLE)(object, name);
}

// GL_APPLE_flush_buffer_range

static void REGAL_CALL loader_glBufferParameteriAPPLE(GLenum target, GLenum pname, GLint param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBufferParameteriAPPLE, "glBufferParameteriAPPLE");
  if (_driver.glBufferParameteriAPPLE) {
    _driver.glBufferParameteriAPPLE(target, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBufferParameteriAPPLE)(target, pname, param);
}

static void REGAL_CALL loader_glFlushMappedBufferRangeAPPLE(GLenum target, GLintptr offset, GLsizeiptr size)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFlushMappedBufferRangeAPPLE, "glFlushMappedBufferRangeAPPLE");
  if (_driver.glFlushMappedBufferRangeAPPLE) {
    _driver.glFlushMappedBufferRangeAPPLE(target, offset, size);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFlushMappedBufferRangeAPPLE)(target, offset, size);
}

// GL_APPLE_flush_render

static void REGAL_CALL loader_glFinishRenderAPPLE(void)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFinishRenderAPPLE, "glFinishRenderAPPLE");
  if (_driver.glFinishRenderAPPLE) {
    _driver.glFinishRenderAPPLE();
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFinishRenderAPPLE)();
}

static void REGAL_CALL loader_glFlushRenderAPPLE(void)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFlushRenderAPPLE, "glFlushRenderAPPLE");
  if (_driver.glFlushRenderAPPLE) {
    _driver.glFlushRenderAPPLE();
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFlushRenderAPPLE)();
}

static void REGAL_CALL loader_glSwapAPPLE(void)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSwapAPPLE, "glSwapAPPLE");
  if (_driver.glSwapAPPLE) {
    _driver.glSwapAPPLE();
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSwapAPPLE)();
}

// GL_APPLE_framebuffer_multisample

static void REGAL_CALL loader_glRenderbufferStorageMultisampleAPPLE(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glRenderbufferStorageMultisampleAPPLE, "glRenderbufferStorageMultisampleAPPLE");
  if (_driver.glRenderbufferStorageMultisampleAPPLE) {
    _driver.glRenderbufferStorageMultisampleAPPLE(target, samples, internalformat, width, height);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glRenderbufferStorageMultisampleAPPLE)(target, samples, internalformat, width, height);
}

static void REGAL_CALL loader_glResolveMultisampleFramebufferAPPLE(void)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glResolveMultisampleFramebufferAPPLE, "glResolveMultisampleFramebufferAPPLE");
  if (_driver.glResolveMultisampleFramebufferAPPLE) {
    _driver.glResolveMultisampleFramebufferAPPLE();
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glResolveMultisampleFramebufferAPPLE)();
}

// GL_APPLE_object_purgeable

static void REGAL_CALL loader_glGetObjectParameterivAPPLE(GLenum objectType, GLuint name, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetObjectParameterivAPPLE, "glGetObjectParameterivAPPLE");
  if (_driver.glGetObjectParameterivAPPLE) {
    _driver.glGetObjectParameterivAPPLE(objectType, name, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetObjectParameterivAPPLE)(objectType, name, pname, params);
}

static GLenum REGAL_CALL loader_glObjectPurgeableAPPLE(GLenum objectType, GLuint name, GLenum option)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glObjectPurgeableAPPLE, "glObjectPurgeableAPPLE");
  if (_driver.glObjectPurgeableAPPLE) {
    return _driver.glObjectPurgeableAPPLE(objectType, name, option);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glObjectPurgeableAPPLE)(objectType, name, option);
}

static GLenum REGAL_CALL loader_glObjectUnpurgeableAPPLE(GLenum objectType, GLuint name, GLenum option)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glObjectUnpurgeableAPPLE, "glObjectUnpurgeableAPPLE");
  if (_driver.glObjectUnpurgeableAPPLE) {
    return _driver.glObjectUnpurgeableAPPLE(objectType, name, option);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glObjectUnpurgeableAPPLE)(objectType, name, option);
}

// GL_APPLE_sync

static GLenum REGAL_CALL loader_glClientWaitSyncAPPLE(GLsync sync, GLbitfield flags, GLuint64 timeout)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glClientWaitSyncAPPLE, "glClientWaitSyncAPPLE");
  if (_driver.glClientWaitSyncAPPLE) {
    return _driver.glClientWaitSyncAPPLE(sync, flags, timeout);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glClientWaitSyncAPPLE)(sync, flags, timeout);
}

static void REGAL_CALL loader_glDeleteSyncAPPLE(GLsync sync)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDeleteSyncAPPLE, "glDeleteSyncAPPLE");
  if (_driver.glDeleteSyncAPPLE) {
    _driver.glDeleteSyncAPPLE(sync);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDeleteSyncAPPLE)(sync);
}

static GLsync REGAL_CALL loader_glFenceSyncAPPLE(GLenum condition, GLbitfield flags)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFenceSyncAPPLE, "glFenceSyncAPPLE");
  if (_driver.glFenceSyncAPPLE) {
    return _driver.glFenceSyncAPPLE(condition, flags);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glFenceSyncAPPLE)(condition, flags);
}

static void REGAL_CALL loader_glGetInteger64vAPPLE(GLenum pname, GLint64 *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetInteger64vAPPLE, "glGetInteger64vAPPLE");
  if (_driver.glGetInteger64vAPPLE) {
    _driver.glGetInteger64vAPPLE(pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetInteger64vAPPLE)(pname, params);
}

static void REGAL_CALL loader_glGetSyncivAPPLE(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetSyncivAPPLE, "glGetSyncivAPPLE");
  if (_driver.glGetSyncivAPPLE) {
    _driver.glGetSyncivAPPLE(sync, pname, bufSize, length, values);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetSyncivAPPLE)(sync, pname, bufSize, length, values);
}

static GLboolean REGAL_CALL loader_glIsSyncAPPLE(GLsync sync)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIsSyncAPPLE, "glIsSyncAPPLE");
  if (_driver.glIsSyncAPPLE) {
    return _driver.glIsSyncAPPLE(sync);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glIsSyncAPPLE)(sync);
}

static void REGAL_CALL loader_glWaitSyncAPPLE(GLsync sync, GLbitfield flags, GLuint64 timeout)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWaitSyncAPPLE, "glWaitSyncAPPLE");
  if (_driver.glWaitSyncAPPLE) {
    _driver.glWaitSyncAPPLE(sync, flags, timeout);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWaitSyncAPPLE)(sync, flags, timeout);
}

// GL_APPLE_texture_range

static void REGAL_CALL loader_glGetTexParameterPointervAPPLE(GLenum target, GLenum pname, GLvoid **params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetTexParameterPointervAPPLE, "glGetTexParameterPointervAPPLE");
  if (_driver.glGetTexParameterPointervAPPLE) {
    _driver.glGetTexParameterPointervAPPLE(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetTexParameterPointervAPPLE)(target, pname, params);
}

static void REGAL_CALL loader_glTextureRangeAPPLE(GLenum target, GLsizei length, GLvoid *pointer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTextureRangeAPPLE, "glTextureRangeAPPLE");
  if (_driver.glTextureRangeAPPLE) {
    _driver.glTextureRangeAPPLE(target, length, pointer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTextureRangeAPPLE)(target, length, pointer);
}

// GL_APPLE_vertex_array_object

static void REGAL_CALL loader_glBindVertexArrayAPPLE(GLuint array)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBindVertexArrayAPPLE, "glBindVertexArrayAPPLE");
  if (_driver.glBindVertexArrayAPPLE) {
    _driver.glBindVertexArrayAPPLE(array);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBindVertexArrayAPPLE)(array);
}

static void REGAL_CALL loader_glDeleteVertexArraysAPPLE(GLsizei n, const GLuint *arrays)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDeleteVertexArraysAPPLE, "glDeleteVertexArraysAPPLE");
  if (_driver.glDeleteVertexArraysAPPLE) {
    _driver.glDeleteVertexArraysAPPLE(n, arrays);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDeleteVertexArraysAPPLE)(n, arrays);
}

static void REGAL_CALL loader_glGenVertexArraysAPPLE(GLsizei n, const GLuint *arrays)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGenVertexArraysAPPLE, "glGenVertexArraysAPPLE");
  if (_driver.glGenVertexArraysAPPLE) {
    _driver.glGenVertexArraysAPPLE(n, arrays);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGenVertexArraysAPPLE)(n, arrays);
}

static GLboolean REGAL_CALL loader_glIsVertexArrayAPPLE(GLuint array)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIsVertexArrayAPPLE, "glIsVertexArrayAPPLE");
  if (_driver.glIsVertexArrayAPPLE) {
    return _driver.glIsVertexArrayAPPLE(array);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glIsVertexArrayAPPLE)(array);
}

// GL_APPLE_vertex_array_range

static void REGAL_CALL loader_glFlushVertexArrayRangeAPPLE(GLsizei length, GLvoid *pointer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFlushVertexArrayRangeAPPLE, "glFlushVertexArrayRangeAPPLE");
  if (_driver.glFlushVertexArrayRangeAPPLE) {
    _driver.glFlushVertexArrayRangeAPPLE(length, pointer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFlushVertexArrayRangeAPPLE)(length, pointer);
}

static void REGAL_CALL loader_glVertexArrayParameteriAPPLE(GLenum pname, GLint param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexArrayParameteriAPPLE, "glVertexArrayParameteriAPPLE");
  if (_driver.glVertexArrayParameteriAPPLE) {
    _driver.glVertexArrayParameteriAPPLE(pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexArrayParameteriAPPLE)(pname, param);
}

static void REGAL_CALL loader_glVertexArrayRangeAPPLE(GLsizei length, GLvoid *pointer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexArrayRangeAPPLE, "glVertexArrayRangeAPPLE");
  if (_driver.glVertexArrayRangeAPPLE) {
    _driver.glVertexArrayRangeAPPLE(length, pointer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexArrayRangeAPPLE)(length, pointer);
}

// GL_APPLE_vertex_program_evaluators

static void REGAL_CALL loader_glDisableVertexAttribAPPLE(GLuint index, GLenum pname)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDisableVertexAttribAPPLE, "glDisableVertexAttribAPPLE");
  if (_driver.glDisableVertexAttribAPPLE) {
    _driver.glDisableVertexAttribAPPLE(index, pname);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDisableVertexAttribAPPLE)(index, pname);
}

static void REGAL_CALL loader_glEnableVertexAttribAPPLE(GLuint index, GLenum pname)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glEnableVertexAttribAPPLE, "glEnableVertexAttribAPPLE");
  if (_driver.glEnableVertexAttribAPPLE) {
    _driver.glEnableVertexAttribAPPLE(index, pname);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glEnableVertexAttribAPPLE)(index, pname);
}

static GLboolean REGAL_CALL loader_glIsVertexAttribEnabledAPPLE(GLuint index, GLenum pname)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIsVertexAttribEnabledAPPLE, "glIsVertexAttribEnabledAPPLE");
  if (_driver.glIsVertexAttribEnabledAPPLE) {
    return _driver.glIsVertexAttribEnabledAPPLE(index, pname);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glIsVertexAttribEnabledAPPLE)(index, pname);
}

static void REGAL_CALL loader_glMapVertexAttrib1dAPPLE(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMapVertexAttrib1dAPPLE, "glMapVertexAttrib1dAPPLE");
  if (_driver.glMapVertexAttrib1dAPPLE) {
    _driver.glMapVertexAttrib1dAPPLE(index, size, u1, u2, stride, order, points);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMapVertexAttrib1dAPPLE)(index, size, u1, u2, stride, order, points);
}

static void REGAL_CALL loader_glMapVertexAttrib1fAPPLE(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMapVertexAttrib1fAPPLE, "glMapVertexAttrib1fAPPLE");
  if (_driver.glMapVertexAttrib1fAPPLE) {
    _driver.glMapVertexAttrib1fAPPLE(index, size, u1, u2, stride, order, points);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMapVertexAttrib1fAPPLE)(index, size, u1, u2, stride, order, points);
}

static void REGAL_CALL loader_glMapVertexAttrib2dAPPLE(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMapVertexAttrib2dAPPLE, "glMapVertexAttrib2dAPPLE");
  if (_driver.glMapVertexAttrib2dAPPLE) {
    _driver.glMapVertexAttrib2dAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMapVertexAttrib2dAPPLE)(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
}

static void REGAL_CALL loader_glMapVertexAttrib2fAPPLE(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMapVertexAttrib2fAPPLE, "glMapVertexAttrib2fAPPLE");
  if (_driver.glMapVertexAttrib2fAPPLE) {
    _driver.glMapVertexAttrib2fAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMapVertexAttrib2fAPPLE)(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
}

// GL_ARB_ES2_compatibility

static void REGAL_CALL loader_glClearDepthf(GLclampf d)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glClearDepthf, "glClearDepthf");
  if (_driver.glClearDepthf) {
    _driver.glClearDepthf(d);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glClearDepthf)(d);
}

static void REGAL_CALL loader_glDepthRangef(GLclampf n, GLclampf f)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDepthRangef, "glDepthRangef");
  if (_driver.glDepthRangef) {
    _driver.glDepthRangef(n, f);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDepthRangef)(n, f);
}

static void REGAL_CALL loader_glGetShaderPrecisionFormat(GLenum shadertype, GLenum precisiontype, GLint *range, GLint *precision)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetShaderPrecisionFormat, "glGetShaderPrecisionFormat");
  if (_driver.glGetShaderPrecisionFormat) {
    _driver.glGetShaderPrecisionFormat(shadertype, precisiontype, range, precision);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetShaderPrecisionFormat)(shadertype, precisiontype, range, precision);
}

static void REGAL_CALL loader_glReleaseShaderCompiler(void)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glReleaseShaderCompiler, "glReleaseShaderCompiler");
  if (_driver.glReleaseShaderCompiler) {
    _driver.glReleaseShaderCompiler();
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glReleaseShaderCompiler)();
}

static void REGAL_CALL loader_glShaderBinary(GLsizei count, const GLuint *shaders, GLenum binaryformat, const GLvoid *binary, GLsizei length)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glShaderBinary, "glShaderBinary");
  if (_driver.glShaderBinary) {
    _driver.glShaderBinary(count, shaders, binaryformat, binary, length);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glShaderBinary)(count, shaders, binaryformat, binary, length);
}

// GL_ARB_base_instance

static void REGAL_CALL loader_glDrawArraysInstancedBaseInstance(GLenum mode, GLint first, GLsizei count, GLsizei primcount, GLuint baseinstance)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDrawArraysInstancedBaseInstance, "glDrawArraysInstancedBaseInstance");
  if (_driver.glDrawArraysInstancedBaseInstance) {
    _driver.glDrawArraysInstancedBaseInstance(mode, first, count, primcount, baseinstance);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDrawArraysInstancedBaseInstance)(mode, first, count, primcount, baseinstance);
}

static void REGAL_CALL loader_glDrawElementsInstancedBaseInstance(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount, GLuint baseinstance)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDrawElementsInstancedBaseInstance, "glDrawElementsInstancedBaseInstance");
  if (_driver.glDrawElementsInstancedBaseInstance) {
    _driver.glDrawElementsInstancedBaseInstance(mode, count, type, indices, primcount, baseinstance);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDrawElementsInstancedBaseInstance)(mode, count, type, indices, primcount, baseinstance);
}

static void REGAL_CALL loader_glDrawElementsInstancedBaseVertexBaseInstance(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount, GLint basevertex, GLuint baseinstance)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDrawElementsInstancedBaseVertexBaseInstance, "glDrawElementsInstancedBaseVertexBaseInstance");
  if (_driver.glDrawElementsInstancedBaseVertexBaseInstance) {
    _driver.glDrawElementsInstancedBaseVertexBaseInstance(mode, count, type, indices, primcount, basevertex, baseinstance);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDrawElementsInstancedBaseVertexBaseInstance)(mode, count, type, indices, primcount, basevertex, baseinstance);
}

// GL_ARB_blend_func_extended

static void REGAL_CALL loader_glBindFragDataLocationIndexed(GLuint program, GLuint colorNumber, GLuint index, const GLchar *name)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBindFragDataLocationIndexed, "glBindFragDataLocationIndexed");
  if (_driver.glBindFragDataLocationIndexed) {
    _driver.glBindFragDataLocationIndexed(program, colorNumber, index, name);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBindFragDataLocationIndexed)(program, colorNumber, index, name);
}

static GLint REGAL_CALL loader_glGetFragDataIndex(GLuint program, const GLchar *name)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetFragDataIndex, "glGetFragDataIndex");
  if (_driver.glGetFragDataIndex) {
    return _driver.glGetFragDataIndex(program, name);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glGetFragDataIndex)(program, name);
}

// GL_ARB_cl_event

static GLsync REGAL_CALL loader_glCreateSyncFromCLeventARB(cl_context context, cl_event event, GLbitfield flags)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCreateSyncFromCLeventARB, "glCreateSyncFromCLeventARB");
  if (_driver.glCreateSyncFromCLeventARB) {
    return _driver.glCreateSyncFromCLeventARB(context, event, flags);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glCreateSyncFromCLeventARB)(context, event, flags);
}

// GL_ARB_clear_buffer_object

static void REGAL_CALL loader_glClearBufferData(GLenum target, GLenum internalformat, GLenum format, GLenum type, const GLvoid *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glClearBufferData, "glClearBufferData");
  if (_driver.glClearBufferData) {
    _driver.glClearBufferData(target, internalformat, format, type, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glClearBufferData)(target, internalformat, format, type, data);
}

static void REGAL_CALL loader_glClearBufferSubData(GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const GLvoid *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glClearBufferSubData, "glClearBufferSubData");
  if (_driver.glClearBufferSubData) {
    _driver.glClearBufferSubData(target, internalformat, offset, size, format, type, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glClearBufferSubData)(target, internalformat, offset, size, format, type, data);
}

static void REGAL_CALL loader_glClearNamedBufferDataEXT(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const GLvoid *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glClearNamedBufferDataEXT, "glClearNamedBufferDataEXT");
  if (_driver.glClearNamedBufferDataEXT) {
    _driver.glClearNamedBufferDataEXT(buffer, internalformat, format, type, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glClearNamedBufferDataEXT)(buffer, internalformat, format, type, data);
}

static void REGAL_CALL loader_glClearNamedBufferSubDataEXT(GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const GLvoid *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glClearNamedBufferSubDataEXT, "glClearNamedBufferSubDataEXT");
  if (_driver.glClearNamedBufferSubDataEXT) {
    _driver.glClearNamedBufferSubDataEXT(buffer, internalformat, offset, size, format, type, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glClearNamedBufferSubDataEXT)(buffer, internalformat, offset, size, format, type, data);
}

// GL_ARB_color_buffer_float

static void REGAL_CALL loader_glClampColorARB(GLenum target, GLenum clamp)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glClampColorARB, "glClampColorARB");
  if (_driver.glClampColorARB) {
    _driver.glClampColorARB(target, clamp);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glClampColorARB)(target, clamp);
}

// GL_ARB_compute_shader

static void REGAL_CALL loader_glDispatchCompute(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDispatchCompute, "glDispatchCompute");
  if (_driver.glDispatchCompute) {
    _driver.glDispatchCompute(num_groups_x, num_groups_y, num_groups_z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDispatchCompute)(num_groups_x, num_groups_y, num_groups_z);
}

static void REGAL_CALL loader_glDispatchComputeIndirect(GLintptr indirect)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDispatchComputeIndirect, "glDispatchComputeIndirect");
  if (_driver.glDispatchComputeIndirect) {
    _driver.glDispatchComputeIndirect(indirect);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDispatchComputeIndirect)(indirect);
}

// GL_ARB_copy_buffer

static void REGAL_CALL loader_glCopyBufferSubData(GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCopyBufferSubData, "glCopyBufferSubData");
  if (_driver.glCopyBufferSubData) {
    _driver.glCopyBufferSubData(readtarget, writetarget, readoffset, writeoffset, size);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCopyBufferSubData)(readtarget, writetarget, readoffset, writeoffset, size);
}

// GL_ARB_copy_image

static void REGAL_CALL loader_glCopyImageSubData(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCopyImageSubData, "glCopyImageSubData");
  if (_driver.glCopyImageSubData) {
    _driver.glCopyImageSubData(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCopyImageSubData)(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
}

// GL_ARB_debug_output

static void REGAL_CALL loader_glDebugMessageCallbackARB(GLDEBUGPROCARB callback, GLvoid *userParam)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDebugMessageCallbackARB, "glDebugMessageCallbackARB");
  if (_driver.glDebugMessageCallbackARB) {
    _driver.glDebugMessageCallbackARB(callback, userParam);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDebugMessageCallbackARB)(callback, userParam);
}

static void REGAL_CALL loader_glDebugMessageControlARB(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDebugMessageControlARB, "glDebugMessageControlARB");
  if (_driver.glDebugMessageControlARB) {
    _driver.glDebugMessageControlARB(source, type, severity, count, ids, enabled);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDebugMessageControlARB)(source, type, severity, count, ids, enabled);
}

static void REGAL_CALL loader_glDebugMessageInsertARB(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDebugMessageInsertARB, "glDebugMessageInsertARB");
  if (_driver.glDebugMessageInsertARB) {
    _driver.glDebugMessageInsertARB(source, type, id, severity, length, buf);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDebugMessageInsertARB)(source, type, id, severity, length, buf);
}

static GLuint REGAL_CALL loader_glGetDebugMessageLogARB(GLuint count, GLsizei bufsize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetDebugMessageLogARB, "glGetDebugMessageLogARB");
  if (_driver.glGetDebugMessageLogARB) {
    return _driver.glGetDebugMessageLogARB(count, bufsize, sources, types, ids, severities, lengths, messageLog);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glGetDebugMessageLogARB)(count, bufsize, sources, types, ids, severities, lengths, messageLog);
}

// GL_ARB_draw_buffers

static void REGAL_CALL loader_glDrawBuffersARB(GLsizei n, const GLenum *bufs)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDrawBuffersARB, "glDrawBuffersARB");
  if (_driver.glDrawBuffersARB) {
    _driver.glDrawBuffersARB(n, bufs);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDrawBuffersARB)(n, bufs);
}

// GL_ARB_draw_buffers_blend

static void REGAL_CALL loader_glBlendEquationSeparateiARB(GLuint buf, GLenum modeRGB, GLenum modeAlpha)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBlendEquationSeparateiARB, "glBlendEquationSeparateiARB");
  if (_driver.glBlendEquationSeparateiARB) {
    _driver.glBlendEquationSeparateiARB(buf, modeRGB, modeAlpha);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBlendEquationSeparateiARB)(buf, modeRGB, modeAlpha);
}

static void REGAL_CALL loader_glBlendEquationiARB(GLuint buf, GLenum mode)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBlendEquationiARB, "glBlendEquationiARB");
  if (_driver.glBlendEquationiARB) {
    _driver.glBlendEquationiARB(buf, mode);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBlendEquationiARB)(buf, mode);
}

static void REGAL_CALL loader_glBlendFuncSeparateiARB(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBlendFuncSeparateiARB, "glBlendFuncSeparateiARB");
  if (_driver.glBlendFuncSeparateiARB) {
    _driver.glBlendFuncSeparateiARB(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBlendFuncSeparateiARB)(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
}

static void REGAL_CALL loader_glBlendFunciARB(GLuint buf, GLenum src, GLenum dst)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBlendFunciARB, "glBlendFunciARB");
  if (_driver.glBlendFunciARB) {
    _driver.glBlendFunciARB(buf, src, dst);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBlendFunciARB)(buf, src, dst);
}

// GL_ARB_draw_elements_base_vertex

static void REGAL_CALL loader_glDrawElementsBaseVertex(GLenum mode, GLsizei count, GLenum type, GLvoid *indices, GLint basevertex)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDrawElementsBaseVertex, "glDrawElementsBaseVertex");
  if (_driver.glDrawElementsBaseVertex) {
    _driver.glDrawElementsBaseVertex(mode, count, type, indices, basevertex);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDrawElementsBaseVertex)(mode, count, type, indices, basevertex);
}

static void REGAL_CALL loader_glDrawElementsInstancedBaseVertex(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount, GLint basevertex)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDrawElementsInstancedBaseVertex, "glDrawElementsInstancedBaseVertex");
  if (_driver.glDrawElementsInstancedBaseVertex) {
    _driver.glDrawElementsInstancedBaseVertex(mode, count, type, indices, primcount, basevertex);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDrawElementsInstancedBaseVertex)(mode, count, type, indices, primcount, basevertex);
}

static void REGAL_CALL loader_glDrawRangeElementsBaseVertex(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, GLvoid *indices, GLint basevertex)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDrawRangeElementsBaseVertex, "glDrawRangeElementsBaseVertex");
  if (_driver.glDrawRangeElementsBaseVertex) {
    _driver.glDrawRangeElementsBaseVertex(mode, start, end, count, type, indices, basevertex);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDrawRangeElementsBaseVertex)(mode, start, end, count, type, indices, basevertex);
}

static void REGAL_CALL loader_glMultiDrawElementsBaseVertex(GLenum mode, GLsizei *count, GLenum type, GLvoid **indices, GLsizei primcount, GLint *basevertex)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiDrawElementsBaseVertex, "glMultiDrawElementsBaseVertex");
  if (_driver.glMultiDrawElementsBaseVertex) {
    _driver.glMultiDrawElementsBaseVertex(mode, count, type, indices, primcount, basevertex);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiDrawElementsBaseVertex)(mode, count, type, indices, primcount, basevertex);
}

// GL_ARB_draw_indirect

static void REGAL_CALL loader_glDrawArraysIndirect(GLenum mode, const GLvoid *indirect)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDrawArraysIndirect, "glDrawArraysIndirect");
  if (_driver.glDrawArraysIndirect) {
    _driver.glDrawArraysIndirect(mode, indirect);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDrawArraysIndirect)(mode, indirect);
}

static void REGAL_CALL loader_glDrawElementsIndirect(GLenum mode, GLenum type, const GLvoid *indirect)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDrawElementsIndirect, "glDrawElementsIndirect");
  if (_driver.glDrawElementsIndirect) {
    _driver.glDrawElementsIndirect(mode, type, indirect);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDrawElementsIndirect)(mode, type, indirect);
}

// GL_ARB_draw_instanced

static void REGAL_CALL loader_glDrawArraysInstancedARB(GLenum mode, GLint start, GLsizei count, GLsizei primcount)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDrawArraysInstancedARB, "glDrawArraysInstancedARB");
  if (_driver.glDrawArraysInstancedARB) {
    _driver.glDrawArraysInstancedARB(mode, start, count, primcount);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDrawArraysInstancedARB)(mode, start, count, primcount);
}

static void REGAL_CALL loader_glDrawElementsInstancedARB(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDrawElementsInstancedARB, "glDrawElementsInstancedARB");
  if (_driver.glDrawElementsInstancedARB) {
    _driver.glDrawElementsInstancedARB(mode, count, type, indices, primcount);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDrawElementsInstancedARB)(mode, count, type, indices, primcount);
}

// GL_ARB_framebuffer_no_attachments

static void REGAL_CALL loader_glFramebufferParameteri(GLenum target, GLenum pname, GLint param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFramebufferParameteri, "glFramebufferParameteri");
  if (_driver.glFramebufferParameteri) {
    _driver.glFramebufferParameteri(target, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFramebufferParameteri)(target, pname, param);
}

static void REGAL_CALL loader_glGetFramebufferParameteriv(GLenum target, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetFramebufferParameteriv, "glGetFramebufferParameteriv");
  if (_driver.glGetFramebufferParameteriv) {
    _driver.glGetFramebufferParameteriv(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetFramebufferParameteriv)(target, pname, params);
}

static void REGAL_CALL loader_glGetNamedFramebufferParameterivEXT(GLuint framebuffer, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetNamedFramebufferParameterivEXT, "glGetNamedFramebufferParameterivEXT");
  if (_driver.glGetNamedFramebufferParameterivEXT) {
    _driver.glGetNamedFramebufferParameterivEXT(framebuffer, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetNamedFramebufferParameterivEXT)(framebuffer, pname, params);
}

static void REGAL_CALL loader_glNamedFramebufferParameteriEXT(GLuint framebuffer, GLenum pname, GLint param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNamedFramebufferParameteriEXT, "glNamedFramebufferParameteriEXT");
  if (_driver.glNamedFramebufferParameteriEXT) {
    _driver.glNamedFramebufferParameteriEXT(framebuffer, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNamedFramebufferParameteriEXT)(framebuffer, pname, param);
}

// GL_ARB_framebuffer_object

static void REGAL_CALL loader_glBindFramebuffer(GLenum target, GLuint framebuffer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBindFramebuffer, "glBindFramebuffer");
  if (_driver.glBindFramebuffer) {
    _driver.glBindFramebuffer(target, framebuffer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBindFramebuffer)(target, framebuffer);
}

static void REGAL_CALL loader_glBindRenderbuffer(GLenum target, GLuint renderbuffer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBindRenderbuffer, "glBindRenderbuffer");
  if (_driver.glBindRenderbuffer) {
    _driver.glBindRenderbuffer(target, renderbuffer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBindRenderbuffer)(target, renderbuffer);
}

static void REGAL_CALL loader_glBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBlitFramebuffer, "glBlitFramebuffer");
  if (_driver.glBlitFramebuffer) {
    _driver.glBlitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBlitFramebuffer)(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
}

static GLenum REGAL_CALL loader_glCheckFramebufferStatus(GLenum target)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCheckFramebufferStatus, "glCheckFramebufferStatus");
  if (_driver.glCheckFramebufferStatus) {
    return _driver.glCheckFramebufferStatus(target);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glCheckFramebufferStatus)(target);
}

static void REGAL_CALL loader_glDeleteFramebuffers(GLsizei n, const GLuint *framebuffers)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDeleteFramebuffers, "glDeleteFramebuffers");
  if (_driver.glDeleteFramebuffers) {
    _driver.glDeleteFramebuffers(n, framebuffers);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDeleteFramebuffers)(n, framebuffers);
}

static void REGAL_CALL loader_glDeleteRenderbuffers(GLsizei n, const GLuint *renderbuffers)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDeleteRenderbuffers, "glDeleteRenderbuffers");
  if (_driver.glDeleteRenderbuffers) {
    _driver.glDeleteRenderbuffers(n, renderbuffers);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDeleteRenderbuffers)(n, renderbuffers);
}

static void REGAL_CALL loader_glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFramebufferRenderbuffer, "glFramebufferRenderbuffer");
  if (_driver.glFramebufferRenderbuffer) {
    _driver.glFramebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFramebufferRenderbuffer)(target, attachment, renderbuffertarget, renderbuffer);
}

static void REGAL_CALL loader_glFramebufferTexture1D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFramebufferTexture1D, "glFramebufferTexture1D");
  if (_driver.glFramebufferTexture1D) {
    _driver.glFramebufferTexture1D(target, attachment, textarget, texture, level);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFramebufferTexture1D)(target, attachment, textarget, texture, level);
}

static void REGAL_CALL loader_glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFramebufferTexture2D, "glFramebufferTexture2D");
  if (_driver.glFramebufferTexture2D) {
    _driver.glFramebufferTexture2D(target, attachment, textarget, texture, level);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFramebufferTexture2D)(target, attachment, textarget, texture, level);
}

static void REGAL_CALL loader_glFramebufferTexture3D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint layer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFramebufferTexture3D, "glFramebufferTexture3D");
  if (_driver.glFramebufferTexture3D) {
    _driver.glFramebufferTexture3D(target, attachment, textarget, texture, level, layer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFramebufferTexture3D)(target, attachment, textarget, texture, level, layer);
}

static void REGAL_CALL loader_glFramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFramebufferTextureLayer, "glFramebufferTextureLayer");
  if (_driver.glFramebufferTextureLayer) {
    _driver.glFramebufferTextureLayer(target, attachment, texture, level, layer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFramebufferTextureLayer)(target, attachment, texture, level, layer);
}

static void REGAL_CALL loader_glGenFramebuffers(GLsizei n, GLuint *framebuffers)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGenFramebuffers, "glGenFramebuffers");
  if (_driver.glGenFramebuffers) {
    _driver.glGenFramebuffers(n, framebuffers);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGenFramebuffers)(n, framebuffers);
}

static void REGAL_CALL loader_glGenRenderbuffers(GLsizei n, GLuint *renderbuffers)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGenRenderbuffers, "glGenRenderbuffers");
  if (_driver.glGenRenderbuffers) {
    _driver.glGenRenderbuffers(n, renderbuffers);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGenRenderbuffers)(n, renderbuffers);
}

static void REGAL_CALL loader_glGenerateMipmap(GLenum target)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGenerateMipmap, "glGenerateMipmap");
  if (_driver.glGenerateMipmap) {
    _driver.glGenerateMipmap(target);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGenerateMipmap)(target);
}

static void REGAL_CALL loader_glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetFramebufferAttachmentParameteriv, "glGetFramebufferAttachmentParameteriv");
  if (_driver.glGetFramebufferAttachmentParameteriv) {
    _driver.glGetFramebufferAttachmentParameteriv(target, attachment, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetFramebufferAttachmentParameteriv)(target, attachment, pname, params);
}

static void REGAL_CALL loader_glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetRenderbufferParameteriv, "glGetRenderbufferParameteriv");
  if (_driver.glGetRenderbufferParameteriv) {
    _driver.glGetRenderbufferParameteriv(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetRenderbufferParameteriv)(target, pname, params);
}

static GLboolean REGAL_CALL loader_glIsFramebuffer(GLuint framebuffer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIsFramebuffer, "glIsFramebuffer");
  if (_driver.glIsFramebuffer) {
    return _driver.glIsFramebuffer(framebuffer);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glIsFramebuffer)(framebuffer);
}

static GLboolean REGAL_CALL loader_glIsRenderbuffer(GLuint renderbuffer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIsRenderbuffer, "glIsRenderbuffer");
  if (_driver.glIsRenderbuffer) {
    return _driver.glIsRenderbuffer(renderbuffer);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glIsRenderbuffer)(renderbuffer);
}

static void REGAL_CALL loader_glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glRenderbufferStorage, "glRenderbufferStorage");
  if (_driver.glRenderbufferStorage) {
    _driver.glRenderbufferStorage(target, internalformat, width, height);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glRenderbufferStorage)(target, internalformat, width, height);
}

static void REGAL_CALL loader_glRenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glRenderbufferStorageMultisample, "glRenderbufferStorageMultisample");
  if (_driver.glRenderbufferStorageMultisample) {
    _driver.glRenderbufferStorageMultisample(target, samples, internalformat, width, height);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glRenderbufferStorageMultisample)(target, samples, internalformat, width, height);
}

// GL_ARB_geometry_shader4

static void REGAL_CALL loader_glFramebufferTextureARB(GLenum target, GLenum attachment, GLuint texture, GLint level)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFramebufferTextureARB, "glFramebufferTextureARB");
  if (_driver.glFramebufferTextureARB) {
    _driver.glFramebufferTextureARB(target, attachment, texture, level);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFramebufferTextureARB)(target, attachment, texture, level);
}

static void REGAL_CALL loader_glFramebufferTextureFaceARB(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFramebufferTextureFaceARB, "glFramebufferTextureFaceARB");
  if (_driver.glFramebufferTextureFaceARB) {
    _driver.glFramebufferTextureFaceARB(target, attachment, texture, level, face);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFramebufferTextureFaceARB)(target, attachment, texture, level, face);
}

static void REGAL_CALL loader_glFramebufferTextureLayerARB(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFramebufferTextureLayerARB, "glFramebufferTextureLayerARB");
  if (_driver.glFramebufferTextureLayerARB) {
    _driver.glFramebufferTextureLayerARB(target, attachment, texture, level, layer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFramebufferTextureLayerARB)(target, attachment, texture, level, layer);
}

static void REGAL_CALL loader_glProgramParameteriARB(GLuint program, GLenum pname, GLint value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramParameteriARB, "glProgramParameteriARB");
  if (_driver.glProgramParameteriARB) {
    _driver.glProgramParameteriARB(program, pname, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramParameteriARB)(program, pname, value);
}

// GL_ARB_get_program_binary

static void REGAL_CALL loader_glGetProgramBinary(GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, GLvoid *binary)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetProgramBinary, "glGetProgramBinary");
  if (_driver.glGetProgramBinary) {
    _driver.glGetProgramBinary(program, bufSize, length, binaryFormat, binary);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetProgramBinary)(program, bufSize, length, binaryFormat, binary);
}

static void REGAL_CALL loader_glProgramBinary(GLuint program, GLenum binaryFormat, const GLvoid *binary, GLsizei length)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramBinary, "glProgramBinary");
  if (_driver.glProgramBinary) {
    _driver.glProgramBinary(program, binaryFormat, binary, length);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramBinary)(program, binaryFormat, binary, length);
}

static void REGAL_CALL loader_glProgramParameteri(GLuint program, GLenum pname, GLint value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramParameteri, "glProgramParameteri");
  if (_driver.glProgramParameteri) {
    _driver.glProgramParameteri(program, pname, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramParameteri)(program, pname, value);
}

// GL_ARB_gpu_shader_fp64

static void REGAL_CALL loader_glGetUniformdv(GLuint program, GLint location, GLdouble *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetUniformdv, "glGetUniformdv");
  if (_driver.glGetUniformdv) {
    _driver.glGetUniformdv(program, location, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetUniformdv)(program, location, params);
}

static void REGAL_CALL loader_glUniform1d(GLint location, GLdouble x)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform1d, "glUniform1d");
  if (_driver.glUniform1d) {
    _driver.glUniform1d(location, x);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform1d)(location, x);
}

static void REGAL_CALL loader_glUniform1dv(GLint location, GLsizei count, const GLdouble *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform1dv, "glUniform1dv");
  if (_driver.glUniform1dv) {
    _driver.glUniform1dv(location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform1dv)(location, count, value);
}

static void REGAL_CALL loader_glUniform2d(GLint location, GLdouble x, GLdouble y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform2d, "glUniform2d");
  if (_driver.glUniform2d) {
    _driver.glUniform2d(location, x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform2d)(location, x, y);
}

static void REGAL_CALL loader_glUniform2dv(GLint location, GLsizei count, const GLdouble *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform2dv, "glUniform2dv");
  if (_driver.glUniform2dv) {
    _driver.glUniform2dv(location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform2dv)(location, count, value);
}

static void REGAL_CALL loader_glUniform3d(GLint location, GLdouble x, GLdouble y, GLdouble z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform3d, "glUniform3d");
  if (_driver.glUniform3d) {
    _driver.glUniform3d(location, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform3d)(location, x, y, z);
}

static void REGAL_CALL loader_glUniform3dv(GLint location, GLsizei count, const GLdouble *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform3dv, "glUniform3dv");
  if (_driver.glUniform3dv) {
    _driver.glUniform3dv(location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform3dv)(location, count, value);
}

static void REGAL_CALL loader_glUniform4d(GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform4d, "glUniform4d");
  if (_driver.glUniform4d) {
    _driver.glUniform4d(location, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform4d)(location, x, y, z, w);
}

static void REGAL_CALL loader_glUniform4dv(GLint location, GLsizei count, const GLdouble *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform4dv, "glUniform4dv");
  if (_driver.glUniform4dv) {
    _driver.glUniform4dv(location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform4dv)(location, count, value);
}

static void REGAL_CALL loader_glUniformMatrix2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniformMatrix2dv, "glUniformMatrix2dv");
  if (_driver.glUniformMatrix2dv) {
    _driver.glUniformMatrix2dv(location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniformMatrix2dv)(location, count, transpose, value);
}

static void REGAL_CALL loader_glUniformMatrix2x3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniformMatrix2x3dv, "glUniformMatrix2x3dv");
  if (_driver.glUniformMatrix2x3dv) {
    _driver.glUniformMatrix2x3dv(location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniformMatrix2x3dv)(location, count, transpose, value);
}

static void REGAL_CALL loader_glUniformMatrix2x4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniformMatrix2x4dv, "glUniformMatrix2x4dv");
  if (_driver.glUniformMatrix2x4dv) {
    _driver.glUniformMatrix2x4dv(location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniformMatrix2x4dv)(location, count, transpose, value);
}

static void REGAL_CALL loader_glUniformMatrix3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniformMatrix3dv, "glUniformMatrix3dv");
  if (_driver.glUniformMatrix3dv) {
    _driver.glUniformMatrix3dv(location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniformMatrix3dv)(location, count, transpose, value);
}

static void REGAL_CALL loader_glUniformMatrix3x2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniformMatrix3x2dv, "glUniformMatrix3x2dv");
  if (_driver.glUniformMatrix3x2dv) {
    _driver.glUniformMatrix3x2dv(location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniformMatrix3x2dv)(location, count, transpose, value);
}

static void REGAL_CALL loader_glUniformMatrix3x4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniformMatrix3x4dv, "glUniformMatrix3x4dv");
  if (_driver.glUniformMatrix3x4dv) {
    _driver.glUniformMatrix3x4dv(location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniformMatrix3x4dv)(location, count, transpose, value);
}

static void REGAL_CALL loader_glUniformMatrix4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniformMatrix4dv, "glUniformMatrix4dv");
  if (_driver.glUniformMatrix4dv) {
    _driver.glUniformMatrix4dv(location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniformMatrix4dv)(location, count, transpose, value);
}

static void REGAL_CALL loader_glUniformMatrix4x2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniformMatrix4x2dv, "glUniformMatrix4x2dv");
  if (_driver.glUniformMatrix4x2dv) {
    _driver.glUniformMatrix4x2dv(location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniformMatrix4x2dv)(location, count, transpose, value);
}

static void REGAL_CALL loader_glUniformMatrix4x3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniformMatrix4x3dv, "glUniformMatrix4x3dv");
  if (_driver.glUniformMatrix4x3dv) {
    _driver.glUniformMatrix4x3dv(location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniformMatrix4x3dv)(location, count, transpose, value);
}

// GL_ARB_imaging

static void REGAL_CALL loader_glColorSubTable(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColorSubTable, "glColorSubTable");
  if (_driver.glColorSubTable) {
    _driver.glColorSubTable(target, start, count, format, type, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColorSubTable)(target, start, count, format, type, data);
}

static void REGAL_CALL loader_glColorTable(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColorTable, "glColorTable");
  if (_driver.glColorTable) {
    _driver.glColorTable(target, internalformat, width, format, type, table);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColorTable)(target, internalformat, width, format, type, table);
}

static void REGAL_CALL loader_glColorTableParameterfv(GLenum target, GLenum pname, const GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColorTableParameterfv, "glColorTableParameterfv");
  if (_driver.glColorTableParameterfv) {
    _driver.glColorTableParameterfv(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColorTableParameterfv)(target, pname, params);
}

static void REGAL_CALL loader_glColorTableParameteriv(GLenum target, GLenum pname, const GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColorTableParameteriv, "glColorTableParameteriv");
  if (_driver.glColorTableParameteriv) {
    _driver.glColorTableParameteriv(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColorTableParameteriv)(target, pname, params);
}

static void REGAL_CALL loader_glConvolutionFilter1D(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glConvolutionFilter1D, "glConvolutionFilter1D");
  if (_driver.glConvolutionFilter1D) {
    _driver.glConvolutionFilter1D(target, internalformat, width, format, type, image);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glConvolutionFilter1D)(target, internalformat, width, format, type, image);
}

static void REGAL_CALL loader_glConvolutionFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glConvolutionFilter2D, "glConvolutionFilter2D");
  if (_driver.glConvolutionFilter2D) {
    _driver.glConvolutionFilter2D(target, internalformat, width, height, format, type, image);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glConvolutionFilter2D)(target, internalformat, width, height, format, type, image);
}

static void REGAL_CALL loader_glConvolutionParameterf(GLenum target, GLenum pname, GLfloat params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glConvolutionParameterf, "glConvolutionParameterf");
  if (_driver.glConvolutionParameterf) {
    _driver.glConvolutionParameterf(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glConvolutionParameterf)(target, pname, params);
}

static void REGAL_CALL loader_glConvolutionParameterfv(GLenum target, GLenum pname, const GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glConvolutionParameterfv, "glConvolutionParameterfv");
  if (_driver.glConvolutionParameterfv) {
    _driver.glConvolutionParameterfv(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glConvolutionParameterfv)(target, pname, params);
}

static void REGAL_CALL loader_glConvolutionParameteri(GLenum target, GLenum pname, GLint params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glConvolutionParameteri, "glConvolutionParameteri");
  if (_driver.glConvolutionParameteri) {
    _driver.glConvolutionParameteri(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glConvolutionParameteri)(target, pname, params);
}

static void REGAL_CALL loader_glConvolutionParameteriv(GLenum target, GLenum pname, const GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glConvolutionParameteriv, "glConvolutionParameteriv");
  if (_driver.glConvolutionParameteriv) {
    _driver.glConvolutionParameteriv(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glConvolutionParameteriv)(target, pname, params);
}

static void REGAL_CALL loader_glCopyColorSubTable(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCopyColorSubTable, "glCopyColorSubTable");
  if (_driver.glCopyColorSubTable) {
    _driver.glCopyColorSubTable(target, start, x, y, width);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCopyColorSubTable)(target, start, x, y, width);
}

static void REGAL_CALL loader_glCopyColorTable(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCopyColorTable, "glCopyColorTable");
  if (_driver.glCopyColorTable) {
    _driver.glCopyColorTable(target, internalformat, x, y, width);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCopyColorTable)(target, internalformat, x, y, width);
}

static void REGAL_CALL loader_glCopyConvolutionFilter1D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCopyConvolutionFilter1D, "glCopyConvolutionFilter1D");
  if (_driver.glCopyConvolutionFilter1D) {
    _driver.glCopyConvolutionFilter1D(target, internalformat, x, y, width);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCopyConvolutionFilter1D)(target, internalformat, x, y, width);
}

static void REGAL_CALL loader_glCopyConvolutionFilter2D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCopyConvolutionFilter2D, "glCopyConvolutionFilter2D");
  if (_driver.glCopyConvolutionFilter2D) {
    _driver.glCopyConvolutionFilter2D(target, internalformat, x, y, width, height);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCopyConvolutionFilter2D)(target, internalformat, x, y, width, height);
}

static void REGAL_CALL loader_glGetColorTable(GLenum target, GLenum format, GLenum type, GLvoid *table)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetColorTable, "glGetColorTable");
  if (_driver.glGetColorTable) {
    _driver.glGetColorTable(target, format, type, table);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetColorTable)(target, format, type, table);
}

static void REGAL_CALL loader_glGetColorTableParameterfv(GLenum target, GLenum pname, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetColorTableParameterfv, "glGetColorTableParameterfv");
  if (_driver.glGetColorTableParameterfv) {
    _driver.glGetColorTableParameterfv(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetColorTableParameterfv)(target, pname, params);
}

static void REGAL_CALL loader_glGetColorTableParameteriv(GLenum target, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetColorTableParameteriv, "glGetColorTableParameteriv");
  if (_driver.glGetColorTableParameteriv) {
    _driver.glGetColorTableParameteriv(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetColorTableParameteriv)(target, pname, params);
}

static void REGAL_CALL loader_glGetConvolutionFilter(GLenum target, GLenum format, GLenum type, GLvoid *image)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetConvolutionFilter, "glGetConvolutionFilter");
  if (_driver.glGetConvolutionFilter) {
    _driver.glGetConvolutionFilter(target, format, type, image);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetConvolutionFilter)(target, format, type, image);
}

static void REGAL_CALL loader_glGetConvolutionParameterfv(GLenum target, GLenum pname, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetConvolutionParameterfv, "glGetConvolutionParameterfv");
  if (_driver.glGetConvolutionParameterfv) {
    _driver.glGetConvolutionParameterfv(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetConvolutionParameterfv)(target, pname, params);
}

static void REGAL_CALL loader_glGetConvolutionParameteriv(GLenum target, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetConvolutionParameteriv, "glGetConvolutionParameteriv");
  if (_driver.glGetConvolutionParameteriv) {
    _driver.glGetConvolutionParameteriv(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetConvolutionParameteriv)(target, pname, params);
}

static void REGAL_CALL loader_glGetHistogram(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetHistogram, "glGetHistogram");
  if (_driver.glGetHistogram) {
    _driver.glGetHistogram(target, reset, format, type, values);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetHistogram)(target, reset, format, type, values);
}

static void REGAL_CALL loader_glGetHistogramParameterfv(GLenum target, GLenum pname, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetHistogramParameterfv, "glGetHistogramParameterfv");
  if (_driver.glGetHistogramParameterfv) {
    _driver.glGetHistogramParameterfv(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetHistogramParameterfv)(target, pname, params);
}

static void REGAL_CALL loader_glGetHistogramParameteriv(GLenum target, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetHistogramParameteriv, "glGetHistogramParameteriv");
  if (_driver.glGetHistogramParameteriv) {
    _driver.glGetHistogramParameteriv(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetHistogramParameteriv)(target, pname, params);
}

static void REGAL_CALL loader_glGetMinmax(GLenum target, GLboolean reset, GLenum format, GLenum types, GLvoid *values)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetMinmax, "glGetMinmax");
  if (_driver.glGetMinmax) {
    _driver.glGetMinmax(target, reset, format, types, values);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetMinmax)(target, reset, format, types, values);
}

static void REGAL_CALL loader_glGetMinmaxParameterfv(GLenum target, GLenum pname, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetMinmaxParameterfv, "glGetMinmaxParameterfv");
  if (_driver.glGetMinmaxParameterfv) {
    _driver.glGetMinmaxParameterfv(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetMinmaxParameterfv)(target, pname, params);
}

static void REGAL_CALL loader_glGetMinmaxParameteriv(GLenum target, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetMinmaxParameteriv, "glGetMinmaxParameteriv");
  if (_driver.glGetMinmaxParameteriv) {
    _driver.glGetMinmaxParameteriv(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetMinmaxParameteriv)(target, pname, params);
}

static void REGAL_CALL loader_glGetSeparableFilter(GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetSeparableFilter, "glGetSeparableFilter");
  if (_driver.glGetSeparableFilter) {
    _driver.glGetSeparableFilter(target, format, type, row, column, span);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetSeparableFilter)(target, format, type, row, column, span);
}

static void REGAL_CALL loader_glHistogram(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glHistogram, "glHistogram");
  if (_driver.glHistogram) {
    _driver.glHistogram(target, width, internalformat, sink);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glHistogram)(target, width, internalformat, sink);
}

static void REGAL_CALL loader_glMinmax(GLenum target, GLenum internalformat, GLboolean sink)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMinmax, "glMinmax");
  if (_driver.glMinmax) {
    _driver.glMinmax(target, internalformat, sink);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMinmax)(target, internalformat, sink);
}

static void REGAL_CALL loader_glResetHistogram(GLenum target)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glResetHistogram, "glResetHistogram");
  if (_driver.glResetHistogram) {
    _driver.glResetHistogram(target);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glResetHistogram)(target);
}

static void REGAL_CALL loader_glResetMinmax(GLenum target)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glResetMinmax, "glResetMinmax");
  if (_driver.glResetMinmax) {
    _driver.glResetMinmax(target);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glResetMinmax)(target);
}

static void REGAL_CALL loader_glSeparableFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSeparableFilter2D, "glSeparableFilter2D");
  if (_driver.glSeparableFilter2D) {
    _driver.glSeparableFilter2D(target, internalformat, width, height, format, type, row, column);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSeparableFilter2D)(target, internalformat, width, height, format, type, row, column);
}

// GL_ARB_instanced_arrays

static void REGAL_CALL loader_glVertexAttribDivisorARB(GLuint index, GLuint divisor)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribDivisorARB, "glVertexAttribDivisorARB");
  if (_driver.glVertexAttribDivisorARB) {
    _driver.glVertexAttribDivisorARB(index, divisor);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribDivisorARB)(index, divisor);
}

// GL_ARB_internalformat_query

static void REGAL_CALL loader_glGetInternalformativ(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetInternalformativ, "glGetInternalformativ");
  if (_driver.glGetInternalformativ) {
    _driver.glGetInternalformativ(target, internalformat, pname, bufSize, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetInternalformativ)(target, internalformat, pname, bufSize, params);
}

// GL_ARB_internalformat_query2

static void REGAL_CALL loader_glGetInternalformati64v(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint64 *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetInternalformati64v, "glGetInternalformati64v");
  if (_driver.glGetInternalformati64v) {
    _driver.glGetInternalformati64v(target, internalformat, pname, bufSize, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetInternalformati64v)(target, internalformat, pname, bufSize, params);
}

// GL_ARB_invalidate_subdata

static void REGAL_CALL loader_glInvalidateBufferData(GLuint buffer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glInvalidateBufferData, "glInvalidateBufferData");
  if (_driver.glInvalidateBufferData) {
    _driver.glInvalidateBufferData(buffer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glInvalidateBufferData)(buffer);
}

static void REGAL_CALL loader_glInvalidateBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr length)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glInvalidateBufferSubData, "glInvalidateBufferSubData");
  if (_driver.glInvalidateBufferSubData) {
    _driver.glInvalidateBufferSubData(buffer, offset, length);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glInvalidateBufferSubData)(buffer, offset, length);
}

static void REGAL_CALL loader_glInvalidateFramebuffer(GLenum target, GLsizei numAttachments, const GLenum *attachments)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glInvalidateFramebuffer, "glInvalidateFramebuffer");
  if (_driver.glInvalidateFramebuffer) {
    _driver.glInvalidateFramebuffer(target, numAttachments, attachments);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glInvalidateFramebuffer)(target, numAttachments, attachments);
}

static void REGAL_CALL loader_glInvalidateSubFramebuffer(GLenum target, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glInvalidateSubFramebuffer, "glInvalidateSubFramebuffer");
  if (_driver.glInvalidateSubFramebuffer) {
    _driver.glInvalidateSubFramebuffer(target, numAttachments, attachments, x, y, width, height);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glInvalidateSubFramebuffer)(target, numAttachments, attachments, x, y, width, height);
}

static void REGAL_CALL loader_glInvalidateTexImage(GLuint texture, GLint level)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glInvalidateTexImage, "glInvalidateTexImage");
  if (_driver.glInvalidateTexImage) {
    _driver.glInvalidateTexImage(texture, level);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glInvalidateTexImage)(texture, level);
}

static void REGAL_CALL loader_glInvalidateTexSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glInvalidateTexSubImage, "glInvalidateTexSubImage");
  if (_driver.glInvalidateTexSubImage) {
    _driver.glInvalidateTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glInvalidateTexSubImage)(texture, level, xoffset, yoffset, zoffset, width, height, depth);
}

// GL_ARB_map_buffer_range

static void REGAL_CALL loader_glFlushMappedBufferRange(GLenum target, GLintptr offset, GLsizeiptr length)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFlushMappedBufferRange, "glFlushMappedBufferRange");
  if (_driver.glFlushMappedBufferRange) {
    _driver.glFlushMappedBufferRange(target, offset, length);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFlushMappedBufferRange)(target, offset, length);
}

static GLvoid *REGAL_CALL loader_glMapBufferRange(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMapBufferRange, "glMapBufferRange");
  if (_driver.glMapBufferRange) {
    return _driver.glMapBufferRange(target, offset, length, access);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glMapBufferRange)(target, offset, length, access);
}

// GL_ARB_matrix_palette

static void REGAL_CALL loader_glCurrentPaletteMatrixARB(GLint index)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCurrentPaletteMatrixARB, "glCurrentPaletteMatrixARB");
  if (_driver.glCurrentPaletteMatrixARB) {
    _driver.glCurrentPaletteMatrixARB(index);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCurrentPaletteMatrixARB)(index);
}

static void REGAL_CALL loader_glMatrixIndexPointerARB(GLint size, GLenum type, GLsizei stride, GLvoid *pointer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMatrixIndexPointerARB, "glMatrixIndexPointerARB");
  if (_driver.glMatrixIndexPointerARB) {
    _driver.glMatrixIndexPointerARB(size, type, stride, pointer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMatrixIndexPointerARB)(size, type, stride, pointer);
}

static void REGAL_CALL loader_glMatrixIndexubvARB(GLint size, GLubyte *indices)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMatrixIndexubvARB, "glMatrixIndexubvARB");
  if (_driver.glMatrixIndexubvARB) {
    _driver.glMatrixIndexubvARB(size, indices);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMatrixIndexubvARB)(size, indices);
}

static void REGAL_CALL loader_glMatrixIndexuivARB(GLint size, GLuint *indices)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMatrixIndexuivARB, "glMatrixIndexuivARB");
  if (_driver.glMatrixIndexuivARB) {
    _driver.glMatrixIndexuivARB(size, indices);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMatrixIndexuivARB)(size, indices);
}

static void REGAL_CALL loader_glMatrixIndexusvARB(GLint size, GLushort *indices)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMatrixIndexusvARB, "glMatrixIndexusvARB");
  if (_driver.glMatrixIndexusvARB) {
    _driver.glMatrixIndexusvARB(size, indices);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMatrixIndexusvARB)(size, indices);
}

// GL_ARB_multi_draw_indirect

static void REGAL_CALL loader_glMultiDrawArraysIndirect(GLenum mode, const GLvoid *indirect, GLsizei primcount, GLsizei stride)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiDrawArraysIndirect, "glMultiDrawArraysIndirect");
  if (_driver.glMultiDrawArraysIndirect) {
    _driver.glMultiDrawArraysIndirect(mode, indirect, primcount, stride);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiDrawArraysIndirect)(mode, indirect, primcount, stride);
}

static void REGAL_CALL loader_glMultiDrawElementsIndirect(GLenum mode, GLenum type, const GLvoid *indirect, GLsizei primcount, GLsizei stride)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiDrawElementsIndirect, "glMultiDrawElementsIndirect");
  if (_driver.glMultiDrawElementsIndirect) {
    _driver.glMultiDrawElementsIndirect(mode, type, indirect, primcount, stride);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiDrawElementsIndirect)(mode, type, indirect, primcount, stride);
}

// GL_ARB_multisample

static void REGAL_CALL loader_glSampleCoverageARB(GLclampf value, GLboolean invert)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSampleCoverageARB, "glSampleCoverageARB");
  if (_driver.glSampleCoverageARB) {
    _driver.glSampleCoverageARB(value, invert);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSampleCoverageARB)(value, invert);
}

// GL_ARB_multitexture

static void REGAL_CALL loader_glActiveTextureARB(GLenum texture)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glActiveTextureARB, "glActiveTextureARB");
  if (_driver.glActiveTextureARB) {
    _driver.glActiveTextureARB(texture);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glActiveTextureARB)(texture);
}

static void REGAL_CALL loader_glClientActiveTextureARB(GLenum texture)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glClientActiveTextureARB, "glClientActiveTextureARB");
  if (_driver.glClientActiveTextureARB) {
    _driver.glClientActiveTextureARB(texture);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glClientActiveTextureARB)(texture);
}

static void REGAL_CALL loader_glMultiTexCoord1dARB(GLenum target, GLdouble s)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord1dARB, "glMultiTexCoord1dARB");
  if (_driver.glMultiTexCoord1dARB) {
    _driver.glMultiTexCoord1dARB(target, s);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord1dARB)(target, s);
}

static void REGAL_CALL loader_glMultiTexCoord1dvARB(GLenum target, const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord1dvARB, "glMultiTexCoord1dvARB");
  if (_driver.glMultiTexCoord1dvARB) {
    _driver.glMultiTexCoord1dvARB(target, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord1dvARB)(target, v);
}

static void REGAL_CALL loader_glMultiTexCoord1fARB(GLenum target, GLfloat s)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord1fARB, "glMultiTexCoord1fARB");
  if (_driver.glMultiTexCoord1fARB) {
    _driver.glMultiTexCoord1fARB(target, s);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord1fARB)(target, s);
}

static void REGAL_CALL loader_glMultiTexCoord1fvARB(GLenum target, const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord1fvARB, "glMultiTexCoord1fvARB");
  if (_driver.glMultiTexCoord1fvARB) {
    _driver.glMultiTexCoord1fvARB(target, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord1fvARB)(target, v);
}

static void REGAL_CALL loader_glMultiTexCoord1iARB(GLenum target, GLint s)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord1iARB, "glMultiTexCoord1iARB");
  if (_driver.glMultiTexCoord1iARB) {
    _driver.glMultiTexCoord1iARB(target, s);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord1iARB)(target, s);
}

static void REGAL_CALL loader_glMultiTexCoord1ivARB(GLenum target, const GLint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord1ivARB, "glMultiTexCoord1ivARB");
  if (_driver.glMultiTexCoord1ivARB) {
    _driver.glMultiTexCoord1ivARB(target, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord1ivARB)(target, v);
}

static void REGAL_CALL loader_glMultiTexCoord1sARB(GLenum target, GLshort s)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord1sARB, "glMultiTexCoord1sARB");
  if (_driver.glMultiTexCoord1sARB) {
    _driver.glMultiTexCoord1sARB(target, s);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord1sARB)(target, s);
}

static void REGAL_CALL loader_glMultiTexCoord1svARB(GLenum target, const GLshort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord1svARB, "glMultiTexCoord1svARB");
  if (_driver.glMultiTexCoord1svARB) {
    _driver.glMultiTexCoord1svARB(target, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord1svARB)(target, v);
}

static void REGAL_CALL loader_glMultiTexCoord2dARB(GLenum target, GLdouble s, GLdouble t)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord2dARB, "glMultiTexCoord2dARB");
  if (_driver.glMultiTexCoord2dARB) {
    _driver.glMultiTexCoord2dARB(target, s, t);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord2dARB)(target, s, t);
}

static void REGAL_CALL loader_glMultiTexCoord2dvARB(GLenum target, const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord2dvARB, "glMultiTexCoord2dvARB");
  if (_driver.glMultiTexCoord2dvARB) {
    _driver.glMultiTexCoord2dvARB(target, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord2dvARB)(target, v);
}

static void REGAL_CALL loader_glMultiTexCoord2fARB(GLenum target, GLfloat s, GLfloat t)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord2fARB, "glMultiTexCoord2fARB");
  if (_driver.glMultiTexCoord2fARB) {
    _driver.glMultiTexCoord2fARB(target, s, t);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord2fARB)(target, s, t);
}

static void REGAL_CALL loader_glMultiTexCoord2fvARB(GLenum target, const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord2fvARB, "glMultiTexCoord2fvARB");
  if (_driver.glMultiTexCoord2fvARB) {
    _driver.glMultiTexCoord2fvARB(target, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord2fvARB)(target, v);
}

static void REGAL_CALL loader_glMultiTexCoord2iARB(GLenum target, GLint s, GLint t)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord2iARB, "glMultiTexCoord2iARB");
  if (_driver.glMultiTexCoord2iARB) {
    _driver.glMultiTexCoord2iARB(target, s, t);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord2iARB)(target, s, t);
}

static void REGAL_CALL loader_glMultiTexCoord2ivARB(GLenum target, const GLint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord2ivARB, "glMultiTexCoord2ivARB");
  if (_driver.glMultiTexCoord2ivARB) {
    _driver.glMultiTexCoord2ivARB(target, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord2ivARB)(target, v);
}

static void REGAL_CALL loader_glMultiTexCoord2sARB(GLenum target, GLshort s, GLshort t)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord2sARB, "glMultiTexCoord2sARB");
  if (_driver.glMultiTexCoord2sARB) {
    _driver.glMultiTexCoord2sARB(target, s, t);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord2sARB)(target, s, t);
}

static void REGAL_CALL loader_glMultiTexCoord2svARB(GLenum target, const GLshort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord2svARB, "glMultiTexCoord2svARB");
  if (_driver.glMultiTexCoord2svARB) {
    _driver.glMultiTexCoord2svARB(target, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord2svARB)(target, v);
}

static void REGAL_CALL loader_glMultiTexCoord3dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord3dARB, "glMultiTexCoord3dARB");
  if (_driver.glMultiTexCoord3dARB) {
    _driver.glMultiTexCoord3dARB(target, s, t, r);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord3dARB)(target, s, t, r);
}

static void REGAL_CALL loader_glMultiTexCoord3dvARB(GLenum target, const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord3dvARB, "glMultiTexCoord3dvARB");
  if (_driver.glMultiTexCoord3dvARB) {
    _driver.glMultiTexCoord3dvARB(target, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord3dvARB)(target, v);
}

static void REGAL_CALL loader_glMultiTexCoord3fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord3fARB, "glMultiTexCoord3fARB");
  if (_driver.glMultiTexCoord3fARB) {
    _driver.glMultiTexCoord3fARB(target, s, t, r);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord3fARB)(target, s, t, r);
}

static void REGAL_CALL loader_glMultiTexCoord3fvARB(GLenum target, const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord3fvARB, "glMultiTexCoord3fvARB");
  if (_driver.glMultiTexCoord3fvARB) {
    _driver.glMultiTexCoord3fvARB(target, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord3fvARB)(target, v);
}

static void REGAL_CALL loader_glMultiTexCoord3iARB(GLenum target, GLint s, GLint t, GLint r)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord3iARB, "glMultiTexCoord3iARB");
  if (_driver.glMultiTexCoord3iARB) {
    _driver.glMultiTexCoord3iARB(target, s, t, r);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord3iARB)(target, s, t, r);
}

static void REGAL_CALL loader_glMultiTexCoord3ivARB(GLenum target, const GLint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord3ivARB, "glMultiTexCoord3ivARB");
  if (_driver.glMultiTexCoord3ivARB) {
    _driver.glMultiTexCoord3ivARB(target, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord3ivARB)(target, v);
}

static void REGAL_CALL loader_glMultiTexCoord3sARB(GLenum target, GLshort s, GLshort t, GLshort r)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord3sARB, "glMultiTexCoord3sARB");
  if (_driver.glMultiTexCoord3sARB) {
    _driver.glMultiTexCoord3sARB(target, s, t, r);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord3sARB)(target, s, t, r);
}

static void REGAL_CALL loader_glMultiTexCoord3svARB(GLenum target, const GLshort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord3svARB, "glMultiTexCoord3svARB");
  if (_driver.glMultiTexCoord3svARB) {
    _driver.glMultiTexCoord3svARB(target, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord3svARB)(target, v);
}

static void REGAL_CALL loader_glMultiTexCoord4dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord4dARB, "glMultiTexCoord4dARB");
  if (_driver.glMultiTexCoord4dARB) {
    _driver.glMultiTexCoord4dARB(target, s, t, r, q);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord4dARB)(target, s, t, r, q);
}

static void REGAL_CALL loader_glMultiTexCoord4dvARB(GLenum target, const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord4dvARB, "glMultiTexCoord4dvARB");
  if (_driver.glMultiTexCoord4dvARB) {
    _driver.glMultiTexCoord4dvARB(target, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord4dvARB)(target, v);
}

static void REGAL_CALL loader_glMultiTexCoord4fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord4fARB, "glMultiTexCoord4fARB");
  if (_driver.glMultiTexCoord4fARB) {
    _driver.glMultiTexCoord4fARB(target, s, t, r, q);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord4fARB)(target, s, t, r, q);
}

static void REGAL_CALL loader_glMultiTexCoord4fvARB(GLenum target, const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord4fvARB, "glMultiTexCoord4fvARB");
  if (_driver.glMultiTexCoord4fvARB) {
    _driver.glMultiTexCoord4fvARB(target, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord4fvARB)(target, v);
}

static void REGAL_CALL loader_glMultiTexCoord4iARB(GLenum target, GLint s, GLint t, GLint r, GLint q)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord4iARB, "glMultiTexCoord4iARB");
  if (_driver.glMultiTexCoord4iARB) {
    _driver.glMultiTexCoord4iARB(target, s, t, r, q);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord4iARB)(target, s, t, r, q);
}

static void REGAL_CALL loader_glMultiTexCoord4ivARB(GLenum target, const GLint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord4ivARB, "glMultiTexCoord4ivARB");
  if (_driver.glMultiTexCoord4ivARB) {
    _driver.glMultiTexCoord4ivARB(target, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord4ivARB)(target, v);
}

static void REGAL_CALL loader_glMultiTexCoord4sARB(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord4sARB, "glMultiTexCoord4sARB");
  if (_driver.glMultiTexCoord4sARB) {
    _driver.glMultiTexCoord4sARB(target, s, t, r, q);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord4sARB)(target, s, t, r, q);
}

static void REGAL_CALL loader_glMultiTexCoord4svARB(GLenum target, const GLshort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord4svARB, "glMultiTexCoord4svARB");
  if (_driver.glMultiTexCoord4svARB) {
    _driver.glMultiTexCoord4svARB(target, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord4svARB)(target, v);
}

// GL_ARB_occlusion_query

static void REGAL_CALL loader_glBeginQueryARB(GLenum target, GLuint id)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBeginQueryARB, "glBeginQueryARB");
  if (_driver.glBeginQueryARB) {
    _driver.glBeginQueryARB(target, id);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBeginQueryARB)(target, id);
}

static void REGAL_CALL loader_glDeleteQueriesARB(GLsizei n, const GLuint *ids)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDeleteQueriesARB, "glDeleteQueriesARB");
  if (_driver.glDeleteQueriesARB) {
    _driver.glDeleteQueriesARB(n, ids);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDeleteQueriesARB)(n, ids);
}

static void REGAL_CALL loader_glEndQueryARB(GLenum target)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glEndQueryARB, "glEndQueryARB");
  if (_driver.glEndQueryARB) {
    _driver.glEndQueryARB(target);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glEndQueryARB)(target);
}

static void REGAL_CALL loader_glGenQueriesARB(GLsizei n, GLuint *ids)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGenQueriesARB, "glGenQueriesARB");
  if (_driver.glGenQueriesARB) {
    _driver.glGenQueriesARB(n, ids);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGenQueriesARB)(n, ids);
}

static void REGAL_CALL loader_glGetQueryObjectivARB(GLuint id, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetQueryObjectivARB, "glGetQueryObjectivARB");
  if (_driver.glGetQueryObjectivARB) {
    _driver.glGetQueryObjectivARB(id, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetQueryObjectivARB)(id, pname, params);
}

static void REGAL_CALL loader_glGetQueryObjectuivARB(GLuint id, GLenum pname, GLuint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetQueryObjectuivARB, "glGetQueryObjectuivARB");
  if (_driver.glGetQueryObjectuivARB) {
    _driver.glGetQueryObjectuivARB(id, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetQueryObjectuivARB)(id, pname, params);
}

static void REGAL_CALL loader_glGetQueryivARB(GLenum target, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetQueryivARB, "glGetQueryivARB");
  if (_driver.glGetQueryivARB) {
    _driver.glGetQueryivARB(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetQueryivARB)(target, pname, params);
}

static GLboolean REGAL_CALL loader_glIsQueryARB(GLuint id)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIsQueryARB, "glIsQueryARB");
  if (_driver.glIsQueryARB) {
    return _driver.glIsQueryARB(id);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glIsQueryARB)(id);
}

// GL_ARB_point_parameters

static void REGAL_CALL loader_glPointParameterfARB(GLenum pname, GLfloat param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPointParameterfARB, "glPointParameterfARB");
  if (_driver.glPointParameterfARB) {
    _driver.glPointParameterfARB(pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPointParameterfARB)(pname, param);
}

static void REGAL_CALL loader_glPointParameterfvARB(GLenum pname, const GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPointParameterfvARB, "glPointParameterfvARB");
  if (_driver.glPointParameterfvARB) {
    _driver.glPointParameterfvARB(pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPointParameterfvARB)(pname, params);
}

// GL_ARB_program_interface_query

static void REGAL_CALL loader_glGetProgramInterfaceiv(GLuint program, GLenum programInterface, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetProgramInterfaceiv, "glGetProgramInterfaceiv");
  if (_driver.glGetProgramInterfaceiv) {
    _driver.glGetProgramInterfaceiv(program, programInterface, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetProgramInterfaceiv)(program, programInterface, pname, params);
}

static GLuint REGAL_CALL loader_glGetProgramResourceIndex(GLuint program, GLenum programInterface, const GLchar *name)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetProgramResourceIndex, "glGetProgramResourceIndex");
  if (_driver.glGetProgramResourceIndex) {
    return _driver.glGetProgramResourceIndex(program, programInterface, name);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glGetProgramResourceIndex)(program, programInterface, name);
}

static GLint REGAL_CALL loader_glGetProgramResourceLocation(GLuint program, GLenum programInterface, const GLchar *name)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetProgramResourceLocation, "glGetProgramResourceLocation");
  if (_driver.glGetProgramResourceLocation) {
    return _driver.glGetProgramResourceLocation(program, programInterface, name);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glGetProgramResourceLocation)(program, programInterface, name);
}

static GLint REGAL_CALL loader_glGetProgramResourceLocationIndex(GLuint program, GLenum programInterface, const GLchar *name)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetProgramResourceLocationIndex, "glGetProgramResourceLocationIndex");
  if (_driver.glGetProgramResourceLocationIndex) {
    return _driver.glGetProgramResourceLocationIndex(program, programInterface, name);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glGetProgramResourceLocationIndex)(program, programInterface, name);
}

static void REGAL_CALL loader_glGetProgramResourceName(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetProgramResourceName, "glGetProgramResourceName");
  if (_driver.glGetProgramResourceName) {
    _driver.glGetProgramResourceName(program, programInterface, index, bufSize, length, name);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetProgramResourceName)(program, programInterface, index, bufSize, length, name);
}

static void REGAL_CALL loader_glGetProgramResourceiv(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum *props, GLsizei bufSize, GLsizei *length, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetProgramResourceiv, "glGetProgramResourceiv");
  if (_driver.glGetProgramResourceiv) {
    _driver.glGetProgramResourceiv(program, programInterface, index, propCount, props, bufSize, length, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetProgramResourceiv)(program, programInterface, index, propCount, props, bufSize, length, params);
}

// GL_ARB_provoking_vertex

static void REGAL_CALL loader_glProvokingVertex(GLenum mode)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProvokingVertex, "glProvokingVertex");
  if (_driver.glProvokingVertex) {
    _driver.glProvokingVertex(mode);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProvokingVertex)(mode);
}

// GL_ARB_robustness

static GLenum REGAL_CALL loader_glGetGraphicsResetStatusARB(void)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetGraphicsResetStatusARB, "glGetGraphicsResetStatusARB");
  if (_driver.glGetGraphicsResetStatusARB) {
    return _driver.glGetGraphicsResetStatusARB();
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glGetGraphicsResetStatusARB)();
}

static void REGAL_CALL loader_glGetnColorTableARB(GLenum target, GLenum format, GLenum type, GLsizei bufSize, GLvoid *table)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetnColorTableARB, "glGetnColorTableARB");
  if (_driver.glGetnColorTableARB) {
    _driver.glGetnColorTableARB(target, format, type, bufSize, table);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetnColorTableARB)(target, format, type, bufSize, table);
}

static void REGAL_CALL loader_glGetnCompressedTexImageARB(GLenum target, GLint lod, GLsizei bufSize, GLvoid *img)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetnCompressedTexImageARB, "glGetnCompressedTexImageARB");
  if (_driver.glGetnCompressedTexImageARB) {
    _driver.glGetnCompressedTexImageARB(target, lod, bufSize, img);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetnCompressedTexImageARB)(target, lod, bufSize, img);
}

static void REGAL_CALL loader_glGetnConvolutionFilterARB(GLenum target, GLenum format, GLenum type, GLsizei bufSize, GLvoid *image)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetnConvolutionFilterARB, "glGetnConvolutionFilterARB");
  if (_driver.glGetnConvolutionFilterARB) {
    _driver.glGetnConvolutionFilterARB(target, format, type, bufSize, image);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetnConvolutionFilterARB)(target, format, type, bufSize, image);
}

static void REGAL_CALL loader_glGetnHistogramARB(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, GLvoid *values)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetnHistogramARB, "glGetnHistogramARB");
  if (_driver.glGetnHistogramARB) {
    _driver.glGetnHistogramARB(target, reset, format, type, bufSize, values);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetnHistogramARB)(target, reset, format, type, bufSize, values);
}

static void REGAL_CALL loader_glGetnMapdvARB(GLenum target, GLenum query, GLsizei bufSize, GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetnMapdvARB, "glGetnMapdvARB");
  if (_driver.glGetnMapdvARB) {
    _driver.glGetnMapdvARB(target, query, bufSize, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetnMapdvARB)(target, query, bufSize, v);
}

static void REGAL_CALL loader_glGetnMapfvARB(GLenum target, GLenum query, GLsizei bufSize, GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetnMapfvARB, "glGetnMapfvARB");
  if (_driver.glGetnMapfvARB) {
    _driver.glGetnMapfvARB(target, query, bufSize, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetnMapfvARB)(target, query, bufSize, v);
}

static void REGAL_CALL loader_glGetnMapivARB(GLenum target, GLenum query, GLsizei bufSize, GLint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetnMapivARB, "glGetnMapivARB");
  if (_driver.glGetnMapivARB) {
    _driver.glGetnMapivARB(target, query, bufSize, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetnMapivARB)(target, query, bufSize, v);
}

static void REGAL_CALL loader_glGetnMinmaxARB(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, GLvoid *values)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetnMinmaxARB, "glGetnMinmaxARB");
  if (_driver.glGetnMinmaxARB) {
    _driver.glGetnMinmaxARB(target, reset, format, type, bufSize, values);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetnMinmaxARB)(target, reset, format, type, bufSize, values);
}

static void REGAL_CALL loader_glGetnPixelMapfvARB(GLenum map, GLsizei bufSize, GLfloat *values)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetnPixelMapfvARB, "glGetnPixelMapfvARB");
  if (_driver.glGetnPixelMapfvARB) {
    _driver.glGetnPixelMapfvARB(map, bufSize, values);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetnPixelMapfvARB)(map, bufSize, values);
}

static void REGAL_CALL loader_glGetnPixelMapuivARB(GLenum map, GLsizei bufSize, GLuint *values)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetnPixelMapuivARB, "glGetnPixelMapuivARB");
  if (_driver.glGetnPixelMapuivARB) {
    _driver.glGetnPixelMapuivARB(map, bufSize, values);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetnPixelMapuivARB)(map, bufSize, values);
}

static void REGAL_CALL loader_glGetnPixelMapusvARB(GLenum map, GLsizei bufSize, GLushort *values)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetnPixelMapusvARB, "glGetnPixelMapusvARB");
  if (_driver.glGetnPixelMapusvARB) {
    _driver.glGetnPixelMapusvARB(map, bufSize, values);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetnPixelMapusvARB)(map, bufSize, values);
}

static void REGAL_CALL loader_glGetnPolygonStippleARB(GLsizei bufSize, GLubyte *pattern)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetnPolygonStippleARB, "glGetnPolygonStippleARB");
  if (_driver.glGetnPolygonStippleARB) {
    _driver.glGetnPolygonStippleARB(bufSize, pattern);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetnPolygonStippleARB)(bufSize, pattern);
}

static void REGAL_CALL loader_glGetnSeparableFilterARB(GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, GLvoid *row, GLsizei columnBufSize, GLvoid *column, GLvoid *span)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetnSeparableFilterARB, "glGetnSeparableFilterARB");
  if (_driver.glGetnSeparableFilterARB) {
    _driver.glGetnSeparableFilterARB(target, format, type, rowBufSize, row, columnBufSize, column, span);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetnSeparableFilterARB)(target, format, type, rowBufSize, row, columnBufSize, column, span);
}

static void REGAL_CALL loader_glGetnTexImageARB(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, GLvoid *img)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetnTexImageARB, "glGetnTexImageARB");
  if (_driver.glGetnTexImageARB) {
    _driver.glGetnTexImageARB(target, level, format, type, bufSize, img);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetnTexImageARB)(target, level, format, type, bufSize, img);
}

static void REGAL_CALL loader_glGetnUniformdvARB(GLuint program, GLint location, GLsizei bufSize, GLdouble *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetnUniformdvARB, "glGetnUniformdvARB");
  if (_driver.glGetnUniformdvARB) {
    _driver.glGetnUniformdvARB(program, location, bufSize, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetnUniformdvARB)(program, location, bufSize, params);
}

static void REGAL_CALL loader_glGetnUniformfvARB(GLuint program, GLint location, GLsizei bufSize, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetnUniformfvARB, "glGetnUniformfvARB");
  if (_driver.glGetnUniformfvARB) {
    _driver.glGetnUniformfvARB(program, location, bufSize, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetnUniformfvARB)(program, location, bufSize, params);
}

static void REGAL_CALL loader_glGetnUniformivARB(GLuint program, GLint location, GLsizei bufSize, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetnUniformivARB, "glGetnUniformivARB");
  if (_driver.glGetnUniformivARB) {
    _driver.glGetnUniformivARB(program, location, bufSize, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetnUniformivARB)(program, location, bufSize, params);
}

static void REGAL_CALL loader_glGetnUniformuivARB(GLuint program, GLint location, GLsizei bufSize, GLuint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetnUniformuivARB, "glGetnUniformuivARB");
  if (_driver.glGetnUniformuivARB) {
    _driver.glGetnUniformuivARB(program, location, bufSize, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetnUniformuivARB)(program, location, bufSize, params);
}

static void REGAL_CALL loader_glReadnPixelsARB(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, GLvoid *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glReadnPixelsARB, "glReadnPixelsARB");
  if (_driver.glReadnPixelsARB) {
    _driver.glReadnPixelsARB(x, y, width, height, format, type, bufSize, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glReadnPixelsARB)(x, y, width, height, format, type, bufSize, data);
}

// GL_ARB_sample_shading

static void REGAL_CALL loader_glMinSampleShading(GLclampf value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMinSampleShading, "glMinSampleShading");
  if (_driver.glMinSampleShading) {
    _driver.glMinSampleShading(value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMinSampleShading)(value);
}

static void REGAL_CALL loader_glMinSampleShadingARB(GLclampf value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMinSampleShadingARB, "glMinSampleShadingARB");
  if (_driver.glMinSampleShadingARB) {
    _driver.glMinSampleShadingARB(value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMinSampleShadingARB)(value);
}

// GL_ARB_sampler_objects

static void REGAL_CALL loader_glBindSampler(GLuint unit, GLuint sampler)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBindSampler, "glBindSampler");
  if (_driver.glBindSampler) {
    _driver.glBindSampler(unit, sampler);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBindSampler)(unit, sampler);
}

static void REGAL_CALL loader_glDeleteSamplers(GLsizei count, const GLuint *samplers)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDeleteSamplers, "glDeleteSamplers");
  if (_driver.glDeleteSamplers) {
    _driver.glDeleteSamplers(count, samplers);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDeleteSamplers)(count, samplers);
}

static void REGAL_CALL loader_glGenSamplers(GLsizei count, GLuint *samplers)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGenSamplers, "glGenSamplers");
  if (_driver.glGenSamplers) {
    _driver.glGenSamplers(count, samplers);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGenSamplers)(count, samplers);
}

static void REGAL_CALL loader_glGetSamplerParameterIiv(GLuint sampler, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetSamplerParameterIiv, "glGetSamplerParameterIiv");
  if (_driver.glGetSamplerParameterIiv) {
    _driver.glGetSamplerParameterIiv(sampler, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetSamplerParameterIiv)(sampler, pname, params);
}

static void REGAL_CALL loader_glGetSamplerParameterIuiv(GLuint sampler, GLenum pname, GLuint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetSamplerParameterIuiv, "glGetSamplerParameterIuiv");
  if (_driver.glGetSamplerParameterIuiv) {
    _driver.glGetSamplerParameterIuiv(sampler, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetSamplerParameterIuiv)(sampler, pname, params);
}

static void REGAL_CALL loader_glGetSamplerParameterfv(GLuint sampler, GLenum pname, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetSamplerParameterfv, "glGetSamplerParameterfv");
  if (_driver.glGetSamplerParameterfv) {
    _driver.glGetSamplerParameterfv(sampler, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetSamplerParameterfv)(sampler, pname, params);
}

static void REGAL_CALL loader_glGetSamplerParameteriv(GLuint sampler, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetSamplerParameteriv, "glGetSamplerParameteriv");
  if (_driver.glGetSamplerParameteriv) {
    _driver.glGetSamplerParameteriv(sampler, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetSamplerParameteriv)(sampler, pname, params);
}

static GLboolean REGAL_CALL loader_glIsSampler(GLuint sampler)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIsSampler, "glIsSampler");
  if (_driver.glIsSampler) {
    return _driver.glIsSampler(sampler);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glIsSampler)(sampler);
}

static void REGAL_CALL loader_glSamplerParameterIiv(GLuint sampler, GLenum pname, const GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSamplerParameterIiv, "glSamplerParameterIiv");
  if (_driver.glSamplerParameterIiv) {
    _driver.glSamplerParameterIiv(sampler, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSamplerParameterIiv)(sampler, pname, params);
}

static void REGAL_CALL loader_glSamplerParameterIuiv(GLuint sampler, GLenum pname, const GLuint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSamplerParameterIuiv, "glSamplerParameterIuiv");
  if (_driver.glSamplerParameterIuiv) {
    _driver.glSamplerParameterIuiv(sampler, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSamplerParameterIuiv)(sampler, pname, params);
}

static void REGAL_CALL loader_glSamplerParameterf(GLuint sampler, GLenum pname, GLfloat param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSamplerParameterf, "glSamplerParameterf");
  if (_driver.glSamplerParameterf) {
    _driver.glSamplerParameterf(sampler, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSamplerParameterf)(sampler, pname, param);
}

static void REGAL_CALL loader_glSamplerParameterfv(GLuint sampler, GLenum pname, const GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSamplerParameterfv, "glSamplerParameterfv");
  if (_driver.glSamplerParameterfv) {
    _driver.glSamplerParameterfv(sampler, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSamplerParameterfv)(sampler, pname, params);
}

static void REGAL_CALL loader_glSamplerParameteri(GLuint sampler, GLenum pname, GLint param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSamplerParameteri, "glSamplerParameteri");
  if (_driver.glSamplerParameteri) {
    _driver.glSamplerParameteri(sampler, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSamplerParameteri)(sampler, pname, param);
}

static void REGAL_CALL loader_glSamplerParameteriv(GLuint sampler, GLenum pname, const GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSamplerParameteriv, "glSamplerParameteriv");
  if (_driver.glSamplerParameteriv) {
    _driver.glSamplerParameteriv(sampler, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSamplerParameteriv)(sampler, pname, params);
}

// GL_ARB_separate_shader_objects

static void REGAL_CALL loader_glActiveShaderProgram(GLuint pipeline, GLuint program)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glActiveShaderProgram, "glActiveShaderProgram");
  if (_driver.glActiveShaderProgram) {
    _driver.glActiveShaderProgram(pipeline, program);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glActiveShaderProgram)(pipeline, program);
}

static void REGAL_CALL loader_glBindProgramPipeline(GLuint pipeline)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBindProgramPipeline, "glBindProgramPipeline");
  if (_driver.glBindProgramPipeline) {
    _driver.glBindProgramPipeline(pipeline);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBindProgramPipeline)(pipeline);
}

static GLuint REGAL_CALL loader_glCreateShaderProgramv(GLenum type, GLsizei count, const GLchar **strings)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCreateShaderProgramv, "glCreateShaderProgramv");
  if (_driver.glCreateShaderProgramv) {
    return _driver.glCreateShaderProgramv(type, count, strings);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glCreateShaderProgramv)(type, count, strings);
}

static void REGAL_CALL loader_glDeleteProgramPipelines(GLsizei n, const GLuint *pipelines)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDeleteProgramPipelines, "glDeleteProgramPipelines");
  if (_driver.glDeleteProgramPipelines) {
    _driver.glDeleteProgramPipelines(n, pipelines);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDeleteProgramPipelines)(n, pipelines);
}

static void REGAL_CALL loader_glGenProgramPipelines(GLsizei n, GLuint *pipelines)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGenProgramPipelines, "glGenProgramPipelines");
  if (_driver.glGenProgramPipelines) {
    _driver.glGenProgramPipelines(n, pipelines);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGenProgramPipelines)(n, pipelines);
}

static void REGAL_CALL loader_glGetProgramPipelineInfoLog(GLuint pipeline, GLsizei bufSize, GLsizei *length, GLchar *infoLog)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetProgramPipelineInfoLog, "glGetProgramPipelineInfoLog");
  if (_driver.glGetProgramPipelineInfoLog) {
    _driver.glGetProgramPipelineInfoLog(pipeline, bufSize, length, infoLog);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetProgramPipelineInfoLog)(pipeline, bufSize, length, infoLog);
}

static void REGAL_CALL loader_glGetProgramPipelineiv(GLuint pipeline, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetProgramPipelineiv, "glGetProgramPipelineiv");
  if (_driver.glGetProgramPipelineiv) {
    _driver.glGetProgramPipelineiv(pipeline, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetProgramPipelineiv)(pipeline, pname, params);
}

static GLboolean REGAL_CALL loader_glIsProgramPipeline(GLuint pipeline)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIsProgramPipeline, "glIsProgramPipeline");
  if (_driver.glIsProgramPipeline) {
    return _driver.glIsProgramPipeline(pipeline);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glIsProgramPipeline)(pipeline);
}

static void REGAL_CALL loader_glProgramUniform1d(GLuint program, GLint location, GLdouble x)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform1d, "glProgramUniform1d");
  if (_driver.glProgramUniform1d) {
    _driver.glProgramUniform1d(program, location, x);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform1d)(program, location, x);
}

static void REGAL_CALL loader_glProgramUniform1dv(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform1dv, "glProgramUniform1dv");
  if (_driver.glProgramUniform1dv) {
    _driver.glProgramUniform1dv(program, location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform1dv)(program, location, count, value);
}

static void REGAL_CALL loader_glProgramUniform1f(GLuint program, GLint location, GLfloat x)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform1f, "glProgramUniform1f");
  if (_driver.glProgramUniform1f) {
    _driver.glProgramUniform1f(program, location, x);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform1f)(program, location, x);
}

static void REGAL_CALL loader_glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform1fv, "glProgramUniform1fv");
  if (_driver.glProgramUniform1fv) {
    _driver.glProgramUniform1fv(program, location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform1fv)(program, location, count, value);
}

static void REGAL_CALL loader_glProgramUniform1i(GLuint program, GLint location, GLint x)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform1i, "glProgramUniform1i");
  if (_driver.glProgramUniform1i) {
    _driver.glProgramUniform1i(program, location, x);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform1i)(program, location, x);
}

static void REGAL_CALL loader_glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform1iv, "glProgramUniform1iv");
  if (_driver.glProgramUniform1iv) {
    _driver.glProgramUniform1iv(program, location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform1iv)(program, location, count, value);
}

static void REGAL_CALL loader_glProgramUniform1ui(GLuint program, GLint location, GLuint v0)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform1ui, "glProgramUniform1ui");
  if (_driver.glProgramUniform1ui) {
    _driver.glProgramUniform1ui(program, location, v0);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform1ui)(program, location, v0);
}

static void REGAL_CALL loader_glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform1uiv, "glProgramUniform1uiv");
  if (_driver.glProgramUniform1uiv) {
    _driver.glProgramUniform1uiv(program, location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform1uiv)(program, location, count, value);
}

static void REGAL_CALL loader_glProgramUniform2d(GLuint program, GLint location, GLdouble x, GLdouble y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform2d, "glProgramUniform2d");
  if (_driver.glProgramUniform2d) {
    _driver.glProgramUniform2d(program, location, x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform2d)(program, location, x, y);
}

static void REGAL_CALL loader_glProgramUniform2dv(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform2dv, "glProgramUniform2dv");
  if (_driver.glProgramUniform2dv) {
    _driver.glProgramUniform2dv(program, location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform2dv)(program, location, count, value);
}

static void REGAL_CALL loader_glProgramUniform2f(GLuint program, GLint location, GLfloat x, GLfloat y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform2f, "glProgramUniform2f");
  if (_driver.glProgramUniform2f) {
    _driver.glProgramUniform2f(program, location, x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform2f)(program, location, x, y);
}

static void REGAL_CALL loader_glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform2fv, "glProgramUniform2fv");
  if (_driver.glProgramUniform2fv) {
    _driver.glProgramUniform2fv(program, location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform2fv)(program, location, count, value);
}

static void REGAL_CALL loader_glProgramUniform2i(GLuint program, GLint location, GLint x, GLint y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform2i, "glProgramUniform2i");
  if (_driver.glProgramUniform2i) {
    _driver.glProgramUniform2i(program, location, x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform2i)(program, location, x, y);
}

static void REGAL_CALL loader_glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform2iv, "glProgramUniform2iv");
  if (_driver.glProgramUniform2iv) {
    _driver.glProgramUniform2iv(program, location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform2iv)(program, location, count, value);
}

static void REGAL_CALL loader_glProgramUniform2ui(GLuint program, GLint location, GLuint x, GLuint y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform2ui, "glProgramUniform2ui");
  if (_driver.glProgramUniform2ui) {
    _driver.glProgramUniform2ui(program, location, x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform2ui)(program, location, x, y);
}

static void REGAL_CALL loader_glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform2uiv, "glProgramUniform2uiv");
  if (_driver.glProgramUniform2uiv) {
    _driver.glProgramUniform2uiv(program, location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform2uiv)(program, location, count, value);
}

static void REGAL_CALL loader_glProgramUniform3d(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform3d, "glProgramUniform3d");
  if (_driver.glProgramUniform3d) {
    _driver.glProgramUniform3d(program, location, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform3d)(program, location, x, y, z);
}

static void REGAL_CALL loader_glProgramUniform3dv(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform3dv, "glProgramUniform3dv");
  if (_driver.glProgramUniform3dv) {
    _driver.glProgramUniform3dv(program, location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform3dv)(program, location, count, value);
}

static void REGAL_CALL loader_glProgramUniform3f(GLuint program, GLint location, GLfloat x, GLfloat y, GLfloat z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform3f, "glProgramUniform3f");
  if (_driver.glProgramUniform3f) {
    _driver.glProgramUniform3f(program, location, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform3f)(program, location, x, y, z);
}

static void REGAL_CALL loader_glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform3fv, "glProgramUniform3fv");
  if (_driver.glProgramUniform3fv) {
    _driver.glProgramUniform3fv(program, location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform3fv)(program, location, count, value);
}

static void REGAL_CALL loader_glProgramUniform3i(GLuint program, GLint location, GLint x, GLint y, GLint z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform3i, "glProgramUniform3i");
  if (_driver.glProgramUniform3i) {
    _driver.glProgramUniform3i(program, location, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform3i)(program, location, x, y, z);
}

static void REGAL_CALL loader_glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform3iv, "glProgramUniform3iv");
  if (_driver.glProgramUniform3iv) {
    _driver.glProgramUniform3iv(program, location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform3iv)(program, location, count, value);
}

static void REGAL_CALL loader_glProgramUniform3ui(GLuint program, GLint location, GLuint x, GLuint y, GLuint z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform3ui, "glProgramUniform3ui");
  if (_driver.glProgramUniform3ui) {
    _driver.glProgramUniform3ui(program, location, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform3ui)(program, location, x, y, z);
}

static void REGAL_CALL loader_glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform3uiv, "glProgramUniform3uiv");
  if (_driver.glProgramUniform3uiv) {
    _driver.glProgramUniform3uiv(program, location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform3uiv)(program, location, count, value);
}

static void REGAL_CALL loader_glProgramUniform4d(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform4d, "glProgramUniform4d");
  if (_driver.glProgramUniform4d) {
    _driver.glProgramUniform4d(program, location, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform4d)(program, location, x, y, z, w);
}

static void REGAL_CALL loader_glProgramUniform4dv(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform4dv, "glProgramUniform4dv");
  if (_driver.glProgramUniform4dv) {
    _driver.glProgramUniform4dv(program, location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform4dv)(program, location, count, value);
}

static void REGAL_CALL loader_glProgramUniform4f(GLuint program, GLint location, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform4f, "glProgramUniform4f");
  if (_driver.glProgramUniform4f) {
    _driver.glProgramUniform4f(program, location, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform4f)(program, location, x, y, z, w);
}

static void REGAL_CALL loader_glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform4fv, "glProgramUniform4fv");
  if (_driver.glProgramUniform4fv) {
    _driver.glProgramUniform4fv(program, location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform4fv)(program, location, count, value);
}

static void REGAL_CALL loader_glProgramUniform4i(GLuint program, GLint location, GLint x, GLint y, GLint z, GLint w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform4i, "glProgramUniform4i");
  if (_driver.glProgramUniform4i) {
    _driver.glProgramUniform4i(program, location, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform4i)(program, location, x, y, z, w);
}

static void REGAL_CALL loader_glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform4iv, "glProgramUniform4iv");
  if (_driver.glProgramUniform4iv) {
    _driver.glProgramUniform4iv(program, location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform4iv)(program, location, count, value);
}

static void REGAL_CALL loader_glProgramUniform4ui(GLuint program, GLint location, GLuint x, GLuint y, GLuint z, GLuint w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform4ui, "glProgramUniform4ui");
  if (_driver.glProgramUniform4ui) {
    _driver.glProgramUniform4ui(program, location, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform4ui)(program, location, x, y, z, w);
}

static void REGAL_CALL loader_glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform4uiv, "glProgramUniform4uiv");
  if (_driver.glProgramUniform4uiv) {
    _driver.glProgramUniform4uiv(program, location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform4uiv)(program, location, count, value);
}

static void REGAL_CALL loader_glProgramUniformMatrix2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniformMatrix2dv, "glProgramUniformMatrix2dv");
  if (_driver.glProgramUniformMatrix2dv) {
    _driver.glProgramUniformMatrix2dv(program, location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniformMatrix2dv)(program, location, count, transpose, value);
}

static void REGAL_CALL loader_glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniformMatrix2fv, "glProgramUniformMatrix2fv");
  if (_driver.glProgramUniformMatrix2fv) {
    _driver.glProgramUniformMatrix2fv(program, location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniformMatrix2fv)(program, location, count, transpose, value);
}

static void REGAL_CALL loader_glProgramUniformMatrix2x3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniformMatrix2x3dv, "glProgramUniformMatrix2x3dv");
  if (_driver.glProgramUniformMatrix2x3dv) {
    _driver.glProgramUniformMatrix2x3dv(program, location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniformMatrix2x3dv)(program, location, count, transpose, value);
}

static void REGAL_CALL loader_glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniformMatrix2x3fv, "glProgramUniformMatrix2x3fv");
  if (_driver.glProgramUniformMatrix2x3fv) {
    _driver.glProgramUniformMatrix2x3fv(program, location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniformMatrix2x3fv)(program, location, count, transpose, value);
}

static void REGAL_CALL loader_glProgramUniformMatrix2x4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniformMatrix2x4dv, "glProgramUniformMatrix2x4dv");
  if (_driver.glProgramUniformMatrix2x4dv) {
    _driver.glProgramUniformMatrix2x4dv(program, location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniformMatrix2x4dv)(program, location, count, transpose, value);
}

static void REGAL_CALL loader_glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniformMatrix2x4fv, "glProgramUniformMatrix2x4fv");
  if (_driver.glProgramUniformMatrix2x4fv) {
    _driver.glProgramUniformMatrix2x4fv(program, location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniformMatrix2x4fv)(program, location, count, transpose, value);
}

static void REGAL_CALL loader_glProgramUniformMatrix3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniformMatrix3dv, "glProgramUniformMatrix3dv");
  if (_driver.glProgramUniformMatrix3dv) {
    _driver.glProgramUniformMatrix3dv(program, location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniformMatrix3dv)(program, location, count, transpose, value);
}

static void REGAL_CALL loader_glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniformMatrix3fv, "glProgramUniformMatrix3fv");
  if (_driver.glProgramUniformMatrix3fv) {
    _driver.glProgramUniformMatrix3fv(program, location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniformMatrix3fv)(program, location, count, transpose, value);
}

static void REGAL_CALL loader_glProgramUniformMatrix3x2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniformMatrix3x2dv, "glProgramUniformMatrix3x2dv");
  if (_driver.glProgramUniformMatrix3x2dv) {
    _driver.glProgramUniformMatrix3x2dv(program, location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniformMatrix3x2dv)(program, location, count, transpose, value);
}

static void REGAL_CALL loader_glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniformMatrix3x2fv, "glProgramUniformMatrix3x2fv");
  if (_driver.glProgramUniformMatrix3x2fv) {
    _driver.glProgramUniformMatrix3x2fv(program, location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniformMatrix3x2fv)(program, location, count, transpose, value);
}

static void REGAL_CALL loader_glProgramUniformMatrix3x4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniformMatrix3x4dv, "glProgramUniformMatrix3x4dv");
  if (_driver.glProgramUniformMatrix3x4dv) {
    _driver.glProgramUniformMatrix3x4dv(program, location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniformMatrix3x4dv)(program, location, count, transpose, value);
}

static void REGAL_CALL loader_glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniformMatrix3x4fv, "glProgramUniformMatrix3x4fv");
  if (_driver.glProgramUniformMatrix3x4fv) {
    _driver.glProgramUniformMatrix3x4fv(program, location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniformMatrix3x4fv)(program, location, count, transpose, value);
}

static void REGAL_CALL loader_glProgramUniformMatrix4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniformMatrix4dv, "glProgramUniformMatrix4dv");
  if (_driver.glProgramUniformMatrix4dv) {
    _driver.glProgramUniformMatrix4dv(program, location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniformMatrix4dv)(program, location, count, transpose, value);
}

static void REGAL_CALL loader_glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniformMatrix4fv, "glProgramUniformMatrix4fv");
  if (_driver.glProgramUniformMatrix4fv) {
    _driver.glProgramUniformMatrix4fv(program, location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniformMatrix4fv)(program, location, count, transpose, value);
}

static void REGAL_CALL loader_glProgramUniformMatrix4x2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniformMatrix4x2dv, "glProgramUniformMatrix4x2dv");
  if (_driver.glProgramUniformMatrix4x2dv) {
    _driver.glProgramUniformMatrix4x2dv(program, location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniformMatrix4x2dv)(program, location, count, transpose, value);
}

static void REGAL_CALL loader_glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniformMatrix4x2fv, "glProgramUniformMatrix4x2fv");
  if (_driver.glProgramUniformMatrix4x2fv) {
    _driver.glProgramUniformMatrix4x2fv(program, location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniformMatrix4x2fv)(program, location, count, transpose, value);
}

static void REGAL_CALL loader_glProgramUniformMatrix4x3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniformMatrix4x3dv, "glProgramUniformMatrix4x3dv");
  if (_driver.glProgramUniformMatrix4x3dv) {
    _driver.glProgramUniformMatrix4x3dv(program, location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniformMatrix4x3dv)(program, location, count, transpose, value);
}

static void REGAL_CALL loader_glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniformMatrix4x3fv, "glProgramUniformMatrix4x3fv");
  if (_driver.glProgramUniformMatrix4x3fv) {
    _driver.glProgramUniformMatrix4x3fv(program, location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniformMatrix4x3fv)(program, location, count, transpose, value);
}

static void REGAL_CALL loader_glUseProgramStages(GLuint pipeline, GLbitfield stages, GLuint program)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUseProgramStages, "glUseProgramStages");
  if (_driver.glUseProgramStages) {
    _driver.glUseProgramStages(pipeline, stages, program);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUseProgramStages)(pipeline, stages, program);
}

static void REGAL_CALL loader_glValidateProgramPipeline(GLuint pipeline)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glValidateProgramPipeline, "glValidateProgramPipeline");
  if (_driver.glValidateProgramPipeline) {
    _driver.glValidateProgramPipeline(pipeline);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glValidateProgramPipeline)(pipeline);
}

// GL_ARB_shader_atomic_counters

static void REGAL_CALL loader_glGetActiveAtomicCounterBufferiv(GLuint program, GLuint bufferIndex, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetActiveAtomicCounterBufferiv, "glGetActiveAtomicCounterBufferiv");
  if (_driver.glGetActiveAtomicCounterBufferiv) {
    _driver.glGetActiveAtomicCounterBufferiv(program, bufferIndex, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetActiveAtomicCounterBufferiv)(program, bufferIndex, pname, params);
}

// GL_ARB_shader_image_load_store

static void REGAL_CALL loader_glBindImageTexture(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBindImageTexture, "glBindImageTexture");
  if (_driver.glBindImageTexture) {
    _driver.glBindImageTexture(unit, texture, level, layered, layer, access, format);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBindImageTexture)(unit, texture, level, layered, layer, access, format);
}

static void REGAL_CALL loader_glMemoryBarrier(GLbitfield barriers)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMemoryBarrier, "glMemoryBarrier");
  if (_driver.glMemoryBarrier) {
    _driver.glMemoryBarrier(barriers);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMemoryBarrier)(barriers);
}

// GL_ARB_shader_objects

static void REGAL_CALL loader_glAttachObjectARB(GLhandleARB containerObj, GLhandleARB obj)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glAttachObjectARB, "glAttachObjectARB");
  if (_driver.glAttachObjectARB) {
    _driver.glAttachObjectARB(containerObj, obj);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glAttachObjectARB)(containerObj, obj);
}

static void REGAL_CALL loader_glCompileShaderARB(GLhandleARB shaderObj)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCompileShaderARB, "glCompileShaderARB");
  if (_driver.glCompileShaderARB) {
    _driver.glCompileShaderARB(shaderObj);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCompileShaderARB)(shaderObj);
}

static GLhandleARB REGAL_CALL loader_glCreateProgramObjectARB(void)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCreateProgramObjectARB, "glCreateProgramObjectARB");
  if (_driver.glCreateProgramObjectARB) {
    return _driver.glCreateProgramObjectARB();
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glCreateProgramObjectARB)();
}

static GLhandleARB REGAL_CALL loader_glCreateShaderObjectARB(GLenum shaderType)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCreateShaderObjectARB, "glCreateShaderObjectARB");
  if (_driver.glCreateShaderObjectARB) {
    return _driver.glCreateShaderObjectARB(shaderType);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glCreateShaderObjectARB)(shaderType);
}

static void REGAL_CALL loader_glDeleteObjectARB(GLhandleARB obj)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDeleteObjectARB, "glDeleteObjectARB");
  if (_driver.glDeleteObjectARB) {
    _driver.glDeleteObjectARB(obj);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDeleteObjectARB)(obj);
}

static void REGAL_CALL loader_glDetachObjectARB(GLhandleARB containerObj, GLhandleARB attachedObj)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDetachObjectARB, "glDetachObjectARB");
  if (_driver.glDetachObjectARB) {
    _driver.glDetachObjectARB(containerObj, attachedObj);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDetachObjectARB)(containerObj, attachedObj);
}

static void REGAL_CALL loader_glGetActiveUniformARB(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetActiveUniformARB, "glGetActiveUniformARB");
  if (_driver.glGetActiveUniformARB) {
    _driver.glGetActiveUniformARB(programObj, index, maxLength, length, size, type, name);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetActiveUniformARB)(programObj, index, maxLength, length, size, type, name);
}

static void REGAL_CALL loader_glGetAttachedObjectsARB(GLhandleARB containerObj, GLsizei maxCount, GLsizei *count, GLhandleARB *obj)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetAttachedObjectsARB, "glGetAttachedObjectsARB");
  if (_driver.glGetAttachedObjectsARB) {
    _driver.glGetAttachedObjectsARB(containerObj, maxCount, count, obj);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetAttachedObjectsARB)(containerObj, maxCount, count, obj);
}

static GLhandleARB REGAL_CALL loader_glGetHandleARB(GLenum pname)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetHandleARB, "glGetHandleARB");
  if (_driver.glGetHandleARB) {
    return _driver.glGetHandleARB(pname);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glGetHandleARB)(pname);
}

static void REGAL_CALL loader_glGetInfoLogARB(GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *infoLog)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetInfoLogARB, "glGetInfoLogARB");
  if (_driver.glGetInfoLogARB) {
    _driver.glGetInfoLogARB(obj, maxLength, length, infoLog);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetInfoLogARB)(obj, maxLength, length, infoLog);
}

static void REGAL_CALL loader_glGetObjectParameterfvARB(GLhandleARB obj, GLenum pname, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetObjectParameterfvARB, "glGetObjectParameterfvARB");
  if (_driver.glGetObjectParameterfvARB) {
    _driver.glGetObjectParameterfvARB(obj, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetObjectParameterfvARB)(obj, pname, params);
}

static void REGAL_CALL loader_glGetObjectParameterivARB(GLhandleARB obj, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetObjectParameterivARB, "glGetObjectParameterivARB");
  if (_driver.glGetObjectParameterivARB) {
    _driver.glGetObjectParameterivARB(obj, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetObjectParameterivARB)(obj, pname, params);
}

static void REGAL_CALL loader_glGetShaderSourceARB(GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *source)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetShaderSourceARB, "glGetShaderSourceARB");
  if (_driver.glGetShaderSourceARB) {
    _driver.glGetShaderSourceARB(obj, maxLength, length, source);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetShaderSourceARB)(obj, maxLength, length, source);
}

static GLint REGAL_CALL loader_glGetUniformLocationARB(GLhandleARB programObj, const GLcharARB *name)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetUniformLocationARB, "glGetUniformLocationARB");
  if (_driver.glGetUniformLocationARB) {
    return _driver.glGetUniformLocationARB(programObj, name);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glGetUniformLocationARB)(programObj, name);
}

static void REGAL_CALL loader_glGetUniformfvARB(GLhandleARB programObj, GLint location, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetUniformfvARB, "glGetUniformfvARB");
  if (_driver.glGetUniformfvARB) {
    _driver.glGetUniformfvARB(programObj, location, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetUniformfvARB)(programObj, location, params);
}

static void REGAL_CALL loader_glGetUniformivARB(GLhandleARB programObj, GLint location, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetUniformivARB, "glGetUniformivARB");
  if (_driver.glGetUniformivARB) {
    _driver.glGetUniformivARB(programObj, location, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetUniformivARB)(programObj, location, params);
}

static void REGAL_CALL loader_glLinkProgramARB(GLhandleARB programObj)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glLinkProgramARB, "glLinkProgramARB");
  if (_driver.glLinkProgramARB) {
    _driver.glLinkProgramARB(programObj);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glLinkProgramARB)(programObj);
}

static void REGAL_CALL loader_glShaderSourceARB(GLhandleARB shaderObj, GLsizei count, const GLcharARB **string, const GLint *length)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glShaderSourceARB, "glShaderSourceARB");
  if (_driver.glShaderSourceARB) {
    _driver.glShaderSourceARB(shaderObj, count, string, length);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glShaderSourceARB)(shaderObj, count, string, length);
}

static void REGAL_CALL loader_glUniform1fARB(GLint location, GLfloat v0)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform1fARB, "glUniform1fARB");
  if (_driver.glUniform1fARB) {
    _driver.glUniform1fARB(location, v0);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform1fARB)(location, v0);
}

static void REGAL_CALL loader_glUniform1fvARB(GLint location, GLsizei count, const GLfloat *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform1fvARB, "glUniform1fvARB");
  if (_driver.glUniform1fvARB) {
    _driver.glUniform1fvARB(location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform1fvARB)(location, count, value);
}

static void REGAL_CALL loader_glUniform1iARB(GLint location, GLint v0)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform1iARB, "glUniform1iARB");
  if (_driver.glUniform1iARB) {
    _driver.glUniform1iARB(location, v0);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform1iARB)(location, v0);
}

static void REGAL_CALL loader_glUniform1ivARB(GLint location, GLsizei count, const GLint *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform1ivARB, "glUniform1ivARB");
  if (_driver.glUniform1ivARB) {
    _driver.glUniform1ivARB(location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform1ivARB)(location, count, value);
}

static void REGAL_CALL loader_glUniform2fARB(GLint location, GLfloat v0, GLfloat v1)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform2fARB, "glUniform2fARB");
  if (_driver.glUniform2fARB) {
    _driver.glUniform2fARB(location, v0, v1);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform2fARB)(location, v0, v1);
}

static void REGAL_CALL loader_glUniform2fvARB(GLint location, GLsizei count, const GLfloat *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform2fvARB, "glUniform2fvARB");
  if (_driver.glUniform2fvARB) {
    _driver.glUniform2fvARB(location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform2fvARB)(location, count, value);
}

static void REGAL_CALL loader_glUniform2iARB(GLint location, GLint v0, GLint v1)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform2iARB, "glUniform2iARB");
  if (_driver.glUniform2iARB) {
    _driver.glUniform2iARB(location, v0, v1);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform2iARB)(location, v0, v1);
}

static void REGAL_CALL loader_glUniform2ivARB(GLint location, GLsizei count, const GLint *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform2ivARB, "glUniform2ivARB");
  if (_driver.glUniform2ivARB) {
    _driver.glUniform2ivARB(location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform2ivARB)(location, count, value);
}

static void REGAL_CALL loader_glUniform3fARB(GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform3fARB, "glUniform3fARB");
  if (_driver.glUniform3fARB) {
    _driver.glUniform3fARB(location, v0, v1, v2);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform3fARB)(location, v0, v1, v2);
}

static void REGAL_CALL loader_glUniform3fvARB(GLint location, GLsizei count, const GLfloat *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform3fvARB, "glUniform3fvARB");
  if (_driver.glUniform3fvARB) {
    _driver.glUniform3fvARB(location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform3fvARB)(location, count, value);
}

static void REGAL_CALL loader_glUniform3iARB(GLint location, GLint v0, GLint v1, GLint v2)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform3iARB, "glUniform3iARB");
  if (_driver.glUniform3iARB) {
    _driver.glUniform3iARB(location, v0, v1, v2);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform3iARB)(location, v0, v1, v2);
}

static void REGAL_CALL loader_glUniform3ivARB(GLint location, GLsizei count, const GLint *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform3ivARB, "glUniform3ivARB");
  if (_driver.glUniform3ivARB) {
    _driver.glUniform3ivARB(location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform3ivARB)(location, count, value);
}

static void REGAL_CALL loader_glUniform4fARB(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform4fARB, "glUniform4fARB");
  if (_driver.glUniform4fARB) {
    _driver.glUniform4fARB(location, v0, v1, v2, v3);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform4fARB)(location, v0, v1, v2, v3);
}

static void REGAL_CALL loader_glUniform4fvARB(GLint location, GLsizei count, const GLfloat *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform4fvARB, "glUniform4fvARB");
  if (_driver.glUniform4fvARB) {
    _driver.glUniform4fvARB(location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform4fvARB)(location, count, value);
}

static void REGAL_CALL loader_glUniform4iARB(GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform4iARB, "glUniform4iARB");
  if (_driver.glUniform4iARB) {
    _driver.glUniform4iARB(location, v0, v1, v2, v3);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform4iARB)(location, v0, v1, v2, v3);
}

static void REGAL_CALL loader_glUniform4ivARB(GLint location, GLsizei count, const GLint *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform4ivARB, "glUniform4ivARB");
  if (_driver.glUniform4ivARB) {
    _driver.glUniform4ivARB(location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform4ivARB)(location, count, value);
}

static void REGAL_CALL loader_glUniformMatrix2fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniformMatrix2fvARB, "glUniformMatrix2fvARB");
  if (_driver.glUniformMatrix2fvARB) {
    _driver.glUniformMatrix2fvARB(location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniformMatrix2fvARB)(location, count, transpose, value);
}

static void REGAL_CALL loader_glUniformMatrix3fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniformMatrix3fvARB, "glUniformMatrix3fvARB");
  if (_driver.glUniformMatrix3fvARB) {
    _driver.glUniformMatrix3fvARB(location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniformMatrix3fvARB)(location, count, transpose, value);
}

static void REGAL_CALL loader_glUniformMatrix4fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniformMatrix4fvARB, "glUniformMatrix4fvARB");
  if (_driver.glUniformMatrix4fvARB) {
    _driver.glUniformMatrix4fvARB(location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniformMatrix4fvARB)(location, count, transpose, value);
}

static void REGAL_CALL loader_glUseProgramObjectARB(GLhandleARB programObj)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUseProgramObjectARB, "glUseProgramObjectARB");
  if (_driver.glUseProgramObjectARB) {
    _driver.glUseProgramObjectARB(programObj);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUseProgramObjectARB)(programObj);
}

static void REGAL_CALL loader_glValidateProgramARB(GLhandleARB programObj)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glValidateProgramARB, "glValidateProgramARB");
  if (_driver.glValidateProgramARB) {
    _driver.glValidateProgramARB(programObj);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glValidateProgramARB)(programObj);
}

// GL_ARB_shader_storage_buffer_object

static void REGAL_CALL loader_glShaderStorageBlockBinding(GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glShaderStorageBlockBinding, "glShaderStorageBlockBinding");
  if (_driver.glShaderStorageBlockBinding) {
    _driver.glShaderStorageBlockBinding(program, storageBlockIndex, storageBlockBinding);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glShaderStorageBlockBinding)(program, storageBlockIndex, storageBlockBinding);
}

// GL_ARB_shader_subroutine

static void REGAL_CALL loader_glGetActiveSubroutineName(GLuint program, GLenum shaderType, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetActiveSubroutineName, "glGetActiveSubroutineName");
  if (_driver.glGetActiveSubroutineName) {
    _driver.glGetActiveSubroutineName(program, shaderType, index, bufSize, length, name);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetActiveSubroutineName)(program, shaderType, index, bufSize, length, name);
}

static void REGAL_CALL loader_glGetActiveSubroutineUniformName(GLuint program, GLenum shaderType, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetActiveSubroutineUniformName, "glGetActiveSubroutineUniformName");
  if (_driver.glGetActiveSubroutineUniformName) {
    _driver.glGetActiveSubroutineUniformName(program, shaderType, index, bufSize, length, name);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetActiveSubroutineUniformName)(program, shaderType, index, bufSize, length, name);
}

static void REGAL_CALL loader_glGetActiveSubroutineUniformiv(GLuint program, GLenum shaderType, GLuint index, GLenum pname, GLint *values)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetActiveSubroutineUniformiv, "glGetActiveSubroutineUniformiv");
  if (_driver.glGetActiveSubroutineUniformiv) {
    _driver.glGetActiveSubroutineUniformiv(program, shaderType, index, pname, values);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetActiveSubroutineUniformiv)(program, shaderType, index, pname, values);
}

static void REGAL_CALL loader_glGetProgramStageiv(GLuint program, GLenum shaderType, GLenum pname, GLint *values)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetProgramStageiv, "glGetProgramStageiv");
  if (_driver.glGetProgramStageiv) {
    _driver.glGetProgramStageiv(program, shaderType, pname, values);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetProgramStageiv)(program, shaderType, pname, values);
}

static GLuint REGAL_CALL loader_glGetSubroutineIndex(GLuint program, GLenum shaderType, const GLchar *name)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetSubroutineIndex, "glGetSubroutineIndex");
  if (_driver.glGetSubroutineIndex) {
    return _driver.glGetSubroutineIndex(program, shaderType, name);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glGetSubroutineIndex)(program, shaderType, name);
}

static GLint REGAL_CALL loader_glGetSubroutineUniformLocation(GLuint program, GLenum shaderType, const GLchar *name)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetSubroutineUniformLocation, "glGetSubroutineUniformLocation");
  if (_driver.glGetSubroutineUniformLocation) {
    return _driver.glGetSubroutineUniformLocation(program, shaderType, name);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glGetSubroutineUniformLocation)(program, shaderType, name);
}

static void REGAL_CALL loader_glGetUniformSubroutineuiv(GLenum shaderType, GLint location, GLuint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetUniformSubroutineuiv, "glGetUniformSubroutineuiv");
  if (_driver.glGetUniformSubroutineuiv) {
    _driver.glGetUniformSubroutineuiv(shaderType, location, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetUniformSubroutineuiv)(shaderType, location, params);
}

static void REGAL_CALL loader_glUniformSubroutinesuiv(GLenum shaderType, GLsizei count, const GLuint *indices)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniformSubroutinesuiv, "glUniformSubroutinesuiv");
  if (_driver.glUniformSubroutinesuiv) {
    _driver.glUniformSubroutinesuiv(shaderType, count, indices);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniformSubroutinesuiv)(shaderType, count, indices);
}

// GL_ARB_shading_language_include

static void REGAL_CALL loader_glCompileShaderIncludeARB(GLuint shader, GLsizei count, const GLchar **path, const GLint *length)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCompileShaderIncludeARB, "glCompileShaderIncludeARB");
  if (_driver.glCompileShaderIncludeARB) {
    _driver.glCompileShaderIncludeARB(shader, count, path, length);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCompileShaderIncludeARB)(shader, count, path, length);
}

static void REGAL_CALL loader_glDeleteNamedStringARB(GLint namelen, const GLchar *name)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDeleteNamedStringARB, "glDeleteNamedStringARB");
  if (_driver.glDeleteNamedStringARB) {
    _driver.glDeleteNamedStringARB(namelen, name);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDeleteNamedStringARB)(namelen, name);
}

static void REGAL_CALL loader_glGetNamedStringARB(GLint namelen, const GLchar *name, GLsizei bufSize, GLint *stringlen, GLchar *string)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetNamedStringARB, "glGetNamedStringARB");
  if (_driver.glGetNamedStringARB) {
    _driver.glGetNamedStringARB(namelen, name, bufSize, stringlen, string);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetNamedStringARB)(namelen, name, bufSize, stringlen, string);
}

static void REGAL_CALL loader_glGetNamedStringivARB(GLint namelen, const GLchar *name, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetNamedStringivARB, "glGetNamedStringivARB");
  if (_driver.glGetNamedStringivARB) {
    _driver.glGetNamedStringivARB(namelen, name, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetNamedStringivARB)(namelen, name, pname, params);
}

static GLboolean REGAL_CALL loader_glIsNamedStringARB(GLint namelen, const GLchar *name)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIsNamedStringARB, "glIsNamedStringARB");
  if (_driver.glIsNamedStringARB) {
    return _driver.glIsNamedStringARB(namelen, name);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glIsNamedStringARB)(namelen, name);
}

static void REGAL_CALL loader_glNamedStringARB(GLenum type, GLint namelen, const GLchar *name, GLint stringlen, const GLchar *string)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNamedStringARB, "glNamedStringARB");
  if (_driver.glNamedStringARB) {
    _driver.glNamedStringARB(type, namelen, name, stringlen, string);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNamedStringARB)(type, namelen, name, stringlen, string);
}

// GL_ARB_sync

static GLenum REGAL_CALL loader_glClientWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glClientWaitSync, "glClientWaitSync");
  if (_driver.glClientWaitSync) {
    return _driver.glClientWaitSync(sync, flags, timeout);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glClientWaitSync)(sync, flags, timeout);
}

static void REGAL_CALL loader_glDeleteSync(GLsync sync)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDeleteSync, "glDeleteSync");
  if (_driver.glDeleteSync) {
    _driver.glDeleteSync(sync);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDeleteSync)(sync);
}

static GLsync REGAL_CALL loader_glFenceSync(GLenum condition, GLbitfield flags)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFenceSync, "glFenceSync");
  if (_driver.glFenceSync) {
    return _driver.glFenceSync(condition, flags);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glFenceSync)(condition, flags);
}

static void REGAL_CALL loader_glGetInteger64v(GLenum pname, GLint64 *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetInteger64v, "glGetInteger64v");
  if (_driver.glGetInteger64v) {
    _driver.glGetInteger64v(pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetInteger64v)(pname, params);
}

static void REGAL_CALL loader_glGetSynciv(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetSynciv, "glGetSynciv");
  if (_driver.glGetSynciv) {
    _driver.glGetSynciv(sync, pname, bufSize, length, values);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetSynciv)(sync, pname, bufSize, length, values);
}

static GLboolean REGAL_CALL loader_glIsSync(GLsync sync)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIsSync, "glIsSync");
  if (_driver.glIsSync) {
    return _driver.glIsSync(sync);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glIsSync)(sync);
}

static void REGAL_CALL loader_glWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWaitSync, "glWaitSync");
  if (_driver.glWaitSync) {
    _driver.glWaitSync(sync, flags, timeout);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWaitSync)(sync, flags, timeout);
}

// GL_ARB_tessellation_shader

static void REGAL_CALL loader_glPatchParameterfv(GLenum pname, const GLfloat *values)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPatchParameterfv, "glPatchParameterfv");
  if (_driver.glPatchParameterfv) {
    _driver.glPatchParameterfv(pname, values);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPatchParameterfv)(pname, values);
}

static void REGAL_CALL loader_glPatchParameteri(GLenum pname, GLint value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPatchParameteri, "glPatchParameteri");
  if (_driver.glPatchParameteri) {
    _driver.glPatchParameteri(pname, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPatchParameteri)(pname, value);
}

// GL_ARB_texture_buffer_object

static void REGAL_CALL loader_glTexBufferARB(GLenum target, GLenum internalformat, GLuint buffer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexBufferARB, "glTexBufferARB");
  if (_driver.glTexBufferARB) {
    _driver.glTexBufferARB(target, internalformat, buffer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexBufferARB)(target, internalformat, buffer);
}

// GL_ARB_texture_buffer_range

static void REGAL_CALL loader_glTexBufferRange(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexBufferRange, "glTexBufferRange");
  if (_driver.glTexBufferRange) {
    _driver.glTexBufferRange(target, internalformat, buffer, offset, size);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexBufferRange)(target, internalformat, buffer, offset, size);
}

static void REGAL_CALL loader_glTextureBufferRangeEXT(GLuint texture, GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTextureBufferRangeEXT, "glTextureBufferRangeEXT");
  if (_driver.glTextureBufferRangeEXT) {
    _driver.glTextureBufferRangeEXT(texture, target, internalformat, buffer, offset, size);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTextureBufferRangeEXT)(texture, target, internalformat, buffer, offset, size);
}

// GL_ARB_texture_compression

static void REGAL_CALL loader_glCompressedTexImage1DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCompressedTexImage1DARB, "glCompressedTexImage1DARB");
  if (_driver.glCompressedTexImage1DARB) {
    _driver.glCompressedTexImage1DARB(target, level, internalformat, width, border, imageSize, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCompressedTexImage1DARB)(target, level, internalformat, width, border, imageSize, data);
}

static void REGAL_CALL loader_glCompressedTexImage2DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCompressedTexImage2DARB, "glCompressedTexImage2DARB");
  if (_driver.glCompressedTexImage2DARB) {
    _driver.glCompressedTexImage2DARB(target, level, internalformat, width, height, border, imageSize, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCompressedTexImage2DARB)(target, level, internalformat, width, height, border, imageSize, data);
}

static void REGAL_CALL loader_glCompressedTexImage3DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCompressedTexImage3DARB, "glCompressedTexImage3DARB");
  if (_driver.glCompressedTexImage3DARB) {
    _driver.glCompressedTexImage3DARB(target, level, internalformat, width, height, depth, border, imageSize, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCompressedTexImage3DARB)(target, level, internalformat, width, height, depth, border, imageSize, data);
}

static void REGAL_CALL loader_glCompressedTexSubImage1DARB(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCompressedTexSubImage1DARB, "glCompressedTexSubImage1DARB");
  if (_driver.glCompressedTexSubImage1DARB) {
    _driver.glCompressedTexSubImage1DARB(target, level, xoffset, width, format, imageSize, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCompressedTexSubImage1DARB)(target, level, xoffset, width, format, imageSize, data);
}

static void REGAL_CALL loader_glCompressedTexSubImage2DARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCompressedTexSubImage2DARB, "glCompressedTexSubImage2DARB");
  if (_driver.glCompressedTexSubImage2DARB) {
    _driver.glCompressedTexSubImage2DARB(target, level, xoffset, yoffset, width, height, format, imageSize, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCompressedTexSubImage2DARB)(target, level, xoffset, yoffset, width, height, format, imageSize, data);
}

static void REGAL_CALL loader_glCompressedTexSubImage3DARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCompressedTexSubImage3DARB, "glCompressedTexSubImage3DARB");
  if (_driver.glCompressedTexSubImage3DARB) {
    _driver.glCompressedTexSubImage3DARB(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCompressedTexSubImage3DARB)(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
}

static void REGAL_CALL loader_glGetCompressedTexImageARB(GLenum target, GLint lod, GLvoid *img)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetCompressedTexImageARB, "glGetCompressedTexImageARB");
  if (_driver.glGetCompressedTexImageARB) {
    _driver.glGetCompressedTexImageARB(target, lod, img);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetCompressedTexImageARB)(target, lod, img);
}

// GL_ARB_texture_multisample

static void REGAL_CALL loader_glGetMultisamplefv(GLenum pname, GLuint index, GLfloat *val)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetMultisamplefv, "glGetMultisamplefv");
  if (_driver.glGetMultisamplefv) {
    _driver.glGetMultisamplefv(pname, index, val);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetMultisamplefv)(pname, index, val);
}

static void REGAL_CALL loader_glSampleMaski(GLuint index, GLbitfield mask)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSampleMaski, "glSampleMaski");
  if (_driver.glSampleMaski) {
    _driver.glSampleMaski(index, mask);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSampleMaski)(index, mask);
}

static void REGAL_CALL loader_glTexImage2DMultisample(GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexImage2DMultisample, "glTexImage2DMultisample");
  if (_driver.glTexImage2DMultisample) {
    _driver.glTexImage2DMultisample(target, samples, internalformat, width, height, fixedsamplelocations);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexImage2DMultisample)(target, samples, internalformat, width, height, fixedsamplelocations);
}

static void REGAL_CALL loader_glTexImage3DMultisample(GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexImage3DMultisample, "glTexImage3DMultisample");
  if (_driver.glTexImage3DMultisample) {
    _driver.glTexImage3DMultisample(target, samples, internalformat, width, height, depth, fixedsamplelocations);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexImage3DMultisample)(target, samples, internalformat, width, height, depth, fixedsamplelocations);
}

// GL_ARB_texture_storage

static void REGAL_CALL loader_glTexStorage1D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexStorage1D, "glTexStorage1D");
  if (_driver.glTexStorage1D) {
    _driver.glTexStorage1D(target, levels, internalformat, width);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexStorage1D)(target, levels, internalformat, width);
}

static void REGAL_CALL loader_glTexStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexStorage2D, "glTexStorage2D");
  if (_driver.glTexStorage2D) {
    _driver.glTexStorage2D(target, levels, internalformat, width, height);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexStorage2D)(target, levels, internalformat, width, height);
}

static void REGAL_CALL loader_glTexStorage3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexStorage3D, "glTexStorage3D");
  if (_driver.glTexStorage3D) {
    _driver.glTexStorage3D(target, levels, internalformat, width, height, depth);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexStorage3D)(target, levels, internalformat, width, height, depth);
}

static void REGAL_CALL loader_glTextureStorage1DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTextureStorage1DEXT, "glTextureStorage1DEXT");
  if (_driver.glTextureStorage1DEXT) {
    _driver.glTextureStorage1DEXT(texture, target, levels, internalformat, width);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTextureStorage1DEXT)(texture, target, levels, internalformat, width);
}

static void REGAL_CALL loader_glTextureStorage2DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTextureStorage2DEXT, "glTextureStorage2DEXT");
  if (_driver.glTextureStorage2DEXT) {
    _driver.glTextureStorage2DEXT(texture, target, levels, internalformat, width, height);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTextureStorage2DEXT)(texture, target, levels, internalformat, width, height);
}

static void REGAL_CALL loader_glTextureStorage3DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTextureStorage3DEXT, "glTextureStorage3DEXT");
  if (_driver.glTextureStorage3DEXT) {
    _driver.glTextureStorage3DEXT(texture, target, levels, internalformat, width, height, depth);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTextureStorage3DEXT)(texture, target, levels, internalformat, width, height, depth);
}

// GL_ARB_texture_storage_multisample

static void REGAL_CALL loader_glTexStorage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexStorage2DMultisample, "glTexStorage2DMultisample");
  if (_driver.glTexStorage2DMultisample) {
    _driver.glTexStorage2DMultisample(target, samples, internalformat, width, height, fixedsamplelocations);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexStorage2DMultisample)(target, samples, internalformat, width, height, fixedsamplelocations);
}

static void REGAL_CALL loader_glTexStorage3DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexStorage3DMultisample, "glTexStorage3DMultisample");
  if (_driver.glTexStorage3DMultisample) {
    _driver.glTexStorage3DMultisample(target, samples, internalformat, width, height, depth, fixedsamplelocations);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexStorage3DMultisample)(target, samples, internalformat, width, height, depth, fixedsamplelocations);
}

static void REGAL_CALL loader_glTextureStorage2DMultisampleEXT(GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTextureStorage2DMultisampleEXT, "glTextureStorage2DMultisampleEXT");
  if (_driver.glTextureStorage2DMultisampleEXT) {
    _driver.glTextureStorage2DMultisampleEXT(texture, target, samples, internalformat, width, height, fixedsamplelocations);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTextureStorage2DMultisampleEXT)(texture, target, samples, internalformat, width, height, fixedsamplelocations);
}

static void REGAL_CALL loader_glTextureStorage3DMultisampleEXT(GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTextureStorage3DMultisampleEXT, "glTextureStorage3DMultisampleEXT");
  if (_driver.glTextureStorage3DMultisampleEXT) {
    _driver.glTextureStorage3DMultisampleEXT(texture, target, samples, internalformat, width, height, depth, fixedsamplelocations);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTextureStorage3DMultisampleEXT)(texture, target, samples, internalformat, width, height, depth, fixedsamplelocations);
}

// GL_ARB_texture_view

static void REGAL_CALL loader_glTextureView(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTextureView, "glTextureView");
  if (_driver.glTextureView) {
    _driver.glTextureView(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTextureView)(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
}

// GL_ARB_timer_query

static void REGAL_CALL loader_glGetQueryObjecti64v(GLuint id, GLenum pname, GLint64 *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetQueryObjecti64v, "glGetQueryObjecti64v");
  if (_driver.glGetQueryObjecti64v) {
    _driver.glGetQueryObjecti64v(id, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetQueryObjecti64v)(id, pname, params);
}

static void REGAL_CALL loader_glGetQueryObjectui64v(GLuint id, GLenum pname, GLuint64 *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetQueryObjectui64v, "glGetQueryObjectui64v");
  if (_driver.glGetQueryObjectui64v) {
    _driver.glGetQueryObjectui64v(id, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetQueryObjectui64v)(id, pname, params);
}

static void REGAL_CALL loader_glQueryCounter(GLuint id, GLenum target)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glQueryCounter, "glQueryCounter");
  if (_driver.glQueryCounter) {
    _driver.glQueryCounter(id, target);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glQueryCounter)(id, target);
}

// GL_ARB_transform_feedback2

static void REGAL_CALL loader_glBindTransformFeedback(GLenum target, GLuint id)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBindTransformFeedback, "glBindTransformFeedback");
  if (_driver.glBindTransformFeedback) {
    _driver.glBindTransformFeedback(target, id);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBindTransformFeedback)(target, id);
}

static void REGAL_CALL loader_glDeleteTransformFeedbacks(GLsizei n, const GLuint *ids)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDeleteTransformFeedbacks, "glDeleteTransformFeedbacks");
  if (_driver.glDeleteTransformFeedbacks) {
    _driver.glDeleteTransformFeedbacks(n, ids);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDeleteTransformFeedbacks)(n, ids);
}

static void REGAL_CALL loader_glDrawTransformFeedback(GLenum mode, GLuint name)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDrawTransformFeedback, "glDrawTransformFeedback");
  if (_driver.glDrawTransformFeedback) {
    _driver.glDrawTransformFeedback(mode, name);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDrawTransformFeedback)(mode, name);
}

static void REGAL_CALL loader_glGenTransformFeedbacks(GLsizei n, GLuint *ids)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGenTransformFeedbacks, "glGenTransformFeedbacks");
  if (_driver.glGenTransformFeedbacks) {
    _driver.glGenTransformFeedbacks(n, ids);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGenTransformFeedbacks)(n, ids);
}

static GLboolean REGAL_CALL loader_glIsTransformFeedback(GLuint id)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIsTransformFeedback, "glIsTransformFeedback");
  if (_driver.glIsTransformFeedback) {
    return _driver.glIsTransformFeedback(id);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glIsTransformFeedback)(id);
}

static void REGAL_CALL loader_glPauseTransformFeedback(void)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPauseTransformFeedback, "glPauseTransformFeedback");
  if (_driver.glPauseTransformFeedback) {
    _driver.glPauseTransformFeedback();
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPauseTransformFeedback)();
}

static void REGAL_CALL loader_glResumeTransformFeedback(void)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glResumeTransformFeedback, "glResumeTransformFeedback");
  if (_driver.glResumeTransformFeedback) {
    _driver.glResumeTransformFeedback();
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glResumeTransformFeedback)();
}

// GL_ARB_transform_feedback3

static void REGAL_CALL loader_glBeginQueryIndexed(GLenum target, GLuint index, GLuint id)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBeginQueryIndexed, "glBeginQueryIndexed");
  if (_driver.glBeginQueryIndexed) {
    _driver.glBeginQueryIndexed(target, index, id);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBeginQueryIndexed)(target, index, id);
}

static void REGAL_CALL loader_glDrawTransformFeedbackStream(GLenum mode, GLuint id, GLuint stream)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDrawTransformFeedbackStream, "glDrawTransformFeedbackStream");
  if (_driver.glDrawTransformFeedbackStream) {
    _driver.glDrawTransformFeedbackStream(mode, id, stream);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDrawTransformFeedbackStream)(mode, id, stream);
}

static void REGAL_CALL loader_glEndQueryIndexed(GLenum target, GLuint index)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glEndQueryIndexed, "glEndQueryIndexed");
  if (_driver.glEndQueryIndexed) {
    _driver.glEndQueryIndexed(target, index);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glEndQueryIndexed)(target, index);
}

static void REGAL_CALL loader_glGetQueryIndexediv(GLenum target, GLuint index, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetQueryIndexediv, "glGetQueryIndexediv");
  if (_driver.glGetQueryIndexediv) {
    _driver.glGetQueryIndexediv(target, index, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetQueryIndexediv)(target, index, pname, params);
}

// GL_ARB_transform_feedback_instanced

static void REGAL_CALL loader_glDrawTransformFeedbackInstanced(GLenum mode, GLuint id, GLsizei primcount)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDrawTransformFeedbackInstanced, "glDrawTransformFeedbackInstanced");
  if (_driver.glDrawTransformFeedbackInstanced) {
    _driver.glDrawTransformFeedbackInstanced(mode, id, primcount);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDrawTransformFeedbackInstanced)(mode, id, primcount);
}

static void REGAL_CALL loader_glDrawTransformFeedbackStreamInstanced(GLenum mode, GLuint id, GLuint stream, GLsizei primcount)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDrawTransformFeedbackStreamInstanced, "glDrawTransformFeedbackStreamInstanced");
  if (_driver.glDrawTransformFeedbackStreamInstanced) {
    _driver.glDrawTransformFeedbackStreamInstanced(mode, id, stream, primcount);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDrawTransformFeedbackStreamInstanced)(mode, id, stream, primcount);
}

// GL_ARB_transpose_matrix

static void REGAL_CALL loader_glLoadTransposeMatrixdARB(const GLdouble *m)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glLoadTransposeMatrixdARB, "glLoadTransposeMatrixdARB");
  if (_driver.glLoadTransposeMatrixdARB) {
    _driver.glLoadTransposeMatrixdARB(m);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glLoadTransposeMatrixdARB)(m);
}

static void REGAL_CALL loader_glLoadTransposeMatrixfARB(const GLfloat *m)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glLoadTransposeMatrixfARB, "glLoadTransposeMatrixfARB");
  if (_driver.glLoadTransposeMatrixfARB) {
    _driver.glLoadTransposeMatrixfARB(m);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glLoadTransposeMatrixfARB)(m);
}

static void REGAL_CALL loader_glMultTransposeMatrixdARB(const GLdouble *m)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultTransposeMatrixdARB, "glMultTransposeMatrixdARB");
  if (_driver.glMultTransposeMatrixdARB) {
    _driver.glMultTransposeMatrixdARB(m);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultTransposeMatrixdARB)(m);
}

static void REGAL_CALL loader_glMultTransposeMatrixfARB(const GLfloat *m)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultTransposeMatrixfARB, "glMultTransposeMatrixfARB");
  if (_driver.glMultTransposeMatrixfARB) {
    _driver.glMultTransposeMatrixfARB(m);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultTransposeMatrixfARB)(m);
}

// GL_ARB_uniform_buffer_object

static void REGAL_CALL loader_glBindBufferBase(GLenum target, GLuint index, GLuint buffer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBindBufferBase, "glBindBufferBase");
  if (_driver.glBindBufferBase) {
    _driver.glBindBufferBase(target, index, buffer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBindBufferBase)(target, index, buffer);
}

static void REGAL_CALL loader_glBindBufferRange(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBindBufferRange, "glBindBufferRange");
  if (_driver.glBindBufferRange) {
    _driver.glBindBufferRange(target, index, buffer, offset, size);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBindBufferRange)(target, index, buffer, offset, size);
}

static void REGAL_CALL loader_glGetActiveUniformBlockName(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetActiveUniformBlockName, "glGetActiveUniformBlockName");
  if (_driver.glGetActiveUniformBlockName) {
    _driver.glGetActiveUniformBlockName(program, uniformBlockIndex, bufSize, length, uniformBlockName);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetActiveUniformBlockName)(program, uniformBlockIndex, bufSize, length, uniformBlockName);
}

static void REGAL_CALL loader_glGetActiveUniformBlockiv(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetActiveUniformBlockiv, "glGetActiveUniformBlockiv");
  if (_driver.glGetActiveUniformBlockiv) {
    _driver.glGetActiveUniformBlockiv(program, uniformBlockIndex, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetActiveUniformBlockiv)(program, uniformBlockIndex, pname, params);
}

static void REGAL_CALL loader_glGetActiveUniformName(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformName)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetActiveUniformName, "glGetActiveUniformName");
  if (_driver.glGetActiveUniformName) {
    _driver.glGetActiveUniformName(program, uniformIndex, bufSize, length, uniformName);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetActiveUniformName)(program, uniformIndex, bufSize, length, uniformName);
}

static void REGAL_CALL loader_glGetActiveUniformsiv(GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetActiveUniformsiv, "glGetActiveUniformsiv");
  if (_driver.glGetActiveUniformsiv) {
    _driver.glGetActiveUniformsiv(program, uniformCount, uniformIndices, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetActiveUniformsiv)(program, uniformCount, uniformIndices, pname, params);
}

static void REGAL_CALL loader_glGetIntegeri_v(GLenum target, GLuint index, GLint *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetIntegeri_v, "glGetIntegeri_v");
  if (_driver.glGetIntegeri_v) {
    _driver.glGetIntegeri_v(target, index, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetIntegeri_v)(target, index, data);
}

static GLuint REGAL_CALL loader_glGetUniformBlockIndex(GLuint program, const GLchar *uniformBlockName)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetUniformBlockIndex, "glGetUniformBlockIndex");
  if (_driver.glGetUniformBlockIndex) {
    return _driver.glGetUniformBlockIndex(program, uniformBlockName);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glGetUniformBlockIndex)(program, uniformBlockName);
}

static void REGAL_CALL loader_glGetUniformIndices(GLuint program, GLsizei uniformCount, const GLchar **uniformNames, GLuint *uniformIndices)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetUniformIndices, "glGetUniformIndices");
  if (_driver.glGetUniformIndices) {
    _driver.glGetUniformIndices(program, uniformCount, uniformNames, uniformIndices);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetUniformIndices)(program, uniformCount, uniformNames, uniformIndices);
}

static void REGAL_CALL loader_glUniformBlockBinding(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniformBlockBinding, "glUniformBlockBinding");
  if (_driver.glUniformBlockBinding) {
    _driver.glUniformBlockBinding(program, uniformBlockIndex, uniformBlockBinding);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniformBlockBinding)(program, uniformBlockIndex, uniformBlockBinding);
}

// GL_ARB_vertex_array_object

static void REGAL_CALL loader_glBindVertexArray(GLuint array)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBindVertexArray, "glBindVertexArray");
  if (_driver.glBindVertexArray) {
    _driver.glBindVertexArray(array);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBindVertexArray)(array);
}

static void REGAL_CALL loader_glDeleteVertexArrays(GLsizei n, const GLuint *arrays)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDeleteVertexArrays, "glDeleteVertexArrays");
  if (_driver.glDeleteVertexArrays) {
    _driver.glDeleteVertexArrays(n, arrays);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDeleteVertexArrays)(n, arrays);
}

static void REGAL_CALL loader_glGenVertexArrays(GLsizei n, GLuint *arrays)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGenVertexArrays, "glGenVertexArrays");
  if (_driver.glGenVertexArrays) {
    _driver.glGenVertexArrays(n, arrays);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGenVertexArrays)(n, arrays);
}

static GLboolean REGAL_CALL loader_glIsVertexArray(GLuint array)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIsVertexArray, "glIsVertexArray");
  if (_driver.glIsVertexArray) {
    return _driver.glIsVertexArray(array);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glIsVertexArray)(array);
}

// GL_ARB_vertex_attrib_64bit

static void REGAL_CALL loader_glGetVertexAttribLdv(GLuint index, GLenum pname, GLdouble *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetVertexAttribLdv, "glGetVertexAttribLdv");
  if (_driver.glGetVertexAttribLdv) {
    _driver.glGetVertexAttribLdv(index, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetVertexAttribLdv)(index, pname, params);
}

static void REGAL_CALL loader_glVertexAttribL1d(GLuint index, GLdouble x)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribL1d, "glVertexAttribL1d");
  if (_driver.glVertexAttribL1d) {
    _driver.glVertexAttribL1d(index, x);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribL1d)(index, x);
}

static void REGAL_CALL loader_glVertexAttribL1dv(GLuint index, const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribL1dv, "glVertexAttribL1dv");
  if (_driver.glVertexAttribL1dv) {
    _driver.glVertexAttribL1dv(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribL1dv)(index, v);
}

static void REGAL_CALL loader_glVertexAttribL2d(GLuint index, GLdouble x, GLdouble y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribL2d, "glVertexAttribL2d");
  if (_driver.glVertexAttribL2d) {
    _driver.glVertexAttribL2d(index, x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribL2d)(index, x, y);
}

static void REGAL_CALL loader_glVertexAttribL2dv(GLuint index, const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribL2dv, "glVertexAttribL2dv");
  if (_driver.glVertexAttribL2dv) {
    _driver.glVertexAttribL2dv(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribL2dv)(index, v);
}

static void REGAL_CALL loader_glVertexAttribL3d(GLuint index, GLdouble x, GLdouble y, GLdouble z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribL3d, "glVertexAttribL3d");
  if (_driver.glVertexAttribL3d) {
    _driver.glVertexAttribL3d(index, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribL3d)(index, x, y, z);
}

static void REGAL_CALL loader_glVertexAttribL3dv(GLuint index, const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribL3dv, "glVertexAttribL3dv");
  if (_driver.glVertexAttribL3dv) {
    _driver.glVertexAttribL3dv(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribL3dv)(index, v);
}

static void REGAL_CALL loader_glVertexAttribL4d(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribL4d, "glVertexAttribL4d");
  if (_driver.glVertexAttribL4d) {
    _driver.glVertexAttribL4d(index, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribL4d)(index, x, y, z, w);
}

static void REGAL_CALL loader_glVertexAttribL4dv(GLuint index, const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribL4dv, "glVertexAttribL4dv");
  if (_driver.glVertexAttribL4dv) {
    _driver.glVertexAttribL4dv(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribL4dv)(index, v);
}

static void REGAL_CALL loader_glVertexAttribLPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribLPointer, "glVertexAttribLPointer");
  if (_driver.glVertexAttribLPointer) {
    _driver.glVertexAttribLPointer(index, size, type, stride, pointer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribLPointer)(index, size, type, stride, pointer);
}

// GL_ARB_vertex_attrib_binding

static void REGAL_CALL loader_glBindVertexBuffer(GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBindVertexBuffer, "glBindVertexBuffer");
  if (_driver.glBindVertexBuffer) {
    _driver.glBindVertexBuffer(bindingindex, buffer, offset, stride);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBindVertexBuffer)(bindingindex, buffer, offset, stride);
}

static void REGAL_CALL loader_glVertexAttribBinding(GLuint attribindex, GLuint bindingindex)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribBinding, "glVertexAttribBinding");
  if (_driver.glVertexAttribBinding) {
    _driver.glVertexAttribBinding(attribindex, bindingindex);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribBinding)(attribindex, bindingindex);
}

static void REGAL_CALL loader_glVertexAttribFormat(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribFormat, "glVertexAttribFormat");
  if (_driver.glVertexAttribFormat) {
    _driver.glVertexAttribFormat(attribindex, size, type, normalized, relativeoffset);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribFormat)(attribindex, size, type, normalized, relativeoffset);
}

static void REGAL_CALL loader_glVertexAttribIFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribIFormat, "glVertexAttribIFormat");
  if (_driver.glVertexAttribIFormat) {
    _driver.glVertexAttribIFormat(attribindex, size, type, relativeoffset);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribIFormat)(attribindex, size, type, relativeoffset);
}

static void REGAL_CALL loader_glVertexAttribLFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribLFormat, "glVertexAttribLFormat");
  if (_driver.glVertexAttribLFormat) {
    _driver.glVertexAttribLFormat(attribindex, size, type, relativeoffset);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribLFormat)(attribindex, size, type, relativeoffset);
}

static void REGAL_CALL loader_glVertexBindingDivisor(GLuint bindingindex, GLuint divisor)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexBindingDivisor, "glVertexBindingDivisor");
  if (_driver.glVertexBindingDivisor) {
    _driver.glVertexBindingDivisor(bindingindex, divisor);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexBindingDivisor)(bindingindex, divisor);
}

// GL_ARB_vertex_blend

static void REGAL_CALL loader_glVertexBlendARB(GLint count)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexBlendARB, "glVertexBlendARB");
  if (_driver.glVertexBlendARB) {
    _driver.glVertexBlendARB(count);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexBlendARB)(count);
}

static void REGAL_CALL loader_glWeightPointerARB(GLint size, GLenum type, GLsizei stride, GLvoid *pointer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWeightPointerARB, "glWeightPointerARB");
  if (_driver.glWeightPointerARB) {
    _driver.glWeightPointerARB(size, type, stride, pointer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWeightPointerARB)(size, type, stride, pointer);
}

static void REGAL_CALL loader_glWeightbvARB(GLint size, GLbyte *weights)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWeightbvARB, "glWeightbvARB");
  if (_driver.glWeightbvARB) {
    _driver.glWeightbvARB(size, weights);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWeightbvARB)(size, weights);
}

static void REGAL_CALL loader_glWeightdvARB(GLint size, GLdouble *weights)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWeightdvARB, "glWeightdvARB");
  if (_driver.glWeightdvARB) {
    _driver.glWeightdvARB(size, weights);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWeightdvARB)(size, weights);
}

static void REGAL_CALL loader_glWeightfvARB(GLint size, GLfloat *weights)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWeightfvARB, "glWeightfvARB");
  if (_driver.glWeightfvARB) {
    _driver.glWeightfvARB(size, weights);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWeightfvARB)(size, weights);
}

static void REGAL_CALL loader_glWeightivARB(GLint size, GLint *weights)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWeightivARB, "glWeightivARB");
  if (_driver.glWeightivARB) {
    _driver.glWeightivARB(size, weights);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWeightivARB)(size, weights);
}

static void REGAL_CALL loader_glWeightsvARB(GLint size, GLshort *weights)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWeightsvARB, "glWeightsvARB");
  if (_driver.glWeightsvARB) {
    _driver.glWeightsvARB(size, weights);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWeightsvARB)(size, weights);
}

static void REGAL_CALL loader_glWeightubvARB(GLint size, GLubyte *weights)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWeightubvARB, "glWeightubvARB");
  if (_driver.glWeightubvARB) {
    _driver.glWeightubvARB(size, weights);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWeightubvARB)(size, weights);
}

static void REGAL_CALL loader_glWeightuivARB(GLint size, GLuint *weights)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWeightuivARB, "glWeightuivARB");
  if (_driver.glWeightuivARB) {
    _driver.glWeightuivARB(size, weights);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWeightuivARB)(size, weights);
}

static void REGAL_CALL loader_glWeightusvARB(GLint size, GLushort *weights)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWeightusvARB, "glWeightusvARB");
  if (_driver.glWeightusvARB) {
    _driver.glWeightusvARB(size, weights);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWeightusvARB)(size, weights);
}

// GL_ARB_vertex_buffer_object

static void REGAL_CALL loader_glBindBufferARB(GLenum target, GLuint buffer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBindBufferARB, "glBindBufferARB");
  if (_driver.glBindBufferARB) {
    _driver.glBindBufferARB(target, buffer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBindBufferARB)(target, buffer);
}

static void REGAL_CALL loader_glBufferDataARB(GLenum target, GLsizeiptrARB size, const GLvoid *data, GLenum usage)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBufferDataARB, "glBufferDataARB");
  if (_driver.glBufferDataARB) {
    _driver.glBufferDataARB(target, size, data, usage);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBufferDataARB)(target, size, data, usage);
}

static void REGAL_CALL loader_glBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBufferSubDataARB, "glBufferSubDataARB");
  if (_driver.glBufferSubDataARB) {
    _driver.glBufferSubDataARB(target, offset, size, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBufferSubDataARB)(target, offset, size, data);
}

static void REGAL_CALL loader_glDeleteBuffersARB(GLsizei n, const GLuint *buffers)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDeleteBuffersARB, "glDeleteBuffersARB");
  if (_driver.glDeleteBuffersARB) {
    _driver.glDeleteBuffersARB(n, buffers);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDeleteBuffersARB)(n, buffers);
}

static void REGAL_CALL loader_glGenBuffersARB(GLsizei n, GLuint *buffers)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGenBuffersARB, "glGenBuffersARB");
  if (_driver.glGenBuffersARB) {
    _driver.glGenBuffersARB(n, buffers);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGenBuffersARB)(n, buffers);
}

static void REGAL_CALL loader_glGetBufferParameterivARB(GLenum target, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetBufferParameterivARB, "glGetBufferParameterivARB");
  if (_driver.glGetBufferParameterivARB) {
    _driver.glGetBufferParameterivARB(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetBufferParameterivARB)(target, pname, params);
}

static void REGAL_CALL loader_glGetBufferPointervARB(GLenum target, GLenum pname, GLvoid **params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetBufferPointervARB, "glGetBufferPointervARB");
  if (_driver.glGetBufferPointervARB) {
    _driver.glGetBufferPointervARB(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetBufferPointervARB)(target, pname, params);
}

static void REGAL_CALL loader_glGetBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, GLvoid *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetBufferSubDataARB, "glGetBufferSubDataARB");
  if (_driver.glGetBufferSubDataARB) {
    _driver.glGetBufferSubDataARB(target, offset, size, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetBufferSubDataARB)(target, offset, size, data);
}

static GLboolean REGAL_CALL loader_glIsBufferARB(GLuint buffer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIsBufferARB, "glIsBufferARB");
  if (_driver.glIsBufferARB) {
    return _driver.glIsBufferARB(buffer);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glIsBufferARB)(buffer);
}

static GLvoid *REGAL_CALL loader_glMapBufferARB(GLenum target, GLenum access)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMapBufferARB, "glMapBufferARB");
  if (_driver.glMapBufferARB) {
    return _driver.glMapBufferARB(target, access);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glMapBufferARB)(target, access);
}

static GLboolean REGAL_CALL loader_glUnmapBufferARB(GLenum target)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUnmapBufferARB, "glUnmapBufferARB");
  if (_driver.glUnmapBufferARB) {
    return _driver.glUnmapBufferARB(target);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glUnmapBufferARB)(target);
}

// GL_ARB_vertex_program

static void REGAL_CALL loader_glBindProgramARB(GLenum target, GLuint program)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBindProgramARB, "glBindProgramARB");
  if (_driver.glBindProgramARB) {
    _driver.glBindProgramARB(target, program);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBindProgramARB)(target, program);
}

static void REGAL_CALL loader_glDeleteProgramsARB(GLsizei n, const GLuint *programs)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDeleteProgramsARB, "glDeleteProgramsARB");
  if (_driver.glDeleteProgramsARB) {
    _driver.glDeleteProgramsARB(n, programs);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDeleteProgramsARB)(n, programs);
}

static void REGAL_CALL loader_glDisableVertexAttribArrayARB(GLuint index)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDisableVertexAttribArrayARB, "glDisableVertexAttribArrayARB");
  if (_driver.glDisableVertexAttribArrayARB) {
    _driver.glDisableVertexAttribArrayARB(index);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDisableVertexAttribArrayARB)(index);
}

static void REGAL_CALL loader_glEnableVertexAttribArrayARB(GLuint index)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glEnableVertexAttribArrayARB, "glEnableVertexAttribArrayARB");
  if (_driver.glEnableVertexAttribArrayARB) {
    _driver.glEnableVertexAttribArrayARB(index);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glEnableVertexAttribArrayARB)(index);
}

static void REGAL_CALL loader_glGenProgramsARB(GLsizei n, GLuint *programs)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGenProgramsARB, "glGenProgramsARB");
  if (_driver.glGenProgramsARB) {
    _driver.glGenProgramsARB(n, programs);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGenProgramsARB)(n, programs);
}

static void REGAL_CALL loader_glGetProgramEnvParameterdvARB(GLenum target, GLuint index, GLdouble *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetProgramEnvParameterdvARB, "glGetProgramEnvParameterdvARB");
  if (_driver.glGetProgramEnvParameterdvARB) {
    _driver.glGetProgramEnvParameterdvARB(target, index, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetProgramEnvParameterdvARB)(target, index, params);
}

static void REGAL_CALL loader_glGetProgramEnvParameterfvARB(GLenum target, GLuint index, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetProgramEnvParameterfvARB, "glGetProgramEnvParameterfvARB");
  if (_driver.glGetProgramEnvParameterfvARB) {
    _driver.glGetProgramEnvParameterfvARB(target, index, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetProgramEnvParameterfvARB)(target, index, params);
}

static void REGAL_CALL loader_glGetProgramLocalParameterdvARB(GLenum target, GLuint index, GLdouble *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetProgramLocalParameterdvARB, "glGetProgramLocalParameterdvARB");
  if (_driver.glGetProgramLocalParameterdvARB) {
    _driver.glGetProgramLocalParameterdvARB(target, index, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetProgramLocalParameterdvARB)(target, index, params);
}

static void REGAL_CALL loader_glGetProgramLocalParameterfvARB(GLenum target, GLuint index, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetProgramLocalParameterfvARB, "glGetProgramLocalParameterfvARB");
  if (_driver.glGetProgramLocalParameterfvARB) {
    _driver.glGetProgramLocalParameterfvARB(target, index, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetProgramLocalParameterfvARB)(target, index, params);
}

static void REGAL_CALL loader_glGetProgramStringARB(GLenum target, GLenum pname, GLvoid *string)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetProgramStringARB, "glGetProgramStringARB");
  if (_driver.glGetProgramStringARB) {
    _driver.glGetProgramStringARB(target, pname, string);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetProgramStringARB)(target, pname, string);
}

static void REGAL_CALL loader_glGetProgramivARB(GLenum target, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetProgramivARB, "glGetProgramivARB");
  if (_driver.glGetProgramivARB) {
    _driver.glGetProgramivARB(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetProgramivARB)(target, pname, params);
}

static void REGAL_CALL loader_glGetVertexAttribPointervARB(GLuint index, GLenum pname, GLvoid **pointer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetVertexAttribPointervARB, "glGetVertexAttribPointervARB");
  if (_driver.glGetVertexAttribPointervARB) {
    _driver.glGetVertexAttribPointervARB(index, pname, pointer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetVertexAttribPointervARB)(index, pname, pointer);
}

static void REGAL_CALL loader_glGetVertexAttribdvARB(GLuint index, GLenum pname, GLdouble *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetVertexAttribdvARB, "glGetVertexAttribdvARB");
  if (_driver.glGetVertexAttribdvARB) {
    _driver.glGetVertexAttribdvARB(index, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetVertexAttribdvARB)(index, pname, params);
}

static void REGAL_CALL loader_glGetVertexAttribfvARB(GLuint index, GLenum pname, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetVertexAttribfvARB, "glGetVertexAttribfvARB");
  if (_driver.glGetVertexAttribfvARB) {
    _driver.glGetVertexAttribfvARB(index, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetVertexAttribfvARB)(index, pname, params);
}

static void REGAL_CALL loader_glGetVertexAttribivARB(GLuint index, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetVertexAttribivARB, "glGetVertexAttribivARB");
  if (_driver.glGetVertexAttribivARB) {
    _driver.glGetVertexAttribivARB(index, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetVertexAttribivARB)(index, pname, params);
}

static GLboolean REGAL_CALL loader_glIsProgramARB(GLuint program)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIsProgramARB, "glIsProgramARB");
  if (_driver.glIsProgramARB) {
    return _driver.glIsProgramARB(program);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glIsProgramARB)(program);
}

static void REGAL_CALL loader_glProgramEnvParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramEnvParameter4dARB, "glProgramEnvParameter4dARB");
  if (_driver.glProgramEnvParameter4dARB) {
    _driver.glProgramEnvParameter4dARB(target, index, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramEnvParameter4dARB)(target, index, x, y, z, w);
}

static void REGAL_CALL loader_glProgramEnvParameter4dvARB(GLenum target, GLuint index, const GLdouble *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramEnvParameter4dvARB, "glProgramEnvParameter4dvARB");
  if (_driver.glProgramEnvParameter4dvARB) {
    _driver.glProgramEnvParameter4dvARB(target, index, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramEnvParameter4dvARB)(target, index, params);
}

static void REGAL_CALL loader_glProgramEnvParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramEnvParameter4fARB, "glProgramEnvParameter4fARB");
  if (_driver.glProgramEnvParameter4fARB) {
    _driver.glProgramEnvParameter4fARB(target, index, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramEnvParameter4fARB)(target, index, x, y, z, w);
}

static void REGAL_CALL loader_glProgramEnvParameter4fvARB(GLenum target, GLuint index, const GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramEnvParameter4fvARB, "glProgramEnvParameter4fvARB");
  if (_driver.glProgramEnvParameter4fvARB) {
    _driver.glProgramEnvParameter4fvARB(target, index, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramEnvParameter4fvARB)(target, index, params);
}

static void REGAL_CALL loader_glProgramLocalParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramLocalParameter4dARB, "glProgramLocalParameter4dARB");
  if (_driver.glProgramLocalParameter4dARB) {
    _driver.glProgramLocalParameter4dARB(target, index, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramLocalParameter4dARB)(target, index, x, y, z, w);
}

static void REGAL_CALL loader_glProgramLocalParameter4dvARB(GLenum target, GLuint index, const GLdouble *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramLocalParameter4dvARB, "glProgramLocalParameter4dvARB");
  if (_driver.glProgramLocalParameter4dvARB) {
    _driver.glProgramLocalParameter4dvARB(target, index, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramLocalParameter4dvARB)(target, index, params);
}

static void REGAL_CALL loader_glProgramLocalParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramLocalParameter4fARB, "glProgramLocalParameter4fARB");
  if (_driver.glProgramLocalParameter4fARB) {
    _driver.glProgramLocalParameter4fARB(target, index, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramLocalParameter4fARB)(target, index, x, y, z, w);
}

static void REGAL_CALL loader_glProgramLocalParameter4fvARB(GLenum target, GLuint index, const GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramLocalParameter4fvARB, "glProgramLocalParameter4fvARB");
  if (_driver.glProgramLocalParameter4fvARB) {
    _driver.glProgramLocalParameter4fvARB(target, index, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramLocalParameter4fvARB)(target, index, params);
}

static void REGAL_CALL loader_glProgramStringARB(GLenum target, GLenum format, GLsizei len, const GLvoid *string)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramStringARB, "glProgramStringARB");
  if (_driver.glProgramStringARB) {
    _driver.glProgramStringARB(target, format, len, string);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramStringARB)(target, format, len, string);
}

static void REGAL_CALL loader_glVertexAttrib1dARB(GLuint index, GLdouble x)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib1dARB, "glVertexAttrib1dARB");
  if (_driver.glVertexAttrib1dARB) {
    _driver.glVertexAttrib1dARB(index, x);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib1dARB)(index, x);
}

static void REGAL_CALL loader_glVertexAttrib1dvARB(GLuint index, const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib1dvARB, "glVertexAttrib1dvARB");
  if (_driver.glVertexAttrib1dvARB) {
    _driver.glVertexAttrib1dvARB(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib1dvARB)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib1fARB(GLuint index, GLfloat x)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib1fARB, "glVertexAttrib1fARB");
  if (_driver.glVertexAttrib1fARB) {
    _driver.glVertexAttrib1fARB(index, x);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib1fARB)(index, x);
}

static void REGAL_CALL loader_glVertexAttrib1fvARB(GLuint index, const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib1fvARB, "glVertexAttrib1fvARB");
  if (_driver.glVertexAttrib1fvARB) {
    _driver.glVertexAttrib1fvARB(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib1fvARB)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib1sARB(GLuint index, GLshort x)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib1sARB, "glVertexAttrib1sARB");
  if (_driver.glVertexAttrib1sARB) {
    _driver.glVertexAttrib1sARB(index, x);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib1sARB)(index, x);
}

static void REGAL_CALL loader_glVertexAttrib1svARB(GLuint index, const GLshort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib1svARB, "glVertexAttrib1svARB");
  if (_driver.glVertexAttrib1svARB) {
    _driver.glVertexAttrib1svARB(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib1svARB)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib2dARB(GLuint index, GLdouble x, GLdouble y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib2dARB, "glVertexAttrib2dARB");
  if (_driver.glVertexAttrib2dARB) {
    _driver.glVertexAttrib2dARB(index, x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib2dARB)(index, x, y);
}

static void REGAL_CALL loader_glVertexAttrib2dvARB(GLuint index, const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib2dvARB, "glVertexAttrib2dvARB");
  if (_driver.glVertexAttrib2dvARB) {
    _driver.glVertexAttrib2dvARB(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib2dvARB)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib2fARB(GLuint index, GLfloat x, GLfloat y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib2fARB, "glVertexAttrib2fARB");
  if (_driver.glVertexAttrib2fARB) {
    _driver.glVertexAttrib2fARB(index, x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib2fARB)(index, x, y);
}

static void REGAL_CALL loader_glVertexAttrib2fvARB(GLuint index, const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib2fvARB, "glVertexAttrib2fvARB");
  if (_driver.glVertexAttrib2fvARB) {
    _driver.glVertexAttrib2fvARB(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib2fvARB)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib2sARB(GLuint index, GLshort x, GLshort y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib2sARB, "glVertexAttrib2sARB");
  if (_driver.glVertexAttrib2sARB) {
    _driver.glVertexAttrib2sARB(index, x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib2sARB)(index, x, y);
}

static void REGAL_CALL loader_glVertexAttrib2svARB(GLuint index, const GLshort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib2svARB, "glVertexAttrib2svARB");
  if (_driver.glVertexAttrib2svARB) {
    _driver.glVertexAttrib2svARB(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib2svARB)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib3dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib3dARB, "glVertexAttrib3dARB");
  if (_driver.glVertexAttrib3dARB) {
    _driver.glVertexAttrib3dARB(index, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib3dARB)(index, x, y, z);
}

static void REGAL_CALL loader_glVertexAttrib3dvARB(GLuint index, const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib3dvARB, "glVertexAttrib3dvARB");
  if (_driver.glVertexAttrib3dvARB) {
    _driver.glVertexAttrib3dvARB(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib3dvARB)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib3fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib3fARB, "glVertexAttrib3fARB");
  if (_driver.glVertexAttrib3fARB) {
    _driver.glVertexAttrib3fARB(index, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib3fARB)(index, x, y, z);
}

static void REGAL_CALL loader_glVertexAttrib3fvARB(GLuint index, const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib3fvARB, "glVertexAttrib3fvARB");
  if (_driver.glVertexAttrib3fvARB) {
    _driver.glVertexAttrib3fvARB(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib3fvARB)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib3sARB(GLuint index, GLshort x, GLshort y, GLshort z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib3sARB, "glVertexAttrib3sARB");
  if (_driver.glVertexAttrib3sARB) {
    _driver.glVertexAttrib3sARB(index, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib3sARB)(index, x, y, z);
}

static void REGAL_CALL loader_glVertexAttrib3svARB(GLuint index, const GLshort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib3svARB, "glVertexAttrib3svARB");
  if (_driver.glVertexAttrib3svARB) {
    _driver.glVertexAttrib3svARB(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib3svARB)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib4NbvARB(GLuint index, const GLbyte *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib4NbvARB, "glVertexAttrib4NbvARB");
  if (_driver.glVertexAttrib4NbvARB) {
    _driver.glVertexAttrib4NbvARB(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib4NbvARB)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib4NivARB(GLuint index, const GLint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib4NivARB, "glVertexAttrib4NivARB");
  if (_driver.glVertexAttrib4NivARB) {
    _driver.glVertexAttrib4NivARB(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib4NivARB)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib4NsvARB(GLuint index, const GLshort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib4NsvARB, "glVertexAttrib4NsvARB");
  if (_driver.glVertexAttrib4NsvARB) {
    _driver.glVertexAttrib4NsvARB(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib4NsvARB)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib4NubARB(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib4NubARB, "glVertexAttrib4NubARB");
  if (_driver.glVertexAttrib4NubARB) {
    _driver.glVertexAttrib4NubARB(index, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib4NubARB)(index, x, y, z, w);
}

static void REGAL_CALL loader_glVertexAttrib4NubvARB(GLuint index, const GLubyte *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib4NubvARB, "glVertexAttrib4NubvARB");
  if (_driver.glVertexAttrib4NubvARB) {
    _driver.glVertexAttrib4NubvARB(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib4NubvARB)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib4NuivARB(GLuint index, const GLuint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib4NuivARB, "glVertexAttrib4NuivARB");
  if (_driver.glVertexAttrib4NuivARB) {
    _driver.glVertexAttrib4NuivARB(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib4NuivARB)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib4NusvARB(GLuint index, const GLushort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib4NusvARB, "glVertexAttrib4NusvARB");
  if (_driver.glVertexAttrib4NusvARB) {
    _driver.glVertexAttrib4NusvARB(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib4NusvARB)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib4bvARB(GLuint index, const GLbyte *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib4bvARB, "glVertexAttrib4bvARB");
  if (_driver.glVertexAttrib4bvARB) {
    _driver.glVertexAttrib4bvARB(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib4bvARB)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib4dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib4dARB, "glVertexAttrib4dARB");
  if (_driver.glVertexAttrib4dARB) {
    _driver.glVertexAttrib4dARB(index, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib4dARB)(index, x, y, z, w);
}

static void REGAL_CALL loader_glVertexAttrib4dvARB(GLuint index, const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib4dvARB, "glVertexAttrib4dvARB");
  if (_driver.glVertexAttrib4dvARB) {
    _driver.glVertexAttrib4dvARB(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib4dvARB)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib4fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib4fARB, "glVertexAttrib4fARB");
  if (_driver.glVertexAttrib4fARB) {
    _driver.glVertexAttrib4fARB(index, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib4fARB)(index, x, y, z, w);
}

static void REGAL_CALL loader_glVertexAttrib4fvARB(GLuint index, const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib4fvARB, "glVertexAttrib4fvARB");
  if (_driver.glVertexAttrib4fvARB) {
    _driver.glVertexAttrib4fvARB(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib4fvARB)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib4ivARB(GLuint index, const GLint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib4ivARB, "glVertexAttrib4ivARB");
  if (_driver.glVertexAttrib4ivARB) {
    _driver.glVertexAttrib4ivARB(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib4ivARB)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib4sARB(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib4sARB, "glVertexAttrib4sARB");
  if (_driver.glVertexAttrib4sARB) {
    _driver.glVertexAttrib4sARB(index, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib4sARB)(index, x, y, z, w);
}

static void REGAL_CALL loader_glVertexAttrib4svARB(GLuint index, const GLshort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib4svARB, "glVertexAttrib4svARB");
  if (_driver.glVertexAttrib4svARB) {
    _driver.glVertexAttrib4svARB(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib4svARB)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib4ubvARB(GLuint index, const GLubyte *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib4ubvARB, "glVertexAttrib4ubvARB");
  if (_driver.glVertexAttrib4ubvARB) {
    _driver.glVertexAttrib4ubvARB(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib4ubvARB)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib4uivARB(GLuint index, const GLuint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib4uivARB, "glVertexAttrib4uivARB");
  if (_driver.glVertexAttrib4uivARB) {
    _driver.glVertexAttrib4uivARB(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib4uivARB)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib4usvARB(GLuint index, const GLushort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib4usvARB, "glVertexAttrib4usvARB");
  if (_driver.glVertexAttrib4usvARB) {
    _driver.glVertexAttrib4usvARB(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib4usvARB)(index, v);
}

static void REGAL_CALL loader_glVertexAttribPointerARB(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribPointerARB, "glVertexAttribPointerARB");
  if (_driver.glVertexAttribPointerARB) {
    _driver.glVertexAttribPointerARB(index, size, type, normalized, stride, pointer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribPointerARB)(index, size, type, normalized, stride, pointer);
}

// GL_ARB_vertex_shader

static void REGAL_CALL loader_glBindAttribLocationARB(GLhandleARB programObj, GLuint index, const GLcharARB *name)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBindAttribLocationARB, "glBindAttribLocationARB");
  if (_driver.glBindAttribLocationARB) {
    _driver.glBindAttribLocationARB(programObj, index, name);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBindAttribLocationARB)(programObj, index, name);
}

static void REGAL_CALL loader_glGetActiveAttribARB(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetActiveAttribARB, "glGetActiveAttribARB");
  if (_driver.glGetActiveAttribARB) {
    _driver.glGetActiveAttribARB(programObj, index, maxLength, length, size, type, name);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetActiveAttribARB)(programObj, index, maxLength, length, size, type, name);
}

static GLint REGAL_CALL loader_glGetAttribLocationARB(GLhandleARB programObj, const GLcharARB *name)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetAttribLocationARB, "glGetAttribLocationARB");
  if (_driver.glGetAttribLocationARB) {
    return _driver.glGetAttribLocationARB(programObj, name);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glGetAttribLocationARB)(programObj, name);
}

// GL_ARB_vertex_type_2_10_10_10_rev

static void REGAL_CALL loader_glColorP3ui(GLenum type, GLuint color)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColorP3ui, "glColorP3ui");
  if (_driver.glColorP3ui) {
    _driver.glColorP3ui(type, color);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColorP3ui)(type, color);
}

static void REGAL_CALL loader_glColorP3uiv(GLenum type, const GLuint *color)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColorP3uiv, "glColorP3uiv");
  if (_driver.glColorP3uiv) {
    _driver.glColorP3uiv(type, color);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColorP3uiv)(type, color);
}

static void REGAL_CALL loader_glColorP4ui(GLenum type, GLuint color)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColorP4ui, "glColorP4ui");
  if (_driver.glColorP4ui) {
    _driver.glColorP4ui(type, color);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColorP4ui)(type, color);
}

static void REGAL_CALL loader_glColorP4uiv(GLenum type, const GLuint *color)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColorP4uiv, "glColorP4uiv");
  if (_driver.glColorP4uiv) {
    _driver.glColorP4uiv(type, color);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColorP4uiv)(type, color);
}

static void REGAL_CALL loader_glMultiTexCoordP1ui(GLenum texture, GLenum type, GLuint coords)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoordP1ui, "glMultiTexCoordP1ui");
  if (_driver.glMultiTexCoordP1ui) {
    _driver.glMultiTexCoordP1ui(texture, type, coords);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoordP1ui)(texture, type, coords);
}

static void REGAL_CALL loader_glMultiTexCoordP1uiv(GLenum texture, GLenum type, const GLuint *coords)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoordP1uiv, "glMultiTexCoordP1uiv");
  if (_driver.glMultiTexCoordP1uiv) {
    _driver.glMultiTexCoordP1uiv(texture, type, coords);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoordP1uiv)(texture, type, coords);
}

static void REGAL_CALL loader_glMultiTexCoordP2ui(GLenum texture, GLenum type, GLuint coords)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoordP2ui, "glMultiTexCoordP2ui");
  if (_driver.glMultiTexCoordP2ui) {
    _driver.glMultiTexCoordP2ui(texture, type, coords);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoordP2ui)(texture, type, coords);
}

static void REGAL_CALL loader_glMultiTexCoordP2uiv(GLenum texture, GLenum type, const GLuint *coords)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoordP2uiv, "glMultiTexCoordP2uiv");
  if (_driver.glMultiTexCoordP2uiv) {
    _driver.glMultiTexCoordP2uiv(texture, type, coords);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoordP2uiv)(texture, type, coords);
}

static void REGAL_CALL loader_glMultiTexCoordP3ui(GLenum texture, GLenum type, GLuint coords)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoordP3ui, "glMultiTexCoordP3ui");
  if (_driver.glMultiTexCoordP3ui) {
    _driver.glMultiTexCoordP3ui(texture, type, coords);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoordP3ui)(texture, type, coords);
}

static void REGAL_CALL loader_glMultiTexCoordP3uiv(GLenum texture, GLenum type, const GLuint *coords)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoordP3uiv, "glMultiTexCoordP3uiv");
  if (_driver.glMultiTexCoordP3uiv) {
    _driver.glMultiTexCoordP3uiv(texture, type, coords);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoordP3uiv)(texture, type, coords);
}

static void REGAL_CALL loader_glMultiTexCoordP4ui(GLenum texture, GLenum type, GLuint coords)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoordP4ui, "glMultiTexCoordP4ui");
  if (_driver.glMultiTexCoordP4ui) {
    _driver.glMultiTexCoordP4ui(texture, type, coords);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoordP4ui)(texture, type, coords);
}

static void REGAL_CALL loader_glMultiTexCoordP4uiv(GLenum texture, GLenum type, const GLuint *coords)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoordP4uiv, "glMultiTexCoordP4uiv");
  if (_driver.glMultiTexCoordP4uiv) {
    _driver.glMultiTexCoordP4uiv(texture, type, coords);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoordP4uiv)(texture, type, coords);
}

static void REGAL_CALL loader_glNormalP3ui(GLenum type, GLuint coords)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNormalP3ui, "glNormalP3ui");
  if (_driver.glNormalP3ui) {
    _driver.glNormalP3ui(type, coords);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNormalP3ui)(type, coords);
}

static void REGAL_CALL loader_glNormalP3uiv(GLenum type, const GLuint *coords)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNormalP3uiv, "glNormalP3uiv");
  if (_driver.glNormalP3uiv) {
    _driver.glNormalP3uiv(type, coords);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNormalP3uiv)(type, coords);
}

static void REGAL_CALL loader_glSecondaryColorP3ui(GLenum type, GLuint color)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSecondaryColorP3ui, "glSecondaryColorP3ui");
  if (_driver.glSecondaryColorP3ui) {
    _driver.glSecondaryColorP3ui(type, color);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSecondaryColorP3ui)(type, color);
}

static void REGAL_CALL loader_glSecondaryColorP3uiv(GLenum type, const GLuint *color)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSecondaryColorP3uiv, "glSecondaryColorP3uiv");
  if (_driver.glSecondaryColorP3uiv) {
    _driver.glSecondaryColorP3uiv(type, color);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSecondaryColorP3uiv)(type, color);
}

static void REGAL_CALL loader_glTexCoordP1ui(GLenum type, GLuint coords)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoordP1ui, "glTexCoordP1ui");
  if (_driver.glTexCoordP1ui) {
    _driver.glTexCoordP1ui(type, coords);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoordP1ui)(type, coords);
}

static void REGAL_CALL loader_glTexCoordP1uiv(GLenum type, const GLuint *coords)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoordP1uiv, "glTexCoordP1uiv");
  if (_driver.glTexCoordP1uiv) {
    _driver.glTexCoordP1uiv(type, coords);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoordP1uiv)(type, coords);
}

static void REGAL_CALL loader_glTexCoordP2ui(GLenum type, GLuint coords)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoordP2ui, "glTexCoordP2ui");
  if (_driver.glTexCoordP2ui) {
    _driver.glTexCoordP2ui(type, coords);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoordP2ui)(type, coords);
}

static void REGAL_CALL loader_glTexCoordP2uiv(GLenum type, const GLuint *coords)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoordP2uiv, "glTexCoordP2uiv");
  if (_driver.glTexCoordP2uiv) {
    _driver.glTexCoordP2uiv(type, coords);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoordP2uiv)(type, coords);
}

static void REGAL_CALL loader_glTexCoordP3ui(GLenum type, GLuint coords)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoordP3ui, "glTexCoordP3ui");
  if (_driver.glTexCoordP3ui) {
    _driver.glTexCoordP3ui(type, coords);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoordP3ui)(type, coords);
}

static void REGAL_CALL loader_glTexCoordP3uiv(GLenum type, const GLuint *coords)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoordP3uiv, "glTexCoordP3uiv");
  if (_driver.glTexCoordP3uiv) {
    _driver.glTexCoordP3uiv(type, coords);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoordP3uiv)(type, coords);
}

static void REGAL_CALL loader_glTexCoordP4ui(GLenum type, GLuint coords)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoordP4ui, "glTexCoordP4ui");
  if (_driver.glTexCoordP4ui) {
    _driver.glTexCoordP4ui(type, coords);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoordP4ui)(type, coords);
}

static void REGAL_CALL loader_glTexCoordP4uiv(GLenum type, const GLuint *coords)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoordP4uiv, "glTexCoordP4uiv");
  if (_driver.glTexCoordP4uiv) {
    _driver.glTexCoordP4uiv(type, coords);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoordP4uiv)(type, coords);
}

static void REGAL_CALL loader_glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribP1ui, "glVertexAttribP1ui");
  if (_driver.glVertexAttribP1ui) {
    _driver.glVertexAttribP1ui(index, type, normalized, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribP1ui)(index, type, normalized, value);
}

static void REGAL_CALL loader_glVertexAttribP1uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribP1uiv, "glVertexAttribP1uiv");
  if (_driver.glVertexAttribP1uiv) {
    _driver.glVertexAttribP1uiv(index, type, normalized, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribP1uiv)(index, type, normalized, value);
}

static void REGAL_CALL loader_glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribP2ui, "glVertexAttribP2ui");
  if (_driver.glVertexAttribP2ui) {
    _driver.glVertexAttribP2ui(index, type, normalized, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribP2ui)(index, type, normalized, value);
}

static void REGAL_CALL loader_glVertexAttribP2uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribP2uiv, "glVertexAttribP2uiv");
  if (_driver.glVertexAttribP2uiv) {
    _driver.glVertexAttribP2uiv(index, type, normalized, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribP2uiv)(index, type, normalized, value);
}

static void REGAL_CALL loader_glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribP3ui, "glVertexAttribP3ui");
  if (_driver.glVertexAttribP3ui) {
    _driver.glVertexAttribP3ui(index, type, normalized, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribP3ui)(index, type, normalized, value);
}

static void REGAL_CALL loader_glVertexAttribP3uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribP3uiv, "glVertexAttribP3uiv");
  if (_driver.glVertexAttribP3uiv) {
    _driver.glVertexAttribP3uiv(index, type, normalized, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribP3uiv)(index, type, normalized, value);
}

static void REGAL_CALL loader_glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribP4ui, "glVertexAttribP4ui");
  if (_driver.glVertexAttribP4ui) {
    _driver.glVertexAttribP4ui(index, type, normalized, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribP4ui)(index, type, normalized, value);
}

static void REGAL_CALL loader_glVertexAttribP4uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribP4uiv, "glVertexAttribP4uiv");
  if (_driver.glVertexAttribP4uiv) {
    _driver.glVertexAttribP4uiv(index, type, normalized, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribP4uiv)(index, type, normalized, value);
}

static void REGAL_CALL loader_glVertexP2ui(GLenum type, GLuint coords)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexP2ui, "glVertexP2ui");
  if (_driver.glVertexP2ui) {
    _driver.glVertexP2ui(type, coords);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexP2ui)(type, coords);
}

static void REGAL_CALL loader_glVertexP2uiv(GLenum type, const GLuint *coords)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexP2uiv, "glVertexP2uiv");
  if (_driver.glVertexP2uiv) {
    _driver.glVertexP2uiv(type, coords);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexP2uiv)(type, coords);
}

static void REGAL_CALL loader_glVertexP3ui(GLenum type, GLuint coords)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexP3ui, "glVertexP3ui");
  if (_driver.glVertexP3ui) {
    _driver.glVertexP3ui(type, coords);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexP3ui)(type, coords);
}

static void REGAL_CALL loader_glVertexP3uiv(GLenum type, const GLuint *coords)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexP3uiv, "glVertexP3uiv");
  if (_driver.glVertexP3uiv) {
    _driver.glVertexP3uiv(type, coords);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexP3uiv)(type, coords);
}

static void REGAL_CALL loader_glVertexP4ui(GLenum type, GLuint coords)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexP4ui, "glVertexP4ui");
  if (_driver.glVertexP4ui) {
    _driver.glVertexP4ui(type, coords);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexP4ui)(type, coords);
}

static void REGAL_CALL loader_glVertexP4uiv(GLenum type, const GLuint *coords)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexP4uiv, "glVertexP4uiv");
  if (_driver.glVertexP4uiv) {
    _driver.glVertexP4uiv(type, coords);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexP4uiv)(type, coords);
}

// GL_ARB_viewport_array

static void REGAL_CALL loader_glDepthRangeArrayv(GLuint first, GLsizei count, const GLclampd *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDepthRangeArrayv, "glDepthRangeArrayv");
  if (_driver.glDepthRangeArrayv) {
    _driver.glDepthRangeArrayv(first, count, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDepthRangeArrayv)(first, count, v);
}

static void REGAL_CALL loader_glDepthRangeIndexed(GLuint index, GLclampd n, GLclampd f)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDepthRangeIndexed, "glDepthRangeIndexed");
  if (_driver.glDepthRangeIndexed) {
    _driver.glDepthRangeIndexed(index, n, f);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDepthRangeIndexed)(index, n, f);
}

static void REGAL_CALL loader_glGetDoublei_v(GLenum target, GLuint index, GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetDoublei_v, "glGetDoublei_v");
  if (_driver.glGetDoublei_v) {
    _driver.glGetDoublei_v(target, index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetDoublei_v)(target, index, v);
}

static void REGAL_CALL loader_glGetFloati_v(GLenum target, GLuint index, GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetFloati_v, "glGetFloati_v");
  if (_driver.glGetFloati_v) {
    _driver.glGetFloati_v(target, index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetFloati_v)(target, index, v);
}

static void REGAL_CALL loader_glScissorArrayv(GLuint first, GLsizei count, const GLint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glScissorArrayv, "glScissorArrayv");
  if (_driver.glScissorArrayv) {
    _driver.glScissorArrayv(first, count, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glScissorArrayv)(first, count, v);
}

static void REGAL_CALL loader_glScissorIndexed(GLuint index, GLint left, GLint bottom, GLint width, GLint height)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glScissorIndexed, "glScissorIndexed");
  if (_driver.glScissorIndexed) {
    _driver.glScissorIndexed(index, left, bottom, width, height);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glScissorIndexed)(index, left, bottom, width, height);
}

static void REGAL_CALL loader_glScissorIndexedv(GLuint index, const GLint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glScissorIndexedv, "glScissorIndexedv");
  if (_driver.glScissorIndexedv) {
    _driver.glScissorIndexedv(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glScissorIndexedv)(index, v);
}

static void REGAL_CALL loader_glViewportArrayv(GLuint first, GLsizei count, const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glViewportArrayv, "glViewportArrayv");
  if (_driver.glViewportArrayv) {
    _driver.glViewportArrayv(first, count, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glViewportArrayv)(first, count, v);
}

static void REGAL_CALL loader_glViewportIndexedf(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glViewportIndexedf, "glViewportIndexedf");
  if (_driver.glViewportIndexedf) {
    _driver.glViewportIndexedf(index, x, y, w, h);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glViewportIndexedf)(index, x, y, w, h);
}

static void REGAL_CALL loader_glViewportIndexedfv(GLuint index, const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glViewportIndexedfv, "glViewportIndexedfv");
  if (_driver.glViewportIndexedfv) {
    _driver.glViewportIndexedfv(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glViewportIndexedfv)(index, v);
}

// GL_ARB_window_pos

static void REGAL_CALL loader_glWindowPos2dARB(GLdouble x, GLdouble y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos2dARB, "glWindowPos2dARB");
  if (_driver.glWindowPos2dARB) {
    _driver.glWindowPos2dARB(x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos2dARB)(x, y);
}

static void REGAL_CALL loader_glWindowPos2dvARB(const GLdouble *p)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos2dvARB, "glWindowPos2dvARB");
  if (_driver.glWindowPos2dvARB) {
    _driver.glWindowPos2dvARB(p);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos2dvARB)(p);
}

static void REGAL_CALL loader_glWindowPos2fARB(GLfloat x, GLfloat y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos2fARB, "glWindowPos2fARB");
  if (_driver.glWindowPos2fARB) {
    _driver.glWindowPos2fARB(x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos2fARB)(x, y);
}

static void REGAL_CALL loader_glWindowPos2fvARB(const GLfloat *p)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos2fvARB, "glWindowPos2fvARB");
  if (_driver.glWindowPos2fvARB) {
    _driver.glWindowPos2fvARB(p);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos2fvARB)(p);
}

static void REGAL_CALL loader_glWindowPos2iARB(GLint x, GLint y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos2iARB, "glWindowPos2iARB");
  if (_driver.glWindowPos2iARB) {
    _driver.glWindowPos2iARB(x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos2iARB)(x, y);
}

static void REGAL_CALL loader_glWindowPos2ivARB(const GLint *p)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos2ivARB, "glWindowPos2ivARB");
  if (_driver.glWindowPos2ivARB) {
    _driver.glWindowPos2ivARB(p);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos2ivARB)(p);
}

static void REGAL_CALL loader_glWindowPos2sARB(GLshort x, GLshort y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos2sARB, "glWindowPos2sARB");
  if (_driver.glWindowPos2sARB) {
    _driver.glWindowPos2sARB(x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos2sARB)(x, y);
}

static void REGAL_CALL loader_glWindowPos2svARB(const GLshort *p)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos2svARB, "glWindowPos2svARB");
  if (_driver.glWindowPos2svARB) {
    _driver.glWindowPos2svARB(p);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos2svARB)(p);
}

static void REGAL_CALL loader_glWindowPos3dARB(GLdouble x, GLdouble y, GLdouble z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos3dARB, "glWindowPos3dARB");
  if (_driver.glWindowPos3dARB) {
    _driver.glWindowPos3dARB(x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos3dARB)(x, y, z);
}

static void REGAL_CALL loader_glWindowPos3dvARB(const GLdouble *p)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos3dvARB, "glWindowPos3dvARB");
  if (_driver.glWindowPos3dvARB) {
    _driver.glWindowPos3dvARB(p);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos3dvARB)(p);
}

static void REGAL_CALL loader_glWindowPos3fARB(GLfloat x, GLfloat y, GLfloat z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos3fARB, "glWindowPos3fARB");
  if (_driver.glWindowPos3fARB) {
    _driver.glWindowPos3fARB(x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos3fARB)(x, y, z);
}

static void REGAL_CALL loader_glWindowPos3fvARB(const GLfloat *p)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos3fvARB, "glWindowPos3fvARB");
  if (_driver.glWindowPos3fvARB) {
    _driver.glWindowPos3fvARB(p);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos3fvARB)(p);
}

static void REGAL_CALL loader_glWindowPos3iARB(GLint x, GLint y, GLint z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos3iARB, "glWindowPos3iARB");
  if (_driver.glWindowPos3iARB) {
    _driver.glWindowPos3iARB(x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos3iARB)(x, y, z);
}

static void REGAL_CALL loader_glWindowPos3ivARB(const GLint *p)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos3ivARB, "glWindowPos3ivARB");
  if (_driver.glWindowPos3ivARB) {
    _driver.glWindowPos3ivARB(p);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos3ivARB)(p);
}

static void REGAL_CALL loader_glWindowPos3sARB(GLshort x, GLshort y, GLshort z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos3sARB, "glWindowPos3sARB");
  if (_driver.glWindowPos3sARB) {
    _driver.glWindowPos3sARB(x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos3sARB)(x, y, z);
}

static void REGAL_CALL loader_glWindowPos3svARB(const GLshort *p)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos3svARB, "glWindowPos3svARB");
  if (_driver.glWindowPos3svARB) {
    _driver.glWindowPos3svARB(p);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos3svARB)(p);
}

// GL_ATI_draw_buffers

static void REGAL_CALL loader_glDrawBuffersATI(GLsizei n, const GLenum *bufs)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDrawBuffersATI, "glDrawBuffersATI");
  if (_driver.glDrawBuffersATI) {
    _driver.glDrawBuffersATI(n, bufs);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDrawBuffersATI)(n, bufs);
}

// GL_ATI_element_array

static void REGAL_CALL loader_glDrawElementArrayATI(GLenum mode, GLsizei count)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDrawElementArrayATI, "glDrawElementArrayATI");
  if (_driver.glDrawElementArrayATI) {
    _driver.glDrawElementArrayATI(mode, count);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDrawElementArrayATI)(mode, count);
}

static void REGAL_CALL loader_glDrawRangeElementArrayATI(GLenum mode, GLuint start, GLuint end, GLsizei count)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDrawRangeElementArrayATI, "glDrawRangeElementArrayATI");
  if (_driver.glDrawRangeElementArrayATI) {
    _driver.glDrawRangeElementArrayATI(mode, start, end, count);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDrawRangeElementArrayATI)(mode, start, end, count);
}

static void REGAL_CALL loader_glElementPointerATI(GLenum type, const GLvoid *pointer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glElementPointerATI, "glElementPointerATI");
  if (_driver.glElementPointerATI) {
    _driver.glElementPointerATI(type, pointer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glElementPointerATI)(type, pointer);
}

// GL_ATI_envmap_bumpmap

static void REGAL_CALL loader_glGetTexBumpParameterfvATI(GLenum pname, GLfloat *param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetTexBumpParameterfvATI, "glGetTexBumpParameterfvATI");
  if (_driver.glGetTexBumpParameterfvATI) {
    _driver.glGetTexBumpParameterfvATI(pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetTexBumpParameterfvATI)(pname, param);
}

static void REGAL_CALL loader_glGetTexBumpParameterivATI(GLenum pname, GLint *param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetTexBumpParameterivATI, "glGetTexBumpParameterivATI");
  if (_driver.glGetTexBumpParameterivATI) {
    _driver.glGetTexBumpParameterivATI(pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetTexBumpParameterivATI)(pname, param);
}

static void REGAL_CALL loader_glTexBumpParameterfvATI(GLenum pname, GLfloat *param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexBumpParameterfvATI, "glTexBumpParameterfvATI");
  if (_driver.glTexBumpParameterfvATI) {
    _driver.glTexBumpParameterfvATI(pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexBumpParameterfvATI)(pname, param);
}

static void REGAL_CALL loader_glTexBumpParameterivATI(GLenum pname, GLint *param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexBumpParameterivATI, "glTexBumpParameterivATI");
  if (_driver.glTexBumpParameterivATI) {
    _driver.glTexBumpParameterivATI(pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexBumpParameterivATI)(pname, param);
}

// GL_ATI_fragment_shader

static void REGAL_CALL loader_glAlphaFragmentOp1ATI(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glAlphaFragmentOp1ATI, "glAlphaFragmentOp1ATI");
  if (_driver.glAlphaFragmentOp1ATI) {
    _driver.glAlphaFragmentOp1ATI(op, dst, dstMod, arg1, arg1Rep, arg1Mod);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glAlphaFragmentOp1ATI)(op, dst, dstMod, arg1, arg1Rep, arg1Mod);
}

static void REGAL_CALL loader_glAlphaFragmentOp2ATI(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glAlphaFragmentOp2ATI, "glAlphaFragmentOp2ATI");
  if (_driver.glAlphaFragmentOp2ATI) {
    _driver.glAlphaFragmentOp2ATI(op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glAlphaFragmentOp2ATI)(op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);
}

static void REGAL_CALL loader_glAlphaFragmentOp3ATI(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glAlphaFragmentOp3ATI, "glAlphaFragmentOp3ATI");
  if (_driver.glAlphaFragmentOp3ATI) {
    _driver.glAlphaFragmentOp3ATI(op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glAlphaFragmentOp3ATI)(op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);
}

static void REGAL_CALL loader_glBeginFragmentShaderATI(void)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBeginFragmentShaderATI, "glBeginFragmentShaderATI");
  if (_driver.glBeginFragmentShaderATI) {
    _driver.glBeginFragmentShaderATI();
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBeginFragmentShaderATI)();
}

static void REGAL_CALL loader_glBindFragmentShaderATI(GLuint id)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBindFragmentShaderATI, "glBindFragmentShaderATI");
  if (_driver.glBindFragmentShaderATI) {
    _driver.glBindFragmentShaderATI(id);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBindFragmentShaderATI)(id);
}

static void REGAL_CALL loader_glColorFragmentOp1ATI(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColorFragmentOp1ATI, "glColorFragmentOp1ATI");
  if (_driver.glColorFragmentOp1ATI) {
    _driver.glColorFragmentOp1ATI(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColorFragmentOp1ATI)(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod);
}

static void REGAL_CALL loader_glColorFragmentOp2ATI(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColorFragmentOp2ATI, "glColorFragmentOp2ATI");
  if (_driver.glColorFragmentOp2ATI) {
    _driver.glColorFragmentOp2ATI(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColorFragmentOp2ATI)(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);
}

static void REGAL_CALL loader_glColorFragmentOp3ATI(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColorFragmentOp3ATI, "glColorFragmentOp3ATI");
  if (_driver.glColorFragmentOp3ATI) {
    _driver.glColorFragmentOp3ATI(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColorFragmentOp3ATI)(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);
}

static void REGAL_CALL loader_glDeleteFragmentShaderATI(GLuint id)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDeleteFragmentShaderATI, "glDeleteFragmentShaderATI");
  if (_driver.glDeleteFragmentShaderATI) {
    _driver.glDeleteFragmentShaderATI(id);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDeleteFragmentShaderATI)(id);
}

static void REGAL_CALL loader_glEndFragmentShaderATI(void)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glEndFragmentShaderATI, "glEndFragmentShaderATI");
  if (_driver.glEndFragmentShaderATI) {
    _driver.glEndFragmentShaderATI();
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glEndFragmentShaderATI)();
}

static GLuint REGAL_CALL loader_glGenFragmentShadersATI(GLuint range)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGenFragmentShadersATI, "glGenFragmentShadersATI");
  if (_driver.glGenFragmentShadersATI) {
    return _driver.glGenFragmentShadersATI(range);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glGenFragmentShadersATI)(range);
}

static void REGAL_CALL loader_glPassTexCoordATI(GLuint dst, GLuint coord, GLenum swizzle)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPassTexCoordATI, "glPassTexCoordATI");
  if (_driver.glPassTexCoordATI) {
    _driver.glPassTexCoordATI(dst, coord, swizzle);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPassTexCoordATI)(dst, coord, swizzle);
}

static void REGAL_CALL loader_glSampleMapATI(GLuint dst, GLuint interp, GLenum swizzle)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSampleMapATI, "glSampleMapATI");
  if (_driver.glSampleMapATI) {
    _driver.glSampleMapATI(dst, interp, swizzle);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSampleMapATI)(dst, interp, swizzle);
}

static void REGAL_CALL loader_glSetFragmentShaderConstantATI(GLuint dst, const GLfloat *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSetFragmentShaderConstantATI, "glSetFragmentShaderConstantATI");
  if (_driver.glSetFragmentShaderConstantATI) {
    _driver.glSetFragmentShaderConstantATI(dst, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSetFragmentShaderConstantATI)(dst, value);
}

// GL_ATI_map_object_buffer

static GLvoid *REGAL_CALL loader_glMapObjectBufferATI(GLuint buffer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMapObjectBufferATI, "glMapObjectBufferATI");
  if (_driver.glMapObjectBufferATI) {
    return _driver.glMapObjectBufferATI(buffer);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glMapObjectBufferATI)(buffer);
}

static void REGAL_CALL loader_glUnmapObjectBufferATI(GLuint buffer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUnmapObjectBufferATI, "glUnmapObjectBufferATI");
  if (_driver.glUnmapObjectBufferATI) {
    _driver.glUnmapObjectBufferATI(buffer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUnmapObjectBufferATI)(buffer);
}

// GL_ATI_pn_triangles

static void REGAL_CALL loader_glPNTrianglesfATI(GLenum pname, GLfloat param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPNTrianglesfATI, "glPNTrianglesfATI");
  if (_driver.glPNTrianglesfATI) {
    _driver.glPNTrianglesfATI(pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPNTrianglesfATI)(pname, param);
}

static void REGAL_CALL loader_glPNTrianglesiATI(GLenum pname, GLint param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPNTrianglesiATI, "glPNTrianglesiATI");
  if (_driver.glPNTrianglesiATI) {
    _driver.glPNTrianglesiATI(pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPNTrianglesiATI)(pname, param);
}

// GL_ATI_separate_stencil

static void REGAL_CALL loader_glStencilFuncSeparateATI(GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glStencilFuncSeparateATI, "glStencilFuncSeparateATI");
  if (_driver.glStencilFuncSeparateATI) {
    _driver.glStencilFuncSeparateATI(frontfunc, backfunc, ref, mask);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glStencilFuncSeparateATI)(frontfunc, backfunc, ref, mask);
}

static void REGAL_CALL loader_glStencilOpSeparateATI(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glStencilOpSeparateATI, "glStencilOpSeparateATI");
  if (_driver.glStencilOpSeparateATI) {
    _driver.glStencilOpSeparateATI(face, sfail, dpfail, dppass);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glStencilOpSeparateATI)(face, sfail, dpfail, dppass);
}

// GL_ATI_vertex_array_object

static void REGAL_CALL loader_glArrayObjectATI(GLenum array, GLint size, GLenum type, GLsizei stride, GLuint buffer, GLuint offset)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glArrayObjectATI, "glArrayObjectATI");
  if (_driver.glArrayObjectATI) {
    _driver.glArrayObjectATI(array, size, type, stride, buffer, offset);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glArrayObjectATI)(array, size, type, stride, buffer, offset);
}

static void REGAL_CALL loader_glFreeObjectBufferATI(GLuint buffer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFreeObjectBufferATI, "glFreeObjectBufferATI");
  if (_driver.glFreeObjectBufferATI) {
    _driver.glFreeObjectBufferATI(buffer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFreeObjectBufferATI)(buffer);
}

static void REGAL_CALL loader_glGetArrayObjectfvATI(GLenum array, GLenum pname, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetArrayObjectfvATI, "glGetArrayObjectfvATI");
  if (_driver.glGetArrayObjectfvATI) {
    _driver.glGetArrayObjectfvATI(array, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetArrayObjectfvATI)(array, pname, params);
}

static void REGAL_CALL loader_glGetArrayObjectivATI(GLenum array, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetArrayObjectivATI, "glGetArrayObjectivATI");
  if (_driver.glGetArrayObjectivATI) {
    _driver.glGetArrayObjectivATI(array, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetArrayObjectivATI)(array, pname, params);
}

static void REGAL_CALL loader_glGetObjectBufferfvATI(GLuint buffer, GLenum pname, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetObjectBufferfvATI, "glGetObjectBufferfvATI");
  if (_driver.glGetObjectBufferfvATI) {
    _driver.glGetObjectBufferfvATI(buffer, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetObjectBufferfvATI)(buffer, pname, params);
}

static void REGAL_CALL loader_glGetObjectBufferivATI(GLuint buffer, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetObjectBufferivATI, "glGetObjectBufferivATI");
  if (_driver.glGetObjectBufferivATI) {
    _driver.glGetObjectBufferivATI(buffer, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetObjectBufferivATI)(buffer, pname, params);
}

static void REGAL_CALL loader_glGetVariantArrayObjectfvATI(GLuint id, GLenum pname, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetVariantArrayObjectfvATI, "glGetVariantArrayObjectfvATI");
  if (_driver.glGetVariantArrayObjectfvATI) {
    _driver.glGetVariantArrayObjectfvATI(id, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetVariantArrayObjectfvATI)(id, pname, params);
}

static void REGAL_CALL loader_glGetVariantArrayObjectivATI(GLuint id, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetVariantArrayObjectivATI, "glGetVariantArrayObjectivATI");
  if (_driver.glGetVariantArrayObjectivATI) {
    _driver.glGetVariantArrayObjectivATI(id, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetVariantArrayObjectivATI)(id, pname, params);
}

static GLboolean REGAL_CALL loader_glIsObjectBufferATI(GLuint buffer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIsObjectBufferATI, "glIsObjectBufferATI");
  if (_driver.glIsObjectBufferATI) {
    return _driver.glIsObjectBufferATI(buffer);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glIsObjectBufferATI)(buffer);
}

static GLuint REGAL_CALL loader_glNewObjectBufferATI(GLsizei size, const GLvoid *pointer, GLenum usage)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNewObjectBufferATI, "glNewObjectBufferATI");
  if (_driver.glNewObjectBufferATI) {
    return _driver.glNewObjectBufferATI(size, pointer, usage);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glNewObjectBufferATI)(size, pointer, usage);
}

static void REGAL_CALL loader_glUpdateObjectBufferATI(GLuint buffer, GLuint offset, GLsizei size, const GLvoid *pointer, GLenum preserve)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUpdateObjectBufferATI, "glUpdateObjectBufferATI");
  if (_driver.glUpdateObjectBufferATI) {
    _driver.glUpdateObjectBufferATI(buffer, offset, size, pointer, preserve);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUpdateObjectBufferATI)(buffer, offset, size, pointer, preserve);
}

static void REGAL_CALL loader_glVariantArrayObjectATI(GLuint id, GLenum type, GLsizei stride, GLuint buffer, GLuint offset)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVariantArrayObjectATI, "glVariantArrayObjectATI");
  if (_driver.glVariantArrayObjectATI) {
    _driver.glVariantArrayObjectATI(id, type, stride, buffer, offset);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVariantArrayObjectATI)(id, type, stride, buffer, offset);
}

// GL_ATI_vertex_attrib_array_object

static void REGAL_CALL loader_glGetVertexAttribArrayObjectfvATI(GLuint index, GLenum pname, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetVertexAttribArrayObjectfvATI, "glGetVertexAttribArrayObjectfvATI");
  if (_driver.glGetVertexAttribArrayObjectfvATI) {
    _driver.glGetVertexAttribArrayObjectfvATI(index, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetVertexAttribArrayObjectfvATI)(index, pname, params);
}

static void REGAL_CALL loader_glGetVertexAttribArrayObjectivATI(GLuint index, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetVertexAttribArrayObjectivATI, "glGetVertexAttribArrayObjectivATI");
  if (_driver.glGetVertexAttribArrayObjectivATI) {
    _driver.glGetVertexAttribArrayObjectivATI(index, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetVertexAttribArrayObjectivATI)(index, pname, params);
}

static void REGAL_CALL loader_glVertexAttribArrayObjectATI(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLuint buffer, GLuint offset)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribArrayObjectATI, "glVertexAttribArrayObjectATI");
  if (_driver.glVertexAttribArrayObjectATI) {
    _driver.glVertexAttribArrayObjectATI(index, size, type, normalized, stride, buffer, offset);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribArrayObjectATI)(index, size, type, normalized, stride, buffer, offset);
}

// GL_ATI_vertex_streams

static void REGAL_CALL loader_glClientActiveVertexStreamATI(GLenum stream)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glClientActiveVertexStreamATI, "glClientActiveVertexStreamATI");
  if (_driver.glClientActiveVertexStreamATI) {
    _driver.glClientActiveVertexStreamATI(stream);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glClientActiveVertexStreamATI)(stream);
}

static void REGAL_CALL loader_glNormalStream3bATI(GLenum stream, GLbyte x, GLbyte y, GLbyte z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNormalStream3bATI, "glNormalStream3bATI");
  if (_driver.glNormalStream3bATI) {
    _driver.glNormalStream3bATI(stream, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNormalStream3bATI)(stream, x, y, z);
}

static void REGAL_CALL loader_glNormalStream3bvATI(GLenum stream, const GLbyte *coords)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNormalStream3bvATI, "glNormalStream3bvATI");
  if (_driver.glNormalStream3bvATI) {
    _driver.glNormalStream3bvATI(stream, coords);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNormalStream3bvATI)(stream, coords);
}

static void REGAL_CALL loader_glNormalStream3dATI(GLenum stream, GLdouble x, GLdouble y, GLdouble z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNormalStream3dATI, "glNormalStream3dATI");
  if (_driver.glNormalStream3dATI) {
    _driver.glNormalStream3dATI(stream, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNormalStream3dATI)(stream, x, y, z);
}

static void REGAL_CALL loader_glNormalStream3dvATI(GLenum stream, const GLdouble *coords)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNormalStream3dvATI, "glNormalStream3dvATI");
  if (_driver.glNormalStream3dvATI) {
    _driver.glNormalStream3dvATI(stream, coords);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNormalStream3dvATI)(stream, coords);
}

static void REGAL_CALL loader_glNormalStream3fATI(GLenum stream, GLfloat x, GLfloat y, GLfloat z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNormalStream3fATI, "glNormalStream3fATI");
  if (_driver.glNormalStream3fATI) {
    _driver.glNormalStream3fATI(stream, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNormalStream3fATI)(stream, x, y, z);
}

static void REGAL_CALL loader_glNormalStream3fvATI(GLenum stream, const GLfloat *coords)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNormalStream3fvATI, "glNormalStream3fvATI");
  if (_driver.glNormalStream3fvATI) {
    _driver.glNormalStream3fvATI(stream, coords);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNormalStream3fvATI)(stream, coords);
}

static void REGAL_CALL loader_glNormalStream3iATI(GLenum stream, GLint x, GLint y, GLint z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNormalStream3iATI, "glNormalStream3iATI");
  if (_driver.glNormalStream3iATI) {
    _driver.glNormalStream3iATI(stream, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNormalStream3iATI)(stream, x, y, z);
}

static void REGAL_CALL loader_glNormalStream3ivATI(GLenum stream, const GLint *coords)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNormalStream3ivATI, "glNormalStream3ivATI");
  if (_driver.glNormalStream3ivATI) {
    _driver.glNormalStream3ivATI(stream, coords);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNormalStream3ivATI)(stream, coords);
}

static void REGAL_CALL loader_glNormalStream3sATI(GLenum stream, GLshort x, GLshort y, GLshort z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNormalStream3sATI, "glNormalStream3sATI");
  if (_driver.glNormalStream3sATI) {
    _driver.glNormalStream3sATI(stream, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNormalStream3sATI)(stream, x, y, z);
}

static void REGAL_CALL loader_glNormalStream3svATI(GLenum stream, const GLshort *coords)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNormalStream3svATI, "glNormalStream3svATI");
  if (_driver.glNormalStream3svATI) {
    _driver.glNormalStream3svATI(stream, coords);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNormalStream3svATI)(stream, coords);
}

static void REGAL_CALL loader_glVertexBlendEnvfATI(GLenum pname, GLfloat param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexBlendEnvfATI, "glVertexBlendEnvfATI");
  if (_driver.glVertexBlendEnvfATI) {
    _driver.glVertexBlendEnvfATI(pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexBlendEnvfATI)(pname, param);
}

static void REGAL_CALL loader_glVertexBlendEnviATI(GLenum pname, GLint param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexBlendEnviATI, "glVertexBlendEnviATI");
  if (_driver.glVertexBlendEnviATI) {
    _driver.glVertexBlendEnviATI(pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexBlendEnviATI)(pname, param);
}

static void REGAL_CALL loader_glVertexStream1dATI(GLenum stream, GLdouble x)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexStream1dATI, "glVertexStream1dATI");
  if (_driver.glVertexStream1dATI) {
    _driver.glVertexStream1dATI(stream, x);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexStream1dATI)(stream, x);
}

static void REGAL_CALL loader_glVertexStream1dvATI(GLenum stream, const GLdouble *coords)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexStream1dvATI, "glVertexStream1dvATI");
  if (_driver.glVertexStream1dvATI) {
    _driver.glVertexStream1dvATI(stream, coords);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexStream1dvATI)(stream, coords);
}

static void REGAL_CALL loader_glVertexStream1fATI(GLenum stream, GLfloat x)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexStream1fATI, "glVertexStream1fATI");
  if (_driver.glVertexStream1fATI) {
    _driver.glVertexStream1fATI(stream, x);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexStream1fATI)(stream, x);
}

static void REGAL_CALL loader_glVertexStream1fvATI(GLenum stream, const GLfloat *coords)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexStream1fvATI, "glVertexStream1fvATI");
  if (_driver.glVertexStream1fvATI) {
    _driver.glVertexStream1fvATI(stream, coords);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexStream1fvATI)(stream, coords);
}

static void REGAL_CALL loader_glVertexStream1iATI(GLenum stream, GLint x)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexStream1iATI, "glVertexStream1iATI");
  if (_driver.glVertexStream1iATI) {
    _driver.glVertexStream1iATI(stream, x);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexStream1iATI)(stream, x);
}

static void REGAL_CALL loader_glVertexStream1ivATI(GLenum stream, const GLint *coords)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexStream1ivATI, "glVertexStream1ivATI");
  if (_driver.glVertexStream1ivATI) {
    _driver.glVertexStream1ivATI(stream, coords);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexStream1ivATI)(stream, coords);
}

static void REGAL_CALL loader_glVertexStream1sATI(GLenum stream, GLshort x)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexStream1sATI, "glVertexStream1sATI");
  if (_driver.glVertexStream1sATI) {
    _driver.glVertexStream1sATI(stream, x);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexStream1sATI)(stream, x);
}

static void REGAL_CALL loader_glVertexStream1svATI(GLenum stream, const GLshort *coords)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexStream1svATI, "glVertexStream1svATI");
  if (_driver.glVertexStream1svATI) {
    _driver.glVertexStream1svATI(stream, coords);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexStream1svATI)(stream, coords);
}

static void REGAL_CALL loader_glVertexStream2dATI(GLenum stream, GLdouble x, GLdouble y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexStream2dATI, "glVertexStream2dATI");
  if (_driver.glVertexStream2dATI) {
    _driver.glVertexStream2dATI(stream, x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexStream2dATI)(stream, x, y);
}

static void REGAL_CALL loader_glVertexStream2dvATI(GLenum stream, const GLdouble *coords)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexStream2dvATI, "glVertexStream2dvATI");
  if (_driver.glVertexStream2dvATI) {
    _driver.glVertexStream2dvATI(stream, coords);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexStream2dvATI)(stream, coords);
}

static void REGAL_CALL loader_glVertexStream2fATI(GLenum stream, GLfloat x, GLfloat y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexStream2fATI, "glVertexStream2fATI");
  if (_driver.glVertexStream2fATI) {
    _driver.glVertexStream2fATI(stream, x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexStream2fATI)(stream, x, y);
}

static void REGAL_CALL loader_glVertexStream2fvATI(GLenum stream, const GLfloat *coords)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexStream2fvATI, "glVertexStream2fvATI");
  if (_driver.glVertexStream2fvATI) {
    _driver.glVertexStream2fvATI(stream, coords);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexStream2fvATI)(stream, coords);
}

static void REGAL_CALL loader_glVertexStream2iATI(GLenum stream, GLint x, GLint y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexStream2iATI, "glVertexStream2iATI");
  if (_driver.glVertexStream2iATI) {
    _driver.glVertexStream2iATI(stream, x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexStream2iATI)(stream, x, y);
}

static void REGAL_CALL loader_glVertexStream2ivATI(GLenum stream, const GLint *coords)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexStream2ivATI, "glVertexStream2ivATI");
  if (_driver.glVertexStream2ivATI) {
    _driver.glVertexStream2ivATI(stream, coords);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexStream2ivATI)(stream, coords);
}

static void REGAL_CALL loader_glVertexStream2sATI(GLenum stream, GLshort x, GLshort y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexStream2sATI, "glVertexStream2sATI");
  if (_driver.glVertexStream2sATI) {
    _driver.glVertexStream2sATI(stream, x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexStream2sATI)(stream, x, y);
}

static void REGAL_CALL loader_glVertexStream2svATI(GLenum stream, const GLshort *coords)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexStream2svATI, "glVertexStream2svATI");
  if (_driver.glVertexStream2svATI) {
    _driver.glVertexStream2svATI(stream, coords);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexStream2svATI)(stream, coords);
}

static void REGAL_CALL loader_glVertexStream3dATI(GLenum stream, GLdouble x, GLdouble y, GLdouble z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexStream3dATI, "glVertexStream3dATI");
  if (_driver.glVertexStream3dATI) {
    _driver.glVertexStream3dATI(stream, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexStream3dATI)(stream, x, y, z);
}

static void REGAL_CALL loader_glVertexStream3dvATI(GLenum stream, const GLdouble *coords)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexStream3dvATI, "glVertexStream3dvATI");
  if (_driver.glVertexStream3dvATI) {
    _driver.glVertexStream3dvATI(stream, coords);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexStream3dvATI)(stream, coords);
}

static void REGAL_CALL loader_glVertexStream3fATI(GLenum stream, GLfloat x, GLfloat y, GLfloat z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexStream3fATI, "glVertexStream3fATI");
  if (_driver.glVertexStream3fATI) {
    _driver.glVertexStream3fATI(stream, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexStream3fATI)(stream, x, y, z);
}

static void REGAL_CALL loader_glVertexStream3fvATI(GLenum stream, const GLfloat *coords)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexStream3fvATI, "glVertexStream3fvATI");
  if (_driver.glVertexStream3fvATI) {
    _driver.glVertexStream3fvATI(stream, coords);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexStream3fvATI)(stream, coords);
}

static void REGAL_CALL loader_glVertexStream3iATI(GLenum stream, GLint x, GLint y, GLint z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexStream3iATI, "glVertexStream3iATI");
  if (_driver.glVertexStream3iATI) {
    _driver.glVertexStream3iATI(stream, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexStream3iATI)(stream, x, y, z);
}

static void REGAL_CALL loader_glVertexStream3ivATI(GLenum stream, const GLint *coords)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexStream3ivATI, "glVertexStream3ivATI");
  if (_driver.glVertexStream3ivATI) {
    _driver.glVertexStream3ivATI(stream, coords);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexStream3ivATI)(stream, coords);
}

static void REGAL_CALL loader_glVertexStream3sATI(GLenum stream, GLshort x, GLshort y, GLshort z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexStream3sATI, "glVertexStream3sATI");
  if (_driver.glVertexStream3sATI) {
    _driver.glVertexStream3sATI(stream, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexStream3sATI)(stream, x, y, z);
}

static void REGAL_CALL loader_glVertexStream3svATI(GLenum stream, const GLshort *coords)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexStream3svATI, "glVertexStream3svATI");
  if (_driver.glVertexStream3svATI) {
    _driver.glVertexStream3svATI(stream, coords);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexStream3svATI)(stream, coords);
}

static void REGAL_CALL loader_glVertexStream4dATI(GLenum stream, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexStream4dATI, "glVertexStream4dATI");
  if (_driver.glVertexStream4dATI) {
    _driver.glVertexStream4dATI(stream, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexStream4dATI)(stream, x, y, z, w);
}

static void REGAL_CALL loader_glVertexStream4dvATI(GLenum stream, const GLdouble *coords)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexStream4dvATI, "glVertexStream4dvATI");
  if (_driver.glVertexStream4dvATI) {
    _driver.glVertexStream4dvATI(stream, coords);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexStream4dvATI)(stream, coords);
}

static void REGAL_CALL loader_glVertexStream4fATI(GLenum stream, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexStream4fATI, "glVertexStream4fATI");
  if (_driver.glVertexStream4fATI) {
    _driver.glVertexStream4fATI(stream, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexStream4fATI)(stream, x, y, z, w);
}

static void REGAL_CALL loader_glVertexStream4fvATI(GLenum stream, const GLfloat *coords)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexStream4fvATI, "glVertexStream4fvATI");
  if (_driver.glVertexStream4fvATI) {
    _driver.glVertexStream4fvATI(stream, coords);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexStream4fvATI)(stream, coords);
}

static void REGAL_CALL loader_glVertexStream4iATI(GLenum stream, GLint x, GLint y, GLint z, GLint w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexStream4iATI, "glVertexStream4iATI");
  if (_driver.glVertexStream4iATI) {
    _driver.glVertexStream4iATI(stream, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexStream4iATI)(stream, x, y, z, w);
}

static void REGAL_CALL loader_glVertexStream4ivATI(GLenum stream, const GLint *coords)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexStream4ivATI, "glVertexStream4ivATI");
  if (_driver.glVertexStream4ivATI) {
    _driver.glVertexStream4ivATI(stream, coords);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexStream4ivATI)(stream, coords);
}

static void REGAL_CALL loader_glVertexStream4sATI(GLenum stream, GLshort x, GLshort y, GLshort z, GLshort w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexStream4sATI, "glVertexStream4sATI");
  if (_driver.glVertexStream4sATI) {
    _driver.glVertexStream4sATI(stream, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexStream4sATI)(stream, x, y, z, w);
}

static void REGAL_CALL loader_glVertexStream4svATI(GLenum stream, const GLshort *coords)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexStream4svATI, "glVertexStream4svATI");
  if (_driver.glVertexStream4svATI) {
    _driver.glVertexStream4svATI(stream, coords);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexStream4svATI)(stream, coords);
}

// GL_EXT_bindable_uniform

static GLint REGAL_CALL loader_glGetUniformBufferSizeEXT(GLuint program, GLint location)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetUniformBufferSizeEXT, "glGetUniformBufferSizeEXT");
  if (_driver.glGetUniformBufferSizeEXT) {
    return _driver.glGetUniformBufferSizeEXT(program, location);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glGetUniformBufferSizeEXT)(program, location);
}

static GLintptr REGAL_CALL loader_glGetUniformOffsetEXT(GLuint program, GLint location)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetUniformOffsetEXT, "glGetUniformOffsetEXT");
  if (_driver.glGetUniformOffsetEXT) {
    return _driver.glGetUniformOffsetEXT(program, location);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glGetUniformOffsetEXT)(program, location);
}

static void REGAL_CALL loader_glUniformBufferEXT(GLuint program, GLint location, GLuint buffer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniformBufferEXT, "glUniformBufferEXT");
  if (_driver.glUniformBufferEXT) {
    _driver.glUniformBufferEXT(program, location, buffer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniformBufferEXT)(program, location, buffer);
}

// GL_EXT_blend_color

static void REGAL_CALL loader_glBlendColorEXT(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBlendColorEXT, "glBlendColorEXT");
  if (_driver.glBlendColorEXT) {
    _driver.glBlendColorEXT(red, green, blue, alpha);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBlendColorEXT)(red, green, blue, alpha);
}

// GL_EXT_blend_equation_separate

static void REGAL_CALL loader_glBlendEquationSeparateEXT(GLenum modeRGB, GLenum modeAlpha)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBlendEquationSeparateEXT, "glBlendEquationSeparateEXT");
  if (_driver.glBlendEquationSeparateEXT) {
    _driver.glBlendEquationSeparateEXT(modeRGB, modeAlpha);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBlendEquationSeparateEXT)(modeRGB, modeAlpha);
}

// GL_EXT_blend_func_separate

static void REGAL_CALL loader_glBlendFuncSeparateEXT(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBlendFuncSeparateEXT, "glBlendFuncSeparateEXT");
  if (_driver.glBlendFuncSeparateEXT) {
    _driver.glBlendFuncSeparateEXT(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBlendFuncSeparateEXT)(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
}

// GL_EXT_blend_minmax

static void REGAL_CALL loader_glBlendEquationEXT(GLenum mode)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBlendEquationEXT, "glBlendEquationEXT");
  if (_driver.glBlendEquationEXT) {
    _driver.glBlendEquationEXT(mode);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBlendEquationEXT)(mode);
}

// GL_EXT_color_subtable

static void REGAL_CALL loader_glColorSubTableEXT(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *table)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColorSubTableEXT, "glColorSubTableEXT");
  if (_driver.glColorSubTableEXT) {
    _driver.glColorSubTableEXT(target, start, count, format, type, table);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColorSubTableEXT)(target, start, count, format, type, table);
}

static void REGAL_CALL loader_glCopyColorSubTableEXT(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCopyColorSubTableEXT, "glCopyColorSubTableEXT");
  if (_driver.glCopyColorSubTableEXT) {
    _driver.glCopyColorSubTableEXT(target, start, x, y, width);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCopyColorSubTableEXT)(target, start, x, y, width);
}

// GL_EXT_compiled_vertex_array

static void REGAL_CALL loader_glLockArraysEXT(GLint first, GLsizei count)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glLockArraysEXT, "glLockArraysEXT");
  if (_driver.glLockArraysEXT) {
    _driver.glLockArraysEXT(first, count);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glLockArraysEXT)(first, count);
}

static void REGAL_CALL loader_glUnlockArraysEXT(void)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUnlockArraysEXT, "glUnlockArraysEXT");
  if (_driver.glUnlockArraysEXT) {
    _driver.glUnlockArraysEXT();
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUnlockArraysEXT)();
}

// GL_EXT_convolution

static void REGAL_CALL loader_glConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glConvolutionFilter1DEXT, "glConvolutionFilter1DEXT");
  if (_driver.glConvolutionFilter1DEXT) {
    _driver.glConvolutionFilter1DEXT(target, internalformat, width, format, type, image);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glConvolutionFilter1DEXT)(target, internalformat, width, format, type, image);
}

static void REGAL_CALL loader_glConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glConvolutionFilter2DEXT, "glConvolutionFilter2DEXT");
  if (_driver.glConvolutionFilter2DEXT) {
    _driver.glConvolutionFilter2DEXT(target, internalformat, width, height, format, type, image);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glConvolutionFilter2DEXT)(target, internalformat, width, height, format, type, image);
}

static void REGAL_CALL loader_glConvolutionParameterfEXT(GLenum target, GLenum pname, GLfloat param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glConvolutionParameterfEXT, "glConvolutionParameterfEXT");
  if (_driver.glConvolutionParameterfEXT) {
    _driver.glConvolutionParameterfEXT(target, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glConvolutionParameterfEXT)(target, pname, param);
}

static void REGAL_CALL loader_glConvolutionParameterfvEXT(GLenum target, GLenum pname, const GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glConvolutionParameterfvEXT, "glConvolutionParameterfvEXT");
  if (_driver.glConvolutionParameterfvEXT) {
    _driver.glConvolutionParameterfvEXT(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glConvolutionParameterfvEXT)(target, pname, params);
}

static void REGAL_CALL loader_glConvolutionParameteriEXT(GLenum target, GLenum pname, GLint param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glConvolutionParameteriEXT, "glConvolutionParameteriEXT");
  if (_driver.glConvolutionParameteriEXT) {
    _driver.glConvolutionParameteriEXT(target, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glConvolutionParameteriEXT)(target, pname, param);
}

static void REGAL_CALL loader_glConvolutionParameterivEXT(GLenum target, GLenum pname, const GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glConvolutionParameterivEXT, "glConvolutionParameterivEXT");
  if (_driver.glConvolutionParameterivEXT) {
    _driver.glConvolutionParameterivEXT(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glConvolutionParameterivEXT)(target, pname, params);
}

static void REGAL_CALL loader_glCopyConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCopyConvolutionFilter1DEXT, "glCopyConvolutionFilter1DEXT");
  if (_driver.glCopyConvolutionFilter1DEXT) {
    _driver.glCopyConvolutionFilter1DEXT(target, internalformat, x, y, width);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCopyConvolutionFilter1DEXT)(target, internalformat, x, y, width);
}

static void REGAL_CALL loader_glCopyConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCopyConvolutionFilter2DEXT, "glCopyConvolutionFilter2DEXT");
  if (_driver.glCopyConvolutionFilter2DEXT) {
    _driver.glCopyConvolutionFilter2DEXT(target, internalformat, x, y, width, height);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCopyConvolutionFilter2DEXT)(target, internalformat, x, y, width, height);
}

static void REGAL_CALL loader_glGetConvolutionFilterEXT(GLenum target, GLenum format, GLenum type, GLvoid *image)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetConvolutionFilterEXT, "glGetConvolutionFilterEXT");
  if (_driver.glGetConvolutionFilterEXT) {
    _driver.glGetConvolutionFilterEXT(target, format, type, image);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetConvolutionFilterEXT)(target, format, type, image);
}

static void REGAL_CALL loader_glGetConvolutionParameterfvEXT(GLenum target, GLenum pname, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetConvolutionParameterfvEXT, "glGetConvolutionParameterfvEXT");
  if (_driver.glGetConvolutionParameterfvEXT) {
    _driver.glGetConvolutionParameterfvEXT(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetConvolutionParameterfvEXT)(target, pname, params);
}

static void REGAL_CALL loader_glGetConvolutionParameterivEXT(GLenum target, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetConvolutionParameterivEXT, "glGetConvolutionParameterivEXT");
  if (_driver.glGetConvolutionParameterivEXT) {
    _driver.glGetConvolutionParameterivEXT(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetConvolutionParameterivEXT)(target, pname, params);
}

static void REGAL_CALL loader_glGetSeparableFilterEXT(GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetSeparableFilterEXT, "glGetSeparableFilterEXT");
  if (_driver.glGetSeparableFilterEXT) {
    _driver.glGetSeparableFilterEXT(target, format, type, row, column, span);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetSeparableFilterEXT)(target, format, type, row, column, span);
}

static void REGAL_CALL loader_glSeparableFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSeparableFilter2DEXT, "glSeparableFilter2DEXT");
  if (_driver.glSeparableFilter2DEXT) {
    _driver.glSeparableFilter2DEXT(target, internalformat, width, height, format, type, row, column);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSeparableFilter2DEXT)(target, internalformat, width, height, format, type, row, column);
}

// GL_EXT_coordinate_frame

static void REGAL_CALL loader_glBinormal3bEXT(GLbyte bx, GLbyte by, GLbyte bz)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBinormal3bEXT, "glBinormal3bEXT");
  if (_driver.glBinormal3bEXT) {
    _driver.glBinormal3bEXT(bx, by, bz);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBinormal3bEXT)(bx, by, bz);
}

static void REGAL_CALL loader_glBinormal3bvEXT(const GLbyte *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBinormal3bvEXT, "glBinormal3bvEXT");
  if (_driver.glBinormal3bvEXT) {
    _driver.glBinormal3bvEXT(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBinormal3bvEXT)(v);
}

static void REGAL_CALL loader_glBinormal3dEXT(GLdouble bx, GLdouble by, GLdouble bz)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBinormal3dEXT, "glBinormal3dEXT");
  if (_driver.glBinormal3dEXT) {
    _driver.glBinormal3dEXT(bx, by, bz);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBinormal3dEXT)(bx, by, bz);
}

static void REGAL_CALL loader_glBinormal3dvEXT(const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBinormal3dvEXT, "glBinormal3dvEXT");
  if (_driver.glBinormal3dvEXT) {
    _driver.glBinormal3dvEXT(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBinormal3dvEXT)(v);
}

static void REGAL_CALL loader_glBinormal3fEXT(GLfloat bx, GLfloat by, GLfloat bz)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBinormal3fEXT, "glBinormal3fEXT");
  if (_driver.glBinormal3fEXT) {
    _driver.glBinormal3fEXT(bx, by, bz);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBinormal3fEXT)(bx, by, bz);
}

static void REGAL_CALL loader_glBinormal3fvEXT(const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBinormal3fvEXT, "glBinormal3fvEXT");
  if (_driver.glBinormal3fvEXT) {
    _driver.glBinormal3fvEXT(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBinormal3fvEXT)(v);
}

static void REGAL_CALL loader_glBinormal3iEXT(GLint bx, GLint by, GLint bz)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBinormal3iEXT, "glBinormal3iEXT");
  if (_driver.glBinormal3iEXT) {
    _driver.glBinormal3iEXT(bx, by, bz);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBinormal3iEXT)(bx, by, bz);
}

static void REGAL_CALL loader_glBinormal3ivEXT(const GLint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBinormal3ivEXT, "glBinormal3ivEXT");
  if (_driver.glBinormal3ivEXT) {
    _driver.glBinormal3ivEXT(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBinormal3ivEXT)(v);
}

static void REGAL_CALL loader_glBinormal3sEXT(GLshort bx, GLshort by, GLshort bz)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBinormal3sEXT, "glBinormal3sEXT");
  if (_driver.glBinormal3sEXT) {
    _driver.glBinormal3sEXT(bx, by, bz);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBinormal3sEXT)(bx, by, bz);
}

static void REGAL_CALL loader_glBinormal3svEXT(const GLshort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBinormal3svEXT, "glBinormal3svEXT");
  if (_driver.glBinormal3svEXT) {
    _driver.glBinormal3svEXT(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBinormal3svEXT)(v);
}

static void REGAL_CALL loader_glBinormalPointerEXT(GLenum type, GLsizei stride, const GLvoid *pointer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBinormalPointerEXT, "glBinormalPointerEXT");
  if (_driver.glBinormalPointerEXT) {
    _driver.glBinormalPointerEXT(type, stride, pointer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBinormalPointerEXT)(type, stride, pointer);
}

static void REGAL_CALL loader_glTangent3bEXT(GLbyte tx, GLbyte ty, GLbyte tz)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTangent3bEXT, "glTangent3bEXT");
  if (_driver.glTangent3bEXT) {
    _driver.glTangent3bEXT(tx, ty, tz);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTangent3bEXT)(tx, ty, tz);
}

static void REGAL_CALL loader_glTangent3bvEXT(const GLbyte *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTangent3bvEXT, "glTangent3bvEXT");
  if (_driver.glTangent3bvEXT) {
    _driver.glTangent3bvEXT(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTangent3bvEXT)(v);
}

static void REGAL_CALL loader_glTangent3dEXT(GLdouble tx, GLdouble ty, GLdouble tz)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTangent3dEXT, "glTangent3dEXT");
  if (_driver.glTangent3dEXT) {
    _driver.glTangent3dEXT(tx, ty, tz);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTangent3dEXT)(tx, ty, tz);
}

static void REGAL_CALL loader_glTangent3dvEXT(const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTangent3dvEXT, "glTangent3dvEXT");
  if (_driver.glTangent3dvEXT) {
    _driver.glTangent3dvEXT(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTangent3dvEXT)(v);
}

static void REGAL_CALL loader_glTangent3fEXT(GLfloat tx, GLfloat ty, GLfloat tz)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTangent3fEXT, "glTangent3fEXT");
  if (_driver.glTangent3fEXT) {
    _driver.glTangent3fEXT(tx, ty, tz);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTangent3fEXT)(tx, ty, tz);
}

static void REGAL_CALL loader_glTangent3fvEXT(const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTangent3fvEXT, "glTangent3fvEXT");
  if (_driver.glTangent3fvEXT) {
    _driver.glTangent3fvEXT(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTangent3fvEXT)(v);
}

static void REGAL_CALL loader_glTangent3iEXT(GLint tx, GLint ty, GLint tz)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTangent3iEXT, "glTangent3iEXT");
  if (_driver.glTangent3iEXT) {
    _driver.glTangent3iEXT(tx, ty, tz);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTangent3iEXT)(tx, ty, tz);
}

static void REGAL_CALL loader_glTangent3ivEXT(const GLint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTangent3ivEXT, "glTangent3ivEXT");
  if (_driver.glTangent3ivEXT) {
    _driver.glTangent3ivEXT(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTangent3ivEXT)(v);
}

static void REGAL_CALL loader_glTangent3sEXT(GLshort tx, GLshort ty, GLshort tz)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTangent3sEXT, "glTangent3sEXT");
  if (_driver.glTangent3sEXT) {
    _driver.glTangent3sEXT(tx, ty, tz);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTangent3sEXT)(tx, ty, tz);
}

static void REGAL_CALL loader_glTangent3svEXT(const GLshort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTangent3svEXT, "glTangent3svEXT");
  if (_driver.glTangent3svEXT) {
    _driver.glTangent3svEXT(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTangent3svEXT)(v);
}

static void REGAL_CALL loader_glTangentPointerEXT(GLenum type, GLsizei stride, const GLvoid *pointer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTangentPointerEXT, "glTangentPointerEXT");
  if (_driver.glTangentPointerEXT) {
    _driver.glTangentPointerEXT(type, stride, pointer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTangentPointerEXT)(type, stride, pointer);
}

// GL_EXT_copy_texture

static void REGAL_CALL loader_glCopyTexImage1DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCopyTexImage1DEXT, "glCopyTexImage1DEXT");
  if (_driver.glCopyTexImage1DEXT) {
    _driver.glCopyTexImage1DEXT(target, level, internalformat, x, y, width, border);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCopyTexImage1DEXT)(target, level, internalformat, x, y, width, border);
}

static void REGAL_CALL loader_glCopyTexImage2DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCopyTexImage2DEXT, "glCopyTexImage2DEXT");
  if (_driver.glCopyTexImage2DEXT) {
    _driver.glCopyTexImage2DEXT(target, level, internalformat, x, y, width, height, border);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCopyTexImage2DEXT)(target, level, internalformat, x, y, width, height, border);
}

static void REGAL_CALL loader_glCopyTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCopyTexSubImage1DEXT, "glCopyTexSubImage1DEXT");
  if (_driver.glCopyTexSubImage1DEXT) {
    _driver.glCopyTexSubImage1DEXT(target, level, xoffset, x, y, width);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCopyTexSubImage1DEXT)(target, level, xoffset, x, y, width);
}

static void REGAL_CALL loader_glCopyTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCopyTexSubImage2DEXT, "glCopyTexSubImage2DEXT");
  if (_driver.glCopyTexSubImage2DEXT) {
    _driver.glCopyTexSubImage2DEXT(target, level, xoffset, yoffset, x, y, width, height);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCopyTexSubImage2DEXT)(target, level, xoffset, yoffset, x, y, width, height);
}

static void REGAL_CALL loader_glCopyTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCopyTexSubImage3DEXT, "glCopyTexSubImage3DEXT");
  if (_driver.glCopyTexSubImage3DEXT) {
    _driver.glCopyTexSubImage3DEXT(target, level, xoffset, yoffset, zoffset, x, y, width, height);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCopyTexSubImage3DEXT)(target, level, xoffset, yoffset, zoffset, x, y, width, height);
}

// GL_EXT_cull_vertex

static void REGAL_CALL loader_glCullParameterdvEXT(GLenum pname, GLdouble *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCullParameterdvEXT, "glCullParameterdvEXT");
  if (_driver.glCullParameterdvEXT) {
    _driver.glCullParameterdvEXT(pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCullParameterdvEXT)(pname, params);
}

static void REGAL_CALL loader_glCullParameterfvEXT(GLenum pname, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCullParameterfvEXT, "glCullParameterfvEXT");
  if (_driver.glCullParameterfvEXT) {
    _driver.glCullParameterfvEXT(pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCullParameterfvEXT)(pname, params);
}

// GL_EXT_debug_label

static void REGAL_CALL loader_glGetObjectLabelEXT(GLenum type, GLuint object, GLsizei bufSize, GLsizei *length, GLchar *label)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetObjectLabelEXT, "glGetObjectLabelEXT");
  if (_driver.glGetObjectLabelEXT) {
    _driver.glGetObjectLabelEXT(type, object, bufSize, length, label);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetObjectLabelEXT)(type, object, bufSize, length, label);
}

static void REGAL_CALL loader_glLabelObjectEXT(GLenum type, GLuint object, GLsizei length, const GLchar *label)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glLabelObjectEXT, "glLabelObjectEXT");
  if (_driver.glLabelObjectEXT) {
    _driver.glLabelObjectEXT(type, object, length, label);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glLabelObjectEXT)(type, object, length, label);
}

// GL_EXT_debug_marker

static void REGAL_CALL loader_glInsertEventMarkerEXT(GLsizei length, const GLchar *marker)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glInsertEventMarkerEXT, "glInsertEventMarkerEXT");
  if (_driver.glInsertEventMarkerEXT) {
    _driver.glInsertEventMarkerEXT(length, marker);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glInsertEventMarkerEXT)(length, marker);
}

static void REGAL_CALL loader_glPopGroupMarkerEXT(void)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPopGroupMarkerEXT, "glPopGroupMarkerEXT");
  if (_driver.glPopGroupMarkerEXT) {
    _driver.glPopGroupMarkerEXT();
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPopGroupMarkerEXT)();
}

static void REGAL_CALL loader_glPushGroupMarkerEXT(GLsizei length, const GLchar *marker)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPushGroupMarkerEXT, "glPushGroupMarkerEXT");
  if (_driver.glPushGroupMarkerEXT) {
    _driver.glPushGroupMarkerEXT(length, marker);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPushGroupMarkerEXT)(length, marker);
}

// GL_EXT_depth_bounds_test

static void REGAL_CALL loader_glDepthBoundsEXT(GLclampd zmin, GLclampd zmax)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDepthBoundsEXT, "glDepthBoundsEXT");
  if (_driver.glDepthBoundsEXT) {
    _driver.glDepthBoundsEXT(zmin, zmax);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDepthBoundsEXT)(zmin, zmax);
}

// GL_EXT_direct_state_access

static void REGAL_CALL loader_glBindMultiTextureEXT(GLenum texunit, GLenum target, GLuint texture)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBindMultiTextureEXT, "glBindMultiTextureEXT");
  if (_driver.glBindMultiTextureEXT) {
    _driver.glBindMultiTextureEXT(texunit, target, texture);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBindMultiTextureEXT)(texunit, target, texture);
}

static GLenum REGAL_CALL loader_glCheckNamedFramebufferStatusEXT(GLuint framebuffer, GLenum target)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCheckNamedFramebufferStatusEXT, "glCheckNamedFramebufferStatusEXT");
  if (_driver.glCheckNamedFramebufferStatusEXT) {
    return _driver.glCheckNamedFramebufferStatusEXT(framebuffer, target);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glCheckNamedFramebufferStatusEXT)(framebuffer, target);
}

static void REGAL_CALL loader_glClientAttribDefaultEXT(GLbitfield mask)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glClientAttribDefaultEXT, "glClientAttribDefaultEXT");
  if (_driver.glClientAttribDefaultEXT) {
    _driver.glClientAttribDefaultEXT(mask);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glClientAttribDefaultEXT)(mask);
}

static void REGAL_CALL loader_glCompressedMultiTexImage1DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCompressedMultiTexImage1DEXT, "glCompressedMultiTexImage1DEXT");
  if (_driver.glCompressedMultiTexImage1DEXT) {
    _driver.glCompressedMultiTexImage1DEXT(texunit, target, level, internalformat, width, border, imageSize, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCompressedMultiTexImage1DEXT)(texunit, target, level, internalformat, width, border, imageSize, data);
}

static void REGAL_CALL loader_glCompressedMultiTexImage2DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *bits)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCompressedMultiTexImage2DEXT, "glCompressedMultiTexImage2DEXT");
  if (_driver.glCompressedMultiTexImage2DEXT) {
    _driver.glCompressedMultiTexImage2DEXT(texunit, target, level, internalformat, width, height, border, imageSize, bits);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCompressedMultiTexImage2DEXT)(texunit, target, level, internalformat, width, height, border, imageSize, bits);
}

static void REGAL_CALL loader_glCompressedMultiTexImage3DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *bits)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCompressedMultiTexImage3DEXT, "glCompressedMultiTexImage3DEXT");
  if (_driver.glCompressedMultiTexImage3DEXT) {
    _driver.glCompressedMultiTexImage3DEXT(texunit, target, level, internalformat, width, height, depth, border, imageSize, bits);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCompressedMultiTexImage3DEXT)(texunit, target, level, internalformat, width, height, depth, border, imageSize, bits);
}

static void REGAL_CALL loader_glCompressedMultiTexSubImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCompressedMultiTexSubImage1DEXT, "glCompressedMultiTexSubImage1DEXT");
  if (_driver.glCompressedMultiTexSubImage1DEXT) {
    _driver.glCompressedMultiTexSubImage1DEXT(texunit, target, level, xoffset, width, format, imageSize, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCompressedMultiTexSubImage1DEXT)(texunit, target, level, xoffset, width, format, imageSize, data);
}

static void REGAL_CALL loader_glCompressedMultiTexSubImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCompressedMultiTexSubImage2DEXT, "glCompressedMultiTexSubImage2DEXT");
  if (_driver.glCompressedMultiTexSubImage2DEXT) {
    _driver.glCompressedMultiTexSubImage2DEXT(texunit, target, level, xoffset, yoffset, width, height, format, imageSize, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCompressedMultiTexSubImage2DEXT)(texunit, target, level, xoffset, yoffset, width, height, format, imageSize, data);
}

static void REGAL_CALL loader_glCompressedMultiTexSubImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCompressedMultiTexSubImage3DEXT, "glCompressedMultiTexSubImage3DEXT");
  if (_driver.glCompressedMultiTexSubImage3DEXT) {
    _driver.glCompressedMultiTexSubImage3DEXT(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCompressedMultiTexSubImage3DEXT)(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
}

static void REGAL_CALL loader_glCompressedTextureImage1DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *bits)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCompressedTextureImage1DEXT, "glCompressedTextureImage1DEXT");
  if (_driver.glCompressedTextureImage1DEXT) {
    _driver.glCompressedTextureImage1DEXT(texture, target, level, internalformat, width, border, imageSize, bits);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCompressedTextureImage1DEXT)(texture, target, level, internalformat, width, border, imageSize, bits);
}

static void REGAL_CALL loader_glCompressedTextureImage2DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *bits)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCompressedTextureImage2DEXT, "glCompressedTextureImage2DEXT");
  if (_driver.glCompressedTextureImage2DEXT) {
    _driver.glCompressedTextureImage2DEXT(texture, target, level, internalformat, width, height, border, imageSize, bits);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCompressedTextureImage2DEXT)(texture, target, level, internalformat, width, height, border, imageSize, bits);
}

static void REGAL_CALL loader_glCompressedTextureImage3DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *bits)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCompressedTextureImage3DEXT, "glCompressedTextureImage3DEXT");
  if (_driver.glCompressedTextureImage3DEXT) {
    _driver.glCompressedTextureImage3DEXT(texture, target, level, internalformat, width, height, depth, border, imageSize, bits);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCompressedTextureImage3DEXT)(texture, target, level, internalformat, width, height, depth, border, imageSize, bits);
}

static void REGAL_CALL loader_glCompressedTextureSubImage1DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *bits)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCompressedTextureSubImage1DEXT, "glCompressedTextureSubImage1DEXT");
  if (_driver.glCompressedTextureSubImage1DEXT) {
    _driver.glCompressedTextureSubImage1DEXT(texture, target, level, xoffset, width, format, imageSize, bits);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCompressedTextureSubImage1DEXT)(texture, target, level, xoffset, width, format, imageSize, bits);
}

static void REGAL_CALL loader_glCompressedTextureSubImage2DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *bits)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCompressedTextureSubImage2DEXT, "glCompressedTextureSubImage2DEXT");
  if (_driver.glCompressedTextureSubImage2DEXT) {
    _driver.glCompressedTextureSubImage2DEXT(texture, target, level, xoffset, yoffset, width, height, format, imageSize, bits);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCompressedTextureSubImage2DEXT)(texture, target, level, xoffset, yoffset, width, height, format, imageSize, bits);
}

static void REGAL_CALL loader_glCompressedTextureSubImage3DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *bits)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCompressedTextureSubImage3DEXT, "glCompressedTextureSubImage3DEXT");
  if (_driver.glCompressedTextureSubImage3DEXT) {
    _driver.glCompressedTextureSubImage3DEXT(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCompressedTextureSubImage3DEXT)(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits);
}

static void REGAL_CALL loader_glCopyMultiTexImage1DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCopyMultiTexImage1DEXT, "glCopyMultiTexImage1DEXT");
  if (_driver.glCopyMultiTexImage1DEXT) {
    _driver.glCopyMultiTexImage1DEXT(texunit, target, level, internalformat, x, y, width, border);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCopyMultiTexImage1DEXT)(texunit, target, level, internalformat, x, y, width, border);
}

static void REGAL_CALL loader_glCopyMultiTexImage2DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCopyMultiTexImage2DEXT, "glCopyMultiTexImage2DEXT");
  if (_driver.glCopyMultiTexImage2DEXT) {
    _driver.glCopyMultiTexImage2DEXT(texunit, target, level, internalformat, x, y, width, height, border);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCopyMultiTexImage2DEXT)(texunit, target, level, internalformat, x, y, width, height, border);
}

static void REGAL_CALL loader_glCopyMultiTexSubImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCopyMultiTexSubImage1DEXT, "glCopyMultiTexSubImage1DEXT");
  if (_driver.glCopyMultiTexSubImage1DEXT) {
    _driver.glCopyMultiTexSubImage1DEXT(texunit, target, level, xoffset, x, y, width);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCopyMultiTexSubImage1DEXT)(texunit, target, level, xoffset, x, y, width);
}

static void REGAL_CALL loader_glCopyMultiTexSubImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCopyMultiTexSubImage2DEXT, "glCopyMultiTexSubImage2DEXT");
  if (_driver.glCopyMultiTexSubImage2DEXT) {
    _driver.glCopyMultiTexSubImage2DEXT(texunit, target, level, xoffset, yoffset, x, y, width, height);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCopyMultiTexSubImage2DEXT)(texunit, target, level, xoffset, yoffset, x, y, width, height);
}

static void REGAL_CALL loader_glCopyMultiTexSubImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCopyMultiTexSubImage3DEXT, "glCopyMultiTexSubImage3DEXT");
  if (_driver.glCopyMultiTexSubImage3DEXT) {
    _driver.glCopyMultiTexSubImage3DEXT(texunit, target, level, xoffset, yoffset, zoffset, x, y, width, height);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCopyMultiTexSubImage3DEXT)(texunit, target, level, xoffset, yoffset, zoffset, x, y, width, height);
}

static void REGAL_CALL loader_glCopyTextureImage1DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCopyTextureImage1DEXT, "glCopyTextureImage1DEXT");
  if (_driver.glCopyTextureImage1DEXT) {
    _driver.glCopyTextureImage1DEXT(texture, target, level, internalformat, x, y, width, border);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCopyTextureImage1DEXT)(texture, target, level, internalformat, x, y, width, border);
}

static void REGAL_CALL loader_glCopyTextureImage2DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCopyTextureImage2DEXT, "glCopyTextureImage2DEXT");
  if (_driver.glCopyTextureImage2DEXT) {
    _driver.glCopyTextureImage2DEXT(texture, target, level, internalformat, x, y, width, height, border);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCopyTextureImage2DEXT)(texture, target, level, internalformat, x, y, width, height, border);
}

static void REGAL_CALL loader_glCopyTextureSubImage1DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCopyTextureSubImage1DEXT, "glCopyTextureSubImage1DEXT");
  if (_driver.glCopyTextureSubImage1DEXT) {
    _driver.glCopyTextureSubImage1DEXT(texture, target, level, xoffset, x, y, width);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCopyTextureSubImage1DEXT)(texture, target, level, xoffset, x, y, width);
}

static void REGAL_CALL loader_glCopyTextureSubImage2DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCopyTextureSubImage2DEXT, "glCopyTextureSubImage2DEXT");
  if (_driver.glCopyTextureSubImage2DEXT) {
    _driver.glCopyTextureSubImage2DEXT(texture, target, level, xoffset, yoffset, x, y, width, height);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCopyTextureSubImage2DEXT)(texture, target, level, xoffset, yoffset, x, y, width, height);
}

static void REGAL_CALL loader_glCopyTextureSubImage3DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCopyTextureSubImage3DEXT, "glCopyTextureSubImage3DEXT");
  if (_driver.glCopyTextureSubImage3DEXT) {
    _driver.glCopyTextureSubImage3DEXT(texture, target, level, xoffset, yoffset, zoffset, x, y, width, height);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCopyTextureSubImage3DEXT)(texture, target, level, xoffset, yoffset, zoffset, x, y, width, height);
}

static void REGAL_CALL loader_glDisableClientStateIndexedEXT(GLenum array, GLuint index)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDisableClientStateIndexedEXT, "glDisableClientStateIndexedEXT");
  if (_driver.glDisableClientStateIndexedEXT) {
    _driver.glDisableClientStateIndexedEXT(array, index);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDisableClientStateIndexedEXT)(array, index);
}

static void REGAL_CALL loader_glDisableClientStateiEXT(GLenum array, GLuint index)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDisableClientStateiEXT, "glDisableClientStateiEXT");
  if (_driver.glDisableClientStateiEXT) {
    _driver.glDisableClientStateiEXT(array, index);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDisableClientStateiEXT)(array, index);
}

static void REGAL_CALL loader_glDisableVertexArrayAttribEXT(GLuint vaobj, GLenum array)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDisableVertexArrayAttribEXT, "glDisableVertexArrayAttribEXT");
  if (_driver.glDisableVertexArrayAttribEXT) {
    _driver.glDisableVertexArrayAttribEXT(vaobj, array);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDisableVertexArrayAttribEXT)(vaobj, array);
}

static void REGAL_CALL loader_glDisableVertexArrayEXT(GLuint vaobj, GLenum array)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDisableVertexArrayEXT, "glDisableVertexArrayEXT");
  if (_driver.glDisableVertexArrayEXT) {
    _driver.glDisableVertexArrayEXT(vaobj, array);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDisableVertexArrayEXT)(vaobj, array);
}

static void REGAL_CALL loader_glEnableClientStateIndexedEXT(GLenum array, GLuint index)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glEnableClientStateIndexedEXT, "glEnableClientStateIndexedEXT");
  if (_driver.glEnableClientStateIndexedEXT) {
    _driver.glEnableClientStateIndexedEXT(array, index);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glEnableClientStateIndexedEXT)(array, index);
}

static void REGAL_CALL loader_glEnableClientStateiEXT(GLenum array, GLuint index)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glEnableClientStateiEXT, "glEnableClientStateiEXT");
  if (_driver.glEnableClientStateiEXT) {
    _driver.glEnableClientStateiEXT(array, index);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glEnableClientStateiEXT)(array, index);
}

static void REGAL_CALL loader_glEnableVertexArrayAttribEXT(GLuint vaobj, GLenum array)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glEnableVertexArrayAttribEXT, "glEnableVertexArrayAttribEXT");
  if (_driver.glEnableVertexArrayAttribEXT) {
    _driver.glEnableVertexArrayAttribEXT(vaobj, array);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glEnableVertexArrayAttribEXT)(vaobj, array);
}

static void REGAL_CALL loader_glEnableVertexArrayEXT(GLuint vaobj, GLenum array)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glEnableVertexArrayEXT, "glEnableVertexArrayEXT");
  if (_driver.glEnableVertexArrayEXT) {
    _driver.glEnableVertexArrayEXT(vaobj, array);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glEnableVertexArrayEXT)(vaobj, array);
}

static void REGAL_CALL loader_glFlushMappedNamedBufferRangeEXT(GLuint buffer, GLintptr offset, GLsizeiptr length)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFlushMappedNamedBufferRangeEXT, "glFlushMappedNamedBufferRangeEXT");
  if (_driver.glFlushMappedNamedBufferRangeEXT) {
    _driver.glFlushMappedNamedBufferRangeEXT(buffer, offset, length);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFlushMappedNamedBufferRangeEXT)(buffer, offset, length);
}

static void REGAL_CALL loader_glFramebufferDrawBufferEXT(GLuint framebuffer, GLenum mode)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFramebufferDrawBufferEXT, "glFramebufferDrawBufferEXT");
  if (_driver.glFramebufferDrawBufferEXT) {
    _driver.glFramebufferDrawBufferEXT(framebuffer, mode);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFramebufferDrawBufferEXT)(framebuffer, mode);
}

static void REGAL_CALL loader_glFramebufferDrawBuffersEXT(GLuint framebuffer, GLsizei n, const GLenum *bufs)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFramebufferDrawBuffersEXT, "glFramebufferDrawBuffersEXT");
  if (_driver.glFramebufferDrawBuffersEXT) {
    _driver.glFramebufferDrawBuffersEXT(framebuffer, n, bufs);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFramebufferDrawBuffersEXT)(framebuffer, n, bufs);
}

static void REGAL_CALL loader_glFramebufferReadBufferEXT(GLuint framebuffer, GLenum mode)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFramebufferReadBufferEXT, "glFramebufferReadBufferEXT");
  if (_driver.glFramebufferReadBufferEXT) {
    _driver.glFramebufferReadBufferEXT(framebuffer, mode);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFramebufferReadBufferEXT)(framebuffer, mode);
}

static void REGAL_CALL loader_glGenerateMultiTexMipmapEXT(GLenum texunit, GLenum target)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGenerateMultiTexMipmapEXT, "glGenerateMultiTexMipmapEXT");
  if (_driver.glGenerateMultiTexMipmapEXT) {
    _driver.glGenerateMultiTexMipmapEXT(texunit, target);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGenerateMultiTexMipmapEXT)(texunit, target);
}

static void REGAL_CALL loader_glGenerateTextureMipmapEXT(GLuint texture, GLenum target)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGenerateTextureMipmapEXT, "glGenerateTextureMipmapEXT");
  if (_driver.glGenerateTextureMipmapEXT) {
    _driver.glGenerateTextureMipmapEXT(texture, target);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGenerateTextureMipmapEXT)(texture, target);
}

static void REGAL_CALL loader_glGetCompressedMultiTexImageEXT(GLenum texunit, GLenum target, GLint lod, GLvoid *img)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetCompressedMultiTexImageEXT, "glGetCompressedMultiTexImageEXT");
  if (_driver.glGetCompressedMultiTexImageEXT) {
    _driver.glGetCompressedMultiTexImageEXT(texunit, target, lod, img);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetCompressedMultiTexImageEXT)(texunit, target, lod, img);
}

static void REGAL_CALL loader_glGetCompressedTextureImageEXT(GLuint texture, GLenum target, GLint lod, GLvoid *img)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetCompressedTextureImageEXT, "glGetCompressedTextureImageEXT");
  if (_driver.glGetCompressedTextureImageEXT) {
    _driver.glGetCompressedTextureImageEXT(texture, target, lod, img);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetCompressedTextureImageEXT)(texture, target, lod, img);
}

static void REGAL_CALL loader_glGetDoubleIndexedvEXT(GLenum target, GLuint index, GLdouble *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetDoubleIndexedvEXT, "glGetDoubleIndexedvEXT");
  if (_driver.glGetDoubleIndexedvEXT) {
    _driver.glGetDoubleIndexedvEXT(target, index, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetDoubleIndexedvEXT)(target, index, data);
}

static void REGAL_CALL loader_glGetDoublei_vEXT(GLenum target, GLuint index, GLdouble *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetDoublei_vEXT, "glGetDoublei_vEXT");
  if (_driver.glGetDoublei_vEXT) {
    _driver.glGetDoublei_vEXT(target, index, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetDoublei_vEXT)(target, index, data);
}

static void REGAL_CALL loader_glGetFloatIndexedvEXT(GLenum target, GLuint index, GLfloat *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetFloatIndexedvEXT, "glGetFloatIndexedvEXT");
  if (_driver.glGetFloatIndexedvEXT) {
    _driver.glGetFloatIndexedvEXT(target, index, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetFloatIndexedvEXT)(target, index, data);
}

static void REGAL_CALL loader_glGetFloati_vEXT(GLenum target, GLuint index, GLfloat *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetFloati_vEXT, "glGetFloati_vEXT");
  if (_driver.glGetFloati_vEXT) {
    _driver.glGetFloati_vEXT(target, index, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetFloati_vEXT)(target, index, data);
}

static void REGAL_CALL loader_glGetFramebufferParameterivEXT(GLuint framebuffer, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetFramebufferParameterivEXT, "glGetFramebufferParameterivEXT");
  if (_driver.glGetFramebufferParameterivEXT) {
    _driver.glGetFramebufferParameterivEXT(framebuffer, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetFramebufferParameterivEXT)(framebuffer, pname, params);
}

static void REGAL_CALL loader_glGetMultiTexEnvfvEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetMultiTexEnvfvEXT, "glGetMultiTexEnvfvEXT");
  if (_driver.glGetMultiTexEnvfvEXT) {
    _driver.glGetMultiTexEnvfvEXT(texunit, target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetMultiTexEnvfvEXT)(texunit, target, pname, params);
}

static void REGAL_CALL loader_glGetMultiTexEnvivEXT(GLenum texunit, GLenum target, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetMultiTexEnvivEXT, "glGetMultiTexEnvivEXT");
  if (_driver.glGetMultiTexEnvivEXT) {
    _driver.glGetMultiTexEnvivEXT(texunit, target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetMultiTexEnvivEXT)(texunit, target, pname, params);
}

static void REGAL_CALL loader_glGetMultiTexGendvEXT(GLenum texunit, GLenum coord, GLenum pname, GLdouble *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetMultiTexGendvEXT, "glGetMultiTexGendvEXT");
  if (_driver.glGetMultiTexGendvEXT) {
    _driver.glGetMultiTexGendvEXT(texunit, coord, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetMultiTexGendvEXT)(texunit, coord, pname, params);
}

static void REGAL_CALL loader_glGetMultiTexGenfvEXT(GLenum texunit, GLenum coord, GLenum pname, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetMultiTexGenfvEXT, "glGetMultiTexGenfvEXT");
  if (_driver.glGetMultiTexGenfvEXT) {
    _driver.glGetMultiTexGenfvEXT(texunit, coord, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetMultiTexGenfvEXT)(texunit, coord, pname, params);
}

static void REGAL_CALL loader_glGetMultiTexGenivEXT(GLenum texunit, GLenum coord, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetMultiTexGenivEXT, "glGetMultiTexGenivEXT");
  if (_driver.glGetMultiTexGenivEXT) {
    _driver.glGetMultiTexGenivEXT(texunit, coord, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetMultiTexGenivEXT)(texunit, coord, pname, params);
}

static void REGAL_CALL loader_glGetMultiTexImageEXT(GLenum texunit, GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetMultiTexImageEXT, "glGetMultiTexImageEXT");
  if (_driver.glGetMultiTexImageEXT) {
    _driver.glGetMultiTexImageEXT(texunit, target, level, format, type, pixels);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetMultiTexImageEXT)(texunit, target, level, format, type, pixels);
}

static void REGAL_CALL loader_glGetMultiTexLevelParameterfvEXT(GLenum texunit, GLenum target, GLint level, GLenum pname, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetMultiTexLevelParameterfvEXT, "glGetMultiTexLevelParameterfvEXT");
  if (_driver.glGetMultiTexLevelParameterfvEXT) {
    _driver.glGetMultiTexLevelParameterfvEXT(texunit, target, level, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetMultiTexLevelParameterfvEXT)(texunit, target, level, pname, params);
}

static void REGAL_CALL loader_glGetMultiTexLevelParameterivEXT(GLenum texunit, GLenum target, GLint level, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetMultiTexLevelParameterivEXT, "glGetMultiTexLevelParameterivEXT");
  if (_driver.glGetMultiTexLevelParameterivEXT) {
    _driver.glGetMultiTexLevelParameterivEXT(texunit, target, level, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetMultiTexLevelParameterivEXT)(texunit, target, level, pname, params);
}

static void REGAL_CALL loader_glGetMultiTexParameterIivEXT(GLenum texunit, GLenum target, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetMultiTexParameterIivEXT, "glGetMultiTexParameterIivEXT");
  if (_driver.glGetMultiTexParameterIivEXT) {
    _driver.glGetMultiTexParameterIivEXT(texunit, target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetMultiTexParameterIivEXT)(texunit, target, pname, params);
}

static void REGAL_CALL loader_glGetMultiTexParameterIuivEXT(GLenum texunit, GLenum target, GLenum pname, GLuint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetMultiTexParameterIuivEXT, "glGetMultiTexParameterIuivEXT");
  if (_driver.glGetMultiTexParameterIuivEXT) {
    _driver.glGetMultiTexParameterIuivEXT(texunit, target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetMultiTexParameterIuivEXT)(texunit, target, pname, params);
}

static void REGAL_CALL loader_glGetMultiTexParameterfvEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetMultiTexParameterfvEXT, "glGetMultiTexParameterfvEXT");
  if (_driver.glGetMultiTexParameterfvEXT) {
    _driver.glGetMultiTexParameterfvEXT(texunit, target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetMultiTexParameterfvEXT)(texunit, target, pname, params);
}

static void REGAL_CALL loader_glGetMultiTexParameterivEXT(GLenum texunit, GLenum target, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetMultiTexParameterivEXT, "glGetMultiTexParameterivEXT");
  if (_driver.glGetMultiTexParameterivEXT) {
    _driver.glGetMultiTexParameterivEXT(texunit, target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetMultiTexParameterivEXT)(texunit, target, pname, params);
}

static void REGAL_CALL loader_glGetNamedBufferParameterivEXT(GLuint buffer, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetNamedBufferParameterivEXT, "glGetNamedBufferParameterivEXT");
  if (_driver.glGetNamedBufferParameterivEXT) {
    _driver.glGetNamedBufferParameterivEXT(buffer, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetNamedBufferParameterivEXT)(buffer, pname, params);
}

static void REGAL_CALL loader_glGetNamedBufferPointervEXT(GLuint buffer, GLenum pname, GLvoid **params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetNamedBufferPointervEXT, "glGetNamedBufferPointervEXT");
  if (_driver.glGetNamedBufferPointervEXT) {
    _driver.glGetNamedBufferPointervEXT(buffer, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetNamedBufferPointervEXT)(buffer, pname, params);
}

static void REGAL_CALL loader_glGetNamedBufferSubDataEXT(GLuint buffer, GLintptr offset, GLsizeiptr size, GLvoid *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetNamedBufferSubDataEXT, "glGetNamedBufferSubDataEXT");
  if (_driver.glGetNamedBufferSubDataEXT) {
    _driver.glGetNamedBufferSubDataEXT(buffer, offset, size, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetNamedBufferSubDataEXT)(buffer, offset, size, data);
}

static void REGAL_CALL loader_glGetNamedFramebufferAttachmentParameterivEXT(GLuint framebuffer, GLenum attachment, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetNamedFramebufferAttachmentParameterivEXT, "glGetNamedFramebufferAttachmentParameterivEXT");
  if (_driver.glGetNamedFramebufferAttachmentParameterivEXT) {
    _driver.glGetNamedFramebufferAttachmentParameterivEXT(framebuffer, attachment, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetNamedFramebufferAttachmentParameterivEXT)(framebuffer, attachment, pname, params);
}

static void REGAL_CALL loader_glGetNamedProgramLocalParameterIivEXT(GLuint program, GLenum target, GLuint index, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetNamedProgramLocalParameterIivEXT, "glGetNamedProgramLocalParameterIivEXT");
  if (_driver.glGetNamedProgramLocalParameterIivEXT) {
    _driver.glGetNamedProgramLocalParameterIivEXT(program, target, index, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetNamedProgramLocalParameterIivEXT)(program, target, index, params);
}

static void REGAL_CALL loader_glGetNamedProgramLocalParameterIuivEXT(GLuint program, GLenum target, GLuint index, GLuint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetNamedProgramLocalParameterIuivEXT, "glGetNamedProgramLocalParameterIuivEXT");
  if (_driver.glGetNamedProgramLocalParameterIuivEXT) {
    _driver.glGetNamedProgramLocalParameterIuivEXT(program, target, index, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetNamedProgramLocalParameterIuivEXT)(program, target, index, params);
}

static void REGAL_CALL loader_glGetNamedProgramLocalParameterdvEXT(GLuint program, GLenum target, GLuint index, GLdouble *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetNamedProgramLocalParameterdvEXT, "glGetNamedProgramLocalParameterdvEXT");
  if (_driver.glGetNamedProgramLocalParameterdvEXT) {
    _driver.glGetNamedProgramLocalParameterdvEXT(program, target, index, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetNamedProgramLocalParameterdvEXT)(program, target, index, params);
}

static void REGAL_CALL loader_glGetNamedProgramLocalParameterfvEXT(GLuint program, GLenum target, GLuint index, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetNamedProgramLocalParameterfvEXT, "glGetNamedProgramLocalParameterfvEXT");
  if (_driver.glGetNamedProgramLocalParameterfvEXT) {
    _driver.glGetNamedProgramLocalParameterfvEXT(program, target, index, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetNamedProgramLocalParameterfvEXT)(program, target, index, params);
}

static void REGAL_CALL loader_glGetNamedProgramStringEXT(GLuint program, GLenum target, GLenum pname, GLvoid *string)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetNamedProgramStringEXT, "glGetNamedProgramStringEXT");
  if (_driver.glGetNamedProgramStringEXT) {
    _driver.glGetNamedProgramStringEXT(program, target, pname, string);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetNamedProgramStringEXT)(program, target, pname, string);
}

static void REGAL_CALL loader_glGetNamedProgramivEXT(GLuint program, GLenum target, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetNamedProgramivEXT, "glGetNamedProgramivEXT");
  if (_driver.glGetNamedProgramivEXT) {
    _driver.glGetNamedProgramivEXT(program, target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetNamedProgramivEXT)(program, target, pname, params);
}

static void REGAL_CALL loader_glGetNamedRenderbufferParameterivEXT(GLuint renderbuffer, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetNamedRenderbufferParameterivEXT, "glGetNamedRenderbufferParameterivEXT");
  if (_driver.glGetNamedRenderbufferParameterivEXT) {
    _driver.glGetNamedRenderbufferParameterivEXT(renderbuffer, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetNamedRenderbufferParameterivEXT)(renderbuffer, pname, params);
}

static void REGAL_CALL loader_glGetPointerIndexedvEXT(GLenum target, GLuint index, GLvoid **data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetPointerIndexedvEXT, "glGetPointerIndexedvEXT");
  if (_driver.glGetPointerIndexedvEXT) {
    _driver.glGetPointerIndexedvEXT(target, index, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetPointerIndexedvEXT)(target, index, data);
}

static void REGAL_CALL loader_glGetPointeri_vEXT(GLenum pname, GLuint index, GLvoid **params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetPointeri_vEXT, "glGetPointeri_vEXT");
  if (_driver.glGetPointeri_vEXT) {
    _driver.glGetPointeri_vEXT(pname, index, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetPointeri_vEXT)(pname, index, params);
}

static void REGAL_CALL loader_glGetTextureImageEXT(GLuint texture, GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetTextureImageEXT, "glGetTextureImageEXT");
  if (_driver.glGetTextureImageEXT) {
    _driver.glGetTextureImageEXT(texture, target, level, format, type, pixels);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetTextureImageEXT)(texture, target, level, format, type, pixels);
}

static void REGAL_CALL loader_glGetTextureLevelParameterfvEXT(GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetTextureLevelParameterfvEXT, "glGetTextureLevelParameterfvEXT");
  if (_driver.glGetTextureLevelParameterfvEXT) {
    _driver.glGetTextureLevelParameterfvEXT(texture, target, level, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetTextureLevelParameterfvEXT)(texture, target, level, pname, params);
}

static void REGAL_CALL loader_glGetTextureLevelParameterivEXT(GLuint texture, GLenum target, GLint level, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetTextureLevelParameterivEXT, "glGetTextureLevelParameterivEXT");
  if (_driver.glGetTextureLevelParameterivEXT) {
    _driver.glGetTextureLevelParameterivEXT(texture, target, level, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetTextureLevelParameterivEXT)(texture, target, level, pname, params);
}

static void REGAL_CALL loader_glGetTextureParameterIivEXT(GLuint texture, GLenum target, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetTextureParameterIivEXT, "glGetTextureParameterIivEXT");
  if (_driver.glGetTextureParameterIivEXT) {
    _driver.glGetTextureParameterIivEXT(texture, target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetTextureParameterIivEXT)(texture, target, pname, params);
}

static void REGAL_CALL loader_glGetTextureParameterIuivEXT(GLuint texture, GLenum target, GLenum pname, GLuint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetTextureParameterIuivEXT, "glGetTextureParameterIuivEXT");
  if (_driver.glGetTextureParameterIuivEXT) {
    _driver.glGetTextureParameterIuivEXT(texture, target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetTextureParameterIuivEXT)(texture, target, pname, params);
}

static void REGAL_CALL loader_glGetTextureParameterfvEXT(GLuint texture, GLenum target, GLenum pname, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetTextureParameterfvEXT, "glGetTextureParameterfvEXT");
  if (_driver.glGetTextureParameterfvEXT) {
    _driver.glGetTextureParameterfvEXT(texture, target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetTextureParameterfvEXT)(texture, target, pname, params);
}

static void REGAL_CALL loader_glGetTextureParameterivEXT(GLuint texture, GLenum target, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetTextureParameterivEXT, "glGetTextureParameterivEXT");
  if (_driver.glGetTextureParameterivEXT) {
    _driver.glGetTextureParameterivEXT(texture, target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetTextureParameterivEXT)(texture, target, pname, params);
}

static void REGAL_CALL loader_glGetVertexArrayIntegeri_vEXT(GLuint vaobj, GLuint index, GLenum pname, GLint *param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetVertexArrayIntegeri_vEXT, "glGetVertexArrayIntegeri_vEXT");
  if (_driver.glGetVertexArrayIntegeri_vEXT) {
    _driver.glGetVertexArrayIntegeri_vEXT(vaobj, index, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetVertexArrayIntegeri_vEXT)(vaobj, index, pname, param);
}

static void REGAL_CALL loader_glGetVertexArrayIntegervEXT(GLuint vaobj, GLenum pname, GLint *param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetVertexArrayIntegervEXT, "glGetVertexArrayIntegervEXT");
  if (_driver.glGetVertexArrayIntegervEXT) {
    _driver.glGetVertexArrayIntegervEXT(vaobj, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetVertexArrayIntegervEXT)(vaobj, pname, param);
}

static void REGAL_CALL loader_glGetVertexArrayPointeri_vEXT(GLuint vaobj, GLuint index, GLenum pname, GLvoid **param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetVertexArrayPointeri_vEXT, "glGetVertexArrayPointeri_vEXT");
  if (_driver.glGetVertexArrayPointeri_vEXT) {
    _driver.glGetVertexArrayPointeri_vEXT(vaobj, index, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetVertexArrayPointeri_vEXT)(vaobj, index, pname, param);
}

static void REGAL_CALL loader_glGetVertexArrayPointervEXT(GLuint vaobj, GLenum pname, GLvoid **param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetVertexArrayPointervEXT, "glGetVertexArrayPointervEXT");
  if (_driver.glGetVertexArrayPointervEXT) {
    _driver.glGetVertexArrayPointervEXT(vaobj, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetVertexArrayPointervEXT)(vaobj, pname, param);
}

static GLvoid *REGAL_CALL loader_glMapNamedBufferEXT(GLuint buffer, GLenum access)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMapNamedBufferEXT, "glMapNamedBufferEXT");
  if (_driver.glMapNamedBufferEXT) {
    return _driver.glMapNamedBufferEXT(buffer, access);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glMapNamedBufferEXT)(buffer, access);
}

static GLvoid *REGAL_CALL loader_glMapNamedBufferRangeEXT(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMapNamedBufferRangeEXT, "glMapNamedBufferRangeEXT");
  if (_driver.glMapNamedBufferRangeEXT) {
    return _driver.glMapNamedBufferRangeEXT(buffer, offset, length, access);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glMapNamedBufferRangeEXT)(buffer, offset, length, access);
}

static void REGAL_CALL loader_glMatrixFrustumEXT(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMatrixFrustumEXT, "glMatrixFrustumEXT");
  if (_driver.glMatrixFrustumEXT) {
    _driver.glMatrixFrustumEXT(mode, left, right, bottom, top, zNear, zFar);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMatrixFrustumEXT)(mode, left, right, bottom, top, zNear, zFar);
}

static void REGAL_CALL loader_glMatrixLoadIdentityEXT(GLenum mode)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMatrixLoadIdentityEXT, "glMatrixLoadIdentityEXT");
  if (_driver.glMatrixLoadIdentityEXT) {
    _driver.glMatrixLoadIdentityEXT(mode);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMatrixLoadIdentityEXT)(mode);
}

static void REGAL_CALL loader_glMatrixLoadTransposedEXT(GLenum mode, const GLdouble *m)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMatrixLoadTransposedEXT, "glMatrixLoadTransposedEXT");
  if (_driver.glMatrixLoadTransposedEXT) {
    _driver.glMatrixLoadTransposedEXT(mode, m);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMatrixLoadTransposedEXT)(mode, m);
}

static void REGAL_CALL loader_glMatrixLoadTransposefEXT(GLenum mode, const GLfloat *m)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMatrixLoadTransposefEXT, "glMatrixLoadTransposefEXT");
  if (_driver.glMatrixLoadTransposefEXT) {
    _driver.glMatrixLoadTransposefEXT(mode, m);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMatrixLoadTransposefEXT)(mode, m);
}

static void REGAL_CALL loader_glMatrixLoaddEXT(GLenum mode, const GLdouble *m)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMatrixLoaddEXT, "glMatrixLoaddEXT");
  if (_driver.glMatrixLoaddEXT) {
    _driver.glMatrixLoaddEXT(mode, m);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMatrixLoaddEXT)(mode, m);
}

static void REGAL_CALL loader_glMatrixLoadfEXT(GLenum mode, const GLfloat *m)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMatrixLoadfEXT, "glMatrixLoadfEXT");
  if (_driver.glMatrixLoadfEXT) {
    _driver.glMatrixLoadfEXT(mode, m);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMatrixLoadfEXT)(mode, m);
}

static void REGAL_CALL loader_glMatrixMultTransposedEXT(GLenum mode, const GLdouble *m)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMatrixMultTransposedEXT, "glMatrixMultTransposedEXT");
  if (_driver.glMatrixMultTransposedEXT) {
    _driver.glMatrixMultTransposedEXT(mode, m);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMatrixMultTransposedEXT)(mode, m);
}

static void REGAL_CALL loader_glMatrixMultTransposefEXT(GLenum mode, const GLfloat *m)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMatrixMultTransposefEXT, "glMatrixMultTransposefEXT");
  if (_driver.glMatrixMultTransposefEXT) {
    _driver.glMatrixMultTransposefEXT(mode, m);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMatrixMultTransposefEXT)(mode, m);
}

static void REGAL_CALL loader_glMatrixMultdEXT(GLenum mode, const GLdouble *m)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMatrixMultdEXT, "glMatrixMultdEXT");
  if (_driver.glMatrixMultdEXT) {
    _driver.glMatrixMultdEXT(mode, m);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMatrixMultdEXT)(mode, m);
}

static void REGAL_CALL loader_glMatrixMultfEXT(GLenum mode, const GLfloat *m)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMatrixMultfEXT, "glMatrixMultfEXT");
  if (_driver.glMatrixMultfEXT) {
    _driver.glMatrixMultfEXT(mode, m);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMatrixMultfEXT)(mode, m);
}

static void REGAL_CALL loader_glMatrixOrthoEXT(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMatrixOrthoEXT, "glMatrixOrthoEXT");
  if (_driver.glMatrixOrthoEXT) {
    _driver.glMatrixOrthoEXT(mode, left, right, bottom, top, zNear, zFar);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMatrixOrthoEXT)(mode, left, right, bottom, top, zNear, zFar);
}

static void REGAL_CALL loader_glMatrixPopEXT(GLenum mode)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMatrixPopEXT, "glMatrixPopEXT");
  if (_driver.glMatrixPopEXT) {
    _driver.glMatrixPopEXT(mode);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMatrixPopEXT)(mode);
}

static void REGAL_CALL loader_glMatrixPushEXT(GLenum mode)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMatrixPushEXT, "glMatrixPushEXT");
  if (_driver.glMatrixPushEXT) {
    _driver.glMatrixPushEXT(mode);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMatrixPushEXT)(mode);
}

static void REGAL_CALL loader_glMatrixRotatedEXT(GLenum mode, GLdouble angle, GLdouble x, GLdouble y, GLdouble z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMatrixRotatedEXT, "glMatrixRotatedEXT");
  if (_driver.glMatrixRotatedEXT) {
    _driver.glMatrixRotatedEXT(mode, angle, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMatrixRotatedEXT)(mode, angle, x, y, z);
}

static void REGAL_CALL loader_glMatrixRotatefEXT(GLenum mode, GLfloat angle, GLfloat x, GLfloat y, GLfloat z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMatrixRotatefEXT, "glMatrixRotatefEXT");
  if (_driver.glMatrixRotatefEXT) {
    _driver.glMatrixRotatefEXT(mode, angle, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMatrixRotatefEXT)(mode, angle, x, y, z);
}

static void REGAL_CALL loader_glMatrixScaledEXT(GLenum mode, GLdouble x, GLdouble y, GLdouble z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMatrixScaledEXT, "glMatrixScaledEXT");
  if (_driver.glMatrixScaledEXT) {
    _driver.glMatrixScaledEXT(mode, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMatrixScaledEXT)(mode, x, y, z);
}

static void REGAL_CALL loader_glMatrixScalefEXT(GLenum mode, GLfloat x, GLfloat y, GLfloat z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMatrixScalefEXT, "glMatrixScalefEXT");
  if (_driver.glMatrixScalefEXT) {
    _driver.glMatrixScalefEXT(mode, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMatrixScalefEXT)(mode, x, y, z);
}

static void REGAL_CALL loader_glMatrixTranslatedEXT(GLenum mode, GLdouble x, GLdouble y, GLdouble z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMatrixTranslatedEXT, "glMatrixTranslatedEXT");
  if (_driver.glMatrixTranslatedEXT) {
    _driver.glMatrixTranslatedEXT(mode, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMatrixTranslatedEXT)(mode, x, y, z);
}

static void REGAL_CALL loader_glMatrixTranslatefEXT(GLenum mode, GLfloat x, GLfloat y, GLfloat z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMatrixTranslatefEXT, "glMatrixTranslatefEXT");
  if (_driver.glMatrixTranslatefEXT) {
    _driver.glMatrixTranslatefEXT(mode, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMatrixTranslatefEXT)(mode, x, y, z);
}

static void REGAL_CALL loader_glMultiTexBufferEXT(GLenum texunit, GLenum target, GLenum internalformat, GLuint buffer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexBufferEXT, "glMultiTexBufferEXT");
  if (_driver.glMultiTexBufferEXT) {
    _driver.glMultiTexBufferEXT(texunit, target, internalformat, buffer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexBufferEXT)(texunit, target, internalformat, buffer);
}

static void REGAL_CALL loader_glMultiTexCoordPointerEXT(GLenum texunit, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoordPointerEXT, "glMultiTexCoordPointerEXT");
  if (_driver.glMultiTexCoordPointerEXT) {
    _driver.glMultiTexCoordPointerEXT(texunit, size, type, stride, pointer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoordPointerEXT)(texunit, size, type, stride, pointer);
}

static void REGAL_CALL loader_glMultiTexEnvfEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexEnvfEXT, "glMultiTexEnvfEXT");
  if (_driver.glMultiTexEnvfEXT) {
    _driver.glMultiTexEnvfEXT(texunit, target, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexEnvfEXT)(texunit, target, pname, param);
}

static void REGAL_CALL loader_glMultiTexEnvfvEXT(GLenum texunit, GLenum target, GLenum pname, const GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexEnvfvEXT, "glMultiTexEnvfvEXT");
  if (_driver.glMultiTexEnvfvEXT) {
    _driver.glMultiTexEnvfvEXT(texunit, target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexEnvfvEXT)(texunit, target, pname, params);
}

static void REGAL_CALL loader_glMultiTexEnviEXT(GLenum texunit, GLenum target, GLenum pname, GLint param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexEnviEXT, "glMultiTexEnviEXT");
  if (_driver.glMultiTexEnviEXT) {
    _driver.glMultiTexEnviEXT(texunit, target, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexEnviEXT)(texunit, target, pname, param);
}

static void REGAL_CALL loader_glMultiTexEnvivEXT(GLenum texunit, GLenum target, GLenum pname, const GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexEnvivEXT, "glMultiTexEnvivEXT");
  if (_driver.glMultiTexEnvivEXT) {
    _driver.glMultiTexEnvivEXT(texunit, target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexEnvivEXT)(texunit, target, pname, params);
}

static void REGAL_CALL loader_glMultiTexGendEXT(GLenum texunit, GLenum coord, GLenum pname, GLdouble param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexGendEXT, "glMultiTexGendEXT");
  if (_driver.glMultiTexGendEXT) {
    _driver.glMultiTexGendEXT(texunit, coord, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexGendEXT)(texunit, coord, pname, param);
}

static void REGAL_CALL loader_glMultiTexGendvEXT(GLenum texunit, GLenum coord, GLenum pname, const GLdouble *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexGendvEXT, "glMultiTexGendvEXT");
  if (_driver.glMultiTexGendvEXT) {
    _driver.glMultiTexGendvEXT(texunit, coord, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexGendvEXT)(texunit, coord, pname, params);
}

static void REGAL_CALL loader_glMultiTexGenfEXT(GLenum texunit, GLenum coord, GLenum pname, GLfloat param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexGenfEXT, "glMultiTexGenfEXT");
  if (_driver.glMultiTexGenfEXT) {
    _driver.glMultiTexGenfEXT(texunit, coord, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexGenfEXT)(texunit, coord, pname, param);
}

static void REGAL_CALL loader_glMultiTexGenfvEXT(GLenum texunit, GLenum coord, GLenum pname, const GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexGenfvEXT, "glMultiTexGenfvEXT");
  if (_driver.glMultiTexGenfvEXT) {
    _driver.glMultiTexGenfvEXT(texunit, coord, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexGenfvEXT)(texunit, coord, pname, params);
}

static void REGAL_CALL loader_glMultiTexGeniEXT(GLenum texunit, GLenum coord, GLenum pname, GLint param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexGeniEXT, "glMultiTexGeniEXT");
  if (_driver.glMultiTexGeniEXT) {
    _driver.glMultiTexGeniEXT(texunit, coord, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexGeniEXT)(texunit, coord, pname, param);
}

static void REGAL_CALL loader_glMultiTexGenivEXT(GLenum texunit, GLenum coord, GLenum pname, const GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexGenivEXT, "glMultiTexGenivEXT");
  if (_driver.glMultiTexGenivEXT) {
    _driver.glMultiTexGenivEXT(texunit, coord, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexGenivEXT)(texunit, coord, pname, params);
}

static void REGAL_CALL loader_glMultiTexImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexImage1DEXT, "glMultiTexImage1DEXT");
  if (_driver.glMultiTexImage1DEXT) {
    _driver.glMultiTexImage1DEXT(texunit, target, level, internalformat, width, border, format, type, pixels);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexImage1DEXT)(texunit, target, level, internalformat, width, border, format, type, pixels);
}

static void REGAL_CALL loader_glMultiTexImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexImage2DEXT, "glMultiTexImage2DEXT");
  if (_driver.glMultiTexImage2DEXT) {
    _driver.glMultiTexImage2DEXT(texunit, target, level, internalformat, width, height, border, format, type, pixels);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexImage2DEXT)(texunit, target, level, internalformat, width, height, border, format, type, pixels);
}

static void REGAL_CALL loader_glMultiTexImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexImage3DEXT, "glMultiTexImage3DEXT");
  if (_driver.glMultiTexImage3DEXT) {
    _driver.glMultiTexImage3DEXT(texunit, target, level, internalformat, width, height, depth, border, format, type, pixels);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexImage3DEXT)(texunit, target, level, internalformat, width, height, depth, border, format, type, pixels);
}

static void REGAL_CALL loader_glMultiTexParameterIivEXT(GLenum texunit, GLenum target, GLenum pname, const GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexParameterIivEXT, "glMultiTexParameterIivEXT");
  if (_driver.glMultiTexParameterIivEXT) {
    _driver.glMultiTexParameterIivEXT(texunit, target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexParameterIivEXT)(texunit, target, pname, params);
}

static void REGAL_CALL loader_glMultiTexParameterIuivEXT(GLenum texunit, GLenum target, GLenum pname, const GLuint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexParameterIuivEXT, "glMultiTexParameterIuivEXT");
  if (_driver.glMultiTexParameterIuivEXT) {
    _driver.glMultiTexParameterIuivEXT(texunit, target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexParameterIuivEXT)(texunit, target, pname, params);
}

static void REGAL_CALL loader_glMultiTexParameterfEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexParameterfEXT, "glMultiTexParameterfEXT");
  if (_driver.glMultiTexParameterfEXT) {
    _driver.glMultiTexParameterfEXT(texunit, target, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexParameterfEXT)(texunit, target, pname, param);
}

static void REGAL_CALL loader_glMultiTexParameterfvEXT(GLenum texunit, GLenum target, GLenum pname, const GLfloat *param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexParameterfvEXT, "glMultiTexParameterfvEXT");
  if (_driver.glMultiTexParameterfvEXT) {
    _driver.glMultiTexParameterfvEXT(texunit, target, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexParameterfvEXT)(texunit, target, pname, param);
}

static void REGAL_CALL loader_glMultiTexParameteriEXT(GLenum texunit, GLenum target, GLenum pname, GLint param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexParameteriEXT, "glMultiTexParameteriEXT");
  if (_driver.glMultiTexParameteriEXT) {
    _driver.glMultiTexParameteriEXT(texunit, target, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexParameteriEXT)(texunit, target, pname, param);
}

static void REGAL_CALL loader_glMultiTexParameterivEXT(GLenum texunit, GLenum target, GLenum pname, const GLint *param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexParameterivEXT, "glMultiTexParameterivEXT");
  if (_driver.glMultiTexParameterivEXT) {
    _driver.glMultiTexParameterivEXT(texunit, target, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexParameterivEXT)(texunit, target, pname, param);
}

static void REGAL_CALL loader_glMultiTexRenderbufferEXT(GLenum texunit, GLenum target, GLuint renderbuffer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexRenderbufferEXT, "glMultiTexRenderbufferEXT");
  if (_driver.glMultiTexRenderbufferEXT) {
    _driver.glMultiTexRenderbufferEXT(texunit, target, renderbuffer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexRenderbufferEXT)(texunit, target, renderbuffer);
}

static void REGAL_CALL loader_glMultiTexSubImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexSubImage1DEXT, "glMultiTexSubImage1DEXT");
  if (_driver.glMultiTexSubImage1DEXT) {
    _driver.glMultiTexSubImage1DEXT(texunit, target, level, xoffset, width, format, type, pixels);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexSubImage1DEXT)(texunit, target, level, xoffset, width, format, type, pixels);
}

static void REGAL_CALL loader_glMultiTexSubImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexSubImage2DEXT, "glMultiTexSubImage2DEXT");
  if (_driver.glMultiTexSubImage2DEXT) {
    _driver.glMultiTexSubImage2DEXT(texunit, target, level, xoffset, yoffset, width, height, format, type, pixels);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexSubImage2DEXT)(texunit, target, level, xoffset, yoffset, width, height, format, type, pixels);
}

static void REGAL_CALL loader_glMultiTexSubImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexSubImage3DEXT, "glMultiTexSubImage3DEXT");
  if (_driver.glMultiTexSubImage3DEXT) {
    _driver.glMultiTexSubImage3DEXT(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexSubImage3DEXT)(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
}

static void REGAL_CALL loader_glNamedBufferDataEXT(GLuint buffer, GLsizeiptr size, const GLvoid *data, GLenum usage)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNamedBufferDataEXT, "glNamedBufferDataEXT");
  if (_driver.glNamedBufferDataEXT) {
    _driver.glNamedBufferDataEXT(buffer, size, data, usage);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNamedBufferDataEXT)(buffer, size, data, usage);
}

static void REGAL_CALL loader_glNamedBufferSubDataEXT(GLuint buffer, GLintptr offset, GLsizeiptr size, const GLvoid *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNamedBufferSubDataEXT, "glNamedBufferSubDataEXT");
  if (_driver.glNamedBufferSubDataEXT) {
    _driver.glNamedBufferSubDataEXT(buffer, offset, size, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNamedBufferSubDataEXT)(buffer, offset, size, data);
}

static void REGAL_CALL loader_glNamedCopyBufferSubDataEXT(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNamedCopyBufferSubDataEXT, "glNamedCopyBufferSubDataEXT");
  if (_driver.glNamedCopyBufferSubDataEXT) {
    _driver.glNamedCopyBufferSubDataEXT(readBuffer, writeBuffer, readOffset, writeOffset, size);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNamedCopyBufferSubDataEXT)(readBuffer, writeBuffer, readOffset, writeOffset, size);
}

static void REGAL_CALL loader_glNamedFramebufferRenderbufferEXT(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNamedFramebufferRenderbufferEXT, "glNamedFramebufferRenderbufferEXT");
  if (_driver.glNamedFramebufferRenderbufferEXT) {
    _driver.glNamedFramebufferRenderbufferEXT(framebuffer, attachment, renderbuffertarget, renderbuffer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNamedFramebufferRenderbufferEXT)(framebuffer, attachment, renderbuffertarget, renderbuffer);
}

static void REGAL_CALL loader_glNamedFramebufferTexture1DEXT(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNamedFramebufferTexture1DEXT, "glNamedFramebufferTexture1DEXT");
  if (_driver.glNamedFramebufferTexture1DEXT) {
    _driver.glNamedFramebufferTexture1DEXT(framebuffer, attachment, textarget, texture, level);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNamedFramebufferTexture1DEXT)(framebuffer, attachment, textarget, texture, level);
}

static void REGAL_CALL loader_glNamedFramebufferTexture2DEXT(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNamedFramebufferTexture2DEXT, "glNamedFramebufferTexture2DEXT");
  if (_driver.glNamedFramebufferTexture2DEXT) {
    _driver.glNamedFramebufferTexture2DEXT(framebuffer, attachment, textarget, texture, level);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNamedFramebufferTexture2DEXT)(framebuffer, attachment, textarget, texture, level);
}

static void REGAL_CALL loader_glNamedFramebufferTexture3DEXT(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNamedFramebufferTexture3DEXT, "glNamedFramebufferTexture3DEXT");
  if (_driver.glNamedFramebufferTexture3DEXT) {
    _driver.glNamedFramebufferTexture3DEXT(framebuffer, attachment, textarget, texture, level, zoffset);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNamedFramebufferTexture3DEXT)(framebuffer, attachment, textarget, texture, level, zoffset);
}

static void REGAL_CALL loader_glNamedFramebufferTextureEXT(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNamedFramebufferTextureEXT, "glNamedFramebufferTextureEXT");
  if (_driver.glNamedFramebufferTextureEXT) {
    _driver.glNamedFramebufferTextureEXT(framebuffer, attachment, texture, level);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNamedFramebufferTextureEXT)(framebuffer, attachment, texture, level);
}

static void REGAL_CALL loader_glNamedFramebufferTextureFaceEXT(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLenum face)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNamedFramebufferTextureFaceEXT, "glNamedFramebufferTextureFaceEXT");
  if (_driver.glNamedFramebufferTextureFaceEXT) {
    _driver.glNamedFramebufferTextureFaceEXT(framebuffer, attachment, texture, level, face);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNamedFramebufferTextureFaceEXT)(framebuffer, attachment, texture, level, face);
}

static void REGAL_CALL loader_glNamedFramebufferTextureLayerEXT(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNamedFramebufferTextureLayerEXT, "glNamedFramebufferTextureLayerEXT");
  if (_driver.glNamedFramebufferTextureLayerEXT) {
    _driver.glNamedFramebufferTextureLayerEXT(framebuffer, attachment, texture, level, layer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNamedFramebufferTextureLayerEXT)(framebuffer, attachment, texture, level, layer);
}

static void REGAL_CALL loader_glNamedProgramLocalParameter4dEXT(GLuint program, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNamedProgramLocalParameter4dEXT, "glNamedProgramLocalParameter4dEXT");
  if (_driver.glNamedProgramLocalParameter4dEXT) {
    _driver.glNamedProgramLocalParameter4dEXT(program, target, index, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNamedProgramLocalParameter4dEXT)(program, target, index, x, y, z, w);
}

static void REGAL_CALL loader_glNamedProgramLocalParameter4dvEXT(GLuint program, GLenum target, GLuint index, const GLdouble *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNamedProgramLocalParameter4dvEXT, "glNamedProgramLocalParameter4dvEXT");
  if (_driver.glNamedProgramLocalParameter4dvEXT) {
    _driver.glNamedProgramLocalParameter4dvEXT(program, target, index, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNamedProgramLocalParameter4dvEXT)(program, target, index, params);
}

static void REGAL_CALL loader_glNamedProgramLocalParameter4fEXT(GLuint program, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNamedProgramLocalParameter4fEXT, "glNamedProgramLocalParameter4fEXT");
  if (_driver.glNamedProgramLocalParameter4fEXT) {
    _driver.glNamedProgramLocalParameter4fEXT(program, target, index, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNamedProgramLocalParameter4fEXT)(program, target, index, x, y, z, w);
}

static void REGAL_CALL loader_glNamedProgramLocalParameter4fvEXT(GLuint program, GLenum target, GLuint index, const GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNamedProgramLocalParameter4fvEXT, "glNamedProgramLocalParameter4fvEXT");
  if (_driver.glNamedProgramLocalParameter4fvEXT) {
    _driver.glNamedProgramLocalParameter4fvEXT(program, target, index, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNamedProgramLocalParameter4fvEXT)(program, target, index, params);
}

static void REGAL_CALL loader_glNamedProgramLocalParameterI4iEXT(GLuint program, GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNamedProgramLocalParameterI4iEXT, "glNamedProgramLocalParameterI4iEXT");
  if (_driver.glNamedProgramLocalParameterI4iEXT) {
    _driver.glNamedProgramLocalParameterI4iEXT(program, target, index, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNamedProgramLocalParameterI4iEXT)(program, target, index, x, y, z, w);
}

static void REGAL_CALL loader_glNamedProgramLocalParameterI4ivEXT(GLuint program, GLenum target, GLuint index, const GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNamedProgramLocalParameterI4ivEXT, "glNamedProgramLocalParameterI4ivEXT");
  if (_driver.glNamedProgramLocalParameterI4ivEXT) {
    _driver.glNamedProgramLocalParameterI4ivEXT(program, target, index, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNamedProgramLocalParameterI4ivEXT)(program, target, index, params);
}

static void REGAL_CALL loader_glNamedProgramLocalParameterI4uiEXT(GLuint program, GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNamedProgramLocalParameterI4uiEXT, "glNamedProgramLocalParameterI4uiEXT");
  if (_driver.glNamedProgramLocalParameterI4uiEXT) {
    _driver.glNamedProgramLocalParameterI4uiEXT(program, target, index, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNamedProgramLocalParameterI4uiEXT)(program, target, index, x, y, z, w);
}

static void REGAL_CALL loader_glNamedProgramLocalParameterI4uivEXT(GLuint program, GLenum target, GLuint index, const GLuint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNamedProgramLocalParameterI4uivEXT, "glNamedProgramLocalParameterI4uivEXT");
  if (_driver.glNamedProgramLocalParameterI4uivEXT) {
    _driver.glNamedProgramLocalParameterI4uivEXT(program, target, index, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNamedProgramLocalParameterI4uivEXT)(program, target, index, params);
}

static void REGAL_CALL loader_glNamedProgramLocalParameters4fvEXT(GLuint program, GLenum target, GLuint index, GLsizei count, const GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNamedProgramLocalParameters4fvEXT, "glNamedProgramLocalParameters4fvEXT");
  if (_driver.glNamedProgramLocalParameters4fvEXT) {
    _driver.glNamedProgramLocalParameters4fvEXT(program, target, index, count, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNamedProgramLocalParameters4fvEXT)(program, target, index, count, params);
}

static void REGAL_CALL loader_glNamedProgramLocalParametersI4ivEXT(GLuint program, GLenum target, GLuint index, GLsizei count, const GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNamedProgramLocalParametersI4ivEXT, "glNamedProgramLocalParametersI4ivEXT");
  if (_driver.glNamedProgramLocalParametersI4ivEXT) {
    _driver.glNamedProgramLocalParametersI4ivEXT(program, target, index, count, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNamedProgramLocalParametersI4ivEXT)(program, target, index, count, params);
}

static void REGAL_CALL loader_glNamedProgramLocalParametersI4uivEXT(GLuint program, GLenum target, GLuint index, GLsizei count, const GLuint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNamedProgramLocalParametersI4uivEXT, "glNamedProgramLocalParametersI4uivEXT");
  if (_driver.glNamedProgramLocalParametersI4uivEXT) {
    _driver.glNamedProgramLocalParametersI4uivEXT(program, target, index, count, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNamedProgramLocalParametersI4uivEXT)(program, target, index, count, params);
}

static void REGAL_CALL loader_glNamedProgramStringEXT(GLuint program, GLenum target, GLenum format, GLsizei len, const GLvoid *string)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNamedProgramStringEXT, "glNamedProgramStringEXT");
  if (_driver.glNamedProgramStringEXT) {
    _driver.glNamedProgramStringEXT(program, target, format, len, string);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNamedProgramStringEXT)(program, target, format, len, string);
}

static void REGAL_CALL loader_glNamedRenderbufferStorageEXT(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNamedRenderbufferStorageEXT, "glNamedRenderbufferStorageEXT");
  if (_driver.glNamedRenderbufferStorageEXT) {
    _driver.glNamedRenderbufferStorageEXT(renderbuffer, internalformat, width, height);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNamedRenderbufferStorageEXT)(renderbuffer, internalformat, width, height);
}

static void REGAL_CALL loader_glNamedRenderbufferStorageMultisampleCoverageEXT(GLuint renderbuffer, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNamedRenderbufferStorageMultisampleCoverageEXT, "glNamedRenderbufferStorageMultisampleCoverageEXT");
  if (_driver.glNamedRenderbufferStorageMultisampleCoverageEXT) {
    _driver.glNamedRenderbufferStorageMultisampleCoverageEXT(renderbuffer, coverageSamples, colorSamples, internalformat, width, height);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNamedRenderbufferStorageMultisampleCoverageEXT)(renderbuffer, coverageSamples, colorSamples, internalformat, width, height);
}

static void REGAL_CALL loader_glNamedRenderbufferStorageMultisampleEXT(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNamedRenderbufferStorageMultisampleEXT, "glNamedRenderbufferStorageMultisampleEXT");
  if (_driver.glNamedRenderbufferStorageMultisampleEXT) {
    _driver.glNamedRenderbufferStorageMultisampleEXT(renderbuffer, samples, internalformat, width, height);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNamedRenderbufferStorageMultisampleEXT)(renderbuffer, samples, internalformat, width, height);
}

static void REGAL_CALL loader_glProgramUniform1dEXT(GLuint program, GLint location, GLdouble x)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform1dEXT, "glProgramUniform1dEXT");
  if (_driver.glProgramUniform1dEXT) {
    _driver.glProgramUniform1dEXT(program, location, x);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform1dEXT)(program, location, x);
}

static void REGAL_CALL loader_glProgramUniform1dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform1dvEXT, "glProgramUniform1dvEXT");
  if (_driver.glProgramUniform1dvEXT) {
    _driver.glProgramUniform1dvEXT(program, location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform1dvEXT)(program, location, count, value);
}

static void REGAL_CALL loader_glProgramUniform1fEXT(GLuint program, GLint location, GLfloat v0)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform1fEXT, "glProgramUniform1fEXT");
  if (_driver.glProgramUniform1fEXT) {
    _driver.glProgramUniform1fEXT(program, location, v0);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform1fEXT)(program, location, v0);
}

static void REGAL_CALL loader_glProgramUniform1fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform1fvEXT, "glProgramUniform1fvEXT");
  if (_driver.glProgramUniform1fvEXT) {
    _driver.glProgramUniform1fvEXT(program, location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform1fvEXT)(program, location, count, value);
}

static void REGAL_CALL loader_glProgramUniform1iEXT(GLuint program, GLint location, GLint v0)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform1iEXT, "glProgramUniform1iEXT");
  if (_driver.glProgramUniform1iEXT) {
    _driver.glProgramUniform1iEXT(program, location, v0);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform1iEXT)(program, location, v0);
}

static void REGAL_CALL loader_glProgramUniform1ivEXT(GLuint program, GLint location, GLsizei count, const GLint *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform1ivEXT, "glProgramUniform1ivEXT");
  if (_driver.glProgramUniform1ivEXT) {
    _driver.glProgramUniform1ivEXT(program, location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform1ivEXT)(program, location, count, value);
}

static void REGAL_CALL loader_glProgramUniform1uiEXT(GLuint program, GLint location, GLuint v0)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform1uiEXT, "glProgramUniform1uiEXT");
  if (_driver.glProgramUniform1uiEXT) {
    _driver.glProgramUniform1uiEXT(program, location, v0);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform1uiEXT)(program, location, v0);
}

static void REGAL_CALL loader_glProgramUniform1uivEXT(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform1uivEXT, "glProgramUniform1uivEXT");
  if (_driver.glProgramUniform1uivEXT) {
    _driver.glProgramUniform1uivEXT(program, location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform1uivEXT)(program, location, count, value);
}

static void REGAL_CALL loader_glProgramUniform2dEXT(GLuint program, GLint location, GLdouble x, GLdouble y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform2dEXT, "glProgramUniform2dEXT");
  if (_driver.glProgramUniform2dEXT) {
    _driver.glProgramUniform2dEXT(program, location, x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform2dEXT)(program, location, x, y);
}

static void REGAL_CALL loader_glProgramUniform2dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform2dvEXT, "glProgramUniform2dvEXT");
  if (_driver.glProgramUniform2dvEXT) {
    _driver.glProgramUniform2dvEXT(program, location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform2dvEXT)(program, location, count, value);
}

static void REGAL_CALL loader_glProgramUniform2fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform2fEXT, "glProgramUniform2fEXT");
  if (_driver.glProgramUniform2fEXT) {
    _driver.glProgramUniform2fEXT(program, location, v0, v1);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform2fEXT)(program, location, v0, v1);
}

static void REGAL_CALL loader_glProgramUniform2fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform2fvEXT, "glProgramUniform2fvEXT");
  if (_driver.glProgramUniform2fvEXT) {
    _driver.glProgramUniform2fvEXT(program, location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform2fvEXT)(program, location, count, value);
}

static void REGAL_CALL loader_glProgramUniform2iEXT(GLuint program, GLint location, GLint v0, GLint v1)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform2iEXT, "glProgramUniform2iEXT");
  if (_driver.glProgramUniform2iEXT) {
    _driver.glProgramUniform2iEXT(program, location, v0, v1);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform2iEXT)(program, location, v0, v1);
}

static void REGAL_CALL loader_glProgramUniform2ivEXT(GLuint program, GLint location, GLsizei count, const GLint *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform2ivEXT, "glProgramUniform2ivEXT");
  if (_driver.glProgramUniform2ivEXT) {
    _driver.glProgramUniform2ivEXT(program, location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform2ivEXT)(program, location, count, value);
}

static void REGAL_CALL loader_glProgramUniform2uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform2uiEXT, "glProgramUniform2uiEXT");
  if (_driver.glProgramUniform2uiEXT) {
    _driver.glProgramUniform2uiEXT(program, location, v0, v1);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform2uiEXT)(program, location, v0, v1);
}

static void REGAL_CALL loader_glProgramUniform2uivEXT(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform2uivEXT, "glProgramUniform2uivEXT");
  if (_driver.glProgramUniform2uivEXT) {
    _driver.glProgramUniform2uivEXT(program, location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform2uivEXT)(program, location, count, value);
}

static void REGAL_CALL loader_glProgramUniform3dEXT(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform3dEXT, "glProgramUniform3dEXT");
  if (_driver.glProgramUniform3dEXT) {
    _driver.glProgramUniform3dEXT(program, location, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform3dEXT)(program, location, x, y, z);
}

static void REGAL_CALL loader_glProgramUniform3dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform3dvEXT, "glProgramUniform3dvEXT");
  if (_driver.glProgramUniform3dvEXT) {
    _driver.glProgramUniform3dvEXT(program, location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform3dvEXT)(program, location, count, value);
}

static void REGAL_CALL loader_glProgramUniform3fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform3fEXT, "glProgramUniform3fEXT");
  if (_driver.glProgramUniform3fEXT) {
    _driver.glProgramUniform3fEXT(program, location, v0, v1, v2);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform3fEXT)(program, location, v0, v1, v2);
}

static void REGAL_CALL loader_glProgramUniform3fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform3fvEXT, "glProgramUniform3fvEXT");
  if (_driver.glProgramUniform3fvEXT) {
    _driver.glProgramUniform3fvEXT(program, location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform3fvEXT)(program, location, count, value);
}

static void REGAL_CALL loader_glProgramUniform3iEXT(GLuint program, GLint location, GLint v0, GLint v1, GLint v2)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform3iEXT, "glProgramUniform3iEXT");
  if (_driver.glProgramUniform3iEXT) {
    _driver.glProgramUniform3iEXT(program, location, v0, v1, v2);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform3iEXT)(program, location, v0, v1, v2);
}

static void REGAL_CALL loader_glProgramUniform3ivEXT(GLuint program, GLint location, GLsizei count, const GLint *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform3ivEXT, "glProgramUniform3ivEXT");
  if (_driver.glProgramUniform3ivEXT) {
    _driver.glProgramUniform3ivEXT(program, location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform3ivEXT)(program, location, count, value);
}

static void REGAL_CALL loader_glProgramUniform3uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform3uiEXT, "glProgramUniform3uiEXT");
  if (_driver.glProgramUniform3uiEXT) {
    _driver.glProgramUniform3uiEXT(program, location, v0, v1, v2);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform3uiEXT)(program, location, v0, v1, v2);
}

static void REGAL_CALL loader_glProgramUniform3uivEXT(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform3uivEXT, "glProgramUniform3uivEXT");
  if (_driver.glProgramUniform3uivEXT) {
    _driver.glProgramUniform3uivEXT(program, location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform3uivEXT)(program, location, count, value);
}

static void REGAL_CALL loader_glProgramUniform4dEXT(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform4dEXT, "glProgramUniform4dEXT");
  if (_driver.glProgramUniform4dEXT) {
    _driver.glProgramUniform4dEXT(program, location, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform4dEXT)(program, location, x, y, z, w);
}

static void REGAL_CALL loader_glProgramUniform4dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform4dvEXT, "glProgramUniform4dvEXT");
  if (_driver.glProgramUniform4dvEXT) {
    _driver.glProgramUniform4dvEXT(program, location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform4dvEXT)(program, location, count, value);
}

static void REGAL_CALL loader_glProgramUniform4fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform4fEXT, "glProgramUniform4fEXT");
  if (_driver.glProgramUniform4fEXT) {
    _driver.glProgramUniform4fEXT(program, location, v0, v1, v2, v3);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform4fEXT)(program, location, v0, v1, v2, v3);
}

static void REGAL_CALL loader_glProgramUniform4fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform4fvEXT, "glProgramUniform4fvEXT");
  if (_driver.glProgramUniform4fvEXT) {
    _driver.glProgramUniform4fvEXT(program, location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform4fvEXT)(program, location, count, value);
}

static void REGAL_CALL loader_glProgramUniform4iEXT(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform4iEXT, "glProgramUniform4iEXT");
  if (_driver.glProgramUniform4iEXT) {
    _driver.glProgramUniform4iEXT(program, location, v0, v1, v2, v3);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform4iEXT)(program, location, v0, v1, v2, v3);
}

static void REGAL_CALL loader_glProgramUniform4ivEXT(GLuint program, GLint location, GLsizei count, const GLint *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform4ivEXT, "glProgramUniform4ivEXT");
  if (_driver.glProgramUniform4ivEXT) {
    _driver.glProgramUniform4ivEXT(program, location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform4ivEXT)(program, location, count, value);
}

static void REGAL_CALL loader_glProgramUniform4uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform4uiEXT, "glProgramUniform4uiEXT");
  if (_driver.glProgramUniform4uiEXT) {
    _driver.glProgramUniform4uiEXT(program, location, v0, v1, v2, v3);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform4uiEXT)(program, location, v0, v1, v2, v3);
}

static void REGAL_CALL loader_glProgramUniform4uivEXT(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform4uivEXT, "glProgramUniform4uivEXT");
  if (_driver.glProgramUniform4uivEXT) {
    _driver.glProgramUniform4uivEXT(program, location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform4uivEXT)(program, location, count, value);
}

static void REGAL_CALL loader_glProgramUniformMatrix2dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniformMatrix2dvEXT, "glProgramUniformMatrix2dvEXT");
  if (_driver.glProgramUniformMatrix2dvEXT) {
    _driver.glProgramUniformMatrix2dvEXT(program, location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniformMatrix2dvEXT)(program, location, count, transpose, value);
}

static void REGAL_CALL loader_glProgramUniformMatrix2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniformMatrix2fvEXT, "glProgramUniformMatrix2fvEXT");
  if (_driver.glProgramUniformMatrix2fvEXT) {
    _driver.glProgramUniformMatrix2fvEXT(program, location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniformMatrix2fvEXT)(program, location, count, transpose, value);
}

static void REGAL_CALL loader_glProgramUniformMatrix2x3dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniformMatrix2x3dvEXT, "glProgramUniformMatrix2x3dvEXT");
  if (_driver.glProgramUniformMatrix2x3dvEXT) {
    _driver.glProgramUniformMatrix2x3dvEXT(program, location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniformMatrix2x3dvEXT)(program, location, count, transpose, value);
}

static void REGAL_CALL loader_glProgramUniformMatrix2x3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniformMatrix2x3fvEXT, "glProgramUniformMatrix2x3fvEXT");
  if (_driver.glProgramUniformMatrix2x3fvEXT) {
    _driver.glProgramUniformMatrix2x3fvEXT(program, location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniformMatrix2x3fvEXT)(program, location, count, transpose, value);
}

static void REGAL_CALL loader_glProgramUniformMatrix2x4dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniformMatrix2x4dvEXT, "glProgramUniformMatrix2x4dvEXT");
  if (_driver.glProgramUniformMatrix2x4dvEXT) {
    _driver.glProgramUniformMatrix2x4dvEXT(program, location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniformMatrix2x4dvEXT)(program, location, count, transpose, value);
}

static void REGAL_CALL loader_glProgramUniformMatrix2x4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniformMatrix2x4fvEXT, "glProgramUniformMatrix2x4fvEXT");
  if (_driver.glProgramUniformMatrix2x4fvEXT) {
    _driver.glProgramUniformMatrix2x4fvEXT(program, location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniformMatrix2x4fvEXT)(program, location, count, transpose, value);
}

static void REGAL_CALL loader_glProgramUniformMatrix3dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniformMatrix3dvEXT, "glProgramUniformMatrix3dvEXT");
  if (_driver.glProgramUniformMatrix3dvEXT) {
    _driver.glProgramUniformMatrix3dvEXT(program, location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniformMatrix3dvEXT)(program, location, count, transpose, value);
}

static void REGAL_CALL loader_glProgramUniformMatrix3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniformMatrix3fvEXT, "glProgramUniformMatrix3fvEXT");
  if (_driver.glProgramUniformMatrix3fvEXT) {
    _driver.glProgramUniformMatrix3fvEXT(program, location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniformMatrix3fvEXT)(program, location, count, transpose, value);
}

static void REGAL_CALL loader_glProgramUniformMatrix3x2dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniformMatrix3x2dvEXT, "glProgramUniformMatrix3x2dvEXT");
  if (_driver.glProgramUniformMatrix3x2dvEXT) {
    _driver.glProgramUniformMatrix3x2dvEXT(program, location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniformMatrix3x2dvEXT)(program, location, count, transpose, value);
}

static void REGAL_CALL loader_glProgramUniformMatrix3x2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniformMatrix3x2fvEXT, "glProgramUniformMatrix3x2fvEXT");
  if (_driver.glProgramUniformMatrix3x2fvEXT) {
    _driver.glProgramUniformMatrix3x2fvEXT(program, location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniformMatrix3x2fvEXT)(program, location, count, transpose, value);
}

static void REGAL_CALL loader_glProgramUniformMatrix3x4dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniformMatrix3x4dvEXT, "glProgramUniformMatrix3x4dvEXT");
  if (_driver.glProgramUniformMatrix3x4dvEXT) {
    _driver.glProgramUniformMatrix3x4dvEXT(program, location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniformMatrix3x4dvEXT)(program, location, count, transpose, value);
}

static void REGAL_CALL loader_glProgramUniformMatrix3x4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniformMatrix3x4fvEXT, "glProgramUniformMatrix3x4fvEXT");
  if (_driver.glProgramUniformMatrix3x4fvEXT) {
    _driver.glProgramUniformMatrix3x4fvEXT(program, location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniformMatrix3x4fvEXT)(program, location, count, transpose, value);
}

static void REGAL_CALL loader_glProgramUniformMatrix4dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniformMatrix4dvEXT, "glProgramUniformMatrix4dvEXT");
  if (_driver.glProgramUniformMatrix4dvEXT) {
    _driver.glProgramUniformMatrix4dvEXT(program, location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniformMatrix4dvEXT)(program, location, count, transpose, value);
}

static void REGAL_CALL loader_glProgramUniformMatrix4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniformMatrix4fvEXT, "glProgramUniformMatrix4fvEXT");
  if (_driver.glProgramUniformMatrix4fvEXT) {
    _driver.glProgramUniformMatrix4fvEXT(program, location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniformMatrix4fvEXT)(program, location, count, transpose, value);
}

static void REGAL_CALL loader_glProgramUniformMatrix4x2dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniformMatrix4x2dvEXT, "glProgramUniformMatrix4x2dvEXT");
  if (_driver.glProgramUniformMatrix4x2dvEXT) {
    _driver.glProgramUniformMatrix4x2dvEXT(program, location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniformMatrix4x2dvEXT)(program, location, count, transpose, value);
}

static void REGAL_CALL loader_glProgramUniformMatrix4x2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniformMatrix4x2fvEXT, "glProgramUniformMatrix4x2fvEXT");
  if (_driver.glProgramUniformMatrix4x2fvEXT) {
    _driver.glProgramUniformMatrix4x2fvEXT(program, location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniformMatrix4x2fvEXT)(program, location, count, transpose, value);
}

static void REGAL_CALL loader_glProgramUniformMatrix4x3dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniformMatrix4x3dvEXT, "glProgramUniformMatrix4x3dvEXT");
  if (_driver.glProgramUniformMatrix4x3dvEXT) {
    _driver.glProgramUniformMatrix4x3dvEXT(program, location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniformMatrix4x3dvEXT)(program, location, count, transpose, value);
}

static void REGAL_CALL loader_glProgramUniformMatrix4x3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniformMatrix4x3fvEXT, "glProgramUniformMatrix4x3fvEXT");
  if (_driver.glProgramUniformMatrix4x3fvEXT) {
    _driver.glProgramUniformMatrix4x3fvEXT(program, location, count, transpose, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniformMatrix4x3fvEXT)(program, location, count, transpose, value);
}

static void REGAL_CALL loader_glPushClientAttribDefaultEXT(GLbitfield mask)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPushClientAttribDefaultEXT, "glPushClientAttribDefaultEXT");
  if (_driver.glPushClientAttribDefaultEXT) {
    _driver.glPushClientAttribDefaultEXT(mask);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPushClientAttribDefaultEXT)(mask);
}

static void REGAL_CALL loader_glTextureBufferEXT(GLuint texture, GLenum target, GLenum internalformat, GLuint buffer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTextureBufferEXT, "glTextureBufferEXT");
  if (_driver.glTextureBufferEXT) {
    _driver.glTextureBufferEXT(texture, target, internalformat, buffer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTextureBufferEXT)(texture, target, internalformat, buffer);
}

static void REGAL_CALL loader_glTextureImage1DEXT(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTextureImage1DEXT, "glTextureImage1DEXT");
  if (_driver.glTextureImage1DEXT) {
    _driver.glTextureImage1DEXT(texture, target, level, internalformat, width, border, format, type, pixels);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTextureImage1DEXT)(texture, target, level, internalformat, width, border, format, type, pixels);
}

static void REGAL_CALL loader_glTextureImage2DEXT(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTextureImage2DEXT, "glTextureImage2DEXT");
  if (_driver.glTextureImage2DEXT) {
    _driver.glTextureImage2DEXT(texture, target, level, internalformat, width, height, border, format, type, pixels);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTextureImage2DEXT)(texture, target, level, internalformat, width, height, border, format, type, pixels);
}

static void REGAL_CALL loader_glTextureImage3DEXT(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTextureImage3DEXT, "glTextureImage3DEXT");
  if (_driver.glTextureImage3DEXT) {
    _driver.glTextureImage3DEXT(texture, target, level, internalformat, width, height, depth, border, format, type, pixels);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTextureImage3DEXT)(texture, target, level, internalformat, width, height, depth, border, format, type, pixels);
}

static void REGAL_CALL loader_glTextureParameterIivEXT(GLuint texture, GLenum target, GLenum pname, const GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTextureParameterIivEXT, "glTextureParameterIivEXT");
  if (_driver.glTextureParameterIivEXT) {
    _driver.glTextureParameterIivEXT(texture, target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTextureParameterIivEXT)(texture, target, pname, params);
}

static void REGAL_CALL loader_glTextureParameterIuivEXT(GLuint texture, GLenum target, GLenum pname, const GLuint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTextureParameterIuivEXT, "glTextureParameterIuivEXT");
  if (_driver.glTextureParameterIuivEXT) {
    _driver.glTextureParameterIuivEXT(texture, target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTextureParameterIuivEXT)(texture, target, pname, params);
}

static void REGAL_CALL loader_glTextureParameterfEXT(GLuint texture, GLenum target, GLenum pname, GLfloat param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTextureParameterfEXT, "glTextureParameterfEXT");
  if (_driver.glTextureParameterfEXT) {
    _driver.glTextureParameterfEXT(texture, target, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTextureParameterfEXT)(texture, target, pname, param);
}

static void REGAL_CALL loader_glTextureParameterfvEXT(GLuint texture, GLenum target, GLenum pname, const GLfloat *param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTextureParameterfvEXT, "glTextureParameterfvEXT");
  if (_driver.glTextureParameterfvEXT) {
    _driver.glTextureParameterfvEXT(texture, target, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTextureParameterfvEXT)(texture, target, pname, param);
}

static void REGAL_CALL loader_glTextureParameteriEXT(GLuint texture, GLenum target, GLenum pname, GLint param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTextureParameteriEXT, "glTextureParameteriEXT");
  if (_driver.glTextureParameteriEXT) {
    _driver.glTextureParameteriEXT(texture, target, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTextureParameteriEXT)(texture, target, pname, param);
}

static void REGAL_CALL loader_glTextureParameterivEXT(GLuint texture, GLenum target, GLenum pname, const GLint *param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTextureParameterivEXT, "glTextureParameterivEXT");
  if (_driver.glTextureParameterivEXT) {
    _driver.glTextureParameterivEXT(texture, target, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTextureParameterivEXT)(texture, target, pname, param);
}

static void REGAL_CALL loader_glTextureRenderbufferEXT(GLuint texture, GLenum target, GLuint renderbuffer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTextureRenderbufferEXT, "glTextureRenderbufferEXT");
  if (_driver.glTextureRenderbufferEXT) {
    _driver.glTextureRenderbufferEXT(texture, target, renderbuffer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTextureRenderbufferEXT)(texture, target, renderbuffer);
}

static void REGAL_CALL loader_glTextureSubImage1DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTextureSubImage1DEXT, "glTextureSubImage1DEXT");
  if (_driver.glTextureSubImage1DEXT) {
    _driver.glTextureSubImage1DEXT(texture, target, level, xoffset, width, format, type, pixels);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTextureSubImage1DEXT)(texture, target, level, xoffset, width, format, type, pixels);
}

static void REGAL_CALL loader_glTextureSubImage2DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTextureSubImage2DEXT, "glTextureSubImage2DEXT");
  if (_driver.glTextureSubImage2DEXT) {
    _driver.glTextureSubImage2DEXT(texture, target, level, xoffset, yoffset, width, height, format, type, pixels);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTextureSubImage2DEXT)(texture, target, level, xoffset, yoffset, width, height, format, type, pixels);
}

static void REGAL_CALL loader_glTextureSubImage3DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTextureSubImage3DEXT, "glTextureSubImage3DEXT");
  if (_driver.glTextureSubImage3DEXT) {
    _driver.glTextureSubImage3DEXT(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTextureSubImage3DEXT)(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
}

static GLboolean REGAL_CALL loader_glUnmapNamedBufferEXT(GLuint buffer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUnmapNamedBufferEXT, "glUnmapNamedBufferEXT");
  if (_driver.glUnmapNamedBufferEXT) {
    return _driver.glUnmapNamedBufferEXT(buffer);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glUnmapNamedBufferEXT)(buffer);
}

static void REGAL_CALL loader_glVertexArrayColorOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, const GLintptr offset)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexArrayColorOffsetEXT, "glVertexArrayColorOffsetEXT");
  if (_driver.glVertexArrayColorOffsetEXT) {
    _driver.glVertexArrayColorOffsetEXT(vaobj, buffer, size, type, stride, offset);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexArrayColorOffsetEXT)(vaobj, buffer, size, type, stride, offset);
}

static void REGAL_CALL loader_glVertexArrayEdgeFlagOffsetEXT(GLuint vaobj, GLuint buffer, GLsizei stride, const GLintptr offset)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexArrayEdgeFlagOffsetEXT, "glVertexArrayEdgeFlagOffsetEXT");
  if (_driver.glVertexArrayEdgeFlagOffsetEXT) {
    _driver.glVertexArrayEdgeFlagOffsetEXT(vaobj, buffer, stride, offset);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexArrayEdgeFlagOffsetEXT)(vaobj, buffer, stride, offset);
}

static void REGAL_CALL loader_glVertexArrayFogCoordOffsetEXT(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, const GLintptr offset)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexArrayFogCoordOffsetEXT, "glVertexArrayFogCoordOffsetEXT");
  if (_driver.glVertexArrayFogCoordOffsetEXT) {
    _driver.glVertexArrayFogCoordOffsetEXT(vaobj, buffer, type, stride, offset);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexArrayFogCoordOffsetEXT)(vaobj, buffer, type, stride, offset);
}

static void REGAL_CALL loader_glVertexArrayIndexOffsetEXT(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, const GLintptr offset)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexArrayIndexOffsetEXT, "glVertexArrayIndexOffsetEXT");
  if (_driver.glVertexArrayIndexOffsetEXT) {
    _driver.glVertexArrayIndexOffsetEXT(vaobj, buffer, type, stride, offset);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexArrayIndexOffsetEXT)(vaobj, buffer, type, stride, offset);
}

static void REGAL_CALL loader_glVertexArrayMultiTexCoordOffsetEXT(GLuint vaobj, GLuint buffer, GLenum texunit, GLint size, GLenum type, GLsizei stride, const GLintptr offset)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexArrayMultiTexCoordOffsetEXT, "glVertexArrayMultiTexCoordOffsetEXT");
  if (_driver.glVertexArrayMultiTexCoordOffsetEXT) {
    _driver.glVertexArrayMultiTexCoordOffsetEXT(vaobj, buffer, texunit, size, type, stride, offset);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexArrayMultiTexCoordOffsetEXT)(vaobj, buffer, texunit, size, type, stride, offset);
}

static void REGAL_CALL loader_glVertexArrayNormalOffsetEXT(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, const GLintptr offset)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexArrayNormalOffsetEXT, "glVertexArrayNormalOffsetEXT");
  if (_driver.glVertexArrayNormalOffsetEXT) {
    _driver.glVertexArrayNormalOffsetEXT(vaobj, buffer, type, stride, offset);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexArrayNormalOffsetEXT)(vaobj, buffer, type, stride, offset);
}

static void REGAL_CALL loader_glVertexArraySecondaryColorOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, const GLintptr offset)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexArraySecondaryColorOffsetEXT, "glVertexArraySecondaryColorOffsetEXT");
  if (_driver.glVertexArraySecondaryColorOffsetEXT) {
    _driver.glVertexArraySecondaryColorOffsetEXT(vaobj, buffer, size, type, stride, offset);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexArraySecondaryColorOffsetEXT)(vaobj, buffer, size, type, stride, offset);
}

static void REGAL_CALL loader_glVertexArrayTexCoordOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, const GLintptr offset)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexArrayTexCoordOffsetEXT, "glVertexArrayTexCoordOffsetEXT");
  if (_driver.glVertexArrayTexCoordOffsetEXT) {
    _driver.glVertexArrayTexCoordOffsetEXT(vaobj, buffer, size, type, stride, offset);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexArrayTexCoordOffsetEXT)(vaobj, buffer, size, type, stride, offset);
}

static void REGAL_CALL loader_glVertexArrayVertexAttribIOffsetEXT(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, const GLintptr offset)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexArrayVertexAttribIOffsetEXT, "glVertexArrayVertexAttribIOffsetEXT");
  if (_driver.glVertexArrayVertexAttribIOffsetEXT) {
    _driver.glVertexArrayVertexAttribIOffsetEXT(vaobj, buffer, index, size, type, stride, offset);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexArrayVertexAttribIOffsetEXT)(vaobj, buffer, index, size, type, stride, offset);
}

static void REGAL_CALL loader_glVertexArrayVertexAttribOffsetEXT(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLintptr offset)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexArrayVertexAttribOffsetEXT, "glVertexArrayVertexAttribOffsetEXT");
  if (_driver.glVertexArrayVertexAttribOffsetEXT) {
    _driver.glVertexArrayVertexAttribOffsetEXT(vaobj, buffer, index, size, type, normalized, stride, offset);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexArrayVertexAttribOffsetEXT)(vaobj, buffer, index, size, type, normalized, stride, offset);
}

static void REGAL_CALL loader_glVertexArrayVertexOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, const GLintptr offset)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexArrayVertexOffsetEXT, "glVertexArrayVertexOffsetEXT");
  if (_driver.glVertexArrayVertexOffsetEXT) {
    _driver.glVertexArrayVertexOffsetEXT(vaobj, buffer, size, type, stride, offset);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexArrayVertexOffsetEXT)(vaobj, buffer, size, type, stride, offset);
}

// GL_EXT_discard_framebuffer

static void REGAL_CALL loader_glDiscardFramebufferEXT(GLenum target, GLsizei numAttachments, const GLenum *attachments)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDiscardFramebufferEXT, "glDiscardFramebufferEXT");
  if (_driver.glDiscardFramebufferEXT) {
    _driver.glDiscardFramebufferEXT(target, numAttachments, attachments);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDiscardFramebufferEXT)(target, numAttachments, attachments);
}

// GL_EXT_draw_buffers2

static void REGAL_CALL loader_glColorMaskIndexedEXT(GLuint buf, GLboolean r, GLboolean g, GLboolean b, GLboolean a)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColorMaskIndexedEXT, "glColorMaskIndexedEXT");
  if (_driver.glColorMaskIndexedEXT) {
    _driver.glColorMaskIndexedEXT(buf, r, g, b, a);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColorMaskIndexedEXT)(buf, r, g, b, a);
}

static void REGAL_CALL loader_glDisableIndexedEXT(GLenum target, GLuint index)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDisableIndexedEXT, "glDisableIndexedEXT");
  if (_driver.glDisableIndexedEXT) {
    _driver.glDisableIndexedEXT(target, index);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDisableIndexedEXT)(target, index);
}

static void REGAL_CALL loader_glEnableIndexedEXT(GLenum target, GLuint index)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glEnableIndexedEXT, "glEnableIndexedEXT");
  if (_driver.glEnableIndexedEXT) {
    _driver.glEnableIndexedEXT(target, index);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glEnableIndexedEXT)(target, index);
}

static void REGAL_CALL loader_glGetBooleanIndexedvEXT(GLenum value, GLuint index, GLboolean *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetBooleanIndexedvEXT, "glGetBooleanIndexedvEXT");
  if (_driver.glGetBooleanIndexedvEXT) {
    _driver.glGetBooleanIndexedvEXT(value, index, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetBooleanIndexedvEXT)(value, index, data);
}

static void REGAL_CALL loader_glGetIntegerIndexedvEXT(GLenum value, GLuint index, GLint *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetIntegerIndexedvEXT, "glGetIntegerIndexedvEXT");
  if (_driver.glGetIntegerIndexedvEXT) {
    _driver.glGetIntegerIndexedvEXT(value, index, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetIntegerIndexedvEXT)(value, index, data);
}

static GLboolean REGAL_CALL loader_glIsEnabledIndexedEXT(GLenum target, GLuint index)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIsEnabledIndexedEXT, "glIsEnabledIndexedEXT");
  if (_driver.glIsEnabledIndexedEXT) {
    return _driver.glIsEnabledIndexedEXT(target, index);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glIsEnabledIndexedEXT)(target, index);
}

// GL_EXT_draw_instanced

static void REGAL_CALL loader_glDrawArraysInstancedEXT(GLenum mode, GLint start, GLsizei count, GLsizei primcount)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDrawArraysInstancedEXT, "glDrawArraysInstancedEXT");
  if (_driver.glDrawArraysInstancedEXT) {
    _driver.glDrawArraysInstancedEXT(mode, start, count, primcount);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDrawArraysInstancedEXT)(mode, start, count, primcount);
}

static void REGAL_CALL loader_glDrawElementsInstancedEXT(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDrawElementsInstancedEXT, "glDrawElementsInstancedEXT");
  if (_driver.glDrawElementsInstancedEXT) {
    _driver.glDrawElementsInstancedEXT(mode, count, type, indices, primcount);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDrawElementsInstancedEXT)(mode, count, type, indices, primcount);
}

// GL_EXT_draw_range_elements

static void REGAL_CALL loader_glDrawRangeElementsEXT(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDrawRangeElementsEXT, "glDrawRangeElementsEXT");
  if (_driver.glDrawRangeElementsEXT) {
    _driver.glDrawRangeElementsEXT(mode, start, end, count, type, indices);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDrawRangeElementsEXT)(mode, start, end, count, type, indices);
}

// GL_EXT_fog_coord

static void REGAL_CALL loader_glFogCoordPointerEXT(GLenum type, GLsizei stride, const GLvoid *pointer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFogCoordPointerEXT, "glFogCoordPointerEXT");
  if (_driver.glFogCoordPointerEXT) {
    _driver.glFogCoordPointerEXT(type, stride, pointer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFogCoordPointerEXT)(type, stride, pointer);
}

static void REGAL_CALL loader_glFogCoorddEXT(GLdouble coord)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFogCoorddEXT, "glFogCoorddEXT");
  if (_driver.glFogCoorddEXT) {
    _driver.glFogCoorddEXT(coord);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFogCoorddEXT)(coord);
}

static void REGAL_CALL loader_glFogCoorddvEXT(const GLdouble *coord)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFogCoorddvEXT, "glFogCoorddvEXT");
  if (_driver.glFogCoorddvEXT) {
    _driver.glFogCoorddvEXT(coord);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFogCoorddvEXT)(coord);
}

static void REGAL_CALL loader_glFogCoordfEXT(GLfloat coord)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFogCoordfEXT, "glFogCoordfEXT");
  if (_driver.glFogCoordfEXT) {
    _driver.glFogCoordfEXT(coord);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFogCoordfEXT)(coord);
}

static void REGAL_CALL loader_glFogCoordfvEXT(const GLfloat *coord)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFogCoordfvEXT, "glFogCoordfvEXT");
  if (_driver.glFogCoordfvEXT) {
    _driver.glFogCoordfvEXT(coord);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFogCoordfvEXT)(coord);
}

// GL_EXT_fragment_lighting

static void REGAL_CALL loader_glFragmentColorMaterialEXT(GLenum face, GLenum mode)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFragmentColorMaterialEXT, "glFragmentColorMaterialEXT");
  if (_driver.glFragmentColorMaterialEXT) {
    _driver.glFragmentColorMaterialEXT(face, mode);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFragmentColorMaterialEXT)(face, mode);
}

static void REGAL_CALL loader_glFragmentLightModelfEXT(GLenum pname, GLfloat param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFragmentLightModelfEXT, "glFragmentLightModelfEXT");
  if (_driver.glFragmentLightModelfEXT) {
    _driver.glFragmentLightModelfEXT(pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFragmentLightModelfEXT)(pname, param);
}

static void REGAL_CALL loader_glFragmentLightModelfvEXT(GLenum pname, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFragmentLightModelfvEXT, "glFragmentLightModelfvEXT");
  if (_driver.glFragmentLightModelfvEXT) {
    _driver.glFragmentLightModelfvEXT(pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFragmentLightModelfvEXT)(pname, params);
}

static void REGAL_CALL loader_glFragmentLightModeliEXT(GLenum pname, GLint param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFragmentLightModeliEXT, "glFragmentLightModeliEXT");
  if (_driver.glFragmentLightModeliEXT) {
    _driver.glFragmentLightModeliEXT(pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFragmentLightModeliEXT)(pname, param);
}

static void REGAL_CALL loader_glFragmentLightModelivEXT(GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFragmentLightModelivEXT, "glFragmentLightModelivEXT");
  if (_driver.glFragmentLightModelivEXT) {
    _driver.glFragmentLightModelivEXT(pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFragmentLightModelivEXT)(pname, params);
}

static void REGAL_CALL loader_glFragmentLightfEXT(GLenum light, GLenum pname, GLfloat param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFragmentLightfEXT, "glFragmentLightfEXT");
  if (_driver.glFragmentLightfEXT) {
    _driver.glFragmentLightfEXT(light, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFragmentLightfEXT)(light, pname, param);
}

static void REGAL_CALL loader_glFragmentLightfvEXT(GLenum light, GLenum pname, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFragmentLightfvEXT, "glFragmentLightfvEXT");
  if (_driver.glFragmentLightfvEXT) {
    _driver.glFragmentLightfvEXT(light, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFragmentLightfvEXT)(light, pname, params);
}

static void REGAL_CALL loader_glFragmentLightiEXT(GLenum light, GLenum pname, GLint param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFragmentLightiEXT, "glFragmentLightiEXT");
  if (_driver.glFragmentLightiEXT) {
    _driver.glFragmentLightiEXT(light, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFragmentLightiEXT)(light, pname, param);
}

static void REGAL_CALL loader_glFragmentLightivEXT(GLenum light, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFragmentLightivEXT, "glFragmentLightivEXT");
  if (_driver.glFragmentLightivEXT) {
    _driver.glFragmentLightivEXT(light, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFragmentLightivEXT)(light, pname, params);
}

static void REGAL_CALL loader_glFragmentMaterialfEXT(GLenum face, GLenum pname, const GLfloat param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFragmentMaterialfEXT, "glFragmentMaterialfEXT");
  if (_driver.glFragmentMaterialfEXT) {
    _driver.glFragmentMaterialfEXT(face, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFragmentMaterialfEXT)(face, pname, param);
}

static void REGAL_CALL loader_glFragmentMaterialfvEXT(GLenum face, GLenum pname, const GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFragmentMaterialfvEXT, "glFragmentMaterialfvEXT");
  if (_driver.glFragmentMaterialfvEXT) {
    _driver.glFragmentMaterialfvEXT(face, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFragmentMaterialfvEXT)(face, pname, params);
}

static void REGAL_CALL loader_glFragmentMaterialiEXT(GLenum face, GLenum pname, const GLint param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFragmentMaterialiEXT, "glFragmentMaterialiEXT");
  if (_driver.glFragmentMaterialiEXT) {
    _driver.glFragmentMaterialiEXT(face, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFragmentMaterialiEXT)(face, pname, param);
}

static void REGAL_CALL loader_glFragmentMaterialivEXT(GLenum face, GLenum pname, const GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFragmentMaterialivEXT, "glFragmentMaterialivEXT");
  if (_driver.glFragmentMaterialivEXT) {
    _driver.glFragmentMaterialivEXT(face, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFragmentMaterialivEXT)(face, pname, params);
}

static void REGAL_CALL loader_glGetFragmentLightfvEXT(GLenum light, GLenum pname, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetFragmentLightfvEXT, "glGetFragmentLightfvEXT");
  if (_driver.glGetFragmentLightfvEXT) {
    _driver.glGetFragmentLightfvEXT(light, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetFragmentLightfvEXT)(light, pname, params);
}

static void REGAL_CALL loader_glGetFragmentLightivEXT(GLenum light, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetFragmentLightivEXT, "glGetFragmentLightivEXT");
  if (_driver.glGetFragmentLightivEXT) {
    _driver.glGetFragmentLightivEXT(light, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetFragmentLightivEXT)(light, pname, params);
}

static void REGAL_CALL loader_glGetFragmentMaterialfvEXT(GLenum face, GLenum pname, const GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetFragmentMaterialfvEXT, "glGetFragmentMaterialfvEXT");
  if (_driver.glGetFragmentMaterialfvEXT) {
    _driver.glGetFragmentMaterialfvEXT(face, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetFragmentMaterialfvEXT)(face, pname, params);
}

static void REGAL_CALL loader_glGetFragmentMaterialivEXT(GLenum face, GLenum pname, const GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetFragmentMaterialivEXT, "glGetFragmentMaterialivEXT");
  if (_driver.glGetFragmentMaterialivEXT) {
    _driver.glGetFragmentMaterialivEXT(face, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetFragmentMaterialivEXT)(face, pname, params);
}

static void REGAL_CALL loader_glLightEnviEXT(GLenum pname, GLint param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glLightEnviEXT, "glLightEnviEXT");
  if (_driver.glLightEnviEXT) {
    _driver.glLightEnviEXT(pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glLightEnviEXT)(pname, param);
}

// GL_EXT_framebuffer_blit

static void REGAL_CALL loader_glBlitFramebufferEXT(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBlitFramebufferEXT, "glBlitFramebufferEXT");
  if (_driver.glBlitFramebufferEXT) {
    _driver.glBlitFramebufferEXT(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBlitFramebufferEXT)(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
}

// GL_EXT_framebuffer_multisample

static void REGAL_CALL loader_glRenderbufferStorageMultisampleEXT(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glRenderbufferStorageMultisampleEXT, "glRenderbufferStorageMultisampleEXT");
  if (_driver.glRenderbufferStorageMultisampleEXT) {
    _driver.glRenderbufferStorageMultisampleEXT(target, samples, internalformat, width, height);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glRenderbufferStorageMultisampleEXT)(target, samples, internalformat, width, height);
}

// GL_EXT_framebuffer_object

static void REGAL_CALL loader_glBindFramebufferEXT(GLenum target, GLuint framebuffer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBindFramebufferEXT, "glBindFramebufferEXT");
  if (_driver.glBindFramebufferEXT) {
    _driver.glBindFramebufferEXT(target, framebuffer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBindFramebufferEXT)(target, framebuffer);
}

static void REGAL_CALL loader_glBindRenderbufferEXT(GLenum target, GLuint renderbuffer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBindRenderbufferEXT, "glBindRenderbufferEXT");
  if (_driver.glBindRenderbufferEXT) {
    _driver.glBindRenderbufferEXT(target, renderbuffer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBindRenderbufferEXT)(target, renderbuffer);
}

static GLenum REGAL_CALL loader_glCheckFramebufferStatusEXT(GLenum target)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCheckFramebufferStatusEXT, "glCheckFramebufferStatusEXT");
  if (_driver.glCheckFramebufferStatusEXT) {
    return _driver.glCheckFramebufferStatusEXT(target);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glCheckFramebufferStatusEXT)(target);
}

static void REGAL_CALL loader_glDeleteFramebuffersEXT(GLsizei n, const GLuint *framebuffers)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDeleteFramebuffersEXT, "glDeleteFramebuffersEXT");
  if (_driver.glDeleteFramebuffersEXT) {
    _driver.glDeleteFramebuffersEXT(n, framebuffers);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDeleteFramebuffersEXT)(n, framebuffers);
}

static void REGAL_CALL loader_glDeleteRenderbuffersEXT(GLsizei n, const GLuint *renderbuffers)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDeleteRenderbuffersEXT, "glDeleteRenderbuffersEXT");
  if (_driver.glDeleteRenderbuffersEXT) {
    _driver.glDeleteRenderbuffersEXT(n, renderbuffers);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDeleteRenderbuffersEXT)(n, renderbuffers);
}

static void REGAL_CALL loader_glFramebufferRenderbufferEXT(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFramebufferRenderbufferEXT, "glFramebufferRenderbufferEXT");
  if (_driver.glFramebufferRenderbufferEXT) {
    _driver.glFramebufferRenderbufferEXT(target, attachment, renderbuffertarget, renderbuffer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFramebufferRenderbufferEXT)(target, attachment, renderbuffertarget, renderbuffer);
}

static void REGAL_CALL loader_glFramebufferTexture1DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFramebufferTexture1DEXT, "glFramebufferTexture1DEXT");
  if (_driver.glFramebufferTexture1DEXT) {
    _driver.glFramebufferTexture1DEXT(target, attachment, textarget, texture, level);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFramebufferTexture1DEXT)(target, attachment, textarget, texture, level);
}

static void REGAL_CALL loader_glFramebufferTexture2DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFramebufferTexture2DEXT, "glFramebufferTexture2DEXT");
  if (_driver.glFramebufferTexture2DEXT) {
    _driver.glFramebufferTexture2DEXT(target, attachment, textarget, texture, level);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFramebufferTexture2DEXT)(target, attachment, textarget, texture, level);
}

static void REGAL_CALL loader_glFramebufferTexture3DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFramebufferTexture3DEXT, "glFramebufferTexture3DEXT");
  if (_driver.glFramebufferTexture3DEXT) {
    _driver.glFramebufferTexture3DEXT(target, attachment, textarget, texture, level, zoffset);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFramebufferTexture3DEXT)(target, attachment, textarget, texture, level, zoffset);
}

static void REGAL_CALL loader_glGenFramebuffersEXT(GLsizei n, GLuint *framebuffers)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGenFramebuffersEXT, "glGenFramebuffersEXT");
  if (_driver.glGenFramebuffersEXT) {
    _driver.glGenFramebuffersEXT(n, framebuffers);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGenFramebuffersEXT)(n, framebuffers);
}

static void REGAL_CALL loader_glGenRenderbuffersEXT(GLsizei n, GLuint *renderbuffers)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGenRenderbuffersEXT, "glGenRenderbuffersEXT");
  if (_driver.glGenRenderbuffersEXT) {
    _driver.glGenRenderbuffersEXT(n, renderbuffers);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGenRenderbuffersEXT)(n, renderbuffers);
}

static void REGAL_CALL loader_glGenerateMipmapEXT(GLenum target)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGenerateMipmapEXT, "glGenerateMipmapEXT");
  if (_driver.glGenerateMipmapEXT) {
    _driver.glGenerateMipmapEXT(target);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGenerateMipmapEXT)(target);
}

static void REGAL_CALL loader_glGetFramebufferAttachmentParameterivEXT(GLenum target, GLenum attachment, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetFramebufferAttachmentParameterivEXT, "glGetFramebufferAttachmentParameterivEXT");
  if (_driver.glGetFramebufferAttachmentParameterivEXT) {
    _driver.glGetFramebufferAttachmentParameterivEXT(target, attachment, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetFramebufferAttachmentParameterivEXT)(target, attachment, pname, params);
}

static void REGAL_CALL loader_glGetRenderbufferParameterivEXT(GLenum target, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetRenderbufferParameterivEXT, "glGetRenderbufferParameterivEXT");
  if (_driver.glGetRenderbufferParameterivEXT) {
    _driver.glGetRenderbufferParameterivEXT(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetRenderbufferParameterivEXT)(target, pname, params);
}

static GLboolean REGAL_CALL loader_glIsFramebufferEXT(GLuint framebuffer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIsFramebufferEXT, "glIsFramebufferEXT");
  if (_driver.glIsFramebufferEXT) {
    return _driver.glIsFramebufferEXT(framebuffer);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glIsFramebufferEXT)(framebuffer);
}

static GLboolean REGAL_CALL loader_glIsRenderbufferEXT(GLuint renderbuffer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIsRenderbufferEXT, "glIsRenderbufferEXT");
  if (_driver.glIsRenderbufferEXT) {
    return _driver.glIsRenderbufferEXT(renderbuffer);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glIsRenderbufferEXT)(renderbuffer);
}

static void REGAL_CALL loader_glRenderbufferStorageEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glRenderbufferStorageEXT, "glRenderbufferStorageEXT");
  if (_driver.glRenderbufferStorageEXT) {
    _driver.glRenderbufferStorageEXT(target, internalformat, width, height);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glRenderbufferStorageEXT)(target, internalformat, width, height);
}

// GL_EXT_geometry_shader4

static void REGAL_CALL loader_glFramebufferTextureEXT(GLenum target, GLenum attachment, GLuint texture, GLint level)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFramebufferTextureEXT, "glFramebufferTextureEXT");
  if (_driver.glFramebufferTextureEXT) {
    _driver.glFramebufferTextureEXT(target, attachment, texture, level);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFramebufferTextureEXT)(target, attachment, texture, level);
}

static void REGAL_CALL loader_glFramebufferTextureFaceEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFramebufferTextureFaceEXT, "glFramebufferTextureFaceEXT");
  if (_driver.glFramebufferTextureFaceEXT) {
    _driver.glFramebufferTextureFaceEXT(target, attachment, texture, level, face);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFramebufferTextureFaceEXT)(target, attachment, texture, level, face);
}

static void REGAL_CALL loader_glProgramParameteriEXT(GLuint program, GLenum pname, GLint value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramParameteriEXT, "glProgramParameteriEXT");
  if (_driver.glProgramParameteriEXT) {
    _driver.glProgramParameteriEXT(program, pname, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramParameteriEXT)(program, pname, value);
}

// GL_EXT_gpu_program_parameters

static void REGAL_CALL loader_glProgramEnvParameters4fvEXT(GLenum target, GLuint index, GLsizei count, const GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramEnvParameters4fvEXT, "glProgramEnvParameters4fvEXT");
  if (_driver.glProgramEnvParameters4fvEXT) {
    _driver.glProgramEnvParameters4fvEXT(target, index, count, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramEnvParameters4fvEXT)(target, index, count, params);
}

static void REGAL_CALL loader_glProgramLocalParameters4fvEXT(GLenum target, GLuint index, GLsizei count, const GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramLocalParameters4fvEXT, "glProgramLocalParameters4fvEXT");
  if (_driver.glProgramLocalParameters4fvEXT) {
    _driver.glProgramLocalParameters4fvEXT(target, index, count, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramLocalParameters4fvEXT)(target, index, count, params);
}

// GL_EXT_gpu_shader4

static void REGAL_CALL loader_glBindFragDataLocationEXT(GLuint program, GLuint color, const GLchar *name)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBindFragDataLocationEXT, "glBindFragDataLocationEXT");
  if (_driver.glBindFragDataLocationEXT) {
    _driver.glBindFragDataLocationEXT(program, color, name);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBindFragDataLocationEXT)(program, color, name);
}

static GLint REGAL_CALL loader_glGetFragDataLocationEXT(GLuint program, const GLchar *name)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetFragDataLocationEXT, "glGetFragDataLocationEXT");
  if (_driver.glGetFragDataLocationEXT) {
    return _driver.glGetFragDataLocationEXT(program, name);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glGetFragDataLocationEXT)(program, name);
}

static void REGAL_CALL loader_glGetUniformuivEXT(GLuint program, GLint location, GLuint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetUniformuivEXT, "glGetUniformuivEXT");
  if (_driver.glGetUniformuivEXT) {
    _driver.glGetUniformuivEXT(program, location, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetUniformuivEXT)(program, location, params);
}

static void REGAL_CALL loader_glGetVertexAttribIivEXT(GLuint index, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetVertexAttribIivEXT, "glGetVertexAttribIivEXT");
  if (_driver.glGetVertexAttribIivEXT) {
    _driver.glGetVertexAttribIivEXT(index, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetVertexAttribIivEXT)(index, pname, params);
}

static void REGAL_CALL loader_glGetVertexAttribIuivEXT(GLuint index, GLenum pname, GLuint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetVertexAttribIuivEXT, "glGetVertexAttribIuivEXT");
  if (_driver.glGetVertexAttribIuivEXT) {
    _driver.glGetVertexAttribIuivEXT(index, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetVertexAttribIuivEXT)(index, pname, params);
}

static void REGAL_CALL loader_glUniform1uiEXT(GLint location, GLuint v0)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform1uiEXT, "glUniform1uiEXT");
  if (_driver.glUniform1uiEXT) {
    _driver.glUniform1uiEXT(location, v0);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform1uiEXT)(location, v0);
}

static void REGAL_CALL loader_glUniform1uivEXT(GLint location, GLsizei count, const GLuint *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform1uivEXT, "glUniform1uivEXT");
  if (_driver.glUniform1uivEXT) {
    _driver.glUniform1uivEXT(location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform1uivEXT)(location, count, value);
}

static void REGAL_CALL loader_glUniform2uiEXT(GLint location, GLuint v0, GLuint v1)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform2uiEXT, "glUniform2uiEXT");
  if (_driver.glUniform2uiEXT) {
    _driver.glUniform2uiEXT(location, v0, v1);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform2uiEXT)(location, v0, v1);
}

static void REGAL_CALL loader_glUniform2uivEXT(GLint location, GLsizei count, const GLuint *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform2uivEXT, "glUniform2uivEXT");
  if (_driver.glUniform2uivEXT) {
    _driver.glUniform2uivEXT(location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform2uivEXT)(location, count, value);
}

static void REGAL_CALL loader_glUniform3uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform3uiEXT, "glUniform3uiEXT");
  if (_driver.glUniform3uiEXT) {
    _driver.glUniform3uiEXT(location, v0, v1, v2);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform3uiEXT)(location, v0, v1, v2);
}

static void REGAL_CALL loader_glUniform3uivEXT(GLint location, GLsizei count, const GLuint *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform3uivEXT, "glUniform3uivEXT");
  if (_driver.glUniform3uivEXT) {
    _driver.glUniform3uivEXT(location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform3uivEXT)(location, count, value);
}

static void REGAL_CALL loader_glUniform4uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform4uiEXT, "glUniform4uiEXT");
  if (_driver.glUniform4uiEXT) {
    _driver.glUniform4uiEXT(location, v0, v1, v2, v3);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform4uiEXT)(location, v0, v1, v2, v3);
}

static void REGAL_CALL loader_glUniform4uivEXT(GLint location, GLsizei count, const GLuint *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform4uivEXT, "glUniform4uivEXT");
  if (_driver.glUniform4uivEXT) {
    _driver.glUniform4uivEXT(location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform4uivEXT)(location, count, value);
}

static void REGAL_CALL loader_glVertexAttribI1iEXT(GLuint index, GLint x)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribI1iEXT, "glVertexAttribI1iEXT");
  if (_driver.glVertexAttribI1iEXT) {
    _driver.glVertexAttribI1iEXT(index, x);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribI1iEXT)(index, x);
}

static void REGAL_CALL loader_glVertexAttribI1ivEXT(GLuint index, const GLint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribI1ivEXT, "glVertexAttribI1ivEXT");
  if (_driver.glVertexAttribI1ivEXT) {
    _driver.glVertexAttribI1ivEXT(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribI1ivEXT)(index, v);
}

static void REGAL_CALL loader_glVertexAttribI1uiEXT(GLuint index, GLuint x)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribI1uiEXT, "glVertexAttribI1uiEXT");
  if (_driver.glVertexAttribI1uiEXT) {
    _driver.glVertexAttribI1uiEXT(index, x);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribI1uiEXT)(index, x);
}

static void REGAL_CALL loader_glVertexAttribI1uivEXT(GLuint index, const GLuint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribI1uivEXT, "glVertexAttribI1uivEXT");
  if (_driver.glVertexAttribI1uivEXT) {
    _driver.glVertexAttribI1uivEXT(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribI1uivEXT)(index, v);
}

static void REGAL_CALL loader_glVertexAttribI2iEXT(GLuint index, GLint x, GLint y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribI2iEXT, "glVertexAttribI2iEXT");
  if (_driver.glVertexAttribI2iEXT) {
    _driver.glVertexAttribI2iEXT(index, x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribI2iEXT)(index, x, y);
}

static void REGAL_CALL loader_glVertexAttribI2ivEXT(GLuint index, const GLint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribI2ivEXT, "glVertexAttribI2ivEXT");
  if (_driver.glVertexAttribI2ivEXT) {
    _driver.glVertexAttribI2ivEXT(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribI2ivEXT)(index, v);
}

static void REGAL_CALL loader_glVertexAttribI2uiEXT(GLuint index, GLuint x, GLuint y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribI2uiEXT, "glVertexAttribI2uiEXT");
  if (_driver.glVertexAttribI2uiEXT) {
    _driver.glVertexAttribI2uiEXT(index, x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribI2uiEXT)(index, x, y);
}

static void REGAL_CALL loader_glVertexAttribI2uivEXT(GLuint index, const GLuint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribI2uivEXT, "glVertexAttribI2uivEXT");
  if (_driver.glVertexAttribI2uivEXT) {
    _driver.glVertexAttribI2uivEXT(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribI2uivEXT)(index, v);
}

static void REGAL_CALL loader_glVertexAttribI3iEXT(GLuint index, GLint x, GLint y, GLint z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribI3iEXT, "glVertexAttribI3iEXT");
  if (_driver.glVertexAttribI3iEXT) {
    _driver.glVertexAttribI3iEXT(index, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribI3iEXT)(index, x, y, z);
}

static void REGAL_CALL loader_glVertexAttribI3ivEXT(GLuint index, const GLint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribI3ivEXT, "glVertexAttribI3ivEXT");
  if (_driver.glVertexAttribI3ivEXT) {
    _driver.glVertexAttribI3ivEXT(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribI3ivEXT)(index, v);
}

static void REGAL_CALL loader_glVertexAttribI3uiEXT(GLuint index, GLuint x, GLuint y, GLuint z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribI3uiEXT, "glVertexAttribI3uiEXT");
  if (_driver.glVertexAttribI3uiEXT) {
    _driver.glVertexAttribI3uiEXT(index, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribI3uiEXT)(index, x, y, z);
}

static void REGAL_CALL loader_glVertexAttribI3uivEXT(GLuint index, const GLuint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribI3uivEXT, "glVertexAttribI3uivEXT");
  if (_driver.glVertexAttribI3uivEXT) {
    _driver.glVertexAttribI3uivEXT(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribI3uivEXT)(index, v);
}

static void REGAL_CALL loader_glVertexAttribI4bvEXT(GLuint index, const GLbyte *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribI4bvEXT, "glVertexAttribI4bvEXT");
  if (_driver.glVertexAttribI4bvEXT) {
    _driver.glVertexAttribI4bvEXT(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribI4bvEXT)(index, v);
}

static void REGAL_CALL loader_glVertexAttribI4iEXT(GLuint index, GLint x, GLint y, GLint z, GLint w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribI4iEXT, "glVertexAttribI4iEXT");
  if (_driver.glVertexAttribI4iEXT) {
    _driver.glVertexAttribI4iEXT(index, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribI4iEXT)(index, x, y, z, w);
}

static void REGAL_CALL loader_glVertexAttribI4ivEXT(GLuint index, const GLint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribI4ivEXT, "glVertexAttribI4ivEXT");
  if (_driver.glVertexAttribI4ivEXT) {
    _driver.glVertexAttribI4ivEXT(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribI4ivEXT)(index, v);
}

static void REGAL_CALL loader_glVertexAttribI4svEXT(GLuint index, const GLshort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribI4svEXT, "glVertexAttribI4svEXT");
  if (_driver.glVertexAttribI4svEXT) {
    _driver.glVertexAttribI4svEXT(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribI4svEXT)(index, v);
}

static void REGAL_CALL loader_glVertexAttribI4ubvEXT(GLuint index, const GLubyte *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribI4ubvEXT, "glVertexAttribI4ubvEXT");
  if (_driver.glVertexAttribI4ubvEXT) {
    _driver.glVertexAttribI4ubvEXT(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribI4ubvEXT)(index, v);
}

static void REGAL_CALL loader_glVertexAttribI4uiEXT(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribI4uiEXT, "glVertexAttribI4uiEXT");
  if (_driver.glVertexAttribI4uiEXT) {
    _driver.glVertexAttribI4uiEXT(index, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribI4uiEXT)(index, x, y, z, w);
}

static void REGAL_CALL loader_glVertexAttribI4uivEXT(GLuint index, const GLuint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribI4uivEXT, "glVertexAttribI4uivEXT");
  if (_driver.glVertexAttribI4uivEXT) {
    _driver.glVertexAttribI4uivEXT(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribI4uivEXT)(index, v);
}

static void REGAL_CALL loader_glVertexAttribI4usvEXT(GLuint index, const GLushort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribI4usvEXT, "glVertexAttribI4usvEXT");
  if (_driver.glVertexAttribI4usvEXT) {
    _driver.glVertexAttribI4usvEXT(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribI4usvEXT)(index, v);
}

static void REGAL_CALL loader_glVertexAttribIPointerEXT(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribIPointerEXT, "glVertexAttribIPointerEXT");
  if (_driver.glVertexAttribIPointerEXT) {
    _driver.glVertexAttribIPointerEXT(index, size, type, stride, pointer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribIPointerEXT)(index, size, type, stride, pointer);
}

// GL_EXT_histogram

static void REGAL_CALL loader_glGetHistogramEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetHistogramEXT, "glGetHistogramEXT");
  if (_driver.glGetHistogramEXT) {
    _driver.glGetHistogramEXT(target, reset, format, type, values);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetHistogramEXT)(target, reset, format, type, values);
}

static void REGAL_CALL loader_glGetHistogramParameterfvEXT(GLenum target, GLenum pname, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetHistogramParameterfvEXT, "glGetHistogramParameterfvEXT");
  if (_driver.glGetHistogramParameterfvEXT) {
    _driver.glGetHistogramParameterfvEXT(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetHistogramParameterfvEXT)(target, pname, params);
}

static void REGAL_CALL loader_glGetHistogramParameterivEXT(GLenum target, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetHistogramParameterivEXT, "glGetHistogramParameterivEXT");
  if (_driver.glGetHistogramParameterivEXT) {
    _driver.glGetHistogramParameterivEXT(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetHistogramParameterivEXT)(target, pname, params);
}

static void REGAL_CALL loader_glGetMinmaxEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetMinmaxEXT, "glGetMinmaxEXT");
  if (_driver.glGetMinmaxEXT) {
    _driver.glGetMinmaxEXT(target, reset, format, type, values);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetMinmaxEXT)(target, reset, format, type, values);
}

static void REGAL_CALL loader_glGetMinmaxParameterfvEXT(GLenum target, GLenum pname, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetMinmaxParameterfvEXT, "glGetMinmaxParameterfvEXT");
  if (_driver.glGetMinmaxParameterfvEXT) {
    _driver.glGetMinmaxParameterfvEXT(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetMinmaxParameterfvEXT)(target, pname, params);
}

static void REGAL_CALL loader_glGetMinmaxParameterivEXT(GLenum target, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetMinmaxParameterivEXT, "glGetMinmaxParameterivEXT");
  if (_driver.glGetMinmaxParameterivEXT) {
    _driver.glGetMinmaxParameterivEXT(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetMinmaxParameterivEXT)(target, pname, params);
}

static void REGAL_CALL loader_glHistogramEXT(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glHistogramEXT, "glHistogramEXT");
  if (_driver.glHistogramEXT) {
    _driver.glHistogramEXT(target, width, internalformat, sink);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glHistogramEXT)(target, width, internalformat, sink);
}

static void REGAL_CALL loader_glMinmaxEXT(GLenum target, GLenum internalformat, GLboolean sink)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMinmaxEXT, "glMinmaxEXT");
  if (_driver.glMinmaxEXT) {
    _driver.glMinmaxEXT(target, internalformat, sink);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMinmaxEXT)(target, internalformat, sink);
}

static void REGAL_CALL loader_glResetHistogramEXT(GLenum target)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glResetHistogramEXT, "glResetHistogramEXT");
  if (_driver.glResetHistogramEXT) {
    _driver.glResetHistogramEXT(target);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glResetHistogramEXT)(target);
}

static void REGAL_CALL loader_glResetMinmaxEXT(GLenum target)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glResetMinmaxEXT, "glResetMinmaxEXT");
  if (_driver.glResetMinmaxEXT) {
    _driver.glResetMinmaxEXT(target);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glResetMinmaxEXT)(target);
}

// GL_EXT_index_func

static void REGAL_CALL loader_glIndexFuncEXT(GLenum func, GLfloat ref)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIndexFuncEXT, "glIndexFuncEXT");
  if (_driver.glIndexFuncEXT) {
    _driver.glIndexFuncEXT(func, ref);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glIndexFuncEXT)(func, ref);
}

// GL_EXT_index_material

static void REGAL_CALL loader_glIndexMaterialEXT(GLenum face, GLenum mode)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIndexMaterialEXT, "glIndexMaterialEXT");
  if (_driver.glIndexMaterialEXT) {
    _driver.glIndexMaterialEXT(face, mode);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glIndexMaterialEXT)(face, mode);
}

// GL_EXT_light_texture

static void REGAL_CALL loader_glApplyTextureEXT(GLenum mode)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glApplyTextureEXT, "glApplyTextureEXT");
  if (_driver.glApplyTextureEXT) {
    _driver.glApplyTextureEXT(mode);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glApplyTextureEXT)(mode);
}

static void REGAL_CALL loader_glTextureLightEXT(GLenum pname)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTextureLightEXT, "glTextureLightEXT");
  if (_driver.glTextureLightEXT) {
    _driver.glTextureLightEXT(pname);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTextureLightEXT)(pname);
}

static void REGAL_CALL loader_glTextureMaterialEXT(GLenum face, GLenum mode)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTextureMaterialEXT, "glTextureMaterialEXT");
  if (_driver.glTextureMaterialEXT) {
    _driver.glTextureMaterialEXT(face, mode);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTextureMaterialEXT)(face, mode);
}

// GL_EXT_map_buffer_range

static void REGAL_CALL loader_glFlushMappedBufferRangeEXT(GLenum target, GLintptr offset, GLsizeiptr length)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFlushMappedBufferRangeEXT, "glFlushMappedBufferRangeEXT");
  if (_driver.glFlushMappedBufferRangeEXT) {
    _driver.glFlushMappedBufferRangeEXT(target, offset, length);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFlushMappedBufferRangeEXT)(target, offset, length);
}

static GLvoid *REGAL_CALL loader_glMapBufferRangeEXT(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMapBufferRangeEXT, "glMapBufferRangeEXT");
  if (_driver.glMapBufferRangeEXT) {
    return _driver.glMapBufferRangeEXT(target, offset, length, access);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glMapBufferRangeEXT)(target, offset, length, access);
}

// GL_EXT_multi_draw_arrays

static void REGAL_CALL loader_glMultiDrawArraysEXT(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiDrawArraysEXT, "glMultiDrawArraysEXT");
  if (_driver.glMultiDrawArraysEXT) {
    _driver.glMultiDrawArraysEXT(mode, first, count, primcount);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiDrawArraysEXT)(mode, first, count, primcount);
}

static void REGAL_CALL loader_glMultiDrawElementsEXT(GLenum mode, GLsizei *count, GLenum type, const GLvoid **indices, GLsizei primcount)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiDrawElementsEXT, "glMultiDrawElementsEXT");
  if (_driver.glMultiDrawElementsEXT) {
    _driver.glMultiDrawElementsEXT(mode, count, type, indices, primcount);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiDrawElementsEXT)(mode, count, type, indices, primcount);
}

// GL_EXT_multisample

static void REGAL_CALL loader_glSampleMaskEXT(GLclampf value, GLboolean invert)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSampleMaskEXT, "glSampleMaskEXT");
  if (_driver.glSampleMaskEXT) {
    _driver.glSampleMaskEXT(value, invert);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSampleMaskEXT)(value, invert);
}

static void REGAL_CALL loader_glSamplePatternEXT(GLenum pattern)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSamplePatternEXT, "glSamplePatternEXT");
  if (_driver.glSamplePatternEXT) {
    _driver.glSamplePatternEXT(pattern);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSamplePatternEXT)(pattern);
}

// GL_EXT_multisampled_render_to_texture

static void REGAL_CALL loader_glFramebufferTexture2DMultisampleEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFramebufferTexture2DMultisampleEXT, "glFramebufferTexture2DMultisampleEXT");
  if (_driver.glFramebufferTexture2DMultisampleEXT) {
    _driver.glFramebufferTexture2DMultisampleEXT(target, attachment, textarget, texture, level, samples);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFramebufferTexture2DMultisampleEXT)(target, attachment, textarget, texture, level, samples);
}

// GL_EXT_multiview_draw_buffers

static void REGAL_CALL loader_glDrawBuffersIndexedEXT(GLint n, const GLenum *location, const GLint *indices)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDrawBuffersIndexedEXT, "glDrawBuffersIndexedEXT");
  if (_driver.glDrawBuffersIndexedEXT) {
    _driver.glDrawBuffersIndexedEXT(n, location, indices);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDrawBuffersIndexedEXT)(n, location, indices);
}

static void REGAL_CALL loader_glGetIntegeri_vEXT(GLenum target, GLuint index, GLint *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetIntegeri_vEXT, "glGetIntegeri_vEXT");
  if (_driver.glGetIntegeri_vEXT) {
    _driver.glGetIntegeri_vEXT(target, index, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetIntegeri_vEXT)(target, index, data);
}

static void REGAL_CALL loader_glReadBufferIndexedEXT(GLenum src, GLint index)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glReadBufferIndexedEXT, "glReadBufferIndexedEXT");
  if (_driver.glReadBufferIndexedEXT) {
    _driver.glReadBufferIndexedEXT(src, index);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glReadBufferIndexedEXT)(src, index);
}

// GL_EXT_occlusion_query_boolean

static void REGAL_CALL loader_glBeginQueryEXT(GLenum target, GLuint id)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBeginQueryEXT, "glBeginQueryEXT");
  if (_driver.glBeginQueryEXT) {
    _driver.glBeginQueryEXT(target, id);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBeginQueryEXT)(target, id);
}

static void REGAL_CALL loader_glDeleteQueriesEXT(GLsizei n, const GLuint *ids)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDeleteQueriesEXT, "glDeleteQueriesEXT");
  if (_driver.glDeleteQueriesEXT) {
    _driver.glDeleteQueriesEXT(n, ids);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDeleteQueriesEXT)(n, ids);
}

static void REGAL_CALL loader_glEndQueryEXT(GLenum target)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glEndQueryEXT, "glEndQueryEXT");
  if (_driver.glEndQueryEXT) {
    _driver.glEndQueryEXT(target);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glEndQueryEXT)(target);
}

static void REGAL_CALL loader_glGenQueriesEXT(GLsizei n, GLuint *ids)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGenQueriesEXT, "glGenQueriesEXT");
  if (_driver.glGenQueriesEXT) {
    _driver.glGenQueriesEXT(n, ids);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGenQueriesEXT)(n, ids);
}

static void REGAL_CALL loader_glGetQueryObjectuivEXT(GLuint id, GLenum pname, GLuint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetQueryObjectuivEXT, "glGetQueryObjectuivEXT");
  if (_driver.glGetQueryObjectuivEXT) {
    _driver.glGetQueryObjectuivEXT(id, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetQueryObjectuivEXT)(id, pname, params);
}

static void REGAL_CALL loader_glGetQueryivEXT(GLenum target, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetQueryivEXT, "glGetQueryivEXT");
  if (_driver.glGetQueryivEXT) {
    _driver.glGetQueryivEXT(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetQueryivEXT)(target, pname, params);
}

static GLboolean REGAL_CALL loader_glIsQueryEXT(GLuint id)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIsQueryEXT, "glIsQueryEXT");
  if (_driver.glIsQueryEXT) {
    return _driver.glIsQueryEXT(id);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glIsQueryEXT)(id);
}

// GL_EXT_paletted_texture

static void REGAL_CALL loader_glColorTableEXT(GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const GLvoid *table)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColorTableEXT, "glColorTableEXT");
  if (_driver.glColorTableEXT) {
    _driver.glColorTableEXT(target, internalFormat, width, format, type, table);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColorTableEXT)(target, internalFormat, width, format, type, table);
}

static void REGAL_CALL loader_glGetColorTableEXT(GLenum target, GLenum format, GLenum type, GLvoid *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetColorTableEXT, "glGetColorTableEXT");
  if (_driver.glGetColorTableEXT) {
    _driver.glGetColorTableEXT(target, format, type, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetColorTableEXT)(target, format, type, data);
}

static void REGAL_CALL loader_glGetColorTableParameterfvEXT(GLenum target, GLenum pname, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetColorTableParameterfvEXT, "glGetColorTableParameterfvEXT");
  if (_driver.glGetColorTableParameterfvEXT) {
    _driver.glGetColorTableParameterfvEXT(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetColorTableParameterfvEXT)(target, pname, params);
}

static void REGAL_CALL loader_glGetColorTableParameterivEXT(GLenum target, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetColorTableParameterivEXT, "glGetColorTableParameterivEXT");
  if (_driver.glGetColorTableParameterivEXT) {
    _driver.glGetColorTableParameterivEXT(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetColorTableParameterivEXT)(target, pname, params);
}

// GL_EXT_pixel_transform

static void REGAL_CALL loader_glGetPixelTransformParameterfvEXT(GLenum target, GLenum pname, const GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetPixelTransformParameterfvEXT, "glGetPixelTransformParameterfvEXT");
  if (_driver.glGetPixelTransformParameterfvEXT) {
    _driver.glGetPixelTransformParameterfvEXT(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetPixelTransformParameterfvEXT)(target, pname, params);
}

static void REGAL_CALL loader_glGetPixelTransformParameterivEXT(GLenum target, GLenum pname, const GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetPixelTransformParameterivEXT, "glGetPixelTransformParameterivEXT");
  if (_driver.glGetPixelTransformParameterivEXT) {
    _driver.glGetPixelTransformParameterivEXT(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetPixelTransformParameterivEXT)(target, pname, params);
}

static void REGAL_CALL loader_glPixelTransformParameterfEXT(GLenum target, GLenum pname, const GLfloat param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPixelTransformParameterfEXT, "glPixelTransformParameterfEXT");
  if (_driver.glPixelTransformParameterfEXT) {
    _driver.glPixelTransformParameterfEXT(target, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPixelTransformParameterfEXT)(target, pname, param);
}

static void REGAL_CALL loader_glPixelTransformParameterfvEXT(GLenum target, GLenum pname, const GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPixelTransformParameterfvEXT, "glPixelTransformParameterfvEXT");
  if (_driver.glPixelTransformParameterfvEXT) {
    _driver.glPixelTransformParameterfvEXT(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPixelTransformParameterfvEXT)(target, pname, params);
}

static void REGAL_CALL loader_glPixelTransformParameteriEXT(GLenum target, GLenum pname, const GLint param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPixelTransformParameteriEXT, "glPixelTransformParameteriEXT");
  if (_driver.glPixelTransformParameteriEXT) {
    _driver.glPixelTransformParameteriEXT(target, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPixelTransformParameteriEXT)(target, pname, param);
}

static void REGAL_CALL loader_glPixelTransformParameterivEXT(GLenum target, GLenum pname, const GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPixelTransformParameterivEXT, "glPixelTransformParameterivEXT");
  if (_driver.glPixelTransformParameterivEXT) {
    _driver.glPixelTransformParameterivEXT(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPixelTransformParameterivEXT)(target, pname, params);
}

// GL_EXT_point_parameters

static void REGAL_CALL loader_glPointParameterfEXT(GLenum pname, GLfloat param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPointParameterfEXT, "glPointParameterfEXT");
  if (_driver.glPointParameterfEXT) {
    _driver.glPointParameterfEXT(pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPointParameterfEXT)(pname, param);
}

static void REGAL_CALL loader_glPointParameterfvEXT(GLenum pname, const GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPointParameterfvEXT, "glPointParameterfvEXT");
  if (_driver.glPointParameterfvEXT) {
    _driver.glPointParameterfvEXT(pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPointParameterfvEXT)(pname, params);
}

// GL_EXT_polygon_offset

static void REGAL_CALL loader_glPolygonOffsetEXT(GLfloat factor, GLfloat bias)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPolygonOffsetEXT, "glPolygonOffsetEXT");
  if (_driver.glPolygonOffsetEXT) {
    _driver.glPolygonOffsetEXT(factor, bias);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPolygonOffsetEXT)(factor, bias);
}

// GL_EXT_provoking_vertex

static void REGAL_CALL loader_glProvokingVertexEXT(GLenum mode)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProvokingVertexEXT, "glProvokingVertexEXT");
  if (_driver.glProvokingVertexEXT) {
    _driver.glProvokingVertexEXT(mode);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProvokingVertexEXT)(mode);
}

// GL_EXT_robustness

static void REGAL_CALL loader_glGetnUniformfvEXT(GLuint program, GLint location, GLsizei bufSize, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetnUniformfvEXT, "glGetnUniformfvEXT");
  if (_driver.glGetnUniformfvEXT) {
    _driver.glGetnUniformfvEXT(program, location, bufSize, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetnUniformfvEXT)(program, location, bufSize, params);
}

static void REGAL_CALL loader_glGetnUniformivEXT(GLuint program, GLint location, GLsizei bufSize, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetnUniformivEXT, "glGetnUniformivEXT");
  if (_driver.glGetnUniformivEXT) {
    _driver.glGetnUniformivEXT(program, location, bufSize, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetnUniformivEXT)(program, location, bufSize, params);
}

static void REGAL_CALL loader_glReadnPixelsEXT(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, GLvoid *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glReadnPixelsEXT, "glReadnPixelsEXT");
  if (_driver.glReadnPixelsEXT) {
    _driver.glReadnPixelsEXT(x, y, width, height, format, type, bufSize, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glReadnPixelsEXT)(x, y, width, height, format, type, bufSize, data);
}

// GL_EXT_scene_marker

static void REGAL_CALL loader_glBeginSceneEXT(void)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBeginSceneEXT, "glBeginSceneEXT");
  if (_driver.glBeginSceneEXT) {
    _driver.glBeginSceneEXT();
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBeginSceneEXT)();
}

static void REGAL_CALL loader_glEndSceneEXT(void)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glEndSceneEXT, "glEndSceneEXT");
  if (_driver.glEndSceneEXT) {
    _driver.glEndSceneEXT();
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glEndSceneEXT)();
}

// GL_EXT_secondary_color

static void REGAL_CALL loader_glSecondaryColor3bEXT(GLbyte red, GLbyte green, GLbyte blue)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSecondaryColor3bEXT, "glSecondaryColor3bEXT");
  if (_driver.glSecondaryColor3bEXT) {
    _driver.glSecondaryColor3bEXT(red, green, blue);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSecondaryColor3bEXT)(red, green, blue);
}

static void REGAL_CALL loader_glSecondaryColor3bvEXT(const GLbyte *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSecondaryColor3bvEXT, "glSecondaryColor3bvEXT");
  if (_driver.glSecondaryColor3bvEXT) {
    _driver.glSecondaryColor3bvEXT(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSecondaryColor3bvEXT)(v);
}

static void REGAL_CALL loader_glSecondaryColor3dEXT(GLdouble red, GLdouble green, GLdouble blue)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSecondaryColor3dEXT, "glSecondaryColor3dEXT");
  if (_driver.glSecondaryColor3dEXT) {
    _driver.glSecondaryColor3dEXT(red, green, blue);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSecondaryColor3dEXT)(red, green, blue);
}

static void REGAL_CALL loader_glSecondaryColor3dvEXT(const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSecondaryColor3dvEXT, "glSecondaryColor3dvEXT");
  if (_driver.glSecondaryColor3dvEXT) {
    _driver.glSecondaryColor3dvEXT(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSecondaryColor3dvEXT)(v);
}

static void REGAL_CALL loader_glSecondaryColor3fEXT(GLfloat red, GLfloat green, GLfloat blue)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSecondaryColor3fEXT, "glSecondaryColor3fEXT");
  if (_driver.glSecondaryColor3fEXT) {
    _driver.glSecondaryColor3fEXT(red, green, blue);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSecondaryColor3fEXT)(red, green, blue);
}

static void REGAL_CALL loader_glSecondaryColor3fvEXT(const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSecondaryColor3fvEXT, "glSecondaryColor3fvEXT");
  if (_driver.glSecondaryColor3fvEXT) {
    _driver.glSecondaryColor3fvEXT(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSecondaryColor3fvEXT)(v);
}

static void REGAL_CALL loader_glSecondaryColor3iEXT(GLint red, GLint green, GLint blue)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSecondaryColor3iEXT, "glSecondaryColor3iEXT");
  if (_driver.glSecondaryColor3iEXT) {
    _driver.glSecondaryColor3iEXT(red, green, blue);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSecondaryColor3iEXT)(red, green, blue);
}

static void REGAL_CALL loader_glSecondaryColor3ivEXT(const GLint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSecondaryColor3ivEXT, "glSecondaryColor3ivEXT");
  if (_driver.glSecondaryColor3ivEXT) {
    _driver.glSecondaryColor3ivEXT(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSecondaryColor3ivEXT)(v);
}

static void REGAL_CALL loader_glSecondaryColor3sEXT(GLshort red, GLshort green, GLshort blue)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSecondaryColor3sEXT, "glSecondaryColor3sEXT");
  if (_driver.glSecondaryColor3sEXT) {
    _driver.glSecondaryColor3sEXT(red, green, blue);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSecondaryColor3sEXT)(red, green, blue);
}

static void REGAL_CALL loader_glSecondaryColor3svEXT(const GLshort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSecondaryColor3svEXT, "glSecondaryColor3svEXT");
  if (_driver.glSecondaryColor3svEXT) {
    _driver.glSecondaryColor3svEXT(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSecondaryColor3svEXT)(v);
}

static void REGAL_CALL loader_glSecondaryColor3ubEXT(GLubyte red, GLubyte green, GLubyte blue)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSecondaryColor3ubEXT, "glSecondaryColor3ubEXT");
  if (_driver.glSecondaryColor3ubEXT) {
    _driver.glSecondaryColor3ubEXT(red, green, blue);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSecondaryColor3ubEXT)(red, green, blue);
}

static void REGAL_CALL loader_glSecondaryColor3ubvEXT(const GLubyte *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSecondaryColor3ubvEXT, "glSecondaryColor3ubvEXT");
  if (_driver.glSecondaryColor3ubvEXT) {
    _driver.glSecondaryColor3ubvEXT(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSecondaryColor3ubvEXT)(v);
}

static void REGAL_CALL loader_glSecondaryColor3uiEXT(GLuint red, GLuint green, GLuint blue)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSecondaryColor3uiEXT, "glSecondaryColor3uiEXT");
  if (_driver.glSecondaryColor3uiEXT) {
    _driver.glSecondaryColor3uiEXT(red, green, blue);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSecondaryColor3uiEXT)(red, green, blue);
}

static void REGAL_CALL loader_glSecondaryColor3uivEXT(const GLuint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSecondaryColor3uivEXT, "glSecondaryColor3uivEXT");
  if (_driver.glSecondaryColor3uivEXT) {
    _driver.glSecondaryColor3uivEXT(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSecondaryColor3uivEXT)(v);
}

static void REGAL_CALL loader_glSecondaryColor3usEXT(GLushort red, GLushort green, GLushort blue)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSecondaryColor3usEXT, "glSecondaryColor3usEXT");
  if (_driver.glSecondaryColor3usEXT) {
    _driver.glSecondaryColor3usEXT(red, green, blue);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSecondaryColor3usEXT)(red, green, blue);
}

static void REGAL_CALL loader_glSecondaryColor3usvEXT(const GLushort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSecondaryColor3usvEXT, "glSecondaryColor3usvEXT");
  if (_driver.glSecondaryColor3usvEXT) {
    _driver.glSecondaryColor3usvEXT(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSecondaryColor3usvEXT)(v);
}

static void REGAL_CALL loader_glSecondaryColorPointerEXT(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSecondaryColorPointerEXT, "glSecondaryColorPointerEXT");
  if (_driver.glSecondaryColorPointerEXT) {
    _driver.glSecondaryColorPointerEXT(size, type, stride, pointer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSecondaryColorPointerEXT)(size, type, stride, pointer);
}

// GL_EXT_separate_shader_objects

static void REGAL_CALL loader_glActiveProgramEXT(GLuint program)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glActiveProgramEXT, "glActiveProgramEXT");
  if (_driver.glActiveProgramEXT) {
    _driver.glActiveProgramEXT(program);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glActiveProgramEXT)(program);
}

static GLuint REGAL_CALL loader_glCreateShaderProgramEXT(GLenum type, const GLchar *string)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCreateShaderProgramEXT, "glCreateShaderProgramEXT");
  if (_driver.glCreateShaderProgramEXT) {
    return _driver.glCreateShaderProgramEXT(type, string);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glCreateShaderProgramEXT)(type, string);
}

static void REGAL_CALL loader_glUseShaderProgramEXT(GLenum type, GLuint program)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUseShaderProgramEXT, "glUseShaderProgramEXT");
  if (_driver.glUseShaderProgramEXT) {
    _driver.glUseShaderProgramEXT(type, program);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUseShaderProgramEXT)(type, program);
}

// GL_EXT_shader_image_load_store

static void REGAL_CALL loader_glBindImageTextureEXT(GLuint index, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLint format)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBindImageTextureEXT, "glBindImageTextureEXT");
  if (_driver.glBindImageTextureEXT) {
    _driver.glBindImageTextureEXT(index, texture, level, layered, layer, access, format);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBindImageTextureEXT)(index, texture, level, layered, layer, access, format);
}

static void REGAL_CALL loader_glMemoryBarrierEXT(GLbitfield barriers)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMemoryBarrierEXT, "glMemoryBarrierEXT");
  if (_driver.glMemoryBarrierEXT) {
    _driver.glMemoryBarrierEXT(barriers);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMemoryBarrierEXT)(barriers);
}

// GL_EXT_stencil_clear_tag

static void REGAL_CALL loader_glStencilClearTagEXT(GLsizei stencilTagBits, GLuint stencilClearTag)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glStencilClearTagEXT, "glStencilClearTagEXT");
  if (_driver.glStencilClearTagEXT) {
    _driver.glStencilClearTagEXT(stencilTagBits, stencilClearTag);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glStencilClearTagEXT)(stencilTagBits, stencilClearTag);
}

// GL_EXT_stencil_two_side

static void REGAL_CALL loader_glActiveStencilFaceEXT(GLenum face)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glActiveStencilFaceEXT, "glActiveStencilFaceEXT");
  if (_driver.glActiveStencilFaceEXT) {
    _driver.glActiveStencilFaceEXT(face);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glActiveStencilFaceEXT)(face);
}

// GL_EXT_subtexture

static void REGAL_CALL loader_glTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexSubImage1DEXT, "glTexSubImage1DEXT");
  if (_driver.glTexSubImage1DEXT) {
    _driver.glTexSubImage1DEXT(target, level, xoffset, width, format, type, pixels);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexSubImage1DEXT)(target, level, xoffset, width, format, type, pixels);
}

static void REGAL_CALL loader_glTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexSubImage2DEXT, "glTexSubImage2DEXT");
  if (_driver.glTexSubImage2DEXT) {
    _driver.glTexSubImage2DEXT(target, level, xoffset, yoffset, width, height, format, type, pixels);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexSubImage2DEXT)(target, level, xoffset, yoffset, width, height, format, type, pixels);
}

static void REGAL_CALL loader_glTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexSubImage3DEXT, "glTexSubImage3DEXT");
  if (_driver.glTexSubImage3DEXT) {
    _driver.glTexSubImage3DEXT(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexSubImage3DEXT)(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
}

// GL_EXT_texture3D

static void REGAL_CALL loader_glTexImage3DEXT(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexImage3DEXT, "glTexImage3DEXT");
  if (_driver.glTexImage3DEXT) {
    _driver.glTexImage3DEXT(target, level, internalformat, width, height, depth, border, format, type, pixels);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexImage3DEXT)(target, level, internalformat, width, height, depth, border, format, type, pixels);
}

// GL_EXT_texture_array

static void REGAL_CALL loader_glFramebufferTextureLayerEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFramebufferTextureLayerEXT, "glFramebufferTextureLayerEXT");
  if (_driver.glFramebufferTextureLayerEXT) {
    _driver.glFramebufferTextureLayerEXT(target, attachment, texture, level, layer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFramebufferTextureLayerEXT)(target, attachment, texture, level, layer);
}

// GL_EXT_texture_buffer_object

static void REGAL_CALL loader_glTexBufferEXT(GLenum target, GLenum internalformat, GLuint buffer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexBufferEXT, "glTexBufferEXT");
  if (_driver.glTexBufferEXT) {
    _driver.glTexBufferEXT(target, internalformat, buffer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexBufferEXT)(target, internalformat, buffer);
}

// GL_EXT_texture_integer

static void REGAL_CALL loader_glClearColorIiEXT(GLint red, GLint green, GLint blue, GLint alpha)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glClearColorIiEXT, "glClearColorIiEXT");
  if (_driver.glClearColorIiEXT) {
    _driver.glClearColorIiEXT(red, green, blue, alpha);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glClearColorIiEXT)(red, green, blue, alpha);
}

static void REGAL_CALL loader_glClearColorIuiEXT(GLuint red, GLuint green, GLuint blue, GLuint alpha)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glClearColorIuiEXT, "glClearColorIuiEXT");
  if (_driver.glClearColorIuiEXT) {
    _driver.glClearColorIuiEXT(red, green, blue, alpha);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glClearColorIuiEXT)(red, green, blue, alpha);
}

static void REGAL_CALL loader_glGetTexParameterIivEXT(GLenum target, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetTexParameterIivEXT, "glGetTexParameterIivEXT");
  if (_driver.glGetTexParameterIivEXT) {
    _driver.glGetTexParameterIivEXT(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetTexParameterIivEXT)(target, pname, params);
}

static void REGAL_CALL loader_glGetTexParameterIuivEXT(GLenum target, GLenum pname, GLuint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetTexParameterIuivEXT, "glGetTexParameterIuivEXT");
  if (_driver.glGetTexParameterIuivEXT) {
    _driver.glGetTexParameterIuivEXT(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetTexParameterIuivEXT)(target, pname, params);
}

static void REGAL_CALL loader_glTexParameterIivEXT(GLenum target, GLenum pname, const GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexParameterIivEXT, "glTexParameterIivEXT");
  if (_driver.glTexParameterIivEXT) {
    _driver.glTexParameterIivEXT(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexParameterIivEXT)(target, pname, params);
}

static void REGAL_CALL loader_glTexParameterIuivEXT(GLenum target, GLenum pname, const GLuint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexParameterIuivEXT, "glTexParameterIuivEXT");
  if (_driver.glTexParameterIuivEXT) {
    _driver.glTexParameterIuivEXT(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexParameterIuivEXT)(target, pname, params);
}

// GL_EXT_texture_object

static GLboolean REGAL_CALL loader_glAreTexturesResidentEXT(GLsizei n, const GLuint *textures, GLboolean *residences)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glAreTexturesResidentEXT, "glAreTexturesResidentEXT");
  if (_driver.glAreTexturesResidentEXT) {
    return _driver.glAreTexturesResidentEXT(n, textures, residences);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glAreTexturesResidentEXT)(n, textures, residences);
}

static void REGAL_CALL loader_glBindTextureEXT(GLenum target, GLuint texture)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBindTextureEXT, "glBindTextureEXT");
  if (_driver.glBindTextureEXT) {
    _driver.glBindTextureEXT(target, texture);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBindTextureEXT)(target, texture);
}

static void REGAL_CALL loader_glDeleteTexturesEXT(GLsizei n, const GLuint *textures)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDeleteTexturesEXT, "glDeleteTexturesEXT");
  if (_driver.glDeleteTexturesEXT) {
    _driver.glDeleteTexturesEXT(n, textures);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDeleteTexturesEXT)(n, textures);
}

static void REGAL_CALL loader_glGenTexturesEXT(GLsizei n, GLuint *textures)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGenTexturesEXT, "glGenTexturesEXT");
  if (_driver.glGenTexturesEXT) {
    _driver.glGenTexturesEXT(n, textures);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGenTexturesEXT)(n, textures);
}

static GLboolean REGAL_CALL loader_glIsTextureEXT(GLuint texture)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIsTextureEXT, "glIsTextureEXT");
  if (_driver.glIsTextureEXT) {
    return _driver.glIsTextureEXT(texture);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glIsTextureEXT)(texture);
}

static void REGAL_CALL loader_glPrioritizeTexturesEXT(GLsizei n, const GLuint *textures, const GLclampf *priorities)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPrioritizeTexturesEXT, "glPrioritizeTexturesEXT");
  if (_driver.glPrioritizeTexturesEXT) {
    _driver.glPrioritizeTexturesEXT(n, textures, priorities);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPrioritizeTexturesEXT)(n, textures, priorities);
}

// GL_EXT_texture_perturb_normal

static void REGAL_CALL loader_glTextureNormalEXT(GLenum mode)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTextureNormalEXT, "glTextureNormalEXT");
  if (_driver.glTextureNormalEXT) {
    _driver.glTextureNormalEXT(mode);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTextureNormalEXT)(mode);
}

// GL_EXT_texture_storage

static void REGAL_CALL loader_glTexStorage1DEXT(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexStorage1DEXT, "glTexStorage1DEXT");
  if (_driver.glTexStorage1DEXT) {
    _driver.glTexStorage1DEXT(target, levels, internalformat, width);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexStorage1DEXT)(target, levels, internalformat, width);
}

static void REGAL_CALL loader_glTexStorage2DEXT(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexStorage2DEXT, "glTexStorage2DEXT");
  if (_driver.glTexStorage2DEXT) {
    _driver.glTexStorage2DEXT(target, levels, internalformat, width, height);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexStorage2DEXT)(target, levels, internalformat, width, height);
}

static void REGAL_CALL loader_glTexStorage3DEXT(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexStorage3DEXT, "glTexStorage3DEXT");
  if (_driver.glTexStorage3DEXT) {
    _driver.glTexStorage3DEXT(target, levels, internalformat, width, height, depth);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexStorage3DEXT)(target, levels, internalformat, width, height, depth);
}

// GL_EXT_timer_query

static void REGAL_CALL loader_glGetQueryObjecti64vEXT(GLuint id, GLenum pname, GLint64EXT *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetQueryObjecti64vEXT, "glGetQueryObjecti64vEXT");
  if (_driver.glGetQueryObjecti64vEXT) {
    _driver.glGetQueryObjecti64vEXT(id, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetQueryObjecti64vEXT)(id, pname, params);
}

static void REGAL_CALL loader_glGetQueryObjectui64vEXT(GLuint id, GLenum pname, GLuint64EXT *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetQueryObjectui64vEXT, "glGetQueryObjectui64vEXT");
  if (_driver.glGetQueryObjectui64vEXT) {
    _driver.glGetQueryObjectui64vEXT(id, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetQueryObjectui64vEXT)(id, pname, params);
}

// GL_EXT_transform_feedback

static void REGAL_CALL loader_glBeginTransformFeedbackEXT(GLenum primitiveMode)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBeginTransformFeedbackEXT, "glBeginTransformFeedbackEXT");
  if (_driver.glBeginTransformFeedbackEXT) {
    _driver.glBeginTransformFeedbackEXT(primitiveMode);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBeginTransformFeedbackEXT)(primitiveMode);
}

static void REGAL_CALL loader_glBindBufferBaseEXT(GLenum target, GLuint index, GLuint buffer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBindBufferBaseEXT, "glBindBufferBaseEXT");
  if (_driver.glBindBufferBaseEXT) {
    _driver.glBindBufferBaseEXT(target, index, buffer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBindBufferBaseEXT)(target, index, buffer);
}

static void REGAL_CALL loader_glBindBufferOffsetEXT(GLenum target, GLuint index, GLuint buffer, GLintptr offset)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBindBufferOffsetEXT, "glBindBufferOffsetEXT");
  if (_driver.glBindBufferOffsetEXT) {
    _driver.glBindBufferOffsetEXT(target, index, buffer, offset);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBindBufferOffsetEXT)(target, index, buffer, offset);
}

static void REGAL_CALL loader_glBindBufferRangeEXT(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBindBufferRangeEXT, "glBindBufferRangeEXT");
  if (_driver.glBindBufferRangeEXT) {
    _driver.glBindBufferRangeEXT(target, index, buffer, offset, size);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBindBufferRangeEXT)(target, index, buffer, offset, size);
}

static void REGAL_CALL loader_glEndTransformFeedbackEXT(void)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glEndTransformFeedbackEXT, "glEndTransformFeedbackEXT");
  if (_driver.glEndTransformFeedbackEXT) {
    _driver.glEndTransformFeedbackEXT();
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glEndTransformFeedbackEXT)();
}

static void REGAL_CALL loader_glGetTransformFeedbackVaryingEXT(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetTransformFeedbackVaryingEXT, "glGetTransformFeedbackVaryingEXT");
  if (_driver.glGetTransformFeedbackVaryingEXT) {
    _driver.glGetTransformFeedbackVaryingEXT(program, index, bufSize, length, size, type, name);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetTransformFeedbackVaryingEXT)(program, index, bufSize, length, size, type, name);
}

static void REGAL_CALL loader_glTransformFeedbackVaryingsEXT(GLuint program, GLsizei count, const GLchar **varyings, GLenum bufferMode)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTransformFeedbackVaryingsEXT, "glTransformFeedbackVaryingsEXT");
  if (_driver.glTransformFeedbackVaryingsEXT) {
    _driver.glTransformFeedbackVaryingsEXT(program, count, varyings, bufferMode);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTransformFeedbackVaryingsEXT)(program, count, varyings, bufferMode);
}

// GL_EXT_vertex_array

static void REGAL_CALL loader_glArrayElementEXT(GLint i)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glArrayElementEXT, "glArrayElementEXT");
  if (_driver.glArrayElementEXT) {
    _driver.glArrayElementEXT(i);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glArrayElementEXT)(i);
}

static void REGAL_CALL loader_glColorPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColorPointerEXT, "glColorPointerEXT");
  if (_driver.glColorPointerEXT) {
    _driver.glColorPointerEXT(size, type, stride, count, pointer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColorPointerEXT)(size, type, stride, count, pointer);
}

static void REGAL_CALL loader_glDrawArraysEXT(GLenum mode, GLint first, GLsizei count)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDrawArraysEXT, "glDrawArraysEXT");
  if (_driver.glDrawArraysEXT) {
    _driver.glDrawArraysEXT(mode, first, count);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDrawArraysEXT)(mode, first, count);
}

static void REGAL_CALL loader_glEdgeFlagPointerEXT(GLsizei stride, GLsizei count, const GLboolean *pointer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glEdgeFlagPointerEXT, "glEdgeFlagPointerEXT");
  if (_driver.glEdgeFlagPointerEXT) {
    _driver.glEdgeFlagPointerEXT(stride, count, pointer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glEdgeFlagPointerEXT)(stride, count, pointer);
}

static void REGAL_CALL loader_glGetPointervEXT(GLenum pname, GLvoid **params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetPointervEXT, "glGetPointervEXT");
  if (_driver.glGetPointervEXT) {
    _driver.glGetPointervEXT(pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetPointervEXT)(pname, params);
}

static void REGAL_CALL loader_glIndexPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIndexPointerEXT, "glIndexPointerEXT");
  if (_driver.glIndexPointerEXT) {
    _driver.glIndexPointerEXT(type, stride, count, pointer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glIndexPointerEXT)(type, stride, count, pointer);
}

static void REGAL_CALL loader_glNormalPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNormalPointerEXT, "glNormalPointerEXT");
  if (_driver.glNormalPointerEXT) {
    _driver.glNormalPointerEXT(type, stride, count, pointer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNormalPointerEXT)(type, stride, count, pointer);
}

static void REGAL_CALL loader_glTexCoordPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoordPointerEXT, "glTexCoordPointerEXT");
  if (_driver.glTexCoordPointerEXT) {
    _driver.glTexCoordPointerEXT(size, type, stride, count, pointer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoordPointerEXT)(size, type, stride, count, pointer);
}

static void REGAL_CALL loader_glVertexPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexPointerEXT, "glVertexPointerEXT");
  if (_driver.glVertexPointerEXT) {
    _driver.glVertexPointerEXT(size, type, stride, count, pointer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexPointerEXT)(size, type, stride, count, pointer);
}

// GL_EXT_vertex_attrib_64bit

static void REGAL_CALL loader_glGetVertexAttribLdvEXT(GLuint index, GLenum pname, GLdouble *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetVertexAttribLdvEXT, "glGetVertexAttribLdvEXT");
  if (_driver.glGetVertexAttribLdvEXT) {
    _driver.glGetVertexAttribLdvEXT(index, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetVertexAttribLdvEXT)(index, pname, params);
}

static void REGAL_CALL loader_glVertexArrayVertexAttribLOffsetEXT(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexArrayVertexAttribLOffsetEXT, "glVertexArrayVertexAttribLOffsetEXT");
  if (_driver.glVertexArrayVertexAttribLOffsetEXT) {
    _driver.glVertexArrayVertexAttribLOffsetEXT(vaobj, buffer, index, size, type, stride, offset);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexArrayVertexAttribLOffsetEXT)(vaobj, buffer, index, size, type, stride, offset);
}

static void REGAL_CALL loader_glVertexAttribL1dEXT(GLuint index, GLdouble x)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribL1dEXT, "glVertexAttribL1dEXT");
  if (_driver.glVertexAttribL1dEXT) {
    _driver.glVertexAttribL1dEXT(index, x);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribL1dEXT)(index, x);
}

static void REGAL_CALL loader_glVertexAttribL1dvEXT(GLuint index, const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribL1dvEXT, "glVertexAttribL1dvEXT");
  if (_driver.glVertexAttribL1dvEXT) {
    _driver.glVertexAttribL1dvEXT(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribL1dvEXT)(index, v);
}

static void REGAL_CALL loader_glVertexAttribL2dEXT(GLuint index, GLdouble x, GLdouble y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribL2dEXT, "glVertexAttribL2dEXT");
  if (_driver.glVertexAttribL2dEXT) {
    _driver.glVertexAttribL2dEXT(index, x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribL2dEXT)(index, x, y);
}

static void REGAL_CALL loader_glVertexAttribL2dvEXT(GLuint index, const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribL2dvEXT, "glVertexAttribL2dvEXT");
  if (_driver.glVertexAttribL2dvEXT) {
    _driver.glVertexAttribL2dvEXT(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribL2dvEXT)(index, v);
}

static void REGAL_CALL loader_glVertexAttribL3dEXT(GLuint index, GLdouble x, GLdouble y, GLdouble z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribL3dEXT, "glVertexAttribL3dEXT");
  if (_driver.glVertexAttribL3dEXT) {
    _driver.glVertexAttribL3dEXT(index, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribL3dEXT)(index, x, y, z);
}

static void REGAL_CALL loader_glVertexAttribL3dvEXT(GLuint index, const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribL3dvEXT, "glVertexAttribL3dvEXT");
  if (_driver.glVertexAttribL3dvEXT) {
    _driver.glVertexAttribL3dvEXT(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribL3dvEXT)(index, v);
}

static void REGAL_CALL loader_glVertexAttribL4dEXT(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribL4dEXT, "glVertexAttribL4dEXT");
  if (_driver.glVertexAttribL4dEXT) {
    _driver.glVertexAttribL4dEXT(index, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribL4dEXT)(index, x, y, z, w);
}

static void REGAL_CALL loader_glVertexAttribL4dvEXT(GLuint index, const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribL4dvEXT, "glVertexAttribL4dvEXT");
  if (_driver.glVertexAttribL4dvEXT) {
    _driver.glVertexAttribL4dvEXT(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribL4dvEXT)(index, v);
}

static void REGAL_CALL loader_glVertexAttribLPointerEXT(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribLPointerEXT, "glVertexAttribLPointerEXT");
  if (_driver.glVertexAttribLPointerEXT) {
    _driver.glVertexAttribLPointerEXT(index, size, type, stride, pointer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribLPointerEXT)(index, size, type, stride, pointer);
}

// GL_EXT_vertex_shader

static void REGAL_CALL loader_glBeginVertexShaderEXT(void)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBeginVertexShaderEXT, "glBeginVertexShaderEXT");
  if (_driver.glBeginVertexShaderEXT) {
    _driver.glBeginVertexShaderEXT();
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBeginVertexShaderEXT)();
}

static GLuint REGAL_CALL loader_glBindLightParameterEXT(GLenum light, GLenum value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBindLightParameterEXT, "glBindLightParameterEXT");
  if (_driver.glBindLightParameterEXT) {
    return _driver.glBindLightParameterEXT(light, value);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glBindLightParameterEXT)(light, value);
}

static GLuint REGAL_CALL loader_glBindMaterialParameterEXT(GLenum face, GLenum value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBindMaterialParameterEXT, "glBindMaterialParameterEXT");
  if (_driver.glBindMaterialParameterEXT) {
    return _driver.glBindMaterialParameterEXT(face, value);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glBindMaterialParameterEXT)(face, value);
}

static GLuint REGAL_CALL loader_glBindParameterEXT(GLenum value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBindParameterEXT, "glBindParameterEXT");
  if (_driver.glBindParameterEXT) {
    return _driver.glBindParameterEXT(value);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glBindParameterEXT)(value);
}

static GLuint REGAL_CALL loader_glBindTexGenParameterEXT(GLenum unit, GLenum coord, GLenum value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBindTexGenParameterEXT, "glBindTexGenParameterEXT");
  if (_driver.glBindTexGenParameterEXT) {
    return _driver.glBindTexGenParameterEXT(unit, coord, value);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glBindTexGenParameterEXT)(unit, coord, value);
}

static GLuint REGAL_CALL loader_glBindTextureUnitParameterEXT(GLenum unit, GLenum value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBindTextureUnitParameterEXT, "glBindTextureUnitParameterEXT");
  if (_driver.glBindTextureUnitParameterEXT) {
    return _driver.glBindTextureUnitParameterEXT(unit, value);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glBindTextureUnitParameterEXT)(unit, value);
}

static void REGAL_CALL loader_glBindVertexShaderEXT(GLuint id)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBindVertexShaderEXT, "glBindVertexShaderEXT");
  if (_driver.glBindVertexShaderEXT) {
    _driver.glBindVertexShaderEXT(id);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBindVertexShaderEXT)(id);
}

static void REGAL_CALL loader_glDeleteVertexShaderEXT(GLuint id)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDeleteVertexShaderEXT, "glDeleteVertexShaderEXT");
  if (_driver.glDeleteVertexShaderEXT) {
    _driver.glDeleteVertexShaderEXT(id);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDeleteVertexShaderEXT)(id);
}

static void REGAL_CALL loader_glDisableVariantClientStateEXT(GLuint id)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDisableVariantClientStateEXT, "glDisableVariantClientStateEXT");
  if (_driver.glDisableVariantClientStateEXT) {
    _driver.glDisableVariantClientStateEXT(id);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDisableVariantClientStateEXT)(id);
}

static void REGAL_CALL loader_glEnableVariantClientStateEXT(GLuint id)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glEnableVariantClientStateEXT, "glEnableVariantClientStateEXT");
  if (_driver.glEnableVariantClientStateEXT) {
    _driver.glEnableVariantClientStateEXT(id);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glEnableVariantClientStateEXT)(id);
}

static void REGAL_CALL loader_glEndVertexShaderEXT(void)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glEndVertexShaderEXT, "glEndVertexShaderEXT");
  if (_driver.glEndVertexShaderEXT) {
    _driver.glEndVertexShaderEXT();
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glEndVertexShaderEXT)();
}

static void REGAL_CALL loader_glExtractComponentEXT(GLuint res, GLuint src, GLuint num)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glExtractComponentEXT, "glExtractComponentEXT");
  if (_driver.glExtractComponentEXT) {
    _driver.glExtractComponentEXT(res, src, num);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glExtractComponentEXT)(res, src, num);
}

static GLuint REGAL_CALL loader_glGenSymbolsEXT(GLenum datatype, GLenum storagetype, GLenum range, GLuint components)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGenSymbolsEXT, "glGenSymbolsEXT");
  if (_driver.glGenSymbolsEXT) {
    return _driver.glGenSymbolsEXT(datatype, storagetype, range, components);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glGenSymbolsEXT)(datatype, storagetype, range, components);
}

static GLuint REGAL_CALL loader_glGenVertexShadersEXT(GLuint range)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGenVertexShadersEXT, "glGenVertexShadersEXT");
  if (_driver.glGenVertexShadersEXT) {
    return _driver.glGenVertexShadersEXT(range);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glGenVertexShadersEXT)(range);
}

static void REGAL_CALL loader_glGetInvariantBooleanvEXT(GLuint id, GLenum value, GLboolean *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetInvariantBooleanvEXT, "glGetInvariantBooleanvEXT");
  if (_driver.glGetInvariantBooleanvEXT) {
    _driver.glGetInvariantBooleanvEXT(id, value, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetInvariantBooleanvEXT)(id, value, data);
}

static void REGAL_CALL loader_glGetInvariantFloatvEXT(GLuint id, GLenum value, GLfloat *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetInvariantFloatvEXT, "glGetInvariantFloatvEXT");
  if (_driver.glGetInvariantFloatvEXT) {
    _driver.glGetInvariantFloatvEXT(id, value, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetInvariantFloatvEXT)(id, value, data);
}

static void REGAL_CALL loader_glGetInvariantIntegervEXT(GLuint id, GLenum value, GLint *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetInvariantIntegervEXT, "glGetInvariantIntegervEXT");
  if (_driver.glGetInvariantIntegervEXT) {
    _driver.glGetInvariantIntegervEXT(id, value, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetInvariantIntegervEXT)(id, value, data);
}

static void REGAL_CALL loader_glGetLocalConstantBooleanvEXT(GLuint id, GLenum value, GLboolean *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetLocalConstantBooleanvEXT, "glGetLocalConstantBooleanvEXT");
  if (_driver.glGetLocalConstantBooleanvEXT) {
    _driver.glGetLocalConstantBooleanvEXT(id, value, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetLocalConstantBooleanvEXT)(id, value, data);
}

static void REGAL_CALL loader_glGetLocalConstantFloatvEXT(GLuint id, GLenum value, GLfloat *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetLocalConstantFloatvEXT, "glGetLocalConstantFloatvEXT");
  if (_driver.glGetLocalConstantFloatvEXT) {
    _driver.glGetLocalConstantFloatvEXT(id, value, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetLocalConstantFloatvEXT)(id, value, data);
}

static void REGAL_CALL loader_glGetLocalConstantIntegervEXT(GLuint id, GLenum value, GLint *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetLocalConstantIntegervEXT, "glGetLocalConstantIntegervEXT");
  if (_driver.glGetLocalConstantIntegervEXT) {
    _driver.glGetLocalConstantIntegervEXT(id, value, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetLocalConstantIntegervEXT)(id, value, data);
}

static void REGAL_CALL loader_glGetVariantBooleanvEXT(GLuint id, GLenum value, GLboolean *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetVariantBooleanvEXT, "glGetVariantBooleanvEXT");
  if (_driver.glGetVariantBooleanvEXT) {
    _driver.glGetVariantBooleanvEXT(id, value, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetVariantBooleanvEXT)(id, value, data);
}

static void REGAL_CALL loader_glGetVariantFloatvEXT(GLuint id, GLenum value, GLfloat *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetVariantFloatvEXT, "glGetVariantFloatvEXT");
  if (_driver.glGetVariantFloatvEXT) {
    _driver.glGetVariantFloatvEXT(id, value, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetVariantFloatvEXT)(id, value, data);
}

static void REGAL_CALL loader_glGetVariantIntegervEXT(GLuint id, GLenum value, GLint *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetVariantIntegervEXT, "glGetVariantIntegervEXT");
  if (_driver.glGetVariantIntegervEXT) {
    _driver.glGetVariantIntegervEXT(id, value, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetVariantIntegervEXT)(id, value, data);
}

static void REGAL_CALL loader_glGetVariantPointervEXT(GLuint id, GLenum value, GLvoid **data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetVariantPointervEXT, "glGetVariantPointervEXT");
  if (_driver.glGetVariantPointervEXT) {
    _driver.glGetVariantPointervEXT(id, value, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetVariantPointervEXT)(id, value, data);
}

static void REGAL_CALL loader_glInsertComponentEXT(GLuint res, GLuint src, GLuint num)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glInsertComponentEXT, "glInsertComponentEXT");
  if (_driver.glInsertComponentEXT) {
    _driver.glInsertComponentEXT(res, src, num);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glInsertComponentEXT)(res, src, num);
}

static GLboolean REGAL_CALL loader_glIsVariantEnabledEXT(GLuint id, GLenum cap)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIsVariantEnabledEXT, "glIsVariantEnabledEXT");
  if (_driver.glIsVariantEnabledEXT) {
    return _driver.glIsVariantEnabledEXT(id, cap);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glIsVariantEnabledEXT)(id, cap);
}

static void REGAL_CALL loader_glSetInvariantEXT(GLuint id, GLenum type, const GLvoid *addr)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSetInvariantEXT, "glSetInvariantEXT");
  if (_driver.glSetInvariantEXT) {
    _driver.glSetInvariantEXT(id, type, addr);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSetInvariantEXT)(id, type, addr);
}

static void REGAL_CALL loader_glSetLocalConstantEXT(GLuint id, GLenum type, const GLvoid *addr)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSetLocalConstantEXT, "glSetLocalConstantEXT");
  if (_driver.glSetLocalConstantEXT) {
    _driver.glSetLocalConstantEXT(id, type, addr);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSetLocalConstantEXT)(id, type, addr);
}

static void REGAL_CALL loader_glShaderOp1EXT(GLenum op, GLuint res, GLuint arg1)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glShaderOp1EXT, "glShaderOp1EXT");
  if (_driver.glShaderOp1EXT) {
    _driver.glShaderOp1EXT(op, res, arg1);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glShaderOp1EXT)(op, res, arg1);
}

static void REGAL_CALL loader_glShaderOp2EXT(GLenum op, GLuint res, GLuint arg1, GLuint arg2)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glShaderOp2EXT, "glShaderOp2EXT");
  if (_driver.glShaderOp2EXT) {
    _driver.glShaderOp2EXT(op, res, arg1, arg2);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glShaderOp2EXT)(op, res, arg1, arg2);
}

static void REGAL_CALL loader_glShaderOp3EXT(GLenum op, GLuint res, GLuint arg1, GLuint arg2, GLuint arg3)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glShaderOp3EXT, "glShaderOp3EXT");
  if (_driver.glShaderOp3EXT) {
    _driver.glShaderOp3EXT(op, res, arg1, arg2, arg3);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glShaderOp3EXT)(op, res, arg1, arg2, arg3);
}

static void REGAL_CALL loader_glSwizzleEXT(GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSwizzleEXT, "glSwizzleEXT");
  if (_driver.glSwizzleEXT) {
    _driver.glSwizzleEXT(res, in, outX, outY, outZ, outW);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSwizzleEXT)(res, in, outX, outY, outZ, outW);
}

static void REGAL_CALL loader_glVariantPointerEXT(GLuint id, GLenum type, GLuint stride, const GLvoid *addr)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVariantPointerEXT, "glVariantPointerEXT");
  if (_driver.glVariantPointerEXT) {
    _driver.glVariantPointerEXT(id, type, stride, addr);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVariantPointerEXT)(id, type, stride, addr);
}

static void REGAL_CALL loader_glVariantbvEXT(GLuint id, const GLbyte *addr)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVariantbvEXT, "glVariantbvEXT");
  if (_driver.glVariantbvEXT) {
    _driver.glVariantbvEXT(id, addr);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVariantbvEXT)(id, addr);
}

static void REGAL_CALL loader_glVariantdvEXT(GLuint id, const GLdouble *addr)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVariantdvEXT, "glVariantdvEXT");
  if (_driver.glVariantdvEXT) {
    _driver.glVariantdvEXT(id, addr);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVariantdvEXT)(id, addr);
}

static void REGAL_CALL loader_glVariantfvEXT(GLuint id, const GLfloat *addr)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVariantfvEXT, "glVariantfvEXT");
  if (_driver.glVariantfvEXT) {
    _driver.glVariantfvEXT(id, addr);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVariantfvEXT)(id, addr);
}

static void REGAL_CALL loader_glVariantivEXT(GLuint id, const GLint *addr)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVariantivEXT, "glVariantivEXT");
  if (_driver.glVariantivEXT) {
    _driver.glVariantivEXT(id, addr);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVariantivEXT)(id, addr);
}

static void REGAL_CALL loader_glVariantsvEXT(GLuint id, const GLshort *addr)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVariantsvEXT, "glVariantsvEXT");
  if (_driver.glVariantsvEXT) {
    _driver.glVariantsvEXT(id, addr);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVariantsvEXT)(id, addr);
}

static void REGAL_CALL loader_glVariantubvEXT(GLuint id, const GLubyte *addr)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVariantubvEXT, "glVariantubvEXT");
  if (_driver.glVariantubvEXT) {
    _driver.glVariantubvEXT(id, addr);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVariantubvEXT)(id, addr);
}

static void REGAL_CALL loader_glVariantuivEXT(GLuint id, const GLuint *addr)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVariantuivEXT, "glVariantuivEXT");
  if (_driver.glVariantuivEXT) {
    _driver.glVariantuivEXT(id, addr);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVariantuivEXT)(id, addr);
}

static void REGAL_CALL loader_glVariantusvEXT(GLuint id, const GLushort *addr)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVariantusvEXT, "glVariantusvEXT");
  if (_driver.glVariantusvEXT) {
    _driver.glVariantusvEXT(id, addr);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVariantusvEXT)(id, addr);
}

static void REGAL_CALL loader_glWriteMaskEXT(GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWriteMaskEXT, "glWriteMaskEXT");
  if (_driver.glWriteMaskEXT) {
    _driver.glWriteMaskEXT(res, in, outX, outY, outZ, outW);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWriteMaskEXT)(res, in, outX, outY, outZ, outW);
}

// GL_EXT_vertex_weighting

static void REGAL_CALL loader_glVertexWeightPointerEXT(GLsizei size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexWeightPointerEXT, "glVertexWeightPointerEXT");
  if (_driver.glVertexWeightPointerEXT) {
    _driver.glVertexWeightPointerEXT(size, type, stride, pointer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexWeightPointerEXT)(size, type, stride, pointer);
}

static void REGAL_CALL loader_glVertexWeightfEXT(GLfloat weight)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexWeightfEXT, "glVertexWeightfEXT");
  if (_driver.glVertexWeightfEXT) {
    _driver.glVertexWeightfEXT(weight);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexWeightfEXT)(weight);
}

static void REGAL_CALL loader_glVertexWeightfvEXT(const GLfloat *weight)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexWeightfvEXT, "glVertexWeightfvEXT");
  if (_driver.glVertexWeightfvEXT) {
    _driver.glVertexWeightfvEXT(weight);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexWeightfvEXT)(weight);
}

// GL_EXT_x11_sync_object

static GLsync REGAL_CALL loader_glImportSyncEXT(GLenum external_sync_type, GLintptr external_sync, GLbitfield flags)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glImportSyncEXT, "glImportSyncEXT");
  if (_driver.glImportSyncEXT) {
    return _driver.glImportSyncEXT(external_sync_type, external_sync, flags);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glImportSyncEXT)(external_sync_type, external_sync, flags);
}

// GL_GREMEDY_frame_terminator

static void REGAL_CALL loader_glFrameTerminatorGREMEDY(void)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFrameTerminatorGREMEDY, "glFrameTerminatorGREMEDY");
  if (_driver.glFrameTerminatorGREMEDY) {
    _driver.glFrameTerminatorGREMEDY();
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFrameTerminatorGREMEDY)();
}

// GL_GREMEDY_string_marker

static void REGAL_CALL loader_glStringMarkerGREMEDY(GLsizei len, const GLvoid *string)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glStringMarkerGREMEDY, "glStringMarkerGREMEDY");
  if (_driver.glStringMarkerGREMEDY) {
    _driver.glStringMarkerGREMEDY(len, string);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glStringMarkerGREMEDY)(len, string);
}

// GL_HP_image_transform

static void REGAL_CALL loader_glGetImageTransformParameterfvHP(GLenum target, GLenum pname, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetImageTransformParameterfvHP, "glGetImageTransformParameterfvHP");
  if (_driver.glGetImageTransformParameterfvHP) {
    _driver.glGetImageTransformParameterfvHP(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetImageTransformParameterfvHP)(target, pname, params);
}

static void REGAL_CALL loader_glGetImageTransformParameterivHP(GLenum target, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetImageTransformParameterivHP, "glGetImageTransformParameterivHP");
  if (_driver.glGetImageTransformParameterivHP) {
    _driver.glGetImageTransformParameterivHP(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetImageTransformParameterivHP)(target, pname, params);
}

static void REGAL_CALL loader_glImageTransformParameterfHP(GLenum target, GLenum pname, GLfloat param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glImageTransformParameterfHP, "glImageTransformParameterfHP");
  if (_driver.glImageTransformParameterfHP) {
    _driver.glImageTransformParameterfHP(target, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glImageTransformParameterfHP)(target, pname, param);
}

static void REGAL_CALL loader_glImageTransformParameterfvHP(GLenum target, GLenum pname, const GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glImageTransformParameterfvHP, "glImageTransformParameterfvHP");
  if (_driver.glImageTransformParameterfvHP) {
    _driver.glImageTransformParameterfvHP(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glImageTransformParameterfvHP)(target, pname, params);
}

static void REGAL_CALL loader_glImageTransformParameteriHP(GLenum target, GLenum pname, GLint param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glImageTransformParameteriHP, "glImageTransformParameteriHP");
  if (_driver.glImageTransformParameteriHP) {
    _driver.glImageTransformParameteriHP(target, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glImageTransformParameteriHP)(target, pname, param);
}

static void REGAL_CALL loader_glImageTransformParameterivHP(GLenum target, GLenum pname, const GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glImageTransformParameterivHP, "glImageTransformParameterivHP");
  if (_driver.glImageTransformParameterivHP) {
    _driver.glImageTransformParameterivHP(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glImageTransformParameterivHP)(target, pname, params);
}

// GL_IBM_multimode_draw_arrays

static void REGAL_CALL loader_glMultiModeDrawArraysIBM(const GLenum *mode, const GLint *first, const GLsizei *count, GLsizei primcount, GLint modestride)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiModeDrawArraysIBM, "glMultiModeDrawArraysIBM");
  if (_driver.glMultiModeDrawArraysIBM) {
    _driver.glMultiModeDrawArraysIBM(mode, first, count, primcount, modestride);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiModeDrawArraysIBM)(mode, first, count, primcount, modestride);
}

static void REGAL_CALL loader_glMultiModeDrawElementsIBM(const GLenum *mode, const GLsizei *count, GLenum type, const GLvoid * const *indices, GLsizei primcount, GLint modestride)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiModeDrawElementsIBM, "glMultiModeDrawElementsIBM");
  if (_driver.glMultiModeDrawElementsIBM) {
    _driver.glMultiModeDrawElementsIBM(mode, count, type, indices, primcount, modestride);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiModeDrawElementsIBM)(mode, count, type, indices, primcount, modestride);
}

// GL_IBM_vertex_array_lists

static void REGAL_CALL loader_glColorPointerListIBM(GLint size, GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColorPointerListIBM, "glColorPointerListIBM");
  if (_driver.glColorPointerListIBM) {
    _driver.glColorPointerListIBM(size, type, stride, pointer, ptrstride);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColorPointerListIBM)(size, type, stride, pointer, ptrstride);
}

static void REGAL_CALL loader_glEdgeFlagPointerListIBM(GLint stride, const GLboolean **pointer, GLint ptrstride)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glEdgeFlagPointerListIBM, "glEdgeFlagPointerListIBM");
  if (_driver.glEdgeFlagPointerListIBM) {
    _driver.glEdgeFlagPointerListIBM(stride, pointer, ptrstride);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glEdgeFlagPointerListIBM)(stride, pointer, ptrstride);
}

static void REGAL_CALL loader_glFogCoordPointerListIBM(GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFogCoordPointerListIBM, "glFogCoordPointerListIBM");
  if (_driver.glFogCoordPointerListIBM) {
    _driver.glFogCoordPointerListIBM(type, stride, pointer, ptrstride);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFogCoordPointerListIBM)(type, stride, pointer, ptrstride);
}

static void REGAL_CALL loader_glIndexPointerListIBM(GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIndexPointerListIBM, "glIndexPointerListIBM");
  if (_driver.glIndexPointerListIBM) {
    _driver.glIndexPointerListIBM(type, stride, pointer, ptrstride);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glIndexPointerListIBM)(type, stride, pointer, ptrstride);
}

static void REGAL_CALL loader_glNormalPointerListIBM(GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNormalPointerListIBM, "glNormalPointerListIBM");
  if (_driver.glNormalPointerListIBM) {
    _driver.glNormalPointerListIBM(type, stride, pointer, ptrstride);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNormalPointerListIBM)(type, stride, pointer, ptrstride);
}

static void REGAL_CALL loader_glSecondaryColorPointerListIBM(GLint size, GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSecondaryColorPointerListIBM, "glSecondaryColorPointerListIBM");
  if (_driver.glSecondaryColorPointerListIBM) {
    _driver.glSecondaryColorPointerListIBM(size, type, stride, pointer, ptrstride);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSecondaryColorPointerListIBM)(size, type, stride, pointer, ptrstride);
}

static void REGAL_CALL loader_glTexCoordPointerListIBM(GLint size, GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoordPointerListIBM, "glTexCoordPointerListIBM");
  if (_driver.glTexCoordPointerListIBM) {
    _driver.glTexCoordPointerListIBM(size, type, stride, pointer, ptrstride);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoordPointerListIBM)(size, type, stride, pointer, ptrstride);
}

static void REGAL_CALL loader_glVertexPointerListIBM(GLint size, GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexPointerListIBM, "glVertexPointerListIBM");
  if (_driver.glVertexPointerListIBM) {
    _driver.glVertexPointerListIBM(size, type, stride, pointer, ptrstride);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexPointerListIBM)(size, type, stride, pointer, ptrstride);
}

// GL_IMG_multisampled_render_to_texture

static void REGAL_CALL loader_glFramebufferTexture2DMultisampleIMG(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFramebufferTexture2DMultisampleIMG, "glFramebufferTexture2DMultisampleIMG");
  if (_driver.glFramebufferTexture2DMultisampleIMG) {
    _driver.glFramebufferTexture2DMultisampleIMG(target, attachment, textarget, texture, level, samples);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFramebufferTexture2DMultisampleIMG)(target, attachment, textarget, texture, level, samples);
}

static void REGAL_CALL loader_glRenderbufferStorageMultisampleIMG(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glRenderbufferStorageMultisampleIMG, "glRenderbufferStorageMultisampleIMG");
  if (_driver.glRenderbufferStorageMultisampleIMG) {
    _driver.glRenderbufferStorageMultisampleIMG(target, samples, internalformat, width, height);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glRenderbufferStorageMultisampleIMG)(target, samples, internalformat, width, height);
}

// GL_INGR_blend_func_separate

static void REGAL_CALL loader_glBlendFuncSeparateINGR(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBlendFuncSeparateINGR, "glBlendFuncSeparateINGR");
  if (_driver.glBlendFuncSeparateINGR) {
    _driver.glBlendFuncSeparateINGR(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBlendFuncSeparateINGR)(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
}

// GL_INTEL_parallel_arrays

static void REGAL_CALL loader_glColorPointervINTEL(GLint size, GLenum type, const GLvoid **pointer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColorPointervINTEL, "glColorPointervINTEL");
  if (_driver.glColorPointervINTEL) {
    _driver.glColorPointervINTEL(size, type, pointer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColorPointervINTEL)(size, type, pointer);
}

static void REGAL_CALL loader_glNormalPointervINTEL(GLenum type, const GLvoid **pointer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNormalPointervINTEL, "glNormalPointervINTEL");
  if (_driver.glNormalPointervINTEL) {
    _driver.glNormalPointervINTEL(type, pointer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNormalPointervINTEL)(type, pointer);
}

static void REGAL_CALL loader_glTexCoordPointervINTEL(GLint size, GLenum type, const GLvoid **pointer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoordPointervINTEL, "glTexCoordPointervINTEL");
  if (_driver.glTexCoordPointervINTEL) {
    _driver.glTexCoordPointervINTEL(size, type, pointer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoordPointervINTEL)(size, type, pointer);
}

static void REGAL_CALL loader_glVertexPointervINTEL(GLint size, GLenum type, const GLvoid **pointer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexPointervINTEL, "glVertexPointervINTEL");
  if (_driver.glVertexPointervINTEL) {
    _driver.glVertexPointervINTEL(size, type, pointer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexPointervINTEL)(size, type, pointer);
}

// GL_INTEL_texture_scissor

static void REGAL_CALL loader_glTexScissorFuncINTEL(GLenum target, GLenum lfunc, GLenum hfunc)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexScissorFuncINTEL, "glTexScissorFuncINTEL");
  if (_driver.glTexScissorFuncINTEL) {
    _driver.glTexScissorFuncINTEL(target, lfunc, hfunc);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexScissorFuncINTEL)(target, lfunc, hfunc);
}

static void REGAL_CALL loader_glTexScissorINTEL(GLenum target, GLclampf tlow, GLclampf thigh)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexScissorINTEL, "glTexScissorINTEL");
  if (_driver.glTexScissorINTEL) {
    _driver.glTexScissorINTEL(target, tlow, thigh);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexScissorINTEL)(target, tlow, thigh);
}

// GL_KHR_debug

static void REGAL_CALL loader_glDebugMessageCallback(GLDEBUGPROC callback, GLvoid *userParam)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDebugMessageCallback, "glDebugMessageCallback");
  if (_driver.glDebugMessageCallback) {
    _driver.glDebugMessageCallback(callback, userParam);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDebugMessageCallback)(callback, userParam);
}

static void REGAL_CALL loader_glDebugMessageControl(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDebugMessageControl, "glDebugMessageControl");
  if (_driver.glDebugMessageControl) {
    _driver.glDebugMessageControl(source, type, severity, count, ids, enabled);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDebugMessageControl)(source, type, severity, count, ids, enabled);
}

static void REGAL_CALL loader_glDebugMessageInsert(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDebugMessageInsert, "glDebugMessageInsert");
  if (_driver.glDebugMessageInsert) {
    _driver.glDebugMessageInsert(source, type, id, severity, length, buf);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDebugMessageInsert)(source, type, id, severity, length, buf);
}

static GLuint REGAL_CALL loader_glGetDebugMessageLog(GLuint count, GLsizei bufsize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetDebugMessageLog, "glGetDebugMessageLog");
  if (_driver.glGetDebugMessageLog) {
    return _driver.glGetDebugMessageLog(count, bufsize, sources, types, ids, severities, lengths, messageLog);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glGetDebugMessageLog)(count, bufsize, sources, types, ids, severities, lengths, messageLog);
}

static void REGAL_CALL loader_glGetObjectLabel(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei *length, GLchar *label)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetObjectLabel, "glGetObjectLabel");
  if (_driver.glGetObjectLabel) {
    _driver.glGetObjectLabel(identifier, name, bufSize, length, label);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetObjectLabel)(identifier, name, bufSize, length, label);
}

static void REGAL_CALL loader_glGetObjectPtrLabel(GLvoid *ptr, GLsizei bufSize, GLsizei *length, GLchar *label)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetObjectPtrLabel, "glGetObjectPtrLabel");
  if (_driver.glGetObjectPtrLabel) {
    _driver.glGetObjectPtrLabel(ptr, bufSize, length, label);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetObjectPtrLabel)(ptr, bufSize, length, label);
}

static void REGAL_CALL loader_glObjectLabel(GLenum identifier, GLuint name, GLsizei length, const GLchar *label)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glObjectLabel, "glObjectLabel");
  if (_driver.glObjectLabel) {
    _driver.glObjectLabel(identifier, name, length, label);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glObjectLabel)(identifier, name, length, label);
}

static void REGAL_CALL loader_glObjectPtrLabel(GLvoid *ptr, GLsizei length, const GLchar *label)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glObjectPtrLabel, "glObjectPtrLabel");
  if (_driver.glObjectPtrLabel) {
    _driver.glObjectPtrLabel(ptr, length, label);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glObjectPtrLabel)(ptr, length, label);
}

static void REGAL_CALL loader_glPopDebugGroup(void)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPopDebugGroup, "glPopDebugGroup");
  if (_driver.glPopDebugGroup) {
    _driver.glPopDebugGroup();
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPopDebugGroup)();
}

static void REGAL_CALL loader_glPushDebugGroup(GLenum source, GLuint id, GLsizei length, const GLchar *message)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPushDebugGroup, "glPushDebugGroup");
  if (_driver.glPushDebugGroup) {
    _driver.glPushDebugGroup(source, id, length, message);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPushDebugGroup)(source, id, length, message);
}

// GL_KTX_buffer_region

static GLuint REGAL_CALL loader_glBufferRegionEnabled(void)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBufferRegionEnabled, "glBufferRegionEnabled");
  if (_driver.glBufferRegionEnabled) {
    return _driver.glBufferRegionEnabled();
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glBufferRegionEnabled)();
}

static void REGAL_CALL loader_glDeleteBufferRegion(GLenum region)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDeleteBufferRegion, "glDeleteBufferRegion");
  if (_driver.glDeleteBufferRegion) {
    _driver.glDeleteBufferRegion(region);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDeleteBufferRegion)(region);
}

static void REGAL_CALL loader_glDrawBufferRegion(GLuint region, GLint x, GLint y, GLsizei width, GLsizei height, GLint xDest, GLint yDest)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDrawBufferRegion, "glDrawBufferRegion");
  if (_driver.glDrawBufferRegion) {
    _driver.glDrawBufferRegion(region, x, y, width, height, xDest, yDest);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDrawBufferRegion)(region, x, y, width, height, xDest, yDest);
}

static GLuint REGAL_CALL loader_glNewBufferRegion(GLenum region)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNewBufferRegion, "glNewBufferRegion");
  if (_driver.glNewBufferRegion) {
    return _driver.glNewBufferRegion(region);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glNewBufferRegion)(region);
}

static void REGAL_CALL loader_glReadBufferRegion(GLuint region, GLint x, GLint y, GLsizei width, GLsizei height)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glReadBufferRegion, "glReadBufferRegion");
  if (_driver.glReadBufferRegion) {
    _driver.glReadBufferRegion(region, x, y, width, height);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glReadBufferRegion)(region, x, y, width, height);
}

// GL_MESA_resize_buffers

static void REGAL_CALL loader_glResizeBuffersMESA(void)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glResizeBuffersMESA, "glResizeBuffersMESA");
  if (_driver.glResizeBuffersMESA) {
    _driver.glResizeBuffersMESA();
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glResizeBuffersMESA)();
}

// GL_MESA_window_pos

static void REGAL_CALL loader_glWindowPos2dMESA(GLdouble x, GLdouble y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos2dMESA, "glWindowPos2dMESA");
  if (_driver.glWindowPos2dMESA) {
    _driver.glWindowPos2dMESA(x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos2dMESA)(x, y);
}

static void REGAL_CALL loader_glWindowPos2dvMESA(const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos2dvMESA, "glWindowPos2dvMESA");
  if (_driver.glWindowPos2dvMESA) {
    _driver.glWindowPos2dvMESA(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos2dvMESA)(v);
}

static void REGAL_CALL loader_glWindowPos2fMESA(GLfloat x, GLfloat y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos2fMESA, "glWindowPos2fMESA");
  if (_driver.glWindowPos2fMESA) {
    _driver.glWindowPos2fMESA(x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos2fMESA)(x, y);
}

static void REGAL_CALL loader_glWindowPos2fvMESA(const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos2fvMESA, "glWindowPos2fvMESA");
  if (_driver.glWindowPos2fvMESA) {
    _driver.glWindowPos2fvMESA(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos2fvMESA)(v);
}

static void REGAL_CALL loader_glWindowPos2iMESA(GLint x, GLint y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos2iMESA, "glWindowPos2iMESA");
  if (_driver.glWindowPos2iMESA) {
    _driver.glWindowPos2iMESA(x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos2iMESA)(x, y);
}

static void REGAL_CALL loader_glWindowPos2ivMESA(const GLint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos2ivMESA, "glWindowPos2ivMESA");
  if (_driver.glWindowPos2ivMESA) {
    _driver.glWindowPos2ivMESA(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos2ivMESA)(v);
}

static void REGAL_CALL loader_glWindowPos2sMESA(GLshort x, GLshort y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos2sMESA, "glWindowPos2sMESA");
  if (_driver.glWindowPos2sMESA) {
    _driver.glWindowPos2sMESA(x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos2sMESA)(x, y);
}

static void REGAL_CALL loader_glWindowPos2svMESA(const GLshort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos2svMESA, "glWindowPos2svMESA");
  if (_driver.glWindowPos2svMESA) {
    _driver.glWindowPos2svMESA(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos2svMESA)(v);
}

static void REGAL_CALL loader_glWindowPos3dMESA(GLdouble x, GLdouble y, GLdouble z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos3dMESA, "glWindowPos3dMESA");
  if (_driver.glWindowPos3dMESA) {
    _driver.glWindowPos3dMESA(x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos3dMESA)(x, y, z);
}

static void REGAL_CALL loader_glWindowPos3dvMESA(const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos3dvMESA, "glWindowPos3dvMESA");
  if (_driver.glWindowPos3dvMESA) {
    _driver.glWindowPos3dvMESA(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos3dvMESA)(v);
}

static void REGAL_CALL loader_glWindowPos3fMESA(GLfloat x, GLfloat y, GLfloat z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos3fMESA, "glWindowPos3fMESA");
  if (_driver.glWindowPos3fMESA) {
    _driver.glWindowPos3fMESA(x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos3fMESA)(x, y, z);
}

static void REGAL_CALL loader_glWindowPos3fvMESA(const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos3fvMESA, "glWindowPos3fvMESA");
  if (_driver.glWindowPos3fvMESA) {
    _driver.glWindowPos3fvMESA(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos3fvMESA)(v);
}

static void REGAL_CALL loader_glWindowPos3iMESA(GLint x, GLint y, GLint z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos3iMESA, "glWindowPos3iMESA");
  if (_driver.glWindowPos3iMESA) {
    _driver.glWindowPos3iMESA(x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos3iMESA)(x, y, z);
}

static void REGAL_CALL loader_glWindowPos3ivMESA(const GLint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos3ivMESA, "glWindowPos3ivMESA");
  if (_driver.glWindowPos3ivMESA) {
    _driver.glWindowPos3ivMESA(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos3ivMESA)(v);
}

static void REGAL_CALL loader_glWindowPos3sMESA(GLshort x, GLshort y, GLshort z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos3sMESA, "glWindowPos3sMESA");
  if (_driver.glWindowPos3sMESA) {
    _driver.glWindowPos3sMESA(x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos3sMESA)(x, y, z);
}

static void REGAL_CALL loader_glWindowPos3svMESA(const GLshort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos3svMESA, "glWindowPos3svMESA");
  if (_driver.glWindowPos3svMESA) {
    _driver.glWindowPos3svMESA(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos3svMESA)(v);
}

static void REGAL_CALL loader_glWindowPos4dMESA(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos4dMESA, "glWindowPos4dMESA");
  if (_driver.glWindowPos4dMESA) {
    _driver.glWindowPos4dMESA(x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos4dMESA)(x, y, z, w);
}

static void REGAL_CALL loader_glWindowPos4dvMESA(const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos4dvMESA, "glWindowPos4dvMESA");
  if (_driver.glWindowPos4dvMESA) {
    _driver.glWindowPos4dvMESA(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos4dvMESA)(v);
}

static void REGAL_CALL loader_glWindowPos4fMESA(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos4fMESA, "glWindowPos4fMESA");
  if (_driver.glWindowPos4fMESA) {
    _driver.glWindowPos4fMESA(x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos4fMESA)(x, y, z, w);
}

static void REGAL_CALL loader_glWindowPos4fvMESA(const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos4fvMESA, "glWindowPos4fvMESA");
  if (_driver.glWindowPos4fvMESA) {
    _driver.glWindowPos4fvMESA(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos4fvMESA)(v);
}

static void REGAL_CALL loader_glWindowPos4iMESA(GLint x, GLint y, GLint z, GLint w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos4iMESA, "glWindowPos4iMESA");
  if (_driver.glWindowPos4iMESA) {
    _driver.glWindowPos4iMESA(x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos4iMESA)(x, y, z, w);
}

static void REGAL_CALL loader_glWindowPos4ivMESA(const GLint *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos4ivMESA, "glWindowPos4ivMESA");
  if (_driver.glWindowPos4ivMESA) {
    _driver.glWindowPos4ivMESA(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos4ivMESA)(v);
}

static void REGAL_CALL loader_glWindowPos4sMESA(GLshort x, GLshort y, GLshort z, GLshort w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos4sMESA, "glWindowPos4sMESA");
  if (_driver.glWindowPos4sMESA) {
    _driver.glWindowPos4sMESA(x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos4sMESA)(x, y, z, w);
}

static void REGAL_CALL loader_glWindowPos4svMESA(const GLshort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWindowPos4svMESA, "glWindowPos4svMESA");
  if (_driver.glWindowPos4svMESA) {
    _driver.glWindowPos4svMESA(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWindowPos4svMESA)(v);
}

// GL_NVX_conditional_render

static void REGAL_CALL loader_glBeginConditionalRenderNVX(GLuint id)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBeginConditionalRenderNVX, "glBeginConditionalRenderNVX");
  if (_driver.glBeginConditionalRenderNVX) {
    _driver.glBeginConditionalRenderNVX(id);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBeginConditionalRenderNVX)(id);
}

static void REGAL_CALL loader_glEndConditionalRenderNVX(void)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glEndConditionalRenderNVX, "glEndConditionalRenderNVX");
  if (_driver.glEndConditionalRenderNVX) {
    _driver.glEndConditionalRenderNVX();
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glEndConditionalRenderNVX)();
}

// GL_NV_bindless_texture

static GLuint64 REGAL_CALL loader_glGetImageHandleNV(GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetImageHandleNV, "glGetImageHandleNV");
  if (_driver.glGetImageHandleNV) {
    return _driver.glGetImageHandleNV(texture, level, layered, layer, format);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glGetImageHandleNV)(texture, level, layered, layer, format);
}

static GLuint64 REGAL_CALL loader_glGetTextureHandleNV(GLuint texture)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetTextureHandleNV, "glGetTextureHandleNV");
  if (_driver.glGetTextureHandleNV) {
    return _driver.glGetTextureHandleNV(texture);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glGetTextureHandleNV)(texture);
}

static GLuint64 REGAL_CALL loader_glGetTextureSamplerHandleNV(GLuint texture, GLuint sampler)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetTextureSamplerHandleNV, "glGetTextureSamplerHandleNV");
  if (_driver.glGetTextureSamplerHandleNV) {
    return _driver.glGetTextureSamplerHandleNV(texture, sampler);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glGetTextureSamplerHandleNV)(texture, sampler);
}

static GLboolean REGAL_CALL loader_glIsImageHandleResidentNV(GLuint64 handle)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIsImageHandleResidentNV, "glIsImageHandleResidentNV");
  if (_driver.glIsImageHandleResidentNV) {
    return _driver.glIsImageHandleResidentNV(handle);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glIsImageHandleResidentNV)(handle);
}

static GLboolean REGAL_CALL loader_glIsTextureHandleResidentNV(GLuint64 handle)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIsTextureHandleResidentNV, "glIsTextureHandleResidentNV");
  if (_driver.glIsTextureHandleResidentNV) {
    return _driver.glIsTextureHandleResidentNV(handle);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glIsTextureHandleResidentNV)(handle);
}

static void REGAL_CALL loader_glMakeImageHandleNonResidentNV(GLuint64 handle)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMakeImageHandleNonResidentNV, "glMakeImageHandleNonResidentNV");
  if (_driver.glMakeImageHandleNonResidentNV) {
    _driver.glMakeImageHandleNonResidentNV(handle);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMakeImageHandleNonResidentNV)(handle);
}

static void REGAL_CALL loader_glMakeImageHandleResidentNV(GLuint64 handle, GLenum access)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMakeImageHandleResidentNV, "glMakeImageHandleResidentNV");
  if (_driver.glMakeImageHandleResidentNV) {
    _driver.glMakeImageHandleResidentNV(handle, access);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMakeImageHandleResidentNV)(handle, access);
}

static void REGAL_CALL loader_glMakeTextureHandleNonResidentNV(GLuint64 handle)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMakeTextureHandleNonResidentNV, "glMakeTextureHandleNonResidentNV");
  if (_driver.glMakeTextureHandleNonResidentNV) {
    _driver.glMakeTextureHandleNonResidentNV(handle);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMakeTextureHandleNonResidentNV)(handle);
}

static void REGAL_CALL loader_glMakeTextureHandleResidentNV(GLuint64 handle)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMakeTextureHandleResidentNV, "glMakeTextureHandleResidentNV");
  if (_driver.glMakeTextureHandleResidentNV) {
    _driver.glMakeTextureHandleResidentNV(handle);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMakeTextureHandleResidentNV)(handle);
}

static void REGAL_CALL loader_glProgramUniformHandleui64NV(GLuint program, GLint location, GLuint64 value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniformHandleui64NV, "glProgramUniformHandleui64NV");
  if (_driver.glProgramUniformHandleui64NV) {
    _driver.glProgramUniformHandleui64NV(program, location, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniformHandleui64NV)(program, location, value);
}

static void REGAL_CALL loader_glProgramUniformHandleui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64 *values)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniformHandleui64vNV, "glProgramUniformHandleui64vNV");
  if (_driver.glProgramUniformHandleui64vNV) {
    _driver.glProgramUniformHandleui64vNV(program, location, count, values);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniformHandleui64vNV)(program, location, count, values);
}

static void REGAL_CALL loader_glUniformHandleui64NV(GLint location, GLuint64 value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniformHandleui64NV, "glUniformHandleui64NV");
  if (_driver.glUniformHandleui64NV) {
    _driver.glUniformHandleui64NV(location, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniformHandleui64NV)(location, value);
}

static void REGAL_CALL loader_glUniformHandleui64vNV(GLint location, GLsizei count, const GLuint64 *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniformHandleui64vNV, "glUniformHandleui64vNV");
  if (_driver.glUniformHandleui64vNV) {
    _driver.glUniformHandleui64vNV(location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniformHandleui64vNV)(location, count, value);
}

// GL_NV_conditional_render

static void REGAL_CALL loader_glBeginConditionalRenderNV(GLuint id, GLenum mode)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBeginConditionalRenderNV, "glBeginConditionalRenderNV");
  if (_driver.glBeginConditionalRenderNV) {
    _driver.glBeginConditionalRenderNV(id, mode);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBeginConditionalRenderNV)(id, mode);
}

static void REGAL_CALL loader_glEndConditionalRenderNV(void)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glEndConditionalRenderNV, "glEndConditionalRenderNV");
  if (_driver.glEndConditionalRenderNV) {
    _driver.glEndConditionalRenderNV();
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glEndConditionalRenderNV)();
}

// GL_NV_copy_image

static void REGAL_CALL loader_glCopyImageSubDataNV(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCopyImageSubDataNV, "glCopyImageSubDataNV");
  if (_driver.glCopyImageSubDataNV) {
    _driver.glCopyImageSubDataNV(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCopyImageSubDataNV)(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
}

// GL_NV_coverage_sample

static void REGAL_CALL loader_glCoverageMaskNV(GLboolean mask)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCoverageMaskNV, "glCoverageMaskNV");
  if (_driver.glCoverageMaskNV) {
    _driver.glCoverageMaskNV(mask);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCoverageMaskNV)(mask);
}

static void REGAL_CALL loader_glCoverageOperationNV(GLenum operation)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCoverageOperationNV, "glCoverageOperationNV");
  if (_driver.glCoverageOperationNV) {
    _driver.glCoverageOperationNV(operation);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCoverageOperationNV)(operation);
}

// GL_NV_depth_buffer_float

static void REGAL_CALL loader_glClearDepthdNV(GLdouble depth)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glClearDepthdNV, "glClearDepthdNV");
  if (_driver.glClearDepthdNV) {
    _driver.glClearDepthdNV(depth);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glClearDepthdNV)(depth);
}

static void REGAL_CALL loader_glDepthBoundsdNV(GLdouble zmin, GLdouble zmax)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDepthBoundsdNV, "glDepthBoundsdNV");
  if (_driver.glDepthBoundsdNV) {
    _driver.glDepthBoundsdNV(zmin, zmax);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDepthBoundsdNV)(zmin, zmax);
}

static void REGAL_CALL loader_glDepthRangedNV(GLdouble zNear, GLdouble zFar)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDepthRangedNV, "glDepthRangedNV");
  if (_driver.glDepthRangedNV) {
    _driver.glDepthRangedNV(zNear, zFar);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDepthRangedNV)(zNear, zFar);
}

// GL_NV_draw_buffers

static void REGAL_CALL loader_glDrawBuffersNV(GLsizei n, const GLenum *bufs)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDrawBuffersNV, "glDrawBuffersNV");
  if (_driver.glDrawBuffersNV) {
    _driver.glDrawBuffersNV(n, bufs);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDrawBuffersNV)(n, bufs);
}

// GL_NV_evaluators

static void REGAL_CALL loader_glEvalMapsNV(GLenum target, GLenum mode)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glEvalMapsNV, "glEvalMapsNV");
  if (_driver.glEvalMapsNV) {
    _driver.glEvalMapsNV(target, mode);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glEvalMapsNV)(target, mode);
}

static void REGAL_CALL loader_glGetMapAttribParameterfvNV(GLenum target, GLuint index, GLenum pname, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetMapAttribParameterfvNV, "glGetMapAttribParameterfvNV");
  if (_driver.glGetMapAttribParameterfvNV) {
    _driver.glGetMapAttribParameterfvNV(target, index, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetMapAttribParameterfvNV)(target, index, pname, params);
}

static void REGAL_CALL loader_glGetMapAttribParameterivNV(GLenum target, GLuint index, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetMapAttribParameterivNV, "glGetMapAttribParameterivNV");
  if (_driver.glGetMapAttribParameterivNV) {
    _driver.glGetMapAttribParameterivNV(target, index, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetMapAttribParameterivNV)(target, index, pname, params);
}

static void REGAL_CALL loader_glGetMapControlPointsNV(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, GLvoid *points)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetMapControlPointsNV, "glGetMapControlPointsNV");
  if (_driver.glGetMapControlPointsNV) {
    _driver.glGetMapControlPointsNV(target, index, type, ustride, vstride, packed, points);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetMapControlPointsNV)(target, index, type, ustride, vstride, packed, points);
}

static void REGAL_CALL loader_glGetMapParameterfvNV(GLenum target, GLenum pname, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetMapParameterfvNV, "glGetMapParameterfvNV");
  if (_driver.glGetMapParameterfvNV) {
    _driver.glGetMapParameterfvNV(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetMapParameterfvNV)(target, pname, params);
}

static void REGAL_CALL loader_glGetMapParameterivNV(GLenum target, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetMapParameterivNV, "glGetMapParameterivNV");
  if (_driver.glGetMapParameterivNV) {
    _driver.glGetMapParameterivNV(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetMapParameterivNV)(target, pname, params);
}

static void REGAL_CALL loader_glMapControlPointsNV(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const GLvoid *points)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMapControlPointsNV, "glMapControlPointsNV");
  if (_driver.glMapControlPointsNV) {
    _driver.glMapControlPointsNV(target, index, type, ustride, vstride, uorder, vorder, packed, points);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMapControlPointsNV)(target, index, type, ustride, vstride, uorder, vorder, packed, points);
}

static void REGAL_CALL loader_glMapParameterfvNV(GLenum target, GLenum pname, const GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMapParameterfvNV, "glMapParameterfvNV");
  if (_driver.glMapParameterfvNV) {
    _driver.glMapParameterfvNV(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMapParameterfvNV)(target, pname, params);
}

static void REGAL_CALL loader_glMapParameterivNV(GLenum target, GLenum pname, const GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMapParameterivNV, "glMapParameterivNV");
  if (_driver.glMapParameterivNV) {
    _driver.glMapParameterivNV(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMapParameterivNV)(target, pname, params);
}

// GL_NV_explicit_multisample

static void REGAL_CALL loader_glGetMultisamplefvNV(GLenum pname, GLuint index, GLfloat *val)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetMultisamplefvNV, "glGetMultisamplefvNV");
  if (_driver.glGetMultisamplefvNV) {
    _driver.glGetMultisamplefvNV(pname, index, val);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetMultisamplefvNV)(pname, index, val);
}

static void REGAL_CALL loader_glSampleMaskIndexedNV(GLuint index, GLbitfield mask)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSampleMaskIndexedNV, "glSampleMaskIndexedNV");
  if (_driver.glSampleMaskIndexedNV) {
    _driver.glSampleMaskIndexedNV(index, mask);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSampleMaskIndexedNV)(index, mask);
}

static void REGAL_CALL loader_glTexRenderbufferNV(GLenum target, GLuint renderbuffer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexRenderbufferNV, "glTexRenderbufferNV");
  if (_driver.glTexRenderbufferNV) {
    _driver.glTexRenderbufferNV(target, renderbuffer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexRenderbufferNV)(target, renderbuffer);
}

// GL_NV_fence

static void REGAL_CALL loader_glDeleteFencesNV(GLsizei n, const GLuint *fences)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDeleteFencesNV, "glDeleteFencesNV");
  if (_driver.glDeleteFencesNV) {
    _driver.glDeleteFencesNV(n, fences);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDeleteFencesNV)(n, fences);
}

static void REGAL_CALL loader_glFinishFenceNV(GLuint fence)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFinishFenceNV, "glFinishFenceNV");
  if (_driver.glFinishFenceNV) {
    _driver.glFinishFenceNV(fence);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFinishFenceNV)(fence);
}

static void REGAL_CALL loader_glGenFencesNV(GLsizei n, GLuint *fences)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGenFencesNV, "glGenFencesNV");
  if (_driver.glGenFencesNV) {
    _driver.glGenFencesNV(n, fences);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGenFencesNV)(n, fences);
}

static void REGAL_CALL loader_glGetFenceivNV(GLuint fence, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetFenceivNV, "glGetFenceivNV");
  if (_driver.glGetFenceivNV) {
    _driver.glGetFenceivNV(fence, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetFenceivNV)(fence, pname, params);
}

static GLboolean REGAL_CALL loader_glIsFenceNV(GLuint fence)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIsFenceNV, "glIsFenceNV");
  if (_driver.glIsFenceNV) {
    return _driver.glIsFenceNV(fence);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glIsFenceNV)(fence);
}

static void REGAL_CALL loader_glSetFenceNV(GLuint fence, GLenum condition)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSetFenceNV, "glSetFenceNV");
  if (_driver.glSetFenceNV) {
    _driver.glSetFenceNV(fence, condition);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSetFenceNV)(fence, condition);
}

static GLboolean REGAL_CALL loader_glTestFenceNV(GLuint fence)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTestFenceNV, "glTestFenceNV");
  if (_driver.glTestFenceNV) {
    return _driver.glTestFenceNV(fence);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glTestFenceNV)(fence);
}

// GL_NV_fragment_program

static void REGAL_CALL loader_glGetProgramNamedParameterdvNV(GLuint id, GLsizei len, const GLubyte *name, GLdouble *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetProgramNamedParameterdvNV, "glGetProgramNamedParameterdvNV");
  if (_driver.glGetProgramNamedParameterdvNV) {
    _driver.glGetProgramNamedParameterdvNV(id, len, name, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetProgramNamedParameterdvNV)(id, len, name, params);
}

static void REGAL_CALL loader_glGetProgramNamedParameterfvNV(GLuint id, GLsizei len, const GLubyte *name, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetProgramNamedParameterfvNV, "glGetProgramNamedParameterfvNV");
  if (_driver.glGetProgramNamedParameterfvNV) {
    _driver.glGetProgramNamedParameterfvNV(id, len, name, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetProgramNamedParameterfvNV)(id, len, name, params);
}

static void REGAL_CALL loader_glProgramNamedParameter4dNV(GLuint id, GLsizei len, const GLubyte *name, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramNamedParameter4dNV, "glProgramNamedParameter4dNV");
  if (_driver.glProgramNamedParameter4dNV) {
    _driver.glProgramNamedParameter4dNV(id, len, name, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramNamedParameter4dNV)(id, len, name, x, y, z, w);
}

static void REGAL_CALL loader_glProgramNamedParameter4dvNV(GLuint id, GLsizei len, const GLubyte *name, const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramNamedParameter4dvNV, "glProgramNamedParameter4dvNV");
  if (_driver.glProgramNamedParameter4dvNV) {
    _driver.glProgramNamedParameter4dvNV(id, len, name, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramNamedParameter4dvNV)(id, len, name, v);
}

static void REGAL_CALL loader_glProgramNamedParameter4fNV(GLuint id, GLsizei len, const GLubyte *name, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramNamedParameter4fNV, "glProgramNamedParameter4fNV");
  if (_driver.glProgramNamedParameter4fNV) {
    _driver.glProgramNamedParameter4fNV(id, len, name, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramNamedParameter4fNV)(id, len, name, x, y, z, w);
}

static void REGAL_CALL loader_glProgramNamedParameter4fvNV(GLuint id, GLsizei len, const GLubyte *name, const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramNamedParameter4fvNV, "glProgramNamedParameter4fvNV");
  if (_driver.glProgramNamedParameter4fvNV) {
    _driver.glProgramNamedParameter4fvNV(id, len, name, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramNamedParameter4fvNV)(id, len, name, v);
}

// GL_NV_framebuffer_multisample_coverage

static void REGAL_CALL loader_glRenderbufferStorageMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glRenderbufferStorageMultisampleCoverageNV, "glRenderbufferStorageMultisampleCoverageNV");
  if (_driver.glRenderbufferStorageMultisampleCoverageNV) {
    _driver.glRenderbufferStorageMultisampleCoverageNV(target, coverageSamples, colorSamples, internalformat, width, height);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glRenderbufferStorageMultisampleCoverageNV)(target, coverageSamples, colorSamples, internalformat, width, height);
}

// GL_NV_geometry_program4

static void REGAL_CALL loader_glProgramVertexLimitNV(GLenum target, GLint limit)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramVertexLimitNV, "glProgramVertexLimitNV");
  if (_driver.glProgramVertexLimitNV) {
    _driver.glProgramVertexLimitNV(target, limit);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramVertexLimitNV)(target, limit);
}

// GL_NV_gpu_program4

static void REGAL_CALL loader_glGetProgramEnvParameterIivNV(GLenum target, GLuint index, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetProgramEnvParameterIivNV, "glGetProgramEnvParameterIivNV");
  if (_driver.glGetProgramEnvParameterIivNV) {
    _driver.glGetProgramEnvParameterIivNV(target, index, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetProgramEnvParameterIivNV)(target, index, params);
}

static void REGAL_CALL loader_glGetProgramEnvParameterIuivNV(GLenum target, GLuint index, GLuint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetProgramEnvParameterIuivNV, "glGetProgramEnvParameterIuivNV");
  if (_driver.glGetProgramEnvParameterIuivNV) {
    _driver.glGetProgramEnvParameterIuivNV(target, index, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetProgramEnvParameterIuivNV)(target, index, params);
}

static void REGAL_CALL loader_glGetProgramLocalParameterIivNV(GLenum target, GLuint index, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetProgramLocalParameterIivNV, "glGetProgramLocalParameterIivNV");
  if (_driver.glGetProgramLocalParameterIivNV) {
    _driver.glGetProgramLocalParameterIivNV(target, index, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetProgramLocalParameterIivNV)(target, index, params);
}

static void REGAL_CALL loader_glGetProgramLocalParameterIuivNV(GLenum target, GLuint index, GLuint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetProgramLocalParameterIuivNV, "glGetProgramLocalParameterIuivNV");
  if (_driver.glGetProgramLocalParameterIuivNV) {
    _driver.glGetProgramLocalParameterIuivNV(target, index, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetProgramLocalParameterIuivNV)(target, index, params);
}

static void REGAL_CALL loader_glProgramEnvParameterI4iNV(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramEnvParameterI4iNV, "glProgramEnvParameterI4iNV");
  if (_driver.glProgramEnvParameterI4iNV) {
    _driver.glProgramEnvParameterI4iNV(target, index, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramEnvParameterI4iNV)(target, index, x, y, z, w);
}

static void REGAL_CALL loader_glProgramEnvParameterI4ivNV(GLenum target, GLuint index, const GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramEnvParameterI4ivNV, "glProgramEnvParameterI4ivNV");
  if (_driver.glProgramEnvParameterI4ivNV) {
    _driver.glProgramEnvParameterI4ivNV(target, index, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramEnvParameterI4ivNV)(target, index, params);
}

static void REGAL_CALL loader_glProgramEnvParameterI4uiNV(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramEnvParameterI4uiNV, "glProgramEnvParameterI4uiNV");
  if (_driver.glProgramEnvParameterI4uiNV) {
    _driver.glProgramEnvParameterI4uiNV(target, index, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramEnvParameterI4uiNV)(target, index, x, y, z, w);
}

static void REGAL_CALL loader_glProgramEnvParameterI4uivNV(GLenum target, GLuint index, const GLuint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramEnvParameterI4uivNV, "glProgramEnvParameterI4uivNV");
  if (_driver.glProgramEnvParameterI4uivNV) {
    _driver.glProgramEnvParameterI4uivNV(target, index, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramEnvParameterI4uivNV)(target, index, params);
}

static void REGAL_CALL loader_glProgramEnvParametersI4ivNV(GLenum target, GLuint index, GLsizei count, const GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramEnvParametersI4ivNV, "glProgramEnvParametersI4ivNV");
  if (_driver.glProgramEnvParametersI4ivNV) {
    _driver.glProgramEnvParametersI4ivNV(target, index, count, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramEnvParametersI4ivNV)(target, index, count, params);
}

static void REGAL_CALL loader_glProgramEnvParametersI4uivNV(GLenum target, GLuint index, GLsizei count, const GLuint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramEnvParametersI4uivNV, "glProgramEnvParametersI4uivNV");
  if (_driver.glProgramEnvParametersI4uivNV) {
    _driver.glProgramEnvParametersI4uivNV(target, index, count, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramEnvParametersI4uivNV)(target, index, count, params);
}

static void REGAL_CALL loader_glProgramLocalParameterI4iNV(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramLocalParameterI4iNV, "glProgramLocalParameterI4iNV");
  if (_driver.glProgramLocalParameterI4iNV) {
    _driver.glProgramLocalParameterI4iNV(target, index, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramLocalParameterI4iNV)(target, index, x, y, z, w);
}

static void REGAL_CALL loader_glProgramLocalParameterI4ivNV(GLenum target, GLuint index, const GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramLocalParameterI4ivNV, "glProgramLocalParameterI4ivNV");
  if (_driver.glProgramLocalParameterI4ivNV) {
    _driver.glProgramLocalParameterI4ivNV(target, index, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramLocalParameterI4ivNV)(target, index, params);
}

static void REGAL_CALL loader_glProgramLocalParameterI4uiNV(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramLocalParameterI4uiNV, "glProgramLocalParameterI4uiNV");
  if (_driver.glProgramLocalParameterI4uiNV) {
    _driver.glProgramLocalParameterI4uiNV(target, index, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramLocalParameterI4uiNV)(target, index, x, y, z, w);
}

static void REGAL_CALL loader_glProgramLocalParameterI4uivNV(GLenum target, GLuint index, const GLuint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramLocalParameterI4uivNV, "glProgramLocalParameterI4uivNV");
  if (_driver.glProgramLocalParameterI4uivNV) {
    _driver.glProgramLocalParameterI4uivNV(target, index, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramLocalParameterI4uivNV)(target, index, params);
}

static void REGAL_CALL loader_glProgramLocalParametersI4ivNV(GLenum target, GLuint index, GLsizei count, const GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramLocalParametersI4ivNV, "glProgramLocalParametersI4ivNV");
  if (_driver.glProgramLocalParametersI4ivNV) {
    _driver.glProgramLocalParametersI4ivNV(target, index, count, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramLocalParametersI4ivNV)(target, index, count, params);
}

static void REGAL_CALL loader_glProgramLocalParametersI4uivNV(GLenum target, GLuint index, GLsizei count, const GLuint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramLocalParametersI4uivNV, "glProgramLocalParametersI4uivNV");
  if (_driver.glProgramLocalParametersI4uivNV) {
    _driver.glProgramLocalParametersI4uivNV(target, index, count, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramLocalParametersI4uivNV)(target, index, count, params);
}

// GL_NV_gpu_shader5

static void REGAL_CALL loader_glGetUniformi64vNV(GLuint program, GLint location, GLint64EXT *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetUniformi64vNV, "glGetUniformi64vNV");
  if (_driver.glGetUniformi64vNV) {
    _driver.glGetUniformi64vNV(program, location, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetUniformi64vNV)(program, location, params);
}

static void REGAL_CALL loader_glProgramUniform1i64NV(GLuint program, GLint location, GLint64EXT x)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform1i64NV, "glProgramUniform1i64NV");
  if (_driver.glProgramUniform1i64NV) {
    _driver.glProgramUniform1i64NV(program, location, x);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform1i64NV)(program, location, x);
}

static void REGAL_CALL loader_glProgramUniform1i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform1i64vNV, "glProgramUniform1i64vNV");
  if (_driver.glProgramUniform1i64vNV) {
    _driver.glProgramUniform1i64vNV(program, location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform1i64vNV)(program, location, count, value);
}

static void REGAL_CALL loader_glProgramUniform1ui64NV(GLuint program, GLint location, GLuint64EXT x)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform1ui64NV, "glProgramUniform1ui64NV");
  if (_driver.glProgramUniform1ui64NV) {
    _driver.glProgramUniform1ui64NV(program, location, x);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform1ui64NV)(program, location, x);
}

static void REGAL_CALL loader_glProgramUniform1ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform1ui64vNV, "glProgramUniform1ui64vNV");
  if (_driver.glProgramUniform1ui64vNV) {
    _driver.glProgramUniform1ui64vNV(program, location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform1ui64vNV)(program, location, count, value);
}

static void REGAL_CALL loader_glProgramUniform2i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform2i64NV, "glProgramUniform2i64NV");
  if (_driver.glProgramUniform2i64NV) {
    _driver.glProgramUniform2i64NV(program, location, x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform2i64NV)(program, location, x, y);
}

static void REGAL_CALL loader_glProgramUniform2i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform2i64vNV, "glProgramUniform2i64vNV");
  if (_driver.glProgramUniform2i64vNV) {
    _driver.glProgramUniform2i64vNV(program, location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform2i64vNV)(program, location, count, value);
}

static void REGAL_CALL loader_glProgramUniform2ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform2ui64NV, "glProgramUniform2ui64NV");
  if (_driver.glProgramUniform2ui64NV) {
    _driver.glProgramUniform2ui64NV(program, location, x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform2ui64NV)(program, location, x, y);
}

static void REGAL_CALL loader_glProgramUniform2ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform2ui64vNV, "glProgramUniform2ui64vNV");
  if (_driver.glProgramUniform2ui64vNV) {
    _driver.glProgramUniform2ui64vNV(program, location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform2ui64vNV)(program, location, count, value);
}

static void REGAL_CALL loader_glProgramUniform3i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform3i64NV, "glProgramUniform3i64NV");
  if (_driver.glProgramUniform3i64NV) {
    _driver.glProgramUniform3i64NV(program, location, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform3i64NV)(program, location, x, y, z);
}

static void REGAL_CALL loader_glProgramUniform3i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform3i64vNV, "glProgramUniform3i64vNV");
  if (_driver.glProgramUniform3i64vNV) {
    _driver.glProgramUniform3i64vNV(program, location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform3i64vNV)(program, location, count, value);
}

static void REGAL_CALL loader_glProgramUniform3ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform3ui64NV, "glProgramUniform3ui64NV");
  if (_driver.glProgramUniform3ui64NV) {
    _driver.glProgramUniform3ui64NV(program, location, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform3ui64NV)(program, location, x, y, z);
}

static void REGAL_CALL loader_glProgramUniform3ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform3ui64vNV, "glProgramUniform3ui64vNV");
  if (_driver.glProgramUniform3ui64vNV) {
    _driver.glProgramUniform3ui64vNV(program, location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform3ui64vNV)(program, location, count, value);
}

static void REGAL_CALL loader_glProgramUniform4i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform4i64NV, "glProgramUniform4i64NV");
  if (_driver.glProgramUniform4i64NV) {
    _driver.glProgramUniform4i64NV(program, location, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform4i64NV)(program, location, x, y, z, w);
}

static void REGAL_CALL loader_glProgramUniform4i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform4i64vNV, "glProgramUniform4i64vNV");
  if (_driver.glProgramUniform4i64vNV) {
    _driver.glProgramUniform4i64vNV(program, location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform4i64vNV)(program, location, count, value);
}

static void REGAL_CALL loader_glProgramUniform4ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform4ui64NV, "glProgramUniform4ui64NV");
  if (_driver.glProgramUniform4ui64NV) {
    _driver.glProgramUniform4ui64NV(program, location, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform4ui64NV)(program, location, x, y, z, w);
}

static void REGAL_CALL loader_glProgramUniform4ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniform4ui64vNV, "glProgramUniform4ui64vNV");
  if (_driver.glProgramUniform4ui64vNV) {
    _driver.glProgramUniform4ui64vNV(program, location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniform4ui64vNV)(program, location, count, value);
}

static void REGAL_CALL loader_glUniform1i64NV(GLint location, GLint64EXT x)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform1i64NV, "glUniform1i64NV");
  if (_driver.glUniform1i64NV) {
    _driver.glUniform1i64NV(location, x);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform1i64NV)(location, x);
}

static void REGAL_CALL loader_glUniform1i64vNV(GLint location, GLsizei count, const GLint64EXT *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform1i64vNV, "glUniform1i64vNV");
  if (_driver.glUniform1i64vNV) {
    _driver.glUniform1i64vNV(location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform1i64vNV)(location, count, value);
}

static void REGAL_CALL loader_glUniform1ui64NV(GLint location, GLuint64EXT x)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform1ui64NV, "glUniform1ui64NV");
  if (_driver.glUniform1ui64NV) {
    _driver.glUniform1ui64NV(location, x);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform1ui64NV)(location, x);
}

static void REGAL_CALL loader_glUniform1ui64vNV(GLint location, GLsizei count, const GLuint64EXT *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform1ui64vNV, "glUniform1ui64vNV");
  if (_driver.glUniform1ui64vNV) {
    _driver.glUniform1ui64vNV(location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform1ui64vNV)(location, count, value);
}

static void REGAL_CALL loader_glUniform2i64NV(GLint location, GLint64EXT x, GLint64EXT y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform2i64NV, "glUniform2i64NV");
  if (_driver.glUniform2i64NV) {
    _driver.glUniform2i64NV(location, x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform2i64NV)(location, x, y);
}

static void REGAL_CALL loader_glUniform2i64vNV(GLint location, GLsizei count, const GLint64EXT *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform2i64vNV, "glUniform2i64vNV");
  if (_driver.glUniform2i64vNV) {
    _driver.glUniform2i64vNV(location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform2i64vNV)(location, count, value);
}

static void REGAL_CALL loader_glUniform2ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform2ui64NV, "glUniform2ui64NV");
  if (_driver.glUniform2ui64NV) {
    _driver.glUniform2ui64NV(location, x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform2ui64NV)(location, x, y);
}

static void REGAL_CALL loader_glUniform2ui64vNV(GLint location, GLsizei count, const GLuint64EXT *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform2ui64vNV, "glUniform2ui64vNV");
  if (_driver.glUniform2ui64vNV) {
    _driver.glUniform2ui64vNV(location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform2ui64vNV)(location, count, value);
}

static void REGAL_CALL loader_glUniform3i64NV(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform3i64NV, "glUniform3i64NV");
  if (_driver.glUniform3i64NV) {
    _driver.glUniform3i64NV(location, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform3i64NV)(location, x, y, z);
}

static void REGAL_CALL loader_glUniform3i64vNV(GLint location, GLsizei count, const GLint64EXT *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform3i64vNV, "glUniform3i64vNV");
  if (_driver.glUniform3i64vNV) {
    _driver.glUniform3i64vNV(location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform3i64vNV)(location, count, value);
}

static void REGAL_CALL loader_glUniform3ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform3ui64NV, "glUniform3ui64NV");
  if (_driver.glUniform3ui64NV) {
    _driver.glUniform3ui64NV(location, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform3ui64NV)(location, x, y, z);
}

static void REGAL_CALL loader_glUniform3ui64vNV(GLint location, GLsizei count, const GLuint64EXT *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform3ui64vNV, "glUniform3ui64vNV");
  if (_driver.glUniform3ui64vNV) {
    _driver.glUniform3ui64vNV(location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform3ui64vNV)(location, count, value);
}

static void REGAL_CALL loader_glUniform4i64NV(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform4i64NV, "glUniform4i64NV");
  if (_driver.glUniform4i64NV) {
    _driver.glUniform4i64NV(location, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform4i64NV)(location, x, y, z, w);
}

static void REGAL_CALL loader_glUniform4i64vNV(GLint location, GLsizei count, const GLint64EXT *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform4i64vNV, "glUniform4i64vNV");
  if (_driver.glUniform4i64vNV) {
    _driver.glUniform4i64vNV(location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform4i64vNV)(location, count, value);
}

static void REGAL_CALL loader_glUniform4ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform4ui64NV, "glUniform4ui64NV");
  if (_driver.glUniform4ui64NV) {
    _driver.glUniform4ui64NV(location, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform4ui64NV)(location, x, y, z, w);
}

static void REGAL_CALL loader_glUniform4ui64vNV(GLint location, GLsizei count, const GLuint64EXT *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniform4ui64vNV, "glUniform4ui64vNV");
  if (_driver.glUniform4ui64vNV) {
    _driver.glUniform4ui64vNV(location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniform4ui64vNV)(location, count, value);
}

// GL_NV_half_float

static void REGAL_CALL loader_glColor3hNV(GLhalfNV red, GLhalfNV green, GLhalfNV blue)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColor3hNV, "glColor3hNV");
  if (_driver.glColor3hNV) {
    _driver.glColor3hNV(red, green, blue);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColor3hNV)(red, green, blue);
}

static void REGAL_CALL loader_glColor3hvNV(const GLhalfNV *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColor3hvNV, "glColor3hvNV");
  if (_driver.glColor3hvNV) {
    _driver.glColor3hvNV(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColor3hvNV)(v);
}

static void REGAL_CALL loader_glColor4hNV(GLhalfNV red, GLhalfNV green, GLhalfNV blue, GLhalfNV alpha)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColor4hNV, "glColor4hNV");
  if (_driver.glColor4hNV) {
    _driver.glColor4hNV(red, green, blue, alpha);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColor4hNV)(red, green, blue, alpha);
}

static void REGAL_CALL loader_glColor4hvNV(const GLhalfNV *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColor4hvNV, "glColor4hvNV");
  if (_driver.glColor4hvNV) {
    _driver.glColor4hvNV(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColor4hvNV)(v);
}

static void REGAL_CALL loader_glFogCoordhNV(GLhalfNV coord)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFogCoordhNV, "glFogCoordhNV");
  if (_driver.glFogCoordhNV) {
    _driver.glFogCoordhNV(coord);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFogCoordhNV)(coord);
}

static void REGAL_CALL loader_glFogCoordhvNV(const GLhalfNV *coord)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFogCoordhvNV, "glFogCoordhvNV");
  if (_driver.glFogCoordhvNV) {
    _driver.glFogCoordhvNV(coord);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFogCoordhvNV)(coord);
}

static void REGAL_CALL loader_glMultiTexCoord1hNV(GLenum target, GLhalfNV s)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord1hNV, "glMultiTexCoord1hNV");
  if (_driver.glMultiTexCoord1hNV) {
    _driver.glMultiTexCoord1hNV(target, s);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord1hNV)(target, s);
}

static void REGAL_CALL loader_glMultiTexCoord1hvNV(GLenum target, const GLhalfNV *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord1hvNV, "glMultiTexCoord1hvNV");
  if (_driver.glMultiTexCoord1hvNV) {
    _driver.glMultiTexCoord1hvNV(target, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord1hvNV)(target, v);
}

static void REGAL_CALL loader_glMultiTexCoord2hNV(GLenum target, GLhalfNV s, GLhalfNV t)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord2hNV, "glMultiTexCoord2hNV");
  if (_driver.glMultiTexCoord2hNV) {
    _driver.glMultiTexCoord2hNV(target, s, t);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord2hNV)(target, s, t);
}

static void REGAL_CALL loader_glMultiTexCoord2hvNV(GLenum target, const GLhalfNV *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord2hvNV, "glMultiTexCoord2hvNV");
  if (_driver.glMultiTexCoord2hvNV) {
    _driver.glMultiTexCoord2hvNV(target, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord2hvNV)(target, v);
}

static void REGAL_CALL loader_glMultiTexCoord3hNV(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord3hNV, "glMultiTexCoord3hNV");
  if (_driver.glMultiTexCoord3hNV) {
    _driver.glMultiTexCoord3hNV(target, s, t, r);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord3hNV)(target, s, t, r);
}

static void REGAL_CALL loader_glMultiTexCoord3hvNV(GLenum target, const GLhalfNV *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord3hvNV, "glMultiTexCoord3hvNV");
  if (_driver.glMultiTexCoord3hvNV) {
    _driver.glMultiTexCoord3hvNV(target, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord3hvNV)(target, v);
}

static void REGAL_CALL loader_glMultiTexCoord4hNV(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord4hNV, "glMultiTexCoord4hNV");
  if (_driver.glMultiTexCoord4hNV) {
    _driver.glMultiTexCoord4hNV(target, s, t, r, q);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord4hNV)(target, s, t, r, q);
}

static void REGAL_CALL loader_glMultiTexCoord4hvNV(GLenum target, const GLhalfNV *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMultiTexCoord4hvNV, "glMultiTexCoord4hvNV");
  if (_driver.glMultiTexCoord4hvNV) {
    _driver.glMultiTexCoord4hvNV(target, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMultiTexCoord4hvNV)(target, v);
}

static void REGAL_CALL loader_glNormal3hNV(GLhalfNV nx, GLhalfNV ny, GLhalfNV nz)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNormal3hNV, "glNormal3hNV");
  if (_driver.glNormal3hNV) {
    _driver.glNormal3hNV(nx, ny, nz);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNormal3hNV)(nx, ny, nz);
}

static void REGAL_CALL loader_glNormal3hvNV(const GLhalfNV *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNormal3hvNV, "glNormal3hvNV");
  if (_driver.glNormal3hvNV) {
    _driver.glNormal3hvNV(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNormal3hvNV)(v);
}

static void REGAL_CALL loader_glSecondaryColor3hNV(GLhalfNV red, GLhalfNV green, GLhalfNV blue)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSecondaryColor3hNV, "glSecondaryColor3hNV");
  if (_driver.glSecondaryColor3hNV) {
    _driver.glSecondaryColor3hNV(red, green, blue);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSecondaryColor3hNV)(red, green, blue);
}

static void REGAL_CALL loader_glSecondaryColor3hvNV(const GLhalfNV *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSecondaryColor3hvNV, "glSecondaryColor3hvNV");
  if (_driver.glSecondaryColor3hvNV) {
    _driver.glSecondaryColor3hvNV(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSecondaryColor3hvNV)(v);
}

static void REGAL_CALL loader_glTexCoord1hNV(GLhalfNV s)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord1hNV, "glTexCoord1hNV");
  if (_driver.glTexCoord1hNV) {
    _driver.glTexCoord1hNV(s);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord1hNV)(s);
}

static void REGAL_CALL loader_glTexCoord1hvNV(const GLhalfNV *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord1hvNV, "glTexCoord1hvNV");
  if (_driver.glTexCoord1hvNV) {
    _driver.glTexCoord1hvNV(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord1hvNV)(v);
}

static void REGAL_CALL loader_glTexCoord2hNV(GLhalfNV s, GLhalfNV t)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord2hNV, "glTexCoord2hNV");
  if (_driver.glTexCoord2hNV) {
    _driver.glTexCoord2hNV(s, t);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord2hNV)(s, t);
}

static void REGAL_CALL loader_glTexCoord2hvNV(const GLhalfNV *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord2hvNV, "glTexCoord2hvNV");
  if (_driver.glTexCoord2hvNV) {
    _driver.glTexCoord2hvNV(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord2hvNV)(v);
}

static void REGAL_CALL loader_glTexCoord3hNV(GLhalfNV s, GLhalfNV t, GLhalfNV r)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord3hNV, "glTexCoord3hNV");
  if (_driver.glTexCoord3hNV) {
    _driver.glTexCoord3hNV(s, t, r);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord3hNV)(s, t, r);
}

static void REGAL_CALL loader_glTexCoord3hvNV(const GLhalfNV *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord3hvNV, "glTexCoord3hvNV");
  if (_driver.glTexCoord3hvNV) {
    _driver.glTexCoord3hvNV(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord3hvNV)(v);
}

static void REGAL_CALL loader_glTexCoord4hNV(GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord4hNV, "glTexCoord4hNV");
  if (_driver.glTexCoord4hNV) {
    _driver.glTexCoord4hNV(s, t, r, q);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord4hNV)(s, t, r, q);
}

static void REGAL_CALL loader_glTexCoord4hvNV(const GLhalfNV *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord4hvNV, "glTexCoord4hvNV");
  if (_driver.glTexCoord4hvNV) {
    _driver.glTexCoord4hvNV(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord4hvNV)(v);
}

static void REGAL_CALL loader_glVertex2hNV(GLhalfNV x, GLhalfNV y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertex2hNV, "glVertex2hNV");
  if (_driver.glVertex2hNV) {
    _driver.glVertex2hNV(x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertex2hNV)(x, y);
}

static void REGAL_CALL loader_glVertex2hvNV(const GLhalfNV *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertex2hvNV, "glVertex2hvNV");
  if (_driver.glVertex2hvNV) {
    _driver.glVertex2hvNV(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertex2hvNV)(v);
}

static void REGAL_CALL loader_glVertex3hNV(GLhalfNV x, GLhalfNV y, GLhalfNV z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertex3hNV, "glVertex3hNV");
  if (_driver.glVertex3hNV) {
    _driver.glVertex3hNV(x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertex3hNV)(x, y, z);
}

static void REGAL_CALL loader_glVertex3hvNV(const GLhalfNV *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertex3hvNV, "glVertex3hvNV");
  if (_driver.glVertex3hvNV) {
    _driver.glVertex3hvNV(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertex3hvNV)(v);
}

static void REGAL_CALL loader_glVertex4hNV(GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertex4hNV, "glVertex4hNV");
  if (_driver.glVertex4hNV) {
    _driver.glVertex4hNV(x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertex4hNV)(x, y, z, w);
}

static void REGAL_CALL loader_glVertex4hvNV(const GLhalfNV *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertex4hvNV, "glVertex4hvNV");
  if (_driver.glVertex4hvNV) {
    _driver.glVertex4hvNV(v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertex4hvNV)(v);
}

static void REGAL_CALL loader_glVertexAttrib1hNV(GLuint index, GLhalfNV x)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib1hNV, "glVertexAttrib1hNV");
  if (_driver.glVertexAttrib1hNV) {
    _driver.glVertexAttrib1hNV(index, x);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib1hNV)(index, x);
}

static void REGAL_CALL loader_glVertexAttrib1hvNV(GLuint index, const GLhalfNV *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib1hvNV, "glVertexAttrib1hvNV");
  if (_driver.glVertexAttrib1hvNV) {
    _driver.glVertexAttrib1hvNV(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib1hvNV)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib2hNV(GLuint index, GLhalfNV x, GLhalfNV y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib2hNV, "glVertexAttrib2hNV");
  if (_driver.glVertexAttrib2hNV) {
    _driver.glVertexAttrib2hNV(index, x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib2hNV)(index, x, y);
}

static void REGAL_CALL loader_glVertexAttrib2hvNV(GLuint index, const GLhalfNV *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib2hvNV, "glVertexAttrib2hvNV");
  if (_driver.glVertexAttrib2hvNV) {
    _driver.glVertexAttrib2hvNV(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib2hvNV)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib3hNV(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib3hNV, "glVertexAttrib3hNV");
  if (_driver.glVertexAttrib3hNV) {
    _driver.glVertexAttrib3hNV(index, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib3hNV)(index, x, y, z);
}

static void REGAL_CALL loader_glVertexAttrib3hvNV(GLuint index, const GLhalfNV *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib3hvNV, "glVertexAttrib3hvNV");
  if (_driver.glVertexAttrib3hvNV) {
    _driver.glVertexAttrib3hvNV(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib3hvNV)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib4hNV(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib4hNV, "glVertexAttrib4hNV");
  if (_driver.glVertexAttrib4hNV) {
    _driver.glVertexAttrib4hNV(index, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib4hNV)(index, x, y, z, w);
}

static void REGAL_CALL loader_glVertexAttrib4hvNV(GLuint index, const GLhalfNV *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib4hvNV, "glVertexAttrib4hvNV");
  if (_driver.glVertexAttrib4hvNV) {
    _driver.glVertexAttrib4hvNV(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib4hvNV)(index, v);
}

static void REGAL_CALL loader_glVertexAttribs1hvNV(GLuint index, GLsizei count, const GLhalfNV *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribs1hvNV, "glVertexAttribs1hvNV");
  if (_driver.glVertexAttribs1hvNV) {
    _driver.glVertexAttribs1hvNV(index, count, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribs1hvNV)(index, count, v);
}

static void REGAL_CALL loader_glVertexAttribs2hvNV(GLuint index, GLsizei count, const GLhalfNV *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribs2hvNV, "glVertexAttribs2hvNV");
  if (_driver.glVertexAttribs2hvNV) {
    _driver.glVertexAttribs2hvNV(index, count, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribs2hvNV)(index, count, v);
}

static void REGAL_CALL loader_glVertexAttribs3hvNV(GLuint index, GLsizei count, const GLhalfNV *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribs3hvNV, "glVertexAttribs3hvNV");
  if (_driver.glVertexAttribs3hvNV) {
    _driver.glVertexAttribs3hvNV(index, count, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribs3hvNV)(index, count, v);
}

static void REGAL_CALL loader_glVertexAttribs4hvNV(GLuint index, GLsizei count, const GLhalfNV *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribs4hvNV, "glVertexAttribs4hvNV");
  if (_driver.glVertexAttribs4hvNV) {
    _driver.glVertexAttribs4hvNV(index, count, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribs4hvNV)(index, count, v);
}

static void REGAL_CALL loader_glVertexWeighthNV(GLhalfNV weight)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexWeighthNV, "glVertexWeighthNV");
  if (_driver.glVertexWeighthNV) {
    _driver.glVertexWeighthNV(weight);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexWeighthNV)(weight);
}

static void REGAL_CALL loader_glVertexWeighthvNV(const GLhalfNV *weight)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexWeighthvNV, "glVertexWeighthvNV");
  if (_driver.glVertexWeighthvNV) {
    _driver.glVertexWeighthvNV(weight);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexWeighthvNV)(weight);
}

// GL_NV_occlusion_query

static void REGAL_CALL loader_glBeginOcclusionQueryNV(GLuint id)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBeginOcclusionQueryNV, "glBeginOcclusionQueryNV");
  if (_driver.glBeginOcclusionQueryNV) {
    _driver.glBeginOcclusionQueryNV(id);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBeginOcclusionQueryNV)(id);
}

static void REGAL_CALL loader_glDeleteOcclusionQueriesNV(GLsizei n, const GLuint *ids)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDeleteOcclusionQueriesNV, "glDeleteOcclusionQueriesNV");
  if (_driver.glDeleteOcclusionQueriesNV) {
    _driver.glDeleteOcclusionQueriesNV(n, ids);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDeleteOcclusionQueriesNV)(n, ids);
}

static void REGAL_CALL loader_glEndOcclusionQueryNV(void)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glEndOcclusionQueryNV, "glEndOcclusionQueryNV");
  if (_driver.glEndOcclusionQueryNV) {
    _driver.glEndOcclusionQueryNV();
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glEndOcclusionQueryNV)();
}

static void REGAL_CALL loader_glGenOcclusionQueriesNV(GLsizei n, GLuint *ids)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGenOcclusionQueriesNV, "glGenOcclusionQueriesNV");
  if (_driver.glGenOcclusionQueriesNV) {
    _driver.glGenOcclusionQueriesNV(n, ids);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGenOcclusionQueriesNV)(n, ids);
}

static void REGAL_CALL loader_glGetOcclusionQueryivNV(GLuint id, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetOcclusionQueryivNV, "glGetOcclusionQueryivNV");
  if (_driver.glGetOcclusionQueryivNV) {
    _driver.glGetOcclusionQueryivNV(id, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetOcclusionQueryivNV)(id, pname, params);
}

static void REGAL_CALL loader_glGetOcclusionQueryuivNV(GLuint id, GLenum pname, GLuint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetOcclusionQueryuivNV, "glGetOcclusionQueryuivNV");
  if (_driver.glGetOcclusionQueryuivNV) {
    _driver.glGetOcclusionQueryuivNV(id, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetOcclusionQueryuivNV)(id, pname, params);
}

static GLboolean REGAL_CALL loader_glIsOcclusionQueryNV(GLuint id)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIsOcclusionQueryNV, "glIsOcclusionQueryNV");
  if (_driver.glIsOcclusionQueryNV) {
    return _driver.glIsOcclusionQueryNV(id);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glIsOcclusionQueryNV)(id);
}

// GL_NV_parameter_buffer_object

static void REGAL_CALL loader_glProgramBufferParametersIivNV(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramBufferParametersIivNV, "glProgramBufferParametersIivNV");
  if (_driver.glProgramBufferParametersIivNV) {
    _driver.glProgramBufferParametersIivNV(target, buffer, index, count, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramBufferParametersIivNV)(target, buffer, index, count, params);
}

static void REGAL_CALL loader_glProgramBufferParametersIuivNV(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLuint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramBufferParametersIuivNV, "glProgramBufferParametersIuivNV");
  if (_driver.glProgramBufferParametersIuivNV) {
    _driver.glProgramBufferParametersIuivNV(target, buffer, index, count, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramBufferParametersIuivNV)(target, buffer, index, count, params);
}

static void REGAL_CALL loader_glProgramBufferParametersfvNV(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramBufferParametersfvNV, "glProgramBufferParametersfvNV");
  if (_driver.glProgramBufferParametersfvNV) {
    _driver.glProgramBufferParametersfvNV(target, buffer, index, count, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramBufferParametersfvNV)(target, buffer, index, count, params);
}

// GL_NV_path_rendering

static void REGAL_CALL loader_glCopyPathNV(GLuint resultPath, GLuint srcPath)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCopyPathNV, "glCopyPathNV");
  if (_driver.glCopyPathNV) {
    _driver.glCopyPathNV(resultPath, srcPath);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCopyPathNV)(resultPath, srcPath);
}

static void REGAL_CALL loader_glCoverFillPathInstancedNV(GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCoverFillPathInstancedNV, "glCoverFillPathInstancedNV");
  if (_driver.glCoverFillPathInstancedNV) {
    _driver.glCoverFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCoverFillPathInstancedNV)(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
}

static void REGAL_CALL loader_glCoverFillPathNV(GLuint path, GLenum coverMode)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCoverFillPathNV, "glCoverFillPathNV");
  if (_driver.glCoverFillPathNV) {
    _driver.glCoverFillPathNV(path, coverMode);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCoverFillPathNV)(path, coverMode);
}

static void REGAL_CALL loader_glCoverStrokePathInstancedNV(GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCoverStrokePathInstancedNV, "glCoverStrokePathInstancedNV");
  if (_driver.glCoverStrokePathInstancedNV) {
    _driver.glCoverStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCoverStrokePathInstancedNV)(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
}

static void REGAL_CALL loader_glCoverStrokePathNV(GLuint name, GLenum coverMode)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCoverStrokePathNV, "glCoverStrokePathNV");
  if (_driver.glCoverStrokePathNV) {
    _driver.glCoverStrokePathNV(name, coverMode);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCoverStrokePathNV)(name, coverMode);
}

static void REGAL_CALL loader_glDeletePathsNV(GLuint path, GLsizei range)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDeletePathsNV, "glDeletePathsNV");
  if (_driver.glDeletePathsNV) {
    _driver.glDeletePathsNV(path, range);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDeletePathsNV)(path, range);
}

static GLuint REGAL_CALL loader_glGenPathsNV(GLsizei range)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGenPathsNV, "glGenPathsNV");
  if (_driver.glGenPathsNV) {
    return _driver.glGenPathsNV(range);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glGenPathsNV)(range);
}

static void REGAL_CALL loader_glGetPathColorGenfvNV(GLenum color, GLenum pname, GLfloat *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetPathColorGenfvNV, "glGetPathColorGenfvNV");
  if (_driver.glGetPathColorGenfvNV) {
    _driver.glGetPathColorGenfvNV(color, pname, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetPathColorGenfvNV)(color, pname, value);
}

static void REGAL_CALL loader_glGetPathColorGenivNV(GLenum color, GLenum pname, GLint *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetPathColorGenivNV, "glGetPathColorGenivNV");
  if (_driver.glGetPathColorGenivNV) {
    _driver.glGetPathColorGenivNV(color, pname, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetPathColorGenivNV)(color, pname, value);
}

static void REGAL_CALL loader_glGetPathCommandsNV(GLuint name, GLubyte *commands)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetPathCommandsNV, "glGetPathCommandsNV");
  if (_driver.glGetPathCommandsNV) {
    _driver.glGetPathCommandsNV(name, commands);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetPathCommandsNV)(name, commands);
}

static void REGAL_CALL loader_glGetPathCoordsNV(GLuint name, GLfloat *coords)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetPathCoordsNV, "glGetPathCoordsNV");
  if (_driver.glGetPathCoordsNV) {
    _driver.glGetPathCoordsNV(name, coords);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetPathCoordsNV)(name, coords);
}

static void REGAL_CALL loader_glGetPathDashArrayNV(GLuint name, GLfloat *dashArray)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetPathDashArrayNV, "glGetPathDashArrayNV");
  if (_driver.glGetPathDashArrayNV) {
    _driver.glGetPathDashArrayNV(name, dashArray);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetPathDashArrayNV)(name, dashArray);
}

static GLfloat REGAL_CALL loader_glGetPathLengthNV(GLuint path, GLsizei startSegment, GLsizei numSegments)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetPathLengthNV, "glGetPathLengthNV");
  if (_driver.glGetPathLengthNV) {
    return _driver.glGetPathLengthNV(path, startSegment, numSegments);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glGetPathLengthNV)(path, startSegment, numSegments);
}

static void REGAL_CALL loader_glGetPathMetricRangeNV(GLbitfield metricQueryMask, GLuint fistPathName, GLsizei numPaths, GLsizei stride, GLfloat *metrics)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetPathMetricRangeNV, "glGetPathMetricRangeNV");
  if (_driver.glGetPathMetricRangeNV) {
    _driver.glGetPathMetricRangeNV(metricQueryMask, fistPathName, numPaths, stride, metrics);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetPathMetricRangeNV)(metricQueryMask, fistPathName, numPaths, stride, metrics);
}

static void REGAL_CALL loader_glGetPathMetricsNV(GLbitfield metricQueryMask, GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLsizei stride, GLfloat *metrics)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetPathMetricsNV, "glGetPathMetricsNV");
  if (_driver.glGetPathMetricsNV) {
    _driver.glGetPathMetricsNV(metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, metrics);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetPathMetricsNV)(metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, metrics);
}

static void REGAL_CALL loader_glGetPathParameterfvNV(GLuint name, GLenum param, GLfloat *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetPathParameterfvNV, "glGetPathParameterfvNV");
  if (_driver.glGetPathParameterfvNV) {
    _driver.glGetPathParameterfvNV(name, param, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetPathParameterfvNV)(name, param, value);
}

static void REGAL_CALL loader_glGetPathParameterivNV(GLuint name, GLenum param, GLint *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetPathParameterivNV, "glGetPathParameterivNV");
  if (_driver.glGetPathParameterivNV) {
    _driver.glGetPathParameterivNV(name, param, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetPathParameterivNV)(name, param, value);
}

static void REGAL_CALL loader_glGetPathSpacingNV(GLenum pathListMode, GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLfloat advanceScale, GLfloat kerningScale, GLenum transformType, GLfloat *returnedSpacing)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetPathSpacingNV, "glGetPathSpacingNV");
  if (_driver.glGetPathSpacingNV) {
    _driver.glGetPathSpacingNV(pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, returnedSpacing);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetPathSpacingNV)(pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, returnedSpacing);
}

static void REGAL_CALL loader_glGetPathTexGenfvNV(GLenum texCoordSet, GLenum pname, GLfloat *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetPathTexGenfvNV, "glGetPathTexGenfvNV");
  if (_driver.glGetPathTexGenfvNV) {
    _driver.glGetPathTexGenfvNV(texCoordSet, pname, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetPathTexGenfvNV)(texCoordSet, pname, value);
}

static void REGAL_CALL loader_glGetPathTexGenivNV(GLenum texCoordSet, GLenum pname, GLint *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetPathTexGenivNV, "glGetPathTexGenivNV");
  if (_driver.glGetPathTexGenivNV) {
    _driver.glGetPathTexGenivNV(texCoordSet, pname, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetPathTexGenivNV)(texCoordSet, pname, value);
}

static void REGAL_CALL loader_glInterpolatePathsNV(GLuint resultPath, GLuint pathA, GLuint pathB, GLfloat weight)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glInterpolatePathsNV, "glInterpolatePathsNV");
  if (_driver.glInterpolatePathsNV) {
    _driver.glInterpolatePathsNV(resultPath, pathA, pathB, weight);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glInterpolatePathsNV)(resultPath, pathA, pathB, weight);
}

static GLboolean REGAL_CALL loader_glIsPathNV(GLuint path)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIsPathNV, "glIsPathNV");
  if (_driver.glIsPathNV) {
    return _driver.glIsPathNV(path);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glIsPathNV)(path);
}

static GLboolean REGAL_CALL loader_glIsPointInFillPathNV(GLuint path, GLuint mask, GLfloat x, GLfloat y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIsPointInFillPathNV, "glIsPointInFillPathNV");
  if (_driver.glIsPointInFillPathNV) {
    return _driver.glIsPointInFillPathNV(path, mask, x, y);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glIsPointInFillPathNV)(path, mask, x, y);
}

static GLboolean REGAL_CALL loader_glIsPointInStrokePathNV(GLuint path, GLfloat x, GLfloat y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIsPointInStrokePathNV, "glIsPointInStrokePathNV");
  if (_driver.glIsPointInStrokePathNV) {
    return _driver.glIsPointInStrokePathNV(path, x, y);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glIsPointInStrokePathNV)(path, x, y);
}

static void REGAL_CALL loader_glPathColorGenNV(GLenum color, GLenum genMode, GLenum colorFormat, const GLfloat *coeffs)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPathColorGenNV, "glPathColorGenNV");
  if (_driver.glPathColorGenNV) {
    _driver.glPathColorGenNV(color, genMode, colorFormat, coeffs);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPathColorGenNV)(color, genMode, colorFormat, coeffs);
}

static void REGAL_CALL loader_glPathCommandsNV(GLuint path, GLsizei numCommands, const GLubyte *commands, GLsizei numCoords, GLenum coordType, const GLvoid *coords)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPathCommandsNV, "glPathCommandsNV");
  if (_driver.glPathCommandsNV) {
    _driver.glPathCommandsNV(path, numCommands, commands, numCoords, coordType, coords);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPathCommandsNV)(path, numCommands, commands, numCoords, coordType, coords);
}

static void REGAL_CALL loader_glPathCoordsNV(GLuint path, GLsizei numCoords, GLenum coordType, const GLvoid *coords)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPathCoordsNV, "glPathCoordsNV");
  if (_driver.glPathCoordsNV) {
    _driver.glPathCoordsNV(path, numCoords, coordType, coords);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPathCoordsNV)(path, numCoords, coordType, coords);
}

static void REGAL_CALL loader_glPathCoverDepthFuncNV(GLenum zfunc)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPathCoverDepthFuncNV, "glPathCoverDepthFuncNV");
  if (_driver.glPathCoverDepthFuncNV) {
    _driver.glPathCoverDepthFuncNV(zfunc);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPathCoverDepthFuncNV)(zfunc);
}

static void REGAL_CALL loader_glPathDashArrayNV(GLuint path, GLsizei dashCount, const GLfloat *dashArray)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPathDashArrayNV, "glPathDashArrayNV");
  if (_driver.glPathDashArrayNV) {
    _driver.glPathDashArrayNV(path, dashCount, dashArray);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPathDashArrayNV)(path, dashCount, dashArray);
}

static void REGAL_CALL loader_glPathFogGenNV(GLenum genMode)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPathFogGenNV, "glPathFogGenNV");
  if (_driver.glPathFogGenNV) {
    _driver.glPathFogGenNV(genMode);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPathFogGenNV)(genMode);
}

static void REGAL_CALL loader_glPathGlyphRangeNV(GLuint firstPathName, GLenum fontTarget, const GLvoid *fontName, GLbitfield fontStyle, GLuint firstGlyph, GLsizei numGlyphs, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPathGlyphRangeNV, "glPathGlyphRangeNV");
  if (_driver.glPathGlyphRangeNV) {
    _driver.glPathGlyphRangeNV(firstPathName, fontTarget, fontName, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPathGlyphRangeNV)(firstPathName, fontTarget, fontName, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale);
}

static void REGAL_CALL loader_glPathGlyphsNV(GLuint firstPathName, GLenum fontTarget, const GLvoid *fontName, GLbitfield fontStyle, GLsizei numGlyphs, GLenum type, const GLvoid *charcodes, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPathGlyphsNV, "glPathGlyphsNV");
  if (_driver.glPathGlyphsNV) {
    _driver.glPathGlyphsNV(firstPathName, fontTarget, fontName, fontStyle, numGlyphs, type, charcodes, handleMissingGlyphs, pathParameterTemplate, emScale);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPathGlyphsNV)(firstPathName, fontTarget, fontName, fontStyle, numGlyphs, type, charcodes, handleMissingGlyphs, pathParameterTemplate, emScale);
}

static void REGAL_CALL loader_glPathParameterfNV(GLuint path, GLenum pname, GLfloat value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPathParameterfNV, "glPathParameterfNV");
  if (_driver.glPathParameterfNV) {
    _driver.glPathParameterfNV(path, pname, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPathParameterfNV)(path, pname, value);
}

static void REGAL_CALL loader_glPathParameterfvNV(GLuint path, GLenum pname, const GLfloat *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPathParameterfvNV, "glPathParameterfvNV");
  if (_driver.glPathParameterfvNV) {
    _driver.glPathParameterfvNV(path, pname, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPathParameterfvNV)(path, pname, value);
}

static void REGAL_CALL loader_glPathParameteriNV(GLuint path, GLenum pname, GLint value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPathParameteriNV, "glPathParameteriNV");
  if (_driver.glPathParameteriNV) {
    _driver.glPathParameteriNV(path, pname, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPathParameteriNV)(path, pname, value);
}

static void REGAL_CALL loader_glPathParameterivNV(GLuint path, GLenum pname, const GLint *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPathParameterivNV, "glPathParameterivNV");
  if (_driver.glPathParameterivNV) {
    _driver.glPathParameterivNV(path, pname, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPathParameterivNV)(path, pname, value);
}

static void REGAL_CALL loader_glPathStencilDepthOffsetNV(GLfloat factor, GLfloat units)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPathStencilDepthOffsetNV, "glPathStencilDepthOffsetNV");
  if (_driver.glPathStencilDepthOffsetNV) {
    _driver.glPathStencilDepthOffsetNV(factor, units);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPathStencilDepthOffsetNV)(factor, units);
}

static void REGAL_CALL loader_glPathStencilFuncNV(GLenum func, GLint ref, GLuint mask)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPathStencilFuncNV, "glPathStencilFuncNV");
  if (_driver.glPathStencilFuncNV) {
    _driver.glPathStencilFuncNV(func, ref, mask);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPathStencilFuncNV)(func, ref, mask);
}

static void REGAL_CALL loader_glPathStringNV(GLuint path, GLenum format, GLsizei length, const GLvoid *pathString)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPathStringNV, "glPathStringNV");
  if (_driver.glPathStringNV) {
    _driver.glPathStringNV(path, format, length, pathString);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPathStringNV)(path, format, length, pathString);
}

static void REGAL_CALL loader_glPathSubCommandsNV(GLuint path, GLsizei commandStart, GLsizei commandsToDelete, GLsizei numCommands, const GLubyte *commands, GLsizei numCoords, GLenum coordType, const GLvoid *coords)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPathSubCommandsNV, "glPathSubCommandsNV");
  if (_driver.glPathSubCommandsNV) {
    _driver.glPathSubCommandsNV(path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, coords);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPathSubCommandsNV)(path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, coords);
}

static void REGAL_CALL loader_glPathSubCoordsNV(GLuint path, GLsizei coordStart, GLsizei numCoords, GLenum coordType, const GLvoid *coords)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPathSubCoordsNV, "glPathSubCoordsNV");
  if (_driver.glPathSubCoordsNV) {
    _driver.glPathSubCoordsNV(path, coordStart, numCoords, coordType, coords);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPathSubCoordsNV)(path, coordStart, numCoords, coordType, coords);
}

static void REGAL_CALL loader_glPathTexGenNV(GLenum texCoordSet, GLenum genMode, GLint components, const GLfloat *coeffs)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPathTexGenNV, "glPathTexGenNV");
  if (_driver.glPathTexGenNV) {
    _driver.glPathTexGenNV(texCoordSet, genMode, components, coeffs);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPathTexGenNV)(texCoordSet, genMode, components, coeffs);
}

static GLboolean REGAL_CALL loader_glPointAlongPathNV(GLuint path, GLsizei startSegment, GLsizei numSegments, GLfloat distance, GLfloat *x, GLfloat *y, GLfloat *tangentX, GLfloat *tangentY)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPointAlongPathNV, "glPointAlongPathNV");
  if (_driver.glPointAlongPathNV) {
    return _driver.glPointAlongPathNV(path, startSegment, numSegments, distance, x, y, tangentX, tangentY);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glPointAlongPathNV)(path, startSegment, numSegments, distance, x, y, tangentX, tangentY);
}

static void REGAL_CALL loader_glStencilFillPathInstancedNV(GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum transformType, const GLfloat *transformValues)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glStencilFillPathInstancedNV, "glStencilFillPathInstancedNV");
  if (_driver.glStencilFillPathInstancedNV) {
    _driver.glStencilFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glStencilFillPathInstancedNV)(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues);
}

static void REGAL_CALL loader_glStencilFillPathNV(GLuint path, GLenum fillMode, GLuint mask)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glStencilFillPathNV, "glStencilFillPathNV");
  if (_driver.glStencilFillPathNV) {
    _driver.glStencilFillPathNV(path, fillMode, mask);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glStencilFillPathNV)(path, fillMode, mask);
}

static void REGAL_CALL loader_glStencilStrokePathInstancedNV(GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLint reference, GLuint mask, GLenum transformType, const GLfloat *transformValues)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glStencilStrokePathInstancedNV, "glStencilStrokePathInstancedNV");
  if (_driver.glStencilStrokePathInstancedNV) {
    _driver.glStencilStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glStencilStrokePathInstancedNV)(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues);
}

static void REGAL_CALL loader_glStencilStrokePathNV(GLuint path, GLint reference, GLuint mask)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glStencilStrokePathNV, "glStencilStrokePathNV");
  if (_driver.glStencilStrokePathNV) {
    _driver.glStencilStrokePathNV(path, reference, mask);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glStencilStrokePathNV)(path, reference, mask);
}

static void REGAL_CALL loader_glTransformPathNV(GLuint resultPath, GLuint srcPath, GLenum transformType, const GLfloat *transformValues)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTransformPathNV, "glTransformPathNV");
  if (_driver.glTransformPathNV) {
    _driver.glTransformPathNV(resultPath, srcPath, transformType, transformValues);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTransformPathNV)(resultPath, srcPath, transformType, transformValues);
}

static void REGAL_CALL loader_glWeightPathsNV(GLuint resultPath, GLsizei numPaths, const GLuint *paths, const GLfloat *weights)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWeightPathsNV, "glWeightPathsNV");
  if (_driver.glWeightPathsNV) {
    _driver.glWeightPathsNV(resultPath, numPaths, paths, weights);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWeightPathsNV)(resultPath, numPaths, paths, weights);
}

// GL_NV_pixel_data_range

static void REGAL_CALL loader_glFlushPixelDataRangeNV(GLenum target)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFlushPixelDataRangeNV, "glFlushPixelDataRangeNV");
  if (_driver.glFlushPixelDataRangeNV) {
    _driver.glFlushPixelDataRangeNV(target);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFlushPixelDataRangeNV)(target);
}

static void REGAL_CALL loader_glPixelDataRangeNV(GLenum target, GLsizei size, const GLvoid *pointer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPixelDataRangeNV, "glPixelDataRangeNV");
  if (_driver.glPixelDataRangeNV) {
    _driver.glPixelDataRangeNV(target, size, pointer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPixelDataRangeNV)(target, size, pointer);
}

// GL_NV_point_sprite

static void REGAL_CALL loader_glPointParameteriNV(GLenum pname, GLint param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPointParameteriNV, "glPointParameteriNV");
  if (_driver.glPointParameteriNV) {
    _driver.glPointParameteriNV(pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPointParameteriNV)(pname, param);
}

static void REGAL_CALL loader_glPointParameterivNV(GLenum pname, const GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPointParameterivNV, "glPointParameterivNV");
  if (_driver.glPointParameterivNV) {
    _driver.glPointParameterivNV(pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPointParameterivNV)(pname, params);
}

// GL_NV_present_video

static void REGAL_CALL loader_glGetVideoi64vNV(GLuint video_slot, GLenum pname, GLint64EXT *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetVideoi64vNV, "glGetVideoi64vNV");
  if (_driver.glGetVideoi64vNV) {
    _driver.glGetVideoi64vNV(video_slot, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetVideoi64vNV)(video_slot, pname, params);
}

static void REGAL_CALL loader_glGetVideoivNV(GLuint video_slot, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetVideoivNV, "glGetVideoivNV");
  if (_driver.glGetVideoivNV) {
    _driver.glGetVideoivNV(video_slot, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetVideoivNV)(video_slot, pname, params);
}

static void REGAL_CALL loader_glGetVideoui64vNV(GLuint video_slot, GLenum pname, GLuint64EXT *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetVideoui64vNV, "glGetVideoui64vNV");
  if (_driver.glGetVideoui64vNV) {
    _driver.glGetVideoui64vNV(video_slot, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetVideoui64vNV)(video_slot, pname, params);
}

static void REGAL_CALL loader_glGetVideouivNV(GLuint video_slot, GLenum pname, GLuint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetVideouivNV, "glGetVideouivNV");
  if (_driver.glGetVideouivNV) {
    _driver.glGetVideouivNV(video_slot, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetVideouivNV)(video_slot, pname, params);
}

static void REGAL_CALL loader_glPresentFrameDualFillNV(GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLenum target1, GLuint fill1, GLenum target2, GLuint fill2, GLenum target3, GLuint fill3)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPresentFrameDualFillNV, "glPresentFrameDualFillNV");
  if (_driver.glPresentFrameDualFillNV) {
    _driver.glPresentFrameDualFillNV(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, target1, fill1, target2, fill2, target3, fill3);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPresentFrameDualFillNV)(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, target1, fill1, target2, fill2, target3, fill3);
}

static void REGAL_CALL loader_glPresentFrameKeyedNV(GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLuint key0, GLenum target1, GLuint fill1, GLuint key1)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPresentFrameKeyedNV, "glPresentFrameKeyedNV");
  if (_driver.glPresentFrameKeyedNV) {
    _driver.glPresentFrameKeyedNV(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, key0, target1, fill1, key1);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPresentFrameKeyedNV)(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, key0, target1, fill1, key1);
}

// GL_NV_primitive_restart

static void REGAL_CALL loader_glPrimitiveRestartIndexNV(GLuint index)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPrimitiveRestartIndexNV, "glPrimitiveRestartIndexNV");
  if (_driver.glPrimitiveRestartIndexNV) {
    _driver.glPrimitiveRestartIndexNV(index);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPrimitiveRestartIndexNV)(index);
}

static void REGAL_CALL loader_glPrimitiveRestartNV(void)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPrimitiveRestartNV, "glPrimitiveRestartNV");
  if (_driver.glPrimitiveRestartNV) {
    _driver.glPrimitiveRestartNV();
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPrimitiveRestartNV)();
}

// GL_NV_read_buffer

static void REGAL_CALL loader_glReadBufferNV(GLenum mode)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glReadBufferNV, "glReadBufferNV");
  if (_driver.glReadBufferNV) {
    _driver.glReadBufferNV(mode);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glReadBufferNV)(mode);
}

// GL_NV_register_combiners

static void REGAL_CALL loader_glCombinerInputNV(GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCombinerInputNV, "glCombinerInputNV");
  if (_driver.glCombinerInputNV) {
    _driver.glCombinerInputNV(stage, portion, variable, input, mapping, componentUsage);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCombinerInputNV)(stage, portion, variable, input, mapping, componentUsage);
}

static void REGAL_CALL loader_glCombinerOutputNV(GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCombinerOutputNV, "glCombinerOutputNV");
  if (_driver.glCombinerOutputNV) {
    _driver.glCombinerOutputNV(stage, portion, abOutput, cdOutput, sumOutput, scale, bias, abDotProduct, cdDotProduct, muxSum);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCombinerOutputNV)(stage, portion, abOutput, cdOutput, sumOutput, scale, bias, abDotProduct, cdDotProduct, muxSum);
}

static void REGAL_CALL loader_glCombinerParameterfNV(GLenum pname, GLfloat param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCombinerParameterfNV, "glCombinerParameterfNV");
  if (_driver.glCombinerParameterfNV) {
    _driver.glCombinerParameterfNV(pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCombinerParameterfNV)(pname, param);
}

static void REGAL_CALL loader_glCombinerParameterfvNV(GLenum pname, const GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCombinerParameterfvNV, "glCombinerParameterfvNV");
  if (_driver.glCombinerParameterfvNV) {
    _driver.glCombinerParameterfvNV(pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCombinerParameterfvNV)(pname, params);
}

static void REGAL_CALL loader_glCombinerParameteriNV(GLenum pname, GLint param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCombinerParameteriNV, "glCombinerParameteriNV");
  if (_driver.glCombinerParameteriNV) {
    _driver.glCombinerParameteriNV(pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCombinerParameteriNV)(pname, param);
}

static void REGAL_CALL loader_glCombinerParameterivNV(GLenum pname, const GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCombinerParameterivNV, "glCombinerParameterivNV");
  if (_driver.glCombinerParameterivNV) {
    _driver.glCombinerParameterivNV(pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCombinerParameterivNV)(pname, params);
}

static void REGAL_CALL loader_glFinalCombinerInputNV(GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFinalCombinerInputNV, "glFinalCombinerInputNV");
  if (_driver.glFinalCombinerInputNV) {
    _driver.glFinalCombinerInputNV(variable, input, mapping, componentUsage);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFinalCombinerInputNV)(variable, input, mapping, componentUsage);
}

static void REGAL_CALL loader_glGetCombinerInputParameterfvNV(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetCombinerInputParameterfvNV, "glGetCombinerInputParameterfvNV");
  if (_driver.glGetCombinerInputParameterfvNV) {
    _driver.glGetCombinerInputParameterfvNV(stage, portion, variable, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetCombinerInputParameterfvNV)(stage, portion, variable, pname, params);
}

static void REGAL_CALL loader_glGetCombinerInputParameterivNV(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetCombinerInputParameterivNV, "glGetCombinerInputParameterivNV");
  if (_driver.glGetCombinerInputParameterivNV) {
    _driver.glGetCombinerInputParameterivNV(stage, portion, variable, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetCombinerInputParameterivNV)(stage, portion, variable, pname, params);
}

static void REGAL_CALL loader_glGetCombinerOutputParameterfvNV(GLenum stage, GLenum portion, GLenum pname, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetCombinerOutputParameterfvNV, "glGetCombinerOutputParameterfvNV");
  if (_driver.glGetCombinerOutputParameterfvNV) {
    _driver.glGetCombinerOutputParameterfvNV(stage, portion, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetCombinerOutputParameterfvNV)(stage, portion, pname, params);
}

static void REGAL_CALL loader_glGetCombinerOutputParameterivNV(GLenum stage, GLenum portion, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetCombinerOutputParameterivNV, "glGetCombinerOutputParameterivNV");
  if (_driver.glGetCombinerOutputParameterivNV) {
    _driver.glGetCombinerOutputParameterivNV(stage, portion, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetCombinerOutputParameterivNV)(stage, portion, pname, params);
}

static void REGAL_CALL loader_glGetFinalCombinerInputParameterfvNV(GLenum variable, GLenum pname, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetFinalCombinerInputParameterfvNV, "glGetFinalCombinerInputParameterfvNV");
  if (_driver.glGetFinalCombinerInputParameterfvNV) {
    _driver.glGetFinalCombinerInputParameterfvNV(variable, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetFinalCombinerInputParameterfvNV)(variable, pname, params);
}

static void REGAL_CALL loader_glGetFinalCombinerInputParameterivNV(GLenum variable, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetFinalCombinerInputParameterivNV, "glGetFinalCombinerInputParameterivNV");
  if (_driver.glGetFinalCombinerInputParameterivNV) {
    _driver.glGetFinalCombinerInputParameterivNV(variable, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetFinalCombinerInputParameterivNV)(variable, pname, params);
}

// GL_NV_register_combiners2

static void REGAL_CALL loader_glCombinerStageParameterfvNV(GLenum stage, GLenum pname, const GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCombinerStageParameterfvNV, "glCombinerStageParameterfvNV");
  if (_driver.glCombinerStageParameterfvNV) {
    _driver.glCombinerStageParameterfvNV(stage, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCombinerStageParameterfvNV)(stage, pname, params);
}

static void REGAL_CALL loader_glGetCombinerStageParameterfvNV(GLenum stage, GLenum pname, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetCombinerStageParameterfvNV, "glGetCombinerStageParameterfvNV");
  if (_driver.glGetCombinerStageParameterfvNV) {
    _driver.glGetCombinerStageParameterfvNV(stage, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetCombinerStageParameterfvNV)(stage, pname, params);
}

// GL_NV_shader_buffer_load

static void REGAL_CALL loader_glGetBufferParameterui64vNV(GLenum target, GLenum pname, GLuint64EXT *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetBufferParameterui64vNV, "glGetBufferParameterui64vNV");
  if (_driver.glGetBufferParameterui64vNV) {
    _driver.glGetBufferParameterui64vNV(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetBufferParameterui64vNV)(target, pname, params);
}

static void REGAL_CALL loader_glGetIntegerui64vNV(GLenum target, GLuint64EXT *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetIntegerui64vNV, "glGetIntegerui64vNV");
  if (_driver.glGetIntegerui64vNV) {
    _driver.glGetIntegerui64vNV(target, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetIntegerui64vNV)(target, data);
}

static void REGAL_CALL loader_glGetNamedBufferParameterui64vNV(GLuint buffer, GLenum pname, GLuint64EXT *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetNamedBufferParameterui64vNV, "glGetNamedBufferParameterui64vNV");
  if (_driver.glGetNamedBufferParameterui64vNV) {
    _driver.glGetNamedBufferParameterui64vNV(buffer, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetNamedBufferParameterui64vNV)(buffer, pname, params);
}

static void REGAL_CALL loader_glGetUniformui64vNV(GLuint program, GLint location, GLuint64EXT *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetUniformui64vNV, "glGetUniformui64vNV");
  if (_driver.glGetUniformui64vNV) {
    _driver.glGetUniformui64vNV(program, location, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetUniformui64vNV)(program, location, params);
}

static GLboolean REGAL_CALL loader_glIsBufferResidentNV(GLenum target)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIsBufferResidentNV, "glIsBufferResidentNV");
  if (_driver.glIsBufferResidentNV) {
    return _driver.glIsBufferResidentNV(target);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glIsBufferResidentNV)(target);
}

static GLboolean REGAL_CALL loader_glIsNamedBufferResidentNV(GLuint buffer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIsNamedBufferResidentNV, "glIsNamedBufferResidentNV");
  if (_driver.glIsNamedBufferResidentNV) {
    return _driver.glIsNamedBufferResidentNV(buffer);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glIsNamedBufferResidentNV)(buffer);
}

static void REGAL_CALL loader_glMakeBufferNonResidentNV(GLenum target)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMakeBufferNonResidentNV, "glMakeBufferNonResidentNV");
  if (_driver.glMakeBufferNonResidentNV) {
    _driver.glMakeBufferNonResidentNV(target);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMakeBufferNonResidentNV)(target);
}

static void REGAL_CALL loader_glMakeBufferResidentNV(GLenum target, GLenum access)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMakeBufferResidentNV, "glMakeBufferResidentNV");
  if (_driver.glMakeBufferResidentNV) {
    _driver.glMakeBufferResidentNV(target, access);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMakeBufferResidentNV)(target, access);
}

static void REGAL_CALL loader_glMakeNamedBufferNonResidentNV(GLuint buffer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMakeNamedBufferNonResidentNV, "glMakeNamedBufferNonResidentNV");
  if (_driver.glMakeNamedBufferNonResidentNV) {
    _driver.glMakeNamedBufferNonResidentNV(buffer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMakeNamedBufferNonResidentNV)(buffer);
}

static void REGAL_CALL loader_glMakeNamedBufferResidentNV(GLuint buffer, GLenum access)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMakeNamedBufferResidentNV, "glMakeNamedBufferResidentNV");
  if (_driver.glMakeNamedBufferResidentNV) {
    _driver.glMakeNamedBufferResidentNV(buffer, access);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMakeNamedBufferResidentNV)(buffer, access);
}

static void REGAL_CALL loader_glProgramUniformui64NV(GLuint program, GLint location, GLuint64EXT v0)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniformui64NV, "glProgramUniformui64NV");
  if (_driver.glProgramUniformui64NV) {
    _driver.glProgramUniformui64NV(program, location, v0);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniformui64NV)(program, location, v0);
}

static void REGAL_CALL loader_glProgramUniformui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramUniformui64vNV, "glProgramUniformui64vNV");
  if (_driver.glProgramUniformui64vNV) {
    _driver.glProgramUniformui64vNV(program, location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramUniformui64vNV)(program, location, count, value);
}

static void REGAL_CALL loader_glUniformui64NV(GLint location, GLuint64EXT v0)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniformui64NV, "glUniformui64NV");
  if (_driver.glUniformui64NV) {
    _driver.glUniformui64NV(location, v0);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniformui64NV)(location, v0);
}

static void REGAL_CALL loader_glUniformui64vNV(GLint location, GLsizei count, const GLuint64EXT *value)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUniformui64vNV, "glUniformui64vNV");
  if (_driver.glUniformui64vNV) {
    _driver.glUniformui64vNV(location, count, value);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glUniformui64vNV)(location, count, value);
}

// GL_NV_texture_barrier

static void REGAL_CALL loader_glTextureBarrierNV(void)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTextureBarrierNV, "glTextureBarrierNV");
  if (_driver.glTextureBarrierNV) {
    _driver.glTextureBarrierNV();
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTextureBarrierNV)();
}

// GL_NV_texture_multisample

static void REGAL_CALL loader_glTexImage2DMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexImage2DMultisampleCoverageNV, "glTexImage2DMultisampleCoverageNV");
  if (_driver.glTexImage2DMultisampleCoverageNV) {
    _driver.glTexImage2DMultisampleCoverageNV(target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexImage2DMultisampleCoverageNV)(target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
}

static void REGAL_CALL loader_glTexImage3DMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexImage3DMultisampleCoverageNV, "glTexImage3DMultisampleCoverageNV");
  if (_driver.glTexImage3DMultisampleCoverageNV) {
    _driver.glTexImage3DMultisampleCoverageNV(target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexImage3DMultisampleCoverageNV)(target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
}

static void REGAL_CALL loader_glTextureImage2DMultisampleCoverageNV(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTextureImage2DMultisampleCoverageNV, "glTextureImage2DMultisampleCoverageNV");
  if (_driver.glTextureImage2DMultisampleCoverageNV) {
    _driver.glTextureImage2DMultisampleCoverageNV(texture, target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTextureImage2DMultisampleCoverageNV)(texture, target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
}

static void REGAL_CALL loader_glTextureImage2DMultisampleNV(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTextureImage2DMultisampleNV, "glTextureImage2DMultisampleNV");
  if (_driver.glTextureImage2DMultisampleNV) {
    _driver.glTextureImage2DMultisampleNV(texture, target, samples, internalFormat, width, height, fixedSampleLocations);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTextureImage2DMultisampleNV)(texture, target, samples, internalFormat, width, height, fixedSampleLocations);
}

static void REGAL_CALL loader_glTextureImage3DMultisampleCoverageNV(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTextureImage3DMultisampleCoverageNV, "glTextureImage3DMultisampleCoverageNV");
  if (_driver.glTextureImage3DMultisampleCoverageNV) {
    _driver.glTextureImage3DMultisampleCoverageNV(texture, target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTextureImage3DMultisampleCoverageNV)(texture, target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
}

static void REGAL_CALL loader_glTextureImage3DMultisampleNV(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTextureImage3DMultisampleNV, "glTextureImage3DMultisampleNV");
  if (_driver.glTextureImage3DMultisampleNV) {
    _driver.glTextureImage3DMultisampleNV(texture, target, samples, internalFormat, width, height, depth, fixedSampleLocations);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTextureImage3DMultisampleNV)(texture, target, samples, internalFormat, width, height, depth, fixedSampleLocations);
}

// GL_NV_transform_feedback

static void REGAL_CALL loader_glActiveVaryingNV(GLuint program, const GLchar *name)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glActiveVaryingNV, "glActiveVaryingNV");
  if (_driver.glActiveVaryingNV) {
    _driver.glActiveVaryingNV(program, name);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glActiveVaryingNV)(program, name);
}

static void REGAL_CALL loader_glBeginTransformFeedbackNV(GLenum primitiveMode)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBeginTransformFeedbackNV, "glBeginTransformFeedbackNV");
  if (_driver.glBeginTransformFeedbackNV) {
    _driver.glBeginTransformFeedbackNV(primitiveMode);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBeginTransformFeedbackNV)(primitiveMode);
}

static void REGAL_CALL loader_glBindBufferBaseNV(GLenum target, GLuint index, GLuint buffer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBindBufferBaseNV, "glBindBufferBaseNV");
  if (_driver.glBindBufferBaseNV) {
    _driver.glBindBufferBaseNV(target, index, buffer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBindBufferBaseNV)(target, index, buffer);
}

static void REGAL_CALL loader_glBindBufferOffsetNV(GLenum target, GLuint index, GLuint buffer, GLintptr offset)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBindBufferOffsetNV, "glBindBufferOffsetNV");
  if (_driver.glBindBufferOffsetNV) {
    _driver.glBindBufferOffsetNV(target, index, buffer, offset);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBindBufferOffsetNV)(target, index, buffer, offset);
}

static void REGAL_CALL loader_glBindBufferRangeNV(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBindBufferRangeNV, "glBindBufferRangeNV");
  if (_driver.glBindBufferRangeNV) {
    _driver.glBindBufferRangeNV(target, index, buffer, offset, size);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBindBufferRangeNV)(target, index, buffer, offset, size);
}

static void REGAL_CALL loader_glEndTransformFeedbackNV(void)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glEndTransformFeedbackNV, "glEndTransformFeedbackNV");
  if (_driver.glEndTransformFeedbackNV) {
    _driver.glEndTransformFeedbackNV();
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glEndTransformFeedbackNV)();
}

static void REGAL_CALL loader_glGetActiveVaryingNV(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetActiveVaryingNV, "glGetActiveVaryingNV");
  if (_driver.glGetActiveVaryingNV) {
    _driver.glGetActiveVaryingNV(program, index, bufSize, length, size, type, name);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetActiveVaryingNV)(program, index, bufSize, length, size, type, name);
}

static void REGAL_CALL loader_glGetTransformFeedbackVaryingNV(GLuint program, GLuint index, GLint *location)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetTransformFeedbackVaryingNV, "glGetTransformFeedbackVaryingNV");
  if (_driver.glGetTransformFeedbackVaryingNV) {
    _driver.glGetTransformFeedbackVaryingNV(program, index, location);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetTransformFeedbackVaryingNV)(program, index, location);
}

static GLint REGAL_CALL loader_glGetVaryingLocationNV(GLuint program, const GLchar *name)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetVaryingLocationNV, "glGetVaryingLocationNV");
  if (_driver.glGetVaryingLocationNV) {
    return _driver.glGetVaryingLocationNV(program, name);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glGetVaryingLocationNV)(program, name);
}

static void REGAL_CALL loader_glTransformFeedbackAttribsNV(GLuint count, const GLint *attribs, GLenum bufferMode)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTransformFeedbackAttribsNV, "glTransformFeedbackAttribsNV");
  if (_driver.glTransformFeedbackAttribsNV) {
    _driver.glTransformFeedbackAttribsNV(count, attribs, bufferMode);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTransformFeedbackAttribsNV)(count, attribs, bufferMode);
}

static void REGAL_CALL loader_glTransformFeedbackVaryingsNV(GLuint program, GLsizei count, const GLint *locations, GLenum bufferMode)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTransformFeedbackVaryingsNV, "glTransformFeedbackVaryingsNV");
  if (_driver.glTransformFeedbackVaryingsNV) {
    _driver.glTransformFeedbackVaryingsNV(program, count, locations, bufferMode);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTransformFeedbackVaryingsNV)(program, count, locations, bufferMode);
}

// GL_NV_transform_feedback2

static void REGAL_CALL loader_glBindTransformFeedbackNV(GLenum target, GLuint id)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBindTransformFeedbackNV, "glBindTransformFeedbackNV");
  if (_driver.glBindTransformFeedbackNV) {
    _driver.glBindTransformFeedbackNV(target, id);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBindTransformFeedbackNV)(target, id);
}

static void REGAL_CALL loader_glDeleteTransformFeedbacksNV(GLsizei n, const GLuint *ids)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDeleteTransformFeedbacksNV, "glDeleteTransformFeedbacksNV");
  if (_driver.glDeleteTransformFeedbacksNV) {
    _driver.glDeleteTransformFeedbacksNV(n, ids);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDeleteTransformFeedbacksNV)(n, ids);
}

static void REGAL_CALL loader_glDrawTransformFeedbackNV(GLenum mode, GLuint name)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDrawTransformFeedbackNV, "glDrawTransformFeedbackNV");
  if (_driver.glDrawTransformFeedbackNV) {
    _driver.glDrawTransformFeedbackNV(mode, name);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDrawTransformFeedbackNV)(mode, name);
}

static void REGAL_CALL loader_glGenTransformFeedbacksNV(GLsizei n, GLuint *ids)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGenTransformFeedbacksNV, "glGenTransformFeedbacksNV");
  if (_driver.glGenTransformFeedbacksNV) {
    _driver.glGenTransformFeedbacksNV(n, ids);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGenTransformFeedbacksNV)(n, ids);
}

static GLboolean REGAL_CALL loader_glIsTransformFeedbackNV(GLuint id)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIsTransformFeedbackNV, "glIsTransformFeedbackNV");
  if (_driver.glIsTransformFeedbackNV) {
    return _driver.glIsTransformFeedbackNV(id);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glIsTransformFeedbackNV)(id);
}

static void REGAL_CALL loader_glPauseTransformFeedbackNV(void)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPauseTransformFeedbackNV, "glPauseTransformFeedbackNV");
  if (_driver.glPauseTransformFeedbackNV) {
    _driver.glPauseTransformFeedbackNV();
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPauseTransformFeedbackNV)();
}

static void REGAL_CALL loader_glResumeTransformFeedbackNV(void)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glResumeTransformFeedbackNV, "glResumeTransformFeedbackNV");
  if (_driver.glResumeTransformFeedbackNV) {
    _driver.glResumeTransformFeedbackNV();
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glResumeTransformFeedbackNV)();
}

// GL_NV_vdpau_interop

static void REGAL_CALL loader_glVDPAUFiniNV(void)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVDPAUFiniNV, "glVDPAUFiniNV");
  if (_driver.glVDPAUFiniNV) {
    _driver.glVDPAUFiniNV();
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVDPAUFiniNV)();
}

static void REGAL_CALL loader_glVDPAUGetSurfaceivNV(GLvdpauSurfaceNV surface, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVDPAUGetSurfaceivNV, "glVDPAUGetSurfaceivNV");
  if (_driver.glVDPAUGetSurfaceivNV) {
    _driver.glVDPAUGetSurfaceivNV(surface, pname, bufSize, length, values);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVDPAUGetSurfaceivNV)(surface, pname, bufSize, length, values);
}

static void REGAL_CALL loader_glVDPAUInitNV(const GLvoid *vdpDevice, const GLvoid *getProcAddress)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVDPAUInitNV, "glVDPAUInitNV");
  if (_driver.glVDPAUInitNV) {
    _driver.glVDPAUInitNV(vdpDevice, getProcAddress);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVDPAUInitNV)(vdpDevice, getProcAddress);
}

static GLboolean REGAL_CALL loader_glVDPAUIsSurfaceNV(GLvdpauSurfaceNV surface)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVDPAUIsSurfaceNV, "glVDPAUIsSurfaceNV");
  if (_driver.glVDPAUIsSurfaceNV) {
    return _driver.glVDPAUIsSurfaceNV(surface);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glVDPAUIsSurfaceNV)(surface);
}

static void REGAL_CALL loader_glVDPAUMapSurfacesNV(GLsizei numSurfaces, const GLvdpauSurfaceNV *surfaces)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVDPAUMapSurfacesNV, "glVDPAUMapSurfacesNV");
  if (_driver.glVDPAUMapSurfacesNV) {
    _driver.glVDPAUMapSurfacesNV(numSurfaces, surfaces);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVDPAUMapSurfacesNV)(numSurfaces, surfaces);
}

static GLvdpauSurfaceNV REGAL_CALL loader_glVDPAURegisterOutputSurfaceNV(const GLvoid *vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVDPAURegisterOutputSurfaceNV, "glVDPAURegisterOutputSurfaceNV");
  if (_driver.glVDPAURegisterOutputSurfaceNV) {
    return _driver.glVDPAURegisterOutputSurfaceNV(vdpSurface, target, numTextureNames, textureNames);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glVDPAURegisterOutputSurfaceNV)(vdpSurface, target, numTextureNames, textureNames);
}

static GLvdpauSurfaceNV REGAL_CALL loader_glVDPAURegisterVideoSurfaceNV(const GLvoid *vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVDPAURegisterVideoSurfaceNV, "glVDPAURegisterVideoSurfaceNV");
  if (_driver.glVDPAURegisterVideoSurfaceNV) {
    return _driver.glVDPAURegisterVideoSurfaceNV(vdpSurface, target, numTextureNames, textureNames);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glVDPAURegisterVideoSurfaceNV)(vdpSurface, target, numTextureNames, textureNames);
}

static void REGAL_CALL loader_glVDPAUSurfaceAccessNV(GLvdpauSurfaceNV surface, GLenum access)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVDPAUSurfaceAccessNV, "glVDPAUSurfaceAccessNV");
  if (_driver.glVDPAUSurfaceAccessNV) {
    _driver.glVDPAUSurfaceAccessNV(surface, access);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVDPAUSurfaceAccessNV)(surface, access);
}

static void REGAL_CALL loader_glVDPAUUnmapSurfacesNV(GLsizei numSurfaces, const GLvdpauSurfaceNV *surfaces)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVDPAUUnmapSurfacesNV, "glVDPAUUnmapSurfacesNV");
  if (_driver.glVDPAUUnmapSurfacesNV) {
    _driver.glVDPAUUnmapSurfacesNV(numSurfaces, surfaces);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVDPAUUnmapSurfacesNV)(numSurfaces, surfaces);
}

static void REGAL_CALL loader_glVDPAUUnregisterSurfaceNV(GLvdpauSurfaceNV surface)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVDPAUUnregisterSurfaceNV, "glVDPAUUnregisterSurfaceNV");
  if (_driver.glVDPAUUnregisterSurfaceNV) {
    _driver.glVDPAUUnregisterSurfaceNV(surface);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVDPAUUnregisterSurfaceNV)(surface);
}

// GL_NV_vertex_array_range

static void REGAL_CALL loader_glFlushVertexArrayRangeNV(void)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFlushVertexArrayRangeNV, "glFlushVertexArrayRangeNV");
  if (_driver.glFlushVertexArrayRangeNV) {
    _driver.glFlushVertexArrayRangeNV();
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFlushVertexArrayRangeNV)();
}

static void REGAL_CALL loader_glVertexArrayRangeNV(GLsizei size, const GLvoid *pointer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexArrayRangeNV, "glVertexArrayRangeNV");
  if (_driver.glVertexArrayRangeNV) {
    _driver.glVertexArrayRangeNV(size, pointer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexArrayRangeNV)(size, pointer);
}

// GL_NV_vertex_attrib_integer_64bit

static void REGAL_CALL loader_glGetVertexAttribLi64vNV(GLuint index, GLenum pname, GLint64EXT *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetVertexAttribLi64vNV, "glGetVertexAttribLi64vNV");
  if (_driver.glGetVertexAttribLi64vNV) {
    _driver.glGetVertexAttribLi64vNV(index, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetVertexAttribLi64vNV)(index, pname, params);
}

static void REGAL_CALL loader_glGetVertexAttribLui64vNV(GLuint index, GLenum pname, GLuint64EXT *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetVertexAttribLui64vNV, "glGetVertexAttribLui64vNV");
  if (_driver.glGetVertexAttribLui64vNV) {
    _driver.glGetVertexAttribLui64vNV(index, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetVertexAttribLui64vNV)(index, pname, params);
}

static void REGAL_CALL loader_glVertexAttribL1i64NV(GLuint index, GLint64EXT x)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribL1i64NV, "glVertexAttribL1i64NV");
  if (_driver.glVertexAttribL1i64NV) {
    _driver.glVertexAttribL1i64NV(index, x);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribL1i64NV)(index, x);
}

static void REGAL_CALL loader_glVertexAttribL1i64vNV(GLuint index, const GLint64EXT *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribL1i64vNV, "glVertexAttribL1i64vNV");
  if (_driver.glVertexAttribL1i64vNV) {
    _driver.glVertexAttribL1i64vNV(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribL1i64vNV)(index, v);
}

static void REGAL_CALL loader_glVertexAttribL1ui64NV(GLuint index, GLuint64EXT x)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribL1ui64NV, "glVertexAttribL1ui64NV");
  if (_driver.glVertexAttribL1ui64NV) {
    _driver.glVertexAttribL1ui64NV(index, x);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribL1ui64NV)(index, x);
}

static void REGAL_CALL loader_glVertexAttribL1ui64vNV(GLuint index, const GLuint64EXT *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribL1ui64vNV, "glVertexAttribL1ui64vNV");
  if (_driver.glVertexAttribL1ui64vNV) {
    _driver.glVertexAttribL1ui64vNV(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribL1ui64vNV)(index, v);
}

static void REGAL_CALL loader_glVertexAttribL2i64NV(GLuint index, GLint64EXT x, GLint64EXT y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribL2i64NV, "glVertexAttribL2i64NV");
  if (_driver.glVertexAttribL2i64NV) {
    _driver.glVertexAttribL2i64NV(index, x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribL2i64NV)(index, x, y);
}

static void REGAL_CALL loader_glVertexAttribL2i64vNV(GLuint index, const GLint64EXT *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribL2i64vNV, "glVertexAttribL2i64vNV");
  if (_driver.glVertexAttribL2i64vNV) {
    _driver.glVertexAttribL2i64vNV(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribL2i64vNV)(index, v);
}

static void REGAL_CALL loader_glVertexAttribL2ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribL2ui64NV, "glVertexAttribL2ui64NV");
  if (_driver.glVertexAttribL2ui64NV) {
    _driver.glVertexAttribL2ui64NV(index, x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribL2ui64NV)(index, x, y);
}

static void REGAL_CALL loader_glVertexAttribL2ui64vNV(GLuint index, const GLuint64EXT *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribL2ui64vNV, "glVertexAttribL2ui64vNV");
  if (_driver.glVertexAttribL2ui64vNV) {
    _driver.glVertexAttribL2ui64vNV(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribL2ui64vNV)(index, v);
}

static void REGAL_CALL loader_glVertexAttribL3i64NV(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribL3i64NV, "glVertexAttribL3i64NV");
  if (_driver.glVertexAttribL3i64NV) {
    _driver.glVertexAttribL3i64NV(index, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribL3i64NV)(index, x, y, z);
}

static void REGAL_CALL loader_glVertexAttribL3i64vNV(GLuint index, const GLint64EXT *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribL3i64vNV, "glVertexAttribL3i64vNV");
  if (_driver.glVertexAttribL3i64vNV) {
    _driver.glVertexAttribL3i64vNV(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribL3i64vNV)(index, v);
}

static void REGAL_CALL loader_glVertexAttribL3ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribL3ui64NV, "glVertexAttribL3ui64NV");
  if (_driver.glVertexAttribL3ui64NV) {
    _driver.glVertexAttribL3ui64NV(index, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribL3ui64NV)(index, x, y, z);
}

static void REGAL_CALL loader_glVertexAttribL3ui64vNV(GLuint index, const GLuint64EXT *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribL3ui64vNV, "glVertexAttribL3ui64vNV");
  if (_driver.glVertexAttribL3ui64vNV) {
    _driver.glVertexAttribL3ui64vNV(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribL3ui64vNV)(index, v);
}

static void REGAL_CALL loader_glVertexAttribL4i64NV(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribL4i64NV, "glVertexAttribL4i64NV");
  if (_driver.glVertexAttribL4i64NV) {
    _driver.glVertexAttribL4i64NV(index, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribL4i64NV)(index, x, y, z, w);
}

static void REGAL_CALL loader_glVertexAttribL4i64vNV(GLuint index, const GLint64EXT *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribL4i64vNV, "glVertexAttribL4i64vNV");
  if (_driver.glVertexAttribL4i64vNV) {
    _driver.glVertexAttribL4i64vNV(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribL4i64vNV)(index, v);
}

static void REGAL_CALL loader_glVertexAttribL4ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribL4ui64NV, "glVertexAttribL4ui64NV");
  if (_driver.glVertexAttribL4ui64NV) {
    _driver.glVertexAttribL4ui64NV(index, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribL4ui64NV)(index, x, y, z, w);
}

static void REGAL_CALL loader_glVertexAttribL4ui64vNV(GLuint index, const GLuint64EXT *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribL4ui64vNV, "glVertexAttribL4ui64vNV");
  if (_driver.glVertexAttribL4ui64vNV) {
    _driver.glVertexAttribL4ui64vNV(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribL4ui64vNV)(index, v);
}

static void REGAL_CALL loader_glVertexAttribLFormatNV(GLuint index, GLint size, GLenum type, GLsizei stride)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribLFormatNV, "glVertexAttribLFormatNV");
  if (_driver.glVertexAttribLFormatNV) {
    _driver.glVertexAttribLFormatNV(index, size, type, stride);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribLFormatNV)(index, size, type, stride);
}

// GL_NV_vertex_buffer_unified_memory

static void REGAL_CALL loader_glBufferAddressRangeNV(GLenum pname, GLuint index, GLuint64EXT address, GLsizeiptr length)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBufferAddressRangeNV, "glBufferAddressRangeNV");
  if (_driver.glBufferAddressRangeNV) {
    _driver.glBufferAddressRangeNV(pname, index, address, length);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBufferAddressRangeNV)(pname, index, address, length);
}

static void REGAL_CALL loader_glColorFormatNV(GLint size, GLenum type, GLsizei stride)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColorFormatNV, "glColorFormatNV");
  if (_driver.glColorFormatNV) {
    _driver.glColorFormatNV(size, type, stride);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColorFormatNV)(size, type, stride);
}

static void REGAL_CALL loader_glEdgeFlagFormatNV(GLsizei stride)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glEdgeFlagFormatNV, "glEdgeFlagFormatNV");
  if (_driver.glEdgeFlagFormatNV) {
    _driver.glEdgeFlagFormatNV(stride);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glEdgeFlagFormatNV)(stride);
}

static void REGAL_CALL loader_glFogCoordFormatNV(GLenum type, GLsizei stride)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFogCoordFormatNV, "glFogCoordFormatNV");
  if (_driver.glFogCoordFormatNV) {
    _driver.glFogCoordFormatNV(type, stride);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFogCoordFormatNV)(type, stride);
}

static void REGAL_CALL loader_glGetIntegerui64i_vNV(GLenum target, GLuint index, GLuint64EXT *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetIntegerui64i_vNV, "glGetIntegerui64i_vNV");
  if (_driver.glGetIntegerui64i_vNV) {
    _driver.glGetIntegerui64i_vNV(target, index, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetIntegerui64i_vNV)(target, index, data);
}

static void REGAL_CALL loader_glIndexFormatNV(GLenum type, GLsizei stride)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIndexFormatNV, "glIndexFormatNV");
  if (_driver.glIndexFormatNV) {
    _driver.glIndexFormatNV(type, stride);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glIndexFormatNV)(type, stride);
}

static void REGAL_CALL loader_glNormalFormatNV(GLenum type, GLsizei stride)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNormalFormatNV, "glNormalFormatNV");
  if (_driver.glNormalFormatNV) {
    _driver.glNormalFormatNV(type, stride);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNormalFormatNV)(type, stride);
}

static void REGAL_CALL loader_glSecondaryColorFormatNV(GLint size, GLenum type, GLsizei stride)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSecondaryColorFormatNV, "glSecondaryColorFormatNV");
  if (_driver.glSecondaryColorFormatNV) {
    _driver.glSecondaryColorFormatNV(size, type, stride);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSecondaryColorFormatNV)(size, type, stride);
}

static void REGAL_CALL loader_glTexCoordFormatNV(GLint size, GLenum type, GLsizei stride)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoordFormatNV, "glTexCoordFormatNV");
  if (_driver.glTexCoordFormatNV) {
    _driver.glTexCoordFormatNV(size, type, stride);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoordFormatNV)(size, type, stride);
}

static void REGAL_CALL loader_glVertexAttribFormatNV(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribFormatNV, "glVertexAttribFormatNV");
  if (_driver.glVertexAttribFormatNV) {
    _driver.glVertexAttribFormatNV(index, size, type, normalized, stride);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribFormatNV)(index, size, type, normalized, stride);
}

static void REGAL_CALL loader_glVertexAttribIFormatNV(GLuint index, GLint size, GLenum type, GLsizei stride)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribIFormatNV, "glVertexAttribIFormatNV");
  if (_driver.glVertexAttribIFormatNV) {
    _driver.glVertexAttribIFormatNV(index, size, type, stride);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribIFormatNV)(index, size, type, stride);
}

static void REGAL_CALL loader_glVertexFormatNV(GLint size, GLenum type, GLsizei stride)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexFormatNV, "glVertexFormatNV");
  if (_driver.glVertexFormatNV) {
    _driver.glVertexFormatNV(size, type, stride);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexFormatNV)(size, type, stride);
}

// GL_NV_vertex_program

static GLboolean REGAL_CALL loader_glAreProgramsResidentNV(GLsizei n, const GLuint *programs, GLboolean *residences)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glAreProgramsResidentNV, "glAreProgramsResidentNV");
  if (_driver.glAreProgramsResidentNV) {
    return _driver.glAreProgramsResidentNV(n, programs, residences);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glAreProgramsResidentNV)(n, programs, residences);
}

static void REGAL_CALL loader_glBindProgramNV(GLenum target, GLuint id)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBindProgramNV, "glBindProgramNV");
  if (_driver.glBindProgramNV) {
    _driver.glBindProgramNV(target, id);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBindProgramNV)(target, id);
}

static void REGAL_CALL loader_glDeleteProgramsNV(GLsizei n, const GLuint *programs)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDeleteProgramsNV, "glDeleteProgramsNV");
  if (_driver.glDeleteProgramsNV) {
    _driver.glDeleteProgramsNV(n, programs);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDeleteProgramsNV)(n, programs);
}

static void REGAL_CALL loader_glExecuteProgramNV(GLenum target, GLuint id, const GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glExecuteProgramNV, "glExecuteProgramNV");
  if (_driver.glExecuteProgramNV) {
    _driver.glExecuteProgramNV(target, id, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glExecuteProgramNV)(target, id, params);
}

static void REGAL_CALL loader_glGenProgramsNV(GLsizei n, GLuint *programs)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGenProgramsNV, "glGenProgramsNV");
  if (_driver.glGenProgramsNV) {
    _driver.glGenProgramsNV(n, programs);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGenProgramsNV)(n, programs);
}

static void REGAL_CALL loader_glGetProgramParameterdvNV(GLenum target, GLuint index, GLenum pname, GLdouble *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetProgramParameterdvNV, "glGetProgramParameterdvNV");
  if (_driver.glGetProgramParameterdvNV) {
    _driver.glGetProgramParameterdvNV(target, index, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetProgramParameterdvNV)(target, index, pname, params);
}

static void REGAL_CALL loader_glGetProgramParameterfvNV(GLenum target, GLuint index, GLenum pname, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetProgramParameterfvNV, "glGetProgramParameterfvNV");
  if (_driver.glGetProgramParameterfvNV) {
    _driver.glGetProgramParameterfvNV(target, index, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetProgramParameterfvNV)(target, index, pname, params);
}

static void REGAL_CALL loader_glGetProgramStringNV(GLuint id, GLenum pname, GLubyte *program)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetProgramStringNV, "glGetProgramStringNV");
  if (_driver.glGetProgramStringNV) {
    _driver.glGetProgramStringNV(id, pname, program);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetProgramStringNV)(id, pname, program);
}

static void REGAL_CALL loader_glGetProgramivNV(GLuint id, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetProgramivNV, "glGetProgramivNV");
  if (_driver.glGetProgramivNV) {
    _driver.glGetProgramivNV(id, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetProgramivNV)(id, pname, params);
}

static void REGAL_CALL loader_glGetTrackMatrixivNV(GLenum target, GLuint address, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetTrackMatrixivNV, "glGetTrackMatrixivNV");
  if (_driver.glGetTrackMatrixivNV) {
    _driver.glGetTrackMatrixivNV(target, address, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetTrackMatrixivNV)(target, address, pname, params);
}

static void REGAL_CALL loader_glGetVertexAttribPointervNV(GLuint index, GLenum pname, GLvoid **pointer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetVertexAttribPointervNV, "glGetVertexAttribPointervNV");
  if (_driver.glGetVertexAttribPointervNV) {
    _driver.glGetVertexAttribPointervNV(index, pname, pointer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetVertexAttribPointervNV)(index, pname, pointer);
}

static void REGAL_CALL loader_glGetVertexAttribdvNV(GLuint index, GLenum pname, GLdouble *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetVertexAttribdvNV, "glGetVertexAttribdvNV");
  if (_driver.glGetVertexAttribdvNV) {
    _driver.glGetVertexAttribdvNV(index, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetVertexAttribdvNV)(index, pname, params);
}

static void REGAL_CALL loader_glGetVertexAttribfvNV(GLuint index, GLenum pname, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetVertexAttribfvNV, "glGetVertexAttribfvNV");
  if (_driver.glGetVertexAttribfvNV) {
    _driver.glGetVertexAttribfvNV(index, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetVertexAttribfvNV)(index, pname, params);
}

static void REGAL_CALL loader_glGetVertexAttribivNV(GLuint index, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetVertexAttribivNV, "glGetVertexAttribivNV");
  if (_driver.glGetVertexAttribivNV) {
    _driver.glGetVertexAttribivNV(index, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetVertexAttribivNV)(index, pname, params);
}

static GLboolean REGAL_CALL loader_glIsProgramNV(GLuint id)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIsProgramNV, "glIsProgramNV");
  if (_driver.glIsProgramNV) {
    return _driver.glIsProgramNV(id);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glIsProgramNV)(id);
}

static void REGAL_CALL loader_glLoadProgramNV(GLenum target, GLuint id, GLsizei len, const GLubyte *program)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glLoadProgramNV, "glLoadProgramNV");
  if (_driver.glLoadProgramNV) {
    _driver.glLoadProgramNV(target, id, len, program);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glLoadProgramNV)(target, id, len, program);
}

static void REGAL_CALL loader_glProgramParameter4dNV(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramParameter4dNV, "glProgramParameter4dNV");
  if (_driver.glProgramParameter4dNV) {
    _driver.glProgramParameter4dNV(target, index, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramParameter4dNV)(target, index, x, y, z, w);
}

static void REGAL_CALL loader_glProgramParameter4dvNV(GLenum target, GLuint index, const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramParameter4dvNV, "glProgramParameter4dvNV");
  if (_driver.glProgramParameter4dvNV) {
    _driver.glProgramParameter4dvNV(target, index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramParameter4dvNV)(target, index, v);
}

static void REGAL_CALL loader_glProgramParameter4fNV(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramParameter4fNV, "glProgramParameter4fNV");
  if (_driver.glProgramParameter4fNV) {
    _driver.glProgramParameter4fNV(target, index, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramParameter4fNV)(target, index, x, y, z, w);
}

static void REGAL_CALL loader_glProgramParameter4fvNV(GLenum target, GLuint index, const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramParameter4fvNV, "glProgramParameter4fvNV");
  if (_driver.glProgramParameter4fvNV) {
    _driver.glProgramParameter4fvNV(target, index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramParameter4fvNV)(target, index, v);
}

static void REGAL_CALL loader_glProgramParameters4dvNV(GLenum target, GLuint index, GLuint count, const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramParameters4dvNV, "glProgramParameters4dvNV");
  if (_driver.glProgramParameters4dvNV) {
    _driver.glProgramParameters4dvNV(target, index, count, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramParameters4dvNV)(target, index, count, v);
}

static void REGAL_CALL loader_glProgramParameters4fvNV(GLenum target, GLuint index, GLuint count, const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramParameters4fvNV, "glProgramParameters4fvNV");
  if (_driver.glProgramParameters4fvNV) {
    _driver.glProgramParameters4fvNV(target, index, count, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramParameters4fvNV)(target, index, count, v);
}

static void REGAL_CALL loader_glRequestResidentProgramsNV(GLsizei n, const GLuint *programs)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glRequestResidentProgramsNV, "glRequestResidentProgramsNV");
  if (_driver.glRequestResidentProgramsNV) {
    _driver.glRequestResidentProgramsNV(n, programs);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glRequestResidentProgramsNV)(n, programs);
}

static void REGAL_CALL loader_glTrackMatrixNV(GLenum target, GLuint address, GLenum matrix, GLenum transform)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTrackMatrixNV, "glTrackMatrixNV");
  if (_driver.glTrackMatrixNV) {
    _driver.glTrackMatrixNV(target, address, matrix, transform);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTrackMatrixNV)(target, address, matrix, transform);
}

static void REGAL_CALL loader_glVertexAttrib1dNV(GLuint index, GLdouble x)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib1dNV, "glVertexAttrib1dNV");
  if (_driver.glVertexAttrib1dNV) {
    _driver.glVertexAttrib1dNV(index, x);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib1dNV)(index, x);
}

static void REGAL_CALL loader_glVertexAttrib1dvNV(GLuint index, const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib1dvNV, "glVertexAttrib1dvNV");
  if (_driver.glVertexAttrib1dvNV) {
    _driver.glVertexAttrib1dvNV(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib1dvNV)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib1fNV(GLuint index, GLfloat x)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib1fNV, "glVertexAttrib1fNV");
  if (_driver.glVertexAttrib1fNV) {
    _driver.glVertexAttrib1fNV(index, x);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib1fNV)(index, x);
}

static void REGAL_CALL loader_glVertexAttrib1fvNV(GLuint index, const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib1fvNV, "glVertexAttrib1fvNV");
  if (_driver.glVertexAttrib1fvNV) {
    _driver.glVertexAttrib1fvNV(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib1fvNV)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib1sNV(GLuint index, GLshort x)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib1sNV, "glVertexAttrib1sNV");
  if (_driver.glVertexAttrib1sNV) {
    _driver.glVertexAttrib1sNV(index, x);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib1sNV)(index, x);
}

static void REGAL_CALL loader_glVertexAttrib1svNV(GLuint index, const GLshort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib1svNV, "glVertexAttrib1svNV");
  if (_driver.glVertexAttrib1svNV) {
    _driver.glVertexAttrib1svNV(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib1svNV)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib2dNV(GLuint index, GLdouble x, GLdouble y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib2dNV, "glVertexAttrib2dNV");
  if (_driver.glVertexAttrib2dNV) {
    _driver.glVertexAttrib2dNV(index, x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib2dNV)(index, x, y);
}

static void REGAL_CALL loader_glVertexAttrib2dvNV(GLuint index, const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib2dvNV, "glVertexAttrib2dvNV");
  if (_driver.glVertexAttrib2dvNV) {
    _driver.glVertexAttrib2dvNV(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib2dvNV)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib2fNV(GLuint index, GLfloat x, GLfloat y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib2fNV, "glVertexAttrib2fNV");
  if (_driver.glVertexAttrib2fNV) {
    _driver.glVertexAttrib2fNV(index, x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib2fNV)(index, x, y);
}

static void REGAL_CALL loader_glVertexAttrib2fvNV(GLuint index, const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib2fvNV, "glVertexAttrib2fvNV");
  if (_driver.glVertexAttrib2fvNV) {
    _driver.glVertexAttrib2fvNV(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib2fvNV)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib2sNV(GLuint index, GLshort x, GLshort y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib2sNV, "glVertexAttrib2sNV");
  if (_driver.glVertexAttrib2sNV) {
    _driver.glVertexAttrib2sNV(index, x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib2sNV)(index, x, y);
}

static void REGAL_CALL loader_glVertexAttrib2svNV(GLuint index, const GLshort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib2svNV, "glVertexAttrib2svNV");
  if (_driver.glVertexAttrib2svNV) {
    _driver.glVertexAttrib2svNV(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib2svNV)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib3dNV(GLuint index, GLdouble x, GLdouble y, GLdouble z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib3dNV, "glVertexAttrib3dNV");
  if (_driver.glVertexAttrib3dNV) {
    _driver.glVertexAttrib3dNV(index, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib3dNV)(index, x, y, z);
}

static void REGAL_CALL loader_glVertexAttrib3dvNV(GLuint index, const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib3dvNV, "glVertexAttrib3dvNV");
  if (_driver.glVertexAttrib3dvNV) {
    _driver.glVertexAttrib3dvNV(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib3dvNV)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib3fNV(GLuint index, GLfloat x, GLfloat y, GLfloat z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib3fNV, "glVertexAttrib3fNV");
  if (_driver.glVertexAttrib3fNV) {
    _driver.glVertexAttrib3fNV(index, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib3fNV)(index, x, y, z);
}

static void REGAL_CALL loader_glVertexAttrib3fvNV(GLuint index, const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib3fvNV, "glVertexAttrib3fvNV");
  if (_driver.glVertexAttrib3fvNV) {
    _driver.glVertexAttrib3fvNV(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib3fvNV)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib3sNV(GLuint index, GLshort x, GLshort y, GLshort z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib3sNV, "glVertexAttrib3sNV");
  if (_driver.glVertexAttrib3sNV) {
    _driver.glVertexAttrib3sNV(index, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib3sNV)(index, x, y, z);
}

static void REGAL_CALL loader_glVertexAttrib3svNV(GLuint index, const GLshort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib3svNV, "glVertexAttrib3svNV");
  if (_driver.glVertexAttrib3svNV) {
    _driver.glVertexAttrib3svNV(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib3svNV)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib4dNV(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib4dNV, "glVertexAttrib4dNV");
  if (_driver.glVertexAttrib4dNV) {
    _driver.glVertexAttrib4dNV(index, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib4dNV)(index, x, y, z, w);
}

static void REGAL_CALL loader_glVertexAttrib4dvNV(GLuint index, const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib4dvNV, "glVertexAttrib4dvNV");
  if (_driver.glVertexAttrib4dvNV) {
    _driver.glVertexAttrib4dvNV(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib4dvNV)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib4fNV(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib4fNV, "glVertexAttrib4fNV");
  if (_driver.glVertexAttrib4fNV) {
    _driver.glVertexAttrib4fNV(index, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib4fNV)(index, x, y, z, w);
}

static void REGAL_CALL loader_glVertexAttrib4fvNV(GLuint index, const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib4fvNV, "glVertexAttrib4fvNV");
  if (_driver.glVertexAttrib4fvNV) {
    _driver.glVertexAttrib4fvNV(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib4fvNV)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib4sNV(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib4sNV, "glVertexAttrib4sNV");
  if (_driver.glVertexAttrib4sNV) {
    _driver.glVertexAttrib4sNV(index, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib4sNV)(index, x, y, z, w);
}

static void REGAL_CALL loader_glVertexAttrib4svNV(GLuint index, const GLshort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib4svNV, "glVertexAttrib4svNV");
  if (_driver.glVertexAttrib4svNV) {
    _driver.glVertexAttrib4svNV(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib4svNV)(index, v);
}

static void REGAL_CALL loader_glVertexAttrib4ubNV(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib4ubNV, "glVertexAttrib4ubNV");
  if (_driver.glVertexAttrib4ubNV) {
    _driver.glVertexAttrib4ubNV(index, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib4ubNV)(index, x, y, z, w);
}

static void REGAL_CALL loader_glVertexAttrib4ubvNV(GLuint index, const GLubyte *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttrib4ubvNV, "glVertexAttrib4ubvNV");
  if (_driver.glVertexAttrib4ubvNV) {
    _driver.glVertexAttrib4ubvNV(index, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttrib4ubvNV)(index, v);
}

static void REGAL_CALL loader_glVertexAttribPointerNV(GLuint index, GLint fsize, GLenum type, GLsizei stride, const GLvoid *pointer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribPointerNV, "glVertexAttribPointerNV");
  if (_driver.glVertexAttribPointerNV) {
    _driver.glVertexAttribPointerNV(index, fsize, type, stride, pointer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribPointerNV)(index, fsize, type, stride, pointer);
}

static void REGAL_CALL loader_glVertexAttribs1dvNV(GLuint index, GLsizei n, const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribs1dvNV, "glVertexAttribs1dvNV");
  if (_driver.glVertexAttribs1dvNV) {
    _driver.glVertexAttribs1dvNV(index, n, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribs1dvNV)(index, n, v);
}

static void REGAL_CALL loader_glVertexAttribs1fvNV(GLuint index, GLsizei n, const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribs1fvNV, "glVertexAttribs1fvNV");
  if (_driver.glVertexAttribs1fvNV) {
    _driver.glVertexAttribs1fvNV(index, n, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribs1fvNV)(index, n, v);
}

static void REGAL_CALL loader_glVertexAttribs1svNV(GLuint index, GLsizei n, const GLshort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribs1svNV, "glVertexAttribs1svNV");
  if (_driver.glVertexAttribs1svNV) {
    _driver.glVertexAttribs1svNV(index, n, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribs1svNV)(index, n, v);
}

static void REGAL_CALL loader_glVertexAttribs2dvNV(GLuint index, GLsizei n, const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribs2dvNV, "glVertexAttribs2dvNV");
  if (_driver.glVertexAttribs2dvNV) {
    _driver.glVertexAttribs2dvNV(index, n, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribs2dvNV)(index, n, v);
}

static void REGAL_CALL loader_glVertexAttribs2fvNV(GLuint index, GLsizei n, const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribs2fvNV, "glVertexAttribs2fvNV");
  if (_driver.glVertexAttribs2fvNV) {
    _driver.glVertexAttribs2fvNV(index, n, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribs2fvNV)(index, n, v);
}

static void REGAL_CALL loader_glVertexAttribs2svNV(GLuint index, GLsizei n, const GLshort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribs2svNV, "glVertexAttribs2svNV");
  if (_driver.glVertexAttribs2svNV) {
    _driver.glVertexAttribs2svNV(index, n, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribs2svNV)(index, n, v);
}

static void REGAL_CALL loader_glVertexAttribs3dvNV(GLuint index, GLsizei n, const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribs3dvNV, "glVertexAttribs3dvNV");
  if (_driver.glVertexAttribs3dvNV) {
    _driver.glVertexAttribs3dvNV(index, n, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribs3dvNV)(index, n, v);
}

static void REGAL_CALL loader_glVertexAttribs3fvNV(GLuint index, GLsizei n, const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribs3fvNV, "glVertexAttribs3fvNV");
  if (_driver.glVertexAttribs3fvNV) {
    _driver.glVertexAttribs3fvNV(index, n, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribs3fvNV)(index, n, v);
}

static void REGAL_CALL loader_glVertexAttribs3svNV(GLuint index, GLsizei n, const GLshort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribs3svNV, "glVertexAttribs3svNV");
  if (_driver.glVertexAttribs3svNV) {
    _driver.glVertexAttribs3svNV(index, n, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribs3svNV)(index, n, v);
}

static void REGAL_CALL loader_glVertexAttribs4dvNV(GLuint index, GLsizei n, const GLdouble *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribs4dvNV, "glVertexAttribs4dvNV");
  if (_driver.glVertexAttribs4dvNV) {
    _driver.glVertexAttribs4dvNV(index, n, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribs4dvNV)(index, n, v);
}

static void REGAL_CALL loader_glVertexAttribs4fvNV(GLuint index, GLsizei n, const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribs4fvNV, "glVertexAttribs4fvNV");
  if (_driver.glVertexAttribs4fvNV) {
    _driver.glVertexAttribs4fvNV(index, n, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribs4fvNV)(index, n, v);
}

static void REGAL_CALL loader_glVertexAttribs4svNV(GLuint index, GLsizei n, const GLshort *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribs4svNV, "glVertexAttribs4svNV");
  if (_driver.glVertexAttribs4svNV) {
    _driver.glVertexAttribs4svNV(index, n, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribs4svNV)(index, n, v);
}

static void REGAL_CALL loader_glVertexAttribs4ubvNV(GLuint index, GLsizei n, const GLubyte *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVertexAttribs4ubvNV, "glVertexAttribs4ubvNV");
  if (_driver.glVertexAttribs4ubvNV) {
    _driver.glVertexAttribs4ubvNV(index, n, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVertexAttribs4ubvNV)(index, n, v);
}

// GL_NV_video_capture

static void REGAL_CALL loader_glBeginVideoCaptureNV(GLuint video_capture_slot)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBeginVideoCaptureNV, "glBeginVideoCaptureNV");
  if (_driver.glBeginVideoCaptureNV) {
    _driver.glBeginVideoCaptureNV(video_capture_slot);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBeginVideoCaptureNV)(video_capture_slot);
}

static void REGAL_CALL loader_glBindVideoCaptureStreamBufferNV(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLintptr offset)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBindVideoCaptureStreamBufferNV, "glBindVideoCaptureStreamBufferNV");
  if (_driver.glBindVideoCaptureStreamBufferNV) {
    _driver.glBindVideoCaptureStreamBufferNV(video_capture_slot, stream, frame_region, offset);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBindVideoCaptureStreamBufferNV)(video_capture_slot, stream, frame_region, offset);
}

static void REGAL_CALL loader_glBindVideoCaptureStreamTextureNV(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLenum target, GLuint texture)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBindVideoCaptureStreamTextureNV, "glBindVideoCaptureStreamTextureNV");
  if (_driver.glBindVideoCaptureStreamTextureNV) {
    _driver.glBindVideoCaptureStreamTextureNV(video_capture_slot, stream, frame_region, target, texture);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBindVideoCaptureStreamTextureNV)(video_capture_slot, stream, frame_region, target, texture);
}

static void REGAL_CALL loader_glEndVideoCaptureNV(GLuint video_capture_slot)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glEndVideoCaptureNV, "glEndVideoCaptureNV");
  if (_driver.glEndVideoCaptureNV) {
    _driver.glEndVideoCaptureNV(video_capture_slot);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glEndVideoCaptureNV)(video_capture_slot);
}

static void REGAL_CALL loader_glGetVideoCaptureStreamdvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, GLdouble *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetVideoCaptureStreamdvNV, "glGetVideoCaptureStreamdvNV");
  if (_driver.glGetVideoCaptureStreamdvNV) {
    _driver.glGetVideoCaptureStreamdvNV(video_capture_slot, stream, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetVideoCaptureStreamdvNV)(video_capture_slot, stream, pname, params);
}

static void REGAL_CALL loader_glGetVideoCaptureStreamfvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetVideoCaptureStreamfvNV, "glGetVideoCaptureStreamfvNV");
  if (_driver.glGetVideoCaptureStreamfvNV) {
    _driver.glGetVideoCaptureStreamfvNV(video_capture_slot, stream, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetVideoCaptureStreamfvNV)(video_capture_slot, stream, pname, params);
}

static void REGAL_CALL loader_glGetVideoCaptureStreamivNV(GLuint video_capture_slot, GLuint stream, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetVideoCaptureStreamivNV, "glGetVideoCaptureStreamivNV");
  if (_driver.glGetVideoCaptureStreamivNV) {
    _driver.glGetVideoCaptureStreamivNV(video_capture_slot, stream, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetVideoCaptureStreamivNV)(video_capture_slot, stream, pname, params);
}

static void REGAL_CALL loader_glGetVideoCaptureivNV(GLuint video_capture_slot, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetVideoCaptureivNV, "glGetVideoCaptureivNV");
  if (_driver.glGetVideoCaptureivNV) {
    _driver.glGetVideoCaptureivNV(video_capture_slot, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetVideoCaptureivNV)(video_capture_slot, pname, params);
}

static GLenum REGAL_CALL loader_glVideoCaptureNV(GLuint video_capture_slot, GLuint *sequence_num, GLuint64EXT *capture_time)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVideoCaptureNV, "glVideoCaptureNV");
  if (_driver.glVideoCaptureNV) {
    return _driver.glVideoCaptureNV(video_capture_slot, sequence_num, capture_time);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glVideoCaptureNV)(video_capture_slot, sequence_num, capture_time);
}

static void REGAL_CALL loader_glVideoCaptureStreamParameterdvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLdouble *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVideoCaptureStreamParameterdvNV, "glVideoCaptureStreamParameterdvNV");
  if (_driver.glVideoCaptureStreamParameterdvNV) {
    _driver.glVideoCaptureStreamParameterdvNV(video_capture_slot, stream, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVideoCaptureStreamParameterdvNV)(video_capture_slot, stream, pname, params);
}

static void REGAL_CALL loader_glVideoCaptureStreamParameterfvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVideoCaptureStreamParameterfvNV, "glVideoCaptureStreamParameterfvNV");
  if (_driver.glVideoCaptureStreamParameterfvNV) {
    _driver.glVideoCaptureStreamParameterfvNV(video_capture_slot, stream, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVideoCaptureStreamParameterfvNV)(video_capture_slot, stream, pname, params);
}

static void REGAL_CALL loader_glVideoCaptureStreamParameterivNV(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glVideoCaptureStreamParameterivNV, "glVideoCaptureStreamParameterivNV");
  if (_driver.glVideoCaptureStreamParameterivNV) {
    _driver.glVideoCaptureStreamParameterivNV(video_capture_slot, stream, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glVideoCaptureStreamParameterivNV)(video_capture_slot, stream, pname, params);
}

// GL_OES_blend_equation_separate

static void REGAL_CALL loader_glBlendEquationSeparateOES(GLenum modeRGB, GLenum modeAlpha)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBlendEquationSeparateOES, "glBlendEquationSeparateOES");
  if (_driver.glBlendEquationSeparateOES) {
    _driver.glBlendEquationSeparateOES(modeRGB, modeAlpha);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBlendEquationSeparateOES)(modeRGB, modeAlpha);
}

// GL_OES_blend_func_separate

static void REGAL_CALL loader_glBlendFuncSeparateOES(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBlendFuncSeparateOES, "glBlendFuncSeparateOES");
  if (_driver.glBlendFuncSeparateOES) {
    _driver.glBlendFuncSeparateOES(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBlendFuncSeparateOES)(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
}

// GL_OES_blend_subtract

static void REGAL_CALL loader_glBlendEquationOES(GLenum mode)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBlendEquationOES, "glBlendEquationOES");
  if (_driver.glBlendEquationOES) {
    _driver.glBlendEquationOES(mode);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBlendEquationOES)(mode);
}

// GL_OES_framebuffer_object

static void REGAL_CALL loader_glBindFramebufferOES(GLenum target, GLuint framebuffer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBindFramebufferOES, "glBindFramebufferOES");
  if (_driver.glBindFramebufferOES) {
    _driver.glBindFramebufferOES(target, framebuffer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBindFramebufferOES)(target, framebuffer);
}

static void REGAL_CALL loader_glBindRenderbufferOES(GLenum target, GLuint renderbuffer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBindRenderbufferOES, "glBindRenderbufferOES");
  if (_driver.glBindRenderbufferOES) {
    _driver.glBindRenderbufferOES(target, renderbuffer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBindRenderbufferOES)(target, renderbuffer);
}

static GLenum REGAL_CALL loader_glCheckFramebufferStatusOES(GLenum target)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCheckFramebufferStatusOES, "glCheckFramebufferStatusOES");
  if (_driver.glCheckFramebufferStatusOES) {
    return _driver.glCheckFramebufferStatusOES(target);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glCheckFramebufferStatusOES)(target);
}

static void REGAL_CALL loader_glDeleteFramebuffersOES(GLsizei n, const GLuint *framebuffers)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDeleteFramebuffersOES, "glDeleteFramebuffersOES");
  if (_driver.glDeleteFramebuffersOES) {
    _driver.glDeleteFramebuffersOES(n, framebuffers);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDeleteFramebuffersOES)(n, framebuffers);
}

static void REGAL_CALL loader_glDeleteRenderbuffersOES(GLsizei n, const GLuint *renderbuffers)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDeleteRenderbuffersOES, "glDeleteRenderbuffersOES");
  if (_driver.glDeleteRenderbuffersOES) {
    _driver.glDeleteRenderbuffersOES(n, renderbuffers);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDeleteRenderbuffersOES)(n, renderbuffers);
}

static void REGAL_CALL loader_glFramebufferRenderbufferOES(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFramebufferRenderbufferOES, "glFramebufferRenderbufferOES");
  if (_driver.glFramebufferRenderbufferOES) {
    _driver.glFramebufferRenderbufferOES(target, attachment, renderbuffertarget, renderbuffer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFramebufferRenderbufferOES)(target, attachment, renderbuffertarget, renderbuffer);
}

static void REGAL_CALL loader_glFramebufferTexture2DOES(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFramebufferTexture2DOES, "glFramebufferTexture2DOES");
  if (_driver.glFramebufferTexture2DOES) {
    _driver.glFramebufferTexture2DOES(target, attachment, textarget, texture, level);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFramebufferTexture2DOES)(target, attachment, textarget, texture, level);
}

static void REGAL_CALL loader_glGenFramebuffersOES(GLsizei n, GLuint *framebuffers)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGenFramebuffersOES, "glGenFramebuffersOES");
  if (_driver.glGenFramebuffersOES) {
    _driver.glGenFramebuffersOES(n, framebuffers);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGenFramebuffersOES)(n, framebuffers);
}

static void REGAL_CALL loader_glGenRenderbuffersOES(GLsizei n, GLuint *renderbuffers)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGenRenderbuffersOES, "glGenRenderbuffersOES");
  if (_driver.glGenRenderbuffersOES) {
    _driver.glGenRenderbuffersOES(n, renderbuffers);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGenRenderbuffersOES)(n, renderbuffers);
}

static void REGAL_CALL loader_glGenerateMipmapOES(GLenum target)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGenerateMipmapOES, "glGenerateMipmapOES");
  if (_driver.glGenerateMipmapOES) {
    _driver.glGenerateMipmapOES(target);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGenerateMipmapOES)(target);
}

static void REGAL_CALL loader_glGetFramebufferAttachmentParameterivOES(GLenum target, GLenum attachment, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetFramebufferAttachmentParameterivOES, "glGetFramebufferAttachmentParameterivOES");
  if (_driver.glGetFramebufferAttachmentParameterivOES) {
    _driver.glGetFramebufferAttachmentParameterivOES(target, attachment, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetFramebufferAttachmentParameterivOES)(target, attachment, pname, params);
}

static void REGAL_CALL loader_glGetRenderbufferParameterivOES(GLenum target, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetRenderbufferParameterivOES, "glGetRenderbufferParameterivOES");
  if (_driver.glGetRenderbufferParameterivOES) {
    _driver.glGetRenderbufferParameterivOES(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetRenderbufferParameterivOES)(target, pname, params);
}

static GLboolean REGAL_CALL loader_glIsFramebufferOES(GLuint framebuffer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIsFramebufferOES, "glIsFramebufferOES");
  if (_driver.glIsFramebufferOES) {
    return _driver.glIsFramebufferOES(framebuffer);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glIsFramebufferOES)(framebuffer);
}

static GLboolean REGAL_CALL loader_glIsRenderbufferOES(GLuint renderbuffer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIsRenderbufferOES, "glIsRenderbufferOES");
  if (_driver.glIsRenderbufferOES) {
    return _driver.glIsRenderbufferOES(renderbuffer);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glIsRenderbufferOES)(renderbuffer);
}

static void REGAL_CALL loader_glRenderbufferStorageOES(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glRenderbufferStorageOES, "glRenderbufferStorageOES");
  if (_driver.glRenderbufferStorageOES) {
    _driver.glRenderbufferStorageOES(target, internalformat, width, height);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glRenderbufferStorageOES)(target, internalformat, width, height);
}

// GL_OES_get_program_binary

static void REGAL_CALL loader_glGetProgramBinaryOES(GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, GLvoid *binary)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetProgramBinaryOES, "glGetProgramBinaryOES");
  if (_driver.glGetProgramBinaryOES) {
    _driver.glGetProgramBinaryOES(program, bufSize, length, binaryFormat, binary);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetProgramBinaryOES)(program, bufSize, length, binaryFormat, binary);
}

static void REGAL_CALL loader_glProgramBinaryOES(GLuint program, GLenum binaryFormat, const GLvoid *binary, GLint length)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glProgramBinaryOES, "glProgramBinaryOES");
  if (_driver.glProgramBinaryOES) {
    _driver.glProgramBinaryOES(program, binaryFormat, binary, length);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glProgramBinaryOES)(program, binaryFormat, binary, length);
}

// GL_OES_mapbuffer

static void REGAL_CALL loader_glGetBufferPointervOES(GLenum target, GLenum pname, GLvoid **params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetBufferPointervOES, "glGetBufferPointervOES");
  if (_driver.glGetBufferPointervOES) {
    _driver.glGetBufferPointervOES(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetBufferPointervOES)(target, pname, params);
}

static GLvoid *REGAL_CALL loader_glMapBufferOES(GLenum target, GLenum access)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMapBufferOES, "glMapBufferOES");
  if (_driver.glMapBufferOES) {
    return _driver.glMapBufferOES(target, access);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glMapBufferOES)(target, access);
}

static GLboolean REGAL_CALL loader_glUnmapBufferOES(GLenum target)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glUnmapBufferOES, "glUnmapBufferOES");
  if (_driver.glUnmapBufferOES) {
    return _driver.glUnmapBufferOES(target);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glUnmapBufferOES)(target);
}

// GL_OES_matrix_palette

static void REGAL_CALL loader_glCurrentPaletteMatrixOES(GLuint index)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCurrentPaletteMatrixOES, "glCurrentPaletteMatrixOES");
  if (_driver.glCurrentPaletteMatrixOES) {
    _driver.glCurrentPaletteMatrixOES(index);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCurrentPaletteMatrixOES)(index);
}

static void REGAL_CALL loader_glMatrixIndexPointerOES(GLint size, GLenum type, GLsizei stride, GLvoid *pointer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glMatrixIndexPointerOES, "glMatrixIndexPointerOES");
  if (_driver.glMatrixIndexPointerOES) {
    _driver.glMatrixIndexPointerOES(size, type, stride, pointer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glMatrixIndexPointerOES)(size, type, stride, pointer);
}

static void REGAL_CALL loader_glWeightPointerOES(GLint size, GLenum type, GLsizei stride, GLvoid *pointer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glWeightPointerOES, "glWeightPointerOES");
  if (_driver.glWeightPointerOES) {
    _driver.glWeightPointerOES(size, type, stride, pointer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glWeightPointerOES)(size, type, stride, pointer);
}

// GL_OES_single_precision

static void REGAL_CALL loader_glClearDepthfOES(GLclampd depth)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glClearDepthfOES, "glClearDepthfOES");
  if (_driver.glClearDepthfOES) {
    _driver.glClearDepthfOES(depth);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glClearDepthfOES)(depth);
}

static void REGAL_CALL loader_glClipPlanefOES(GLenum plane, const GLfloat *equation)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glClipPlanefOES, "glClipPlanefOES");
  if (_driver.glClipPlanefOES) {
    _driver.glClipPlanefOES(plane, equation);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glClipPlanefOES)(plane, equation);
}

static void REGAL_CALL loader_glDepthRangefOES(GLclampf n, GLclampf f)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDepthRangefOES, "glDepthRangefOES");
  if (_driver.glDepthRangefOES) {
    _driver.glDepthRangefOES(n, f);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDepthRangefOES)(n, f);
}

static void REGAL_CALL loader_glFrustumfOES(GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFrustumfOES, "glFrustumfOES");
  if (_driver.glFrustumfOES) {
    _driver.glFrustumfOES(l, r, b, t, n, f);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFrustumfOES)(l, r, b, t, n, f);
}

static void REGAL_CALL loader_glGetClipPlanefOES(GLenum plane, GLfloat *equation)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetClipPlanefOES, "glGetClipPlanefOES");
  if (_driver.glGetClipPlanefOES) {
    _driver.glGetClipPlanefOES(plane, equation);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetClipPlanefOES)(plane, equation);
}

static void REGAL_CALL loader_glOrthofOES(GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glOrthofOES, "glOrthofOES");
  if (_driver.glOrthofOES) {
    _driver.glOrthofOES(l, r, b, t, n, f);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glOrthofOES)(l, r, b, t, n, f);
}

// GL_OES_texture_3D

static void REGAL_CALL loader_glCompressedTexImage3DOES(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCompressedTexImage3DOES, "glCompressedTexImage3DOES");
  if (_driver.glCompressedTexImage3DOES) {
    _driver.glCompressedTexImage3DOES(target, level, internalformat, width, height, depth, border, imageSize, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCompressedTexImage3DOES)(target, level, internalformat, width, height, depth, border, imageSize, data);
}

static void REGAL_CALL loader_glCompressedTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCompressedTexSubImage3DOES, "glCompressedTexSubImage3DOES");
  if (_driver.glCompressedTexSubImage3DOES) {
    _driver.glCompressedTexSubImage3DOES(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCompressedTexSubImage3DOES)(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
}

static void REGAL_CALL loader_glCopyTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCopyTexSubImage3DOES, "glCopyTexSubImage3DOES");
  if (_driver.glCopyTexSubImage3DOES) {
    _driver.glCopyTexSubImage3DOES(target, level, xoffset, yoffset, zoffset, x, y, width, height);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCopyTexSubImage3DOES)(target, level, xoffset, yoffset, zoffset, x, y, width, height);
}

static void REGAL_CALL loader_glFramebufferTexture3DOES(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFramebufferTexture3DOES, "glFramebufferTexture3DOES");
  if (_driver.glFramebufferTexture3DOES) {
    _driver.glFramebufferTexture3DOES(target, attachment, textarget, texture, level, zoffset);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFramebufferTexture3DOES)(target, attachment, textarget, texture, level, zoffset);
}

static void REGAL_CALL loader_glTexImage3DOES(GLenum target, GLint level, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexImage3DOES, "glTexImage3DOES");
  if (_driver.glTexImage3DOES) {
    _driver.glTexImage3DOES(target, level, internalFormat, width, height, depth, border, format, type, pixels);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexImage3DOES)(target, level, internalFormat, width, height, depth, border, format, type, pixels);
}

static void REGAL_CALL loader_glTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexSubImage3DOES, "glTexSubImage3DOES");
  if (_driver.glTexSubImage3DOES) {
    _driver.glTexSubImage3DOES(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexSubImage3DOES)(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
}

// GL_OES_texture_cube_map

static void REGAL_CALL loader_glGetTexGenfvOES(GLenum coord, GLenum pname, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetTexGenfvOES, "glGetTexGenfvOES");
  if (_driver.glGetTexGenfvOES) {
    _driver.glGetTexGenfvOES(coord, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetTexGenfvOES)(coord, pname, params);
}

static void REGAL_CALL loader_glGetTexGenivOES(GLenum coord, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetTexGenivOES, "glGetTexGenivOES");
  if (_driver.glGetTexGenivOES) {
    _driver.glGetTexGenivOES(coord, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetTexGenivOES)(coord, pname, params);
}

static void REGAL_CALL loader_glGetTexGenxvOES(GLenum coord, GLenum pname, GLfixed *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetTexGenxvOES, "glGetTexGenxvOES");
  if (_driver.glGetTexGenxvOES) {
    _driver.glGetTexGenxvOES(coord, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetTexGenxvOES)(coord, pname, params);
}

static void REGAL_CALL loader_glTexGenfOES(GLenum coord, GLenum pname, GLfloat param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexGenfOES, "glTexGenfOES");
  if (_driver.glTexGenfOES) {
    _driver.glTexGenfOES(coord, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexGenfOES)(coord, pname, param);
}

static void REGAL_CALL loader_glTexGenfvOES(GLenum coord, GLenum pname, const GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexGenfvOES, "glTexGenfvOES");
  if (_driver.glTexGenfvOES) {
    _driver.glTexGenfvOES(coord, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexGenfvOES)(coord, pname, params);
}

static void REGAL_CALL loader_glTexGeniOES(GLenum coord, GLenum pname, GLint param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexGeniOES, "glTexGeniOES");
  if (_driver.glTexGeniOES) {
    _driver.glTexGeniOES(coord, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexGeniOES)(coord, pname, param);
}

static void REGAL_CALL loader_glTexGenivOES(GLenum coord, GLenum pname, const GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexGenivOES, "glTexGenivOES");
  if (_driver.glTexGenivOES) {
    _driver.glTexGenivOES(coord, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexGenivOES)(coord, pname, params);
}

static void REGAL_CALL loader_glTexGenxOES(GLenum coord, GLenum pname, GLfixed param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexGenxOES, "glTexGenxOES");
  if (_driver.glTexGenxOES) {
    _driver.glTexGenxOES(coord, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexGenxOES)(coord, pname, param);
}

static void REGAL_CALL loader_glTexGenxvOES(GLenum coord, GLenum pname, const GLfixed *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexGenxvOES, "glTexGenxvOES");
  if (_driver.glTexGenxvOES) {
    _driver.glTexGenxvOES(coord, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexGenxvOES)(coord, pname, params);
}

// GL_OES_vertex_array_object

static void REGAL_CALL loader_glBindVertexArrayOES(GLuint array)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glBindVertexArrayOES, "glBindVertexArrayOES");
  if (_driver.glBindVertexArrayOES) {
    _driver.glBindVertexArrayOES(array);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glBindVertexArrayOES)(array);
}

static void REGAL_CALL loader_glDeleteVertexArraysOES(GLsizei n, const GLuint *arrays)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDeleteVertexArraysOES, "glDeleteVertexArraysOES");
  if (_driver.glDeleteVertexArraysOES) {
    _driver.glDeleteVertexArraysOES(n, arrays);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDeleteVertexArraysOES)(n, arrays);
}

static void REGAL_CALL loader_glGenVertexArraysOES(GLsizei n, GLuint *arrays)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGenVertexArraysOES, "glGenVertexArraysOES");
  if (_driver.glGenVertexArraysOES) {
    _driver.glGenVertexArraysOES(n, arrays);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGenVertexArraysOES)(n, arrays);
}

static GLboolean REGAL_CALL loader_glIsVertexArrayOES(GLuint array)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIsVertexArrayOES, "glIsVertexArrayOES");
  if (_driver.glIsVertexArrayOES) {
    return _driver.glIsVertexArrayOES(array);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glIsVertexArrayOES)(array);
}

// GL_PGI_misc_hints

static void REGAL_CALL loader_glHintPGI(GLenum target, GLint mode)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glHintPGI, "glHintPGI");
  if (_driver.glHintPGI) {
    _driver.glHintPGI(target, mode);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glHintPGI)(target, mode);
}

// GL_QCOM_alpha_test

static void REGAL_CALL loader_glAlphaFuncQCOM(GLenum func, GLclampf ref)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glAlphaFuncQCOM, "glAlphaFuncQCOM");
  if (_driver.glAlphaFuncQCOM) {
    _driver.glAlphaFuncQCOM(func, ref);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glAlphaFuncQCOM)(func, ref);
}

// GL_QCOM_driver_control

static void REGAL_CALL loader_glDisableDriverControlQCOM(GLuint driverControl)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDisableDriverControlQCOM, "glDisableDriverControlQCOM");
  if (_driver.glDisableDriverControlQCOM) {
    _driver.glDisableDriverControlQCOM(driverControl);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDisableDriverControlQCOM)(driverControl);
}

static void REGAL_CALL loader_glEnableDriverControlQCOM(GLuint driverControl)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glEnableDriverControlQCOM, "glEnableDriverControlQCOM");
  if (_driver.glEnableDriverControlQCOM) {
    _driver.glEnableDriverControlQCOM(driverControl);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glEnableDriverControlQCOM)(driverControl);
}

static void REGAL_CALL loader_glGetDriverControlStringQCOM(GLuint driverControl, GLsizei bufSize, GLsizei *length, GLchar *driverControlString)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetDriverControlStringQCOM, "glGetDriverControlStringQCOM");
  if (_driver.glGetDriverControlStringQCOM) {
    _driver.glGetDriverControlStringQCOM(driverControl, bufSize, length, driverControlString);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetDriverControlStringQCOM)(driverControl, bufSize, length, driverControlString);
}

static void REGAL_CALL loader_glGetDriverControlsQCOM(GLint *num, GLsizei size, GLuint *driverControls)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetDriverControlsQCOM, "glGetDriverControlsQCOM");
  if (_driver.glGetDriverControlsQCOM) {
    _driver.glGetDriverControlsQCOM(num, size, driverControls);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetDriverControlsQCOM)(num, size, driverControls);
}

// GL_QCOM_extended_get

static void REGAL_CALL loader_glExtGetBufferPointervQCOM(GLenum target, GLvoid **params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glExtGetBufferPointervQCOM, "glExtGetBufferPointervQCOM");
  if (_driver.glExtGetBufferPointervQCOM) {
    _driver.glExtGetBufferPointervQCOM(target, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glExtGetBufferPointervQCOM)(target, params);
}

static void REGAL_CALL loader_glExtGetBuffersQCOM(GLuint *buffers, GLint maxBuffers, GLint *numBuffers)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glExtGetBuffersQCOM, "glExtGetBuffersQCOM");
  if (_driver.glExtGetBuffersQCOM) {
    _driver.glExtGetBuffersQCOM(buffers, maxBuffers, numBuffers);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glExtGetBuffersQCOM)(buffers, maxBuffers, numBuffers);
}

static void REGAL_CALL loader_glExtGetFramebuffersQCOM(GLuint *framebuffers, GLint maxFramebuffers, GLint *numFramebuffers)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glExtGetFramebuffersQCOM, "glExtGetFramebuffersQCOM");
  if (_driver.glExtGetFramebuffersQCOM) {
    _driver.glExtGetFramebuffersQCOM(framebuffers, maxFramebuffers, numFramebuffers);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glExtGetFramebuffersQCOM)(framebuffers, maxFramebuffers, numFramebuffers);
}

static void REGAL_CALL loader_glExtGetRenderbuffersQCOM(GLuint *renderbuffers, GLint maxRenderbuffers, GLint *numRenderbuffers)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glExtGetRenderbuffersQCOM, "glExtGetRenderbuffersQCOM");
  if (_driver.glExtGetRenderbuffersQCOM) {
    _driver.glExtGetRenderbuffersQCOM(renderbuffers, maxRenderbuffers, numRenderbuffers);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glExtGetRenderbuffersQCOM)(renderbuffers, maxRenderbuffers, numRenderbuffers);
}

static void REGAL_CALL loader_glExtGetTexLevelParameterivQCOM(GLuint texture, GLenum face, GLint level, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glExtGetTexLevelParameterivQCOM, "glExtGetTexLevelParameterivQCOM");
  if (_driver.glExtGetTexLevelParameterivQCOM) {
    _driver.glExtGetTexLevelParameterivQCOM(texture, face, level, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glExtGetTexLevelParameterivQCOM)(texture, face, level, pname, params);
}

static void REGAL_CALL loader_glExtGetTexSubImageQCOM(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLvoid *texels)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glExtGetTexSubImageQCOM, "glExtGetTexSubImageQCOM");
  if (_driver.glExtGetTexSubImageQCOM) {
    _driver.glExtGetTexSubImageQCOM(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, texels);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glExtGetTexSubImageQCOM)(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, texels);
}

static void REGAL_CALL loader_glExtGetTexturesQCOM(GLuint *textures, GLint maxTextures, GLint *numTextures)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glExtGetTexturesQCOM, "glExtGetTexturesQCOM");
  if (_driver.glExtGetTexturesQCOM) {
    _driver.glExtGetTexturesQCOM(textures, maxTextures, numTextures);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glExtGetTexturesQCOM)(textures, maxTextures, numTextures);
}

static void REGAL_CALL loader_glExtTexObjectStateOverrideiQCOM(GLenum target, GLenum pname, GLint param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glExtTexObjectStateOverrideiQCOM, "glExtTexObjectStateOverrideiQCOM");
  if (_driver.glExtTexObjectStateOverrideiQCOM) {
    _driver.glExtTexObjectStateOverrideiQCOM(target, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glExtTexObjectStateOverrideiQCOM)(target, pname, param);
}

// GL_QCOM_extended_get2

static void REGAL_CALL loader_glExtGetProgramBinarySourceQCOM(GLuint program, GLenum shadertype, GLchar *source, GLint *length)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glExtGetProgramBinarySourceQCOM, "glExtGetProgramBinarySourceQCOM");
  if (_driver.glExtGetProgramBinarySourceQCOM) {
    _driver.glExtGetProgramBinarySourceQCOM(program, shadertype, source, length);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glExtGetProgramBinarySourceQCOM)(program, shadertype, source, length);
}

static void REGAL_CALL loader_glExtGetProgramsQCOM(GLuint *programs, GLint maxPrograms, GLint *numPrograms)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glExtGetProgramsQCOM, "glExtGetProgramsQCOM");
  if (_driver.glExtGetProgramsQCOM) {
    _driver.glExtGetProgramsQCOM(programs, maxPrograms, numPrograms);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glExtGetProgramsQCOM)(programs, maxPrograms, numPrograms);
}

static void REGAL_CALL loader_glExtGetShadersQCOM(GLuint *shaders, GLint maxShaders, GLint *numShaders)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glExtGetShadersQCOM, "glExtGetShadersQCOM");
  if (_driver.glExtGetShadersQCOM) {
    _driver.glExtGetShadersQCOM(shaders, maxShaders, numShaders);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glExtGetShadersQCOM)(shaders, maxShaders, numShaders);
}

static GLboolean REGAL_CALL loader_glExtIsProgramBinaryQCOM(GLuint program)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glExtIsProgramBinaryQCOM, "glExtIsProgramBinaryQCOM");
  if (_driver.glExtIsProgramBinaryQCOM) {
    return _driver.glExtIsProgramBinaryQCOM(program);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glExtIsProgramBinaryQCOM)(program);
}

// GL_QCOM_tiled_rendering

static void REGAL_CALL loader_glEndTilingQCOM(GLbitfield preserveMask)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glEndTilingQCOM, "glEndTilingQCOM");
  if (_driver.glEndTilingQCOM) {
    _driver.glEndTilingQCOM(preserveMask);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glEndTilingQCOM)(preserveMask);
}

static void REGAL_CALL loader_glStartTilingQCOM(GLuint x, GLuint y, GLuint width, GLuint height, GLbitfield preserveMask)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glStartTilingQCOM, "glStartTilingQCOM");
  if (_driver.glStartTilingQCOM) {
    _driver.glStartTilingQCOM(x, y, width, height, preserveMask);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glStartTilingQCOM)(x, y, width, height, preserveMask);
}

// GL_REGAL_ES1_1_compatibility

static void REGAL_CALL loader_glPointSizePointerOES(GLenum type, GLsizei stride, const GLvoid *pointer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPointSizePointerOES, "glPointSizePointerOES");
  if (_driver.glPointSizePointerOES) {
    _driver.glPointSizePointerOES(type, stride, pointer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPointSizePointerOES)(type, stride, pointer);
}

// GL_REGAL_log

static void REGAL_CALL loader_glLogMessageCallbackREGAL(GLLOGPROCREGAL callback)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glLogMessageCallbackREGAL, "glLogMessageCallbackREGAL");
  if (_driver.glLogMessageCallbackREGAL) {
    _driver.glLogMessageCallbackREGAL(callback);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glLogMessageCallbackREGAL)(callback);
}

// GL_SGIS_detail_texture

static void REGAL_CALL loader_glDetailTexFuncSGIS(GLenum target, GLsizei n, const GLfloat *points)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDetailTexFuncSGIS, "glDetailTexFuncSGIS");
  if (_driver.glDetailTexFuncSGIS) {
    _driver.glDetailTexFuncSGIS(target, n, points);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDetailTexFuncSGIS)(target, n, points);
}

static void REGAL_CALL loader_glGetDetailTexFuncSGIS(GLenum target, GLfloat *points)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetDetailTexFuncSGIS, "glGetDetailTexFuncSGIS");
  if (_driver.glGetDetailTexFuncSGIS) {
    _driver.glGetDetailTexFuncSGIS(target, points);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetDetailTexFuncSGIS)(target, points);
}

// GL_SGIS_fog_function

static void REGAL_CALL loader_glFogFuncSGIS(GLsizei n, const GLfloat *points)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFogFuncSGIS, "glFogFuncSGIS");
  if (_driver.glFogFuncSGIS) {
    _driver.glFogFuncSGIS(n, points);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFogFuncSGIS)(n, points);
}

static void REGAL_CALL loader_glGetFogFuncSGIS(GLfloat *points)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetFogFuncSGIS, "glGetFogFuncSGIS");
  if (_driver.glGetFogFuncSGIS) {
    _driver.glGetFogFuncSGIS(points);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetFogFuncSGIS)(points);
}

// GL_SGIS_multisample

static void REGAL_CALL loader_glSampleMaskSGIS(GLclampf value, GLboolean invert)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSampleMaskSGIS, "glSampleMaskSGIS");
  if (_driver.glSampleMaskSGIS) {
    _driver.glSampleMaskSGIS(value, invert);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSampleMaskSGIS)(value, invert);
}

static void REGAL_CALL loader_glSamplePatternSGIS(GLenum pattern)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSamplePatternSGIS, "glSamplePatternSGIS");
  if (_driver.glSamplePatternSGIS) {
    _driver.glSamplePatternSGIS(pattern);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSamplePatternSGIS)(pattern);
}

// GL_SGIS_pixel_texture

static void REGAL_CALL loader_glGetPixelTexGenParameterfvSGIS(GLenum pname, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetPixelTexGenParameterfvSGIS, "glGetPixelTexGenParameterfvSGIS");
  if (_driver.glGetPixelTexGenParameterfvSGIS) {
    _driver.glGetPixelTexGenParameterfvSGIS(pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetPixelTexGenParameterfvSGIS)(pname, params);
}

static void REGAL_CALL loader_glGetPixelTexGenParameterivSGIS(GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetPixelTexGenParameterivSGIS, "glGetPixelTexGenParameterivSGIS");
  if (_driver.glGetPixelTexGenParameterivSGIS) {
    _driver.glGetPixelTexGenParameterivSGIS(pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetPixelTexGenParameterivSGIS)(pname, params);
}

static void REGAL_CALL loader_glPixelTexGenParameterfSGIS(GLenum pname, GLfloat param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPixelTexGenParameterfSGIS, "glPixelTexGenParameterfSGIS");
  if (_driver.glPixelTexGenParameterfSGIS) {
    _driver.glPixelTexGenParameterfSGIS(pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPixelTexGenParameterfSGIS)(pname, param);
}

static void REGAL_CALL loader_glPixelTexGenParameterfvSGIS(GLenum pname, const GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPixelTexGenParameterfvSGIS, "glPixelTexGenParameterfvSGIS");
  if (_driver.glPixelTexGenParameterfvSGIS) {
    _driver.glPixelTexGenParameterfvSGIS(pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPixelTexGenParameterfvSGIS)(pname, params);
}

static void REGAL_CALL loader_glPixelTexGenParameteriSGIS(GLenum pname, GLint param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPixelTexGenParameteriSGIS, "glPixelTexGenParameteriSGIS");
  if (_driver.glPixelTexGenParameteriSGIS) {
    _driver.glPixelTexGenParameteriSGIS(pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPixelTexGenParameteriSGIS)(pname, param);
}

static void REGAL_CALL loader_glPixelTexGenParameterivSGIS(GLenum pname, const GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPixelTexGenParameterivSGIS, "glPixelTexGenParameterivSGIS");
  if (_driver.glPixelTexGenParameterivSGIS) {
    _driver.glPixelTexGenParameterivSGIS(pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPixelTexGenParameterivSGIS)(pname, params);
}

// GL_SGIS_point_parameters

static void REGAL_CALL loader_glPointParameterfSGIS(GLenum pname, GLfloat param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPointParameterfSGIS, "glPointParameterfSGIS");
  if (_driver.glPointParameterfSGIS) {
    _driver.glPointParameterfSGIS(pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPointParameterfSGIS)(pname, param);
}

static void REGAL_CALL loader_glPointParameterfvSGIS(GLenum pname, const GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPointParameterfvSGIS, "glPointParameterfvSGIS");
  if (_driver.glPointParameterfvSGIS) {
    _driver.glPointParameterfvSGIS(pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPointParameterfvSGIS)(pname, params);
}

// GL_SGIS_sharpen_texture

static void REGAL_CALL loader_glGetSharpenTexFuncSGIS(GLenum target, GLfloat *points)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetSharpenTexFuncSGIS, "glGetSharpenTexFuncSGIS");
  if (_driver.glGetSharpenTexFuncSGIS) {
    _driver.glGetSharpenTexFuncSGIS(target, points);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetSharpenTexFuncSGIS)(target, points);
}

static void REGAL_CALL loader_glSharpenTexFuncSGIS(GLenum target, GLsizei n, const GLfloat *points)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSharpenTexFuncSGIS, "glSharpenTexFuncSGIS");
  if (_driver.glSharpenTexFuncSGIS) {
    _driver.glSharpenTexFuncSGIS(target, n, points);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSharpenTexFuncSGIS)(target, n, points);
}

// GL_SGIS_texture4D

static void REGAL_CALL loader_glTexImage4DSGIS(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexImage4DSGIS, "glTexImage4DSGIS");
  if (_driver.glTexImage4DSGIS) {
    _driver.glTexImage4DSGIS(target, level, internalformat, width, height, depth, size4d, border, format, type, pixels);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexImage4DSGIS)(target, level, internalformat, width, height, depth, size4d, border, format, type, pixels);
}

static void REGAL_CALL loader_glTexSubImage4DSGIS(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLenum format, GLenum type, const GLvoid *pixels)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexSubImage4DSGIS, "glTexSubImage4DSGIS");
  if (_driver.glTexSubImage4DSGIS) {
    _driver.glTexSubImage4DSGIS(target, level, xoffset, yoffset, zoffset, woffset, width, height, depth, size4d, format, type, pixels);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexSubImage4DSGIS)(target, level, xoffset, yoffset, zoffset, woffset, width, height, depth, size4d, format, type, pixels);
}

// GL_SGIS_texture_color_mask

static void REGAL_CALL loader_glTextureColorMaskSGIS(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTextureColorMaskSGIS, "glTextureColorMaskSGIS");
  if (_driver.glTextureColorMaskSGIS) {
    _driver.glTextureColorMaskSGIS(red, green, blue, alpha);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTextureColorMaskSGIS)(red, green, blue, alpha);
}

// GL_SGIS_texture_filter4

static void REGAL_CALL loader_glGetTexFilterFuncSGIS(GLenum target, GLenum filter, GLfloat *weights)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetTexFilterFuncSGIS, "glGetTexFilterFuncSGIS");
  if (_driver.glGetTexFilterFuncSGIS) {
    _driver.glGetTexFilterFuncSGIS(target, filter, weights);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetTexFilterFuncSGIS)(target, filter, weights);
}

static void REGAL_CALL loader_glTexFilterFuncSGIS(GLenum target, GLenum filter, GLsizei n, const GLfloat *weights)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexFilterFuncSGIS, "glTexFilterFuncSGIS");
  if (_driver.glTexFilterFuncSGIS) {
    _driver.glTexFilterFuncSGIS(target, filter, n, weights);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexFilterFuncSGIS)(target, filter, n, weights);
}

// GL_SGIX_async

static void REGAL_CALL loader_glAsyncMarkerSGIX(GLuint marker)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glAsyncMarkerSGIX, "glAsyncMarkerSGIX");
  if (_driver.glAsyncMarkerSGIX) {
    _driver.glAsyncMarkerSGIX(marker);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glAsyncMarkerSGIX)(marker);
}

static void REGAL_CALL loader_glDeleteAsyncMarkersSGIX(GLuint marker, GLsizei range)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDeleteAsyncMarkersSGIX, "glDeleteAsyncMarkersSGIX");
  if (_driver.glDeleteAsyncMarkersSGIX) {
    _driver.glDeleteAsyncMarkersSGIX(marker, range);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDeleteAsyncMarkersSGIX)(marker, range);
}

static GLint REGAL_CALL loader_glFinishAsyncSGIX(GLuint *markerp)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFinishAsyncSGIX, "glFinishAsyncSGIX");
  if (_driver.glFinishAsyncSGIX) {
    return _driver.glFinishAsyncSGIX(markerp);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glFinishAsyncSGIX)(markerp);
}

static GLuint REGAL_CALL loader_glGenAsyncMarkersSGIX(GLsizei range)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGenAsyncMarkersSGIX, "glGenAsyncMarkersSGIX");
  if (_driver.glGenAsyncMarkersSGIX) {
    return _driver.glGenAsyncMarkersSGIX(range);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glGenAsyncMarkersSGIX)(range);
}

static GLboolean REGAL_CALL loader_glIsAsyncMarkerSGIX(GLuint marker)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIsAsyncMarkerSGIX, "glIsAsyncMarkerSGIX");
  if (_driver.glIsAsyncMarkerSGIX) {
    return _driver.glIsAsyncMarkerSGIX(marker);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glIsAsyncMarkerSGIX)(marker);
}

static GLint REGAL_CALL loader_glPollAsyncSGIX(GLuint *markerp)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPollAsyncSGIX, "glPollAsyncSGIX");
  if (_driver.glPollAsyncSGIX) {
    return _driver.glPollAsyncSGIX(markerp);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glPollAsyncSGIX)(markerp);
}

// GL_SGIX_flush_raster

static void REGAL_CALL loader_glFlushRasterSGIX(void)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFlushRasterSGIX, "glFlushRasterSGIX");
  if (_driver.glFlushRasterSGIX) {
    _driver.glFlushRasterSGIX();
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFlushRasterSGIX)();
}

// GL_SGIX_fog_texture

static void REGAL_CALL loader_glTextureFogSGIX(GLenum pname)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTextureFogSGIX, "glTextureFogSGIX");
  if (_driver.glTextureFogSGIX) {
    _driver.glTextureFogSGIX(pname);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTextureFogSGIX)(pname);
}

// GL_SGIX_fragment_lighting

static void REGAL_CALL loader_glFragmentColorMaterialSGIX(GLenum face, GLenum mode)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFragmentColorMaterialSGIX, "glFragmentColorMaterialSGIX");
  if (_driver.glFragmentColorMaterialSGIX) {
    _driver.glFragmentColorMaterialSGIX(face, mode);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFragmentColorMaterialSGIX)(face, mode);
}

static void REGAL_CALL loader_glFragmentLightModelfSGIX(GLenum pname, GLfloat param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFragmentLightModelfSGIX, "glFragmentLightModelfSGIX");
  if (_driver.glFragmentLightModelfSGIX) {
    _driver.glFragmentLightModelfSGIX(pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFragmentLightModelfSGIX)(pname, param);
}

static void REGAL_CALL loader_glFragmentLightModelfvSGIX(GLenum pname, const GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFragmentLightModelfvSGIX, "glFragmentLightModelfvSGIX");
  if (_driver.glFragmentLightModelfvSGIX) {
    _driver.glFragmentLightModelfvSGIX(pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFragmentLightModelfvSGIX)(pname, params);
}

static void REGAL_CALL loader_glFragmentLightModeliSGIX(GLenum pname, GLint param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFragmentLightModeliSGIX, "glFragmentLightModeliSGIX");
  if (_driver.glFragmentLightModeliSGIX) {
    _driver.glFragmentLightModeliSGIX(pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFragmentLightModeliSGIX)(pname, param);
}

static void REGAL_CALL loader_glFragmentLightModelivSGIX(GLenum pname, const GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFragmentLightModelivSGIX, "glFragmentLightModelivSGIX");
  if (_driver.glFragmentLightModelivSGIX) {
    _driver.glFragmentLightModelivSGIX(pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFragmentLightModelivSGIX)(pname, params);
}

static void REGAL_CALL loader_glFragmentLightfSGIX(GLenum light, GLenum pname, GLfloat param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFragmentLightfSGIX, "glFragmentLightfSGIX");
  if (_driver.glFragmentLightfSGIX) {
    _driver.glFragmentLightfSGIX(light, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFragmentLightfSGIX)(light, pname, param);
}

static void REGAL_CALL loader_glFragmentLightfvSGIX(GLenum light, GLenum pname, const GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFragmentLightfvSGIX, "glFragmentLightfvSGIX");
  if (_driver.glFragmentLightfvSGIX) {
    _driver.glFragmentLightfvSGIX(light, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFragmentLightfvSGIX)(light, pname, params);
}

static void REGAL_CALL loader_glFragmentLightiSGIX(GLenum light, GLenum pname, GLint param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFragmentLightiSGIX, "glFragmentLightiSGIX");
  if (_driver.glFragmentLightiSGIX) {
    _driver.glFragmentLightiSGIX(light, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFragmentLightiSGIX)(light, pname, param);
}

static void REGAL_CALL loader_glFragmentLightivSGIX(GLenum light, GLenum pname, const GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFragmentLightivSGIX, "glFragmentLightivSGIX");
  if (_driver.glFragmentLightivSGIX) {
    _driver.glFragmentLightivSGIX(light, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFragmentLightivSGIX)(light, pname, params);
}

static void REGAL_CALL loader_glFragmentMaterialfSGIX(GLenum face, GLenum pname, GLfloat param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFragmentMaterialfSGIX, "glFragmentMaterialfSGIX");
  if (_driver.glFragmentMaterialfSGIX) {
    _driver.glFragmentMaterialfSGIX(face, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFragmentMaterialfSGIX)(face, pname, param);
}

static void REGAL_CALL loader_glFragmentMaterialfvSGIX(GLenum face, GLenum pname, const GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFragmentMaterialfvSGIX, "glFragmentMaterialfvSGIX");
  if (_driver.glFragmentMaterialfvSGIX) {
    _driver.glFragmentMaterialfvSGIX(face, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFragmentMaterialfvSGIX)(face, pname, params);
}

static void REGAL_CALL loader_glFragmentMaterialiSGIX(GLenum face, GLenum pname, GLint param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFragmentMaterialiSGIX, "glFragmentMaterialiSGIX");
  if (_driver.glFragmentMaterialiSGIX) {
    _driver.glFragmentMaterialiSGIX(face, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFragmentMaterialiSGIX)(face, pname, param);
}

static void REGAL_CALL loader_glFragmentMaterialivSGIX(GLenum face, GLenum pname, const GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFragmentMaterialivSGIX, "glFragmentMaterialivSGIX");
  if (_driver.glFragmentMaterialivSGIX) {
    _driver.glFragmentMaterialivSGIX(face, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFragmentMaterialivSGIX)(face, pname, params);
}

static void REGAL_CALL loader_glGetFragmentLightfvSGIX(GLenum light, GLenum pname, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetFragmentLightfvSGIX, "glGetFragmentLightfvSGIX");
  if (_driver.glGetFragmentLightfvSGIX) {
    _driver.glGetFragmentLightfvSGIX(light, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetFragmentLightfvSGIX)(light, pname, params);
}

static void REGAL_CALL loader_glGetFragmentLightivSGIX(GLenum light, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetFragmentLightivSGIX, "glGetFragmentLightivSGIX");
  if (_driver.glGetFragmentLightivSGIX) {
    _driver.glGetFragmentLightivSGIX(light, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetFragmentLightivSGIX)(light, pname, params);
}

static void REGAL_CALL loader_glGetFragmentMaterialfvSGIX(GLenum face, GLenum pname, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetFragmentMaterialfvSGIX, "glGetFragmentMaterialfvSGIX");
  if (_driver.glGetFragmentMaterialfvSGIX) {
    _driver.glGetFragmentMaterialfvSGIX(face, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetFragmentMaterialfvSGIX)(face, pname, params);
}

static void REGAL_CALL loader_glGetFragmentMaterialivSGIX(GLenum face, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetFragmentMaterialivSGIX, "glGetFragmentMaterialivSGIX");
  if (_driver.glGetFragmentMaterialivSGIX) {
    _driver.glGetFragmentMaterialivSGIX(face, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetFragmentMaterialivSGIX)(face, pname, params);
}

static void REGAL_CALL loader_glLightEnviSGIX(GLenum pname, GLint param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glLightEnviSGIX, "glLightEnviSGIX");
  if (_driver.glLightEnviSGIX) {
    _driver.glLightEnviSGIX(pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glLightEnviSGIX)(pname, param);
}

// GL_SGIX_framezoom

static void REGAL_CALL loader_glFrameZoomSGIX(GLint factor)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFrameZoomSGIX, "glFrameZoomSGIX");
  if (_driver.glFrameZoomSGIX) {
    _driver.glFrameZoomSGIX(factor);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFrameZoomSGIX)(factor);
}

// GL_SGIX_igloo_interface

static void REGAL_CALL loader_glIglooInterfaceSGIX(GLenum pname, const GLvoid *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glIglooInterfaceSGIX, "glIglooInterfaceSGIX");
  if (_driver.glIglooInterfaceSGIX) {
    _driver.glIglooInterfaceSGIX(pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glIglooInterfaceSGIX)(pname, params);
}

// GL_SGIX_instruments

static GLint REGAL_CALL loader_glGetInstrumentsSGIX(void)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetInstrumentsSGIX, "glGetInstrumentsSGIX");
  if (_driver.glGetInstrumentsSGIX) {
    return _driver.glGetInstrumentsSGIX();
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glGetInstrumentsSGIX)();
}

static void REGAL_CALL loader_glInstrumentsBufferSGIX(GLsizei size, GLint *buffer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glInstrumentsBufferSGIX, "glInstrumentsBufferSGIX");
  if (_driver.glInstrumentsBufferSGIX) {
    _driver.glInstrumentsBufferSGIX(size, buffer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glInstrumentsBufferSGIX)(size, buffer);
}

static GLint REGAL_CALL loader_glPollInstrumentsSGIX(GLint *marker_p)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPollInstrumentsSGIX, "glPollInstrumentsSGIX");
  if (_driver.glPollInstrumentsSGIX) {
    return _driver.glPollInstrumentsSGIX(marker_p);
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  return _next->call(&_next->glPollInstrumentsSGIX)(marker_p);
}

static void REGAL_CALL loader_glReadInstrumentsSGIX(GLint marker)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glReadInstrumentsSGIX, "glReadInstrumentsSGIX");
  if (_driver.glReadInstrumentsSGIX) {
    _driver.glReadInstrumentsSGIX(marker);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glReadInstrumentsSGIX)(marker);
}

static void REGAL_CALL loader_glStartInstrumentsSGIX(void)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glStartInstrumentsSGIX, "glStartInstrumentsSGIX");
  if (_driver.glStartInstrumentsSGIX) {
    _driver.glStartInstrumentsSGIX();
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glStartInstrumentsSGIX)();
}

static void REGAL_CALL loader_glStopInstrumentsSGIX(GLint marker)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glStopInstrumentsSGIX, "glStopInstrumentsSGIX");
  if (_driver.glStopInstrumentsSGIX) {
    _driver.glStopInstrumentsSGIX(marker);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glStopInstrumentsSGIX)(marker);
}

// GL_SGIX_list_priority

static void REGAL_CALL loader_glGetListParameterfvSGIX(GLuint list, GLenum pname, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetListParameterfvSGIX, "glGetListParameterfvSGIX");
  if (_driver.glGetListParameterfvSGIX) {
    _driver.glGetListParameterfvSGIX(list, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetListParameterfvSGIX)(list, pname, params);
}

static void REGAL_CALL loader_glGetListParameterivSGIX(GLuint list, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetListParameterivSGIX, "glGetListParameterivSGIX");
  if (_driver.glGetListParameterivSGIX) {
    _driver.glGetListParameterivSGIX(list, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetListParameterivSGIX)(list, pname, params);
}

static void REGAL_CALL loader_glListParameterfSGIX(GLuint list, GLenum pname, GLfloat param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glListParameterfSGIX, "glListParameterfSGIX");
  if (_driver.glListParameterfSGIX) {
    _driver.glListParameterfSGIX(list, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glListParameterfSGIX)(list, pname, param);
}

static void REGAL_CALL loader_glListParameterfvSGIX(GLuint list, GLenum pname, const GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glListParameterfvSGIX, "glListParameterfvSGIX");
  if (_driver.glListParameterfvSGIX) {
    _driver.glListParameterfvSGIX(list, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glListParameterfvSGIX)(list, pname, params);
}

static void REGAL_CALL loader_glListParameteriSGIX(GLuint list, GLenum pname, GLint param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glListParameteriSGIX, "glListParameteriSGIX");
  if (_driver.glListParameteriSGIX) {
    _driver.glListParameteriSGIX(list, pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glListParameteriSGIX)(list, pname, param);
}

static void REGAL_CALL loader_glListParameterivSGIX(GLuint list, GLenum pname, const GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glListParameterivSGIX, "glListParameterivSGIX");
  if (_driver.glListParameterivSGIX) {
    _driver.glListParameterivSGIX(list, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glListParameterivSGIX)(list, pname, params);
}

// GL_SGIX_pixel_texture

static void REGAL_CALL loader_glPixelTexGenSGIX(GLenum mode)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glPixelTexGenSGIX, "glPixelTexGenSGIX");
  if (_driver.glPixelTexGenSGIX) {
    _driver.glPixelTexGenSGIX(mode);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glPixelTexGenSGIX)(mode);
}

// GL_SGIX_polynomial_ffd

static void REGAL_CALL loader_glDeformSGIX(GLbitfield mask)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDeformSGIX, "glDeformSGIX");
  if (_driver.glDeformSGIX) {
    _driver.glDeformSGIX(mask);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDeformSGIX)(mask);
}

static void REGAL_CALL loader_glDeformationMap3dSGIX(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, GLdouble w1, GLdouble w2, GLint wstride, GLint worder, const GLdouble *points)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDeformationMap3dSGIX, "glDeformationMap3dSGIX");
  if (_driver.glDeformationMap3dSGIX) {
    _driver.glDeformationMap3dSGIX(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDeformationMap3dSGIX)(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
}

static void REGAL_CALL loader_glDeformationMap3fSGIX(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, GLfloat w1, GLfloat w2, GLint wstride, GLint worder, const GLfloat *points)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDeformationMap3fSGIX, "glDeformationMap3fSGIX");
  if (_driver.glDeformationMap3fSGIX) {
    _driver.glDeformationMap3fSGIX(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDeformationMap3fSGIX)(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
}

static void REGAL_CALL loader_glLoadIdentityDeformationMapSGIX(GLbitfield mask)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glLoadIdentityDeformationMapSGIX, "glLoadIdentityDeformationMapSGIX");
  if (_driver.glLoadIdentityDeformationMapSGIX) {
    _driver.glLoadIdentityDeformationMapSGIX(mask);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glLoadIdentityDeformationMapSGIX)(mask);
}

// GL_SGIX_reference_plane

static void REGAL_CALL loader_glReferencePlaneSGIX(const GLdouble *equation)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glReferencePlaneSGIX, "glReferencePlaneSGIX");
  if (_driver.glReferencePlaneSGIX) {
    _driver.glReferencePlaneSGIX(equation);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glReferencePlaneSGIX)(equation);
}

// GL_SGIX_sprite

static void REGAL_CALL loader_glSpriteParameterfSGIX(GLenum pname, GLfloat param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSpriteParameterfSGIX, "glSpriteParameterfSGIX");
  if (_driver.glSpriteParameterfSGIX) {
    _driver.glSpriteParameterfSGIX(pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSpriteParameterfSGIX)(pname, param);
}

static void REGAL_CALL loader_glSpriteParameterfvSGIX(GLenum pname, const GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSpriteParameterfvSGIX, "glSpriteParameterfvSGIX");
  if (_driver.glSpriteParameterfvSGIX) {
    _driver.glSpriteParameterfvSGIX(pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSpriteParameterfvSGIX)(pname, params);
}

static void REGAL_CALL loader_glSpriteParameteriSGIX(GLenum pname, GLint param)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSpriteParameteriSGIX, "glSpriteParameteriSGIX");
  if (_driver.glSpriteParameteriSGIX) {
    _driver.glSpriteParameteriSGIX(pname, param);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSpriteParameteriSGIX)(pname, param);
}

static void REGAL_CALL loader_glSpriteParameterivSGIX(GLenum pname, const GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glSpriteParameterivSGIX, "glSpriteParameterivSGIX");
  if (_driver.glSpriteParameterivSGIX) {
    _driver.glSpriteParameterivSGIX(pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glSpriteParameterivSGIX)(pname, params);
}

// GL_SGIX_tag_sample_buffer

static void REGAL_CALL loader_glTagSampleBufferSGIX(void)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTagSampleBufferSGIX, "glTagSampleBufferSGIX");
  if (_driver.glTagSampleBufferSGIX) {
    _driver.glTagSampleBufferSGIX();
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTagSampleBufferSGIX)();
}

// GL_SGI_color_table

static void REGAL_CALL loader_glColorTableParameterfvSGI(GLenum target, GLenum pname, const GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColorTableParameterfvSGI, "glColorTableParameterfvSGI");
  if (_driver.glColorTableParameterfvSGI) {
    _driver.glColorTableParameterfvSGI(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColorTableParameterfvSGI)(target, pname, params);
}

static void REGAL_CALL loader_glColorTableParameterivSGI(GLenum target, GLenum pname, const GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColorTableParameterivSGI, "glColorTableParameterivSGI");
  if (_driver.glColorTableParameterivSGI) {
    _driver.glColorTableParameterivSGI(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColorTableParameterivSGI)(target, pname, params);
}

static void REGAL_CALL loader_glColorTableSGI(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColorTableSGI, "glColorTableSGI");
  if (_driver.glColorTableSGI) {
    _driver.glColorTableSGI(target, internalformat, width, format, type, table);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColorTableSGI)(target, internalformat, width, format, type, table);
}

static void REGAL_CALL loader_glCopyColorTableSGI(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glCopyColorTableSGI, "glCopyColorTableSGI");
  if (_driver.glCopyColorTableSGI) {
    _driver.glCopyColorTableSGI(target, internalformat, x, y, width);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glCopyColorTableSGI)(target, internalformat, x, y, width);
}

static void REGAL_CALL loader_glGetColorTableParameterfvSGI(GLenum target, GLenum pname, GLfloat *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetColorTableParameterfvSGI, "glGetColorTableParameterfvSGI");
  if (_driver.glGetColorTableParameterfvSGI) {
    _driver.glGetColorTableParameterfvSGI(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetColorTableParameterfvSGI)(target, pname, params);
}

static void REGAL_CALL loader_glGetColorTableParameterivSGI(GLenum target, GLenum pname, GLint *params)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetColorTableParameterivSGI, "glGetColorTableParameterivSGI");
  if (_driver.glGetColorTableParameterivSGI) {
    _driver.glGetColorTableParameterivSGI(target, pname, params);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetColorTableParameterivSGI)(target, pname, params);
}

static void REGAL_CALL loader_glGetColorTableSGI(GLenum target, GLenum format, GLenum type, GLvoid *table)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGetColorTableSGI, "glGetColorTableSGI");
  if (_driver.glGetColorTableSGI) {
    _driver.glGetColorTableSGI(target, format, type, table);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGetColorTableSGI)(target, format, type, table);
}

// GL_SUNX_constant_data

static void REGAL_CALL loader_glFinishTextureSUNX(void)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glFinishTextureSUNX, "glFinishTextureSUNX");
  if (_driver.glFinishTextureSUNX) {
    _driver.glFinishTextureSUNX();
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glFinishTextureSUNX)();
}

// GL_SUN_global_alpha

static void REGAL_CALL loader_glGlobalAlphaFactorbSUN(GLbyte factor)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGlobalAlphaFactorbSUN, "glGlobalAlphaFactorbSUN");
  if (_driver.glGlobalAlphaFactorbSUN) {
    _driver.glGlobalAlphaFactorbSUN(factor);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGlobalAlphaFactorbSUN)(factor);
}

static void REGAL_CALL loader_glGlobalAlphaFactordSUN(GLdouble factor)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGlobalAlphaFactordSUN, "glGlobalAlphaFactordSUN");
  if (_driver.glGlobalAlphaFactordSUN) {
    _driver.glGlobalAlphaFactordSUN(factor);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGlobalAlphaFactordSUN)(factor);
}

static void REGAL_CALL loader_glGlobalAlphaFactorfSUN(GLfloat factor)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGlobalAlphaFactorfSUN, "glGlobalAlphaFactorfSUN");
  if (_driver.glGlobalAlphaFactorfSUN) {
    _driver.glGlobalAlphaFactorfSUN(factor);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGlobalAlphaFactorfSUN)(factor);
}

static void REGAL_CALL loader_glGlobalAlphaFactoriSUN(GLint factor)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGlobalAlphaFactoriSUN, "glGlobalAlphaFactoriSUN");
  if (_driver.glGlobalAlphaFactoriSUN) {
    _driver.glGlobalAlphaFactoriSUN(factor);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGlobalAlphaFactoriSUN)(factor);
}

static void REGAL_CALL loader_glGlobalAlphaFactorsSUN(GLshort factor)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGlobalAlphaFactorsSUN, "glGlobalAlphaFactorsSUN");
  if (_driver.glGlobalAlphaFactorsSUN) {
    _driver.glGlobalAlphaFactorsSUN(factor);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGlobalAlphaFactorsSUN)(factor);
}

static void REGAL_CALL loader_glGlobalAlphaFactorubSUN(GLubyte factor)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGlobalAlphaFactorubSUN, "glGlobalAlphaFactorubSUN");
  if (_driver.glGlobalAlphaFactorubSUN) {
    _driver.glGlobalAlphaFactorubSUN(factor);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGlobalAlphaFactorubSUN)(factor);
}

static void REGAL_CALL loader_glGlobalAlphaFactoruiSUN(GLuint factor)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGlobalAlphaFactoruiSUN, "glGlobalAlphaFactoruiSUN");
  if (_driver.glGlobalAlphaFactoruiSUN) {
    _driver.glGlobalAlphaFactoruiSUN(factor);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGlobalAlphaFactoruiSUN)(factor);
}

static void REGAL_CALL loader_glGlobalAlphaFactorusSUN(GLushort factor)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glGlobalAlphaFactorusSUN, "glGlobalAlphaFactorusSUN");
  if (_driver.glGlobalAlphaFactorusSUN) {
    _driver.glGlobalAlphaFactorusSUN(factor);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glGlobalAlphaFactorusSUN)(factor);
}

// GL_SUN_mesh_array

static void REGAL_CALL loader_glDrawMeshArraysSUN(GLenum mode, GLint first, GLsizei count, GLsizei width)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glDrawMeshArraysSUN, "glDrawMeshArraysSUN");
  if (_driver.glDrawMeshArraysSUN) {
    _driver.glDrawMeshArraysSUN(mode, first, count, width);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glDrawMeshArraysSUN)(mode, first, count, width);
}

// GL_SUN_read_video_pixels

static void REGAL_CALL loader_glReadVideoPixelsSUN(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glReadVideoPixelsSUN, "glReadVideoPixelsSUN");
  if (_driver.glReadVideoPixelsSUN) {
    _driver.glReadVideoPixelsSUN(x, y, width, height, format, type, pixels);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glReadVideoPixelsSUN)(x, y, width, height, format, type, pixels);
}

// GL_SUN_triangle_list

static void REGAL_CALL loader_glReplacementCodePointerSUN(GLenum type, GLsizei stride, const GLvoid **pointer)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glReplacementCodePointerSUN, "glReplacementCodePointerSUN");
  if (_driver.glReplacementCodePointerSUN) {
    _driver.glReplacementCodePointerSUN(type, stride, pointer);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glReplacementCodePointerSUN)(type, stride, pointer);
}

static void REGAL_CALL loader_glReplacementCodeubSUN(GLubyte code)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glReplacementCodeubSUN, "glReplacementCodeubSUN");
  if (_driver.glReplacementCodeubSUN) {
    _driver.glReplacementCodeubSUN(code);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glReplacementCodeubSUN)(code);
}

static void REGAL_CALL loader_glReplacementCodeubvSUN(const GLubyte *code)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glReplacementCodeubvSUN, "glReplacementCodeubvSUN");
  if (_driver.glReplacementCodeubvSUN) {
    _driver.glReplacementCodeubvSUN(code);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glReplacementCodeubvSUN)(code);
}

static void REGAL_CALL loader_glReplacementCodeuiSUN(GLuint code)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glReplacementCodeuiSUN, "glReplacementCodeuiSUN");
  if (_driver.glReplacementCodeuiSUN) {
    _driver.glReplacementCodeuiSUN(code);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glReplacementCodeuiSUN)(code);
}

static void REGAL_CALL loader_glReplacementCodeuivSUN(const GLuint *code)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glReplacementCodeuivSUN, "glReplacementCodeuivSUN");
  if (_driver.glReplacementCodeuivSUN) {
    _driver.glReplacementCodeuivSUN(code);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glReplacementCodeuivSUN)(code);
}

static void REGAL_CALL loader_glReplacementCodeusSUN(GLushort code)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glReplacementCodeusSUN, "glReplacementCodeusSUN");
  if (_driver.glReplacementCodeusSUN) {
    _driver.glReplacementCodeusSUN(code);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glReplacementCodeusSUN)(code);
}

static void REGAL_CALL loader_glReplacementCodeusvSUN(const GLushort *code)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glReplacementCodeusvSUN, "glReplacementCodeusvSUN");
  if (_driver.glReplacementCodeusvSUN) {
    _driver.glReplacementCodeusvSUN(code);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glReplacementCodeusvSUN)(code);
}

// GL_SUN_vertex

static void REGAL_CALL loader_glColor3fVertex3fSUN(GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColor3fVertex3fSUN, "glColor3fVertex3fSUN");
  if (_driver.glColor3fVertex3fSUN) {
    _driver.glColor3fVertex3fSUN(r, g, b, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColor3fVertex3fSUN)(r, g, b, x, y, z);
}

static void REGAL_CALL loader_glColor3fVertex3fvSUN(const GLfloat *c, const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColor3fVertex3fvSUN, "glColor3fVertex3fvSUN");
  if (_driver.glColor3fVertex3fvSUN) {
    _driver.glColor3fVertex3fvSUN(c, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColor3fVertex3fvSUN)(c, v);
}

static void REGAL_CALL loader_glColor4fNormal3fVertex3fSUN(GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColor4fNormal3fVertex3fSUN, "glColor4fNormal3fVertex3fSUN");
  if (_driver.glColor4fNormal3fVertex3fSUN) {
    _driver.glColor4fNormal3fVertex3fSUN(r, g, b, a, nx, ny, nz, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColor4fNormal3fVertex3fSUN)(r, g, b, a, nx, ny, nz, x, y, z);
}

static void REGAL_CALL loader_glColor4fNormal3fVertex3fvSUN(const GLfloat *c, const GLfloat *n, const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColor4fNormal3fVertex3fvSUN, "glColor4fNormal3fVertex3fvSUN");
  if (_driver.glColor4fNormal3fVertex3fvSUN) {
    _driver.glColor4fNormal3fVertex3fvSUN(c, n, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColor4fNormal3fVertex3fvSUN)(c, n, v);
}

static void REGAL_CALL loader_glColor4ubVertex2fSUN(GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColor4ubVertex2fSUN, "glColor4ubVertex2fSUN");
  if (_driver.glColor4ubVertex2fSUN) {
    _driver.glColor4ubVertex2fSUN(r, g, b, a, x, y);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColor4ubVertex2fSUN)(r, g, b, a, x, y);
}

static void REGAL_CALL loader_glColor4ubVertex2fvSUN(const GLubyte *c, const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColor4ubVertex2fvSUN, "glColor4ubVertex2fvSUN");
  if (_driver.glColor4ubVertex2fvSUN) {
    _driver.glColor4ubVertex2fvSUN(c, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColor4ubVertex2fvSUN)(c, v);
}

static void REGAL_CALL loader_glColor4ubVertex3fSUN(GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColor4ubVertex3fSUN, "glColor4ubVertex3fSUN");
  if (_driver.glColor4ubVertex3fSUN) {
    _driver.glColor4ubVertex3fSUN(r, g, b, a, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColor4ubVertex3fSUN)(r, g, b, a, x, y, z);
}

static void REGAL_CALL loader_glColor4ubVertex3fvSUN(const GLubyte *c, const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glColor4ubVertex3fvSUN, "glColor4ubVertex3fvSUN");
  if (_driver.glColor4ubVertex3fvSUN) {
    _driver.glColor4ubVertex3fvSUN(c, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glColor4ubVertex3fvSUN)(c, v);
}

static void REGAL_CALL loader_glNormal3fVertex3fSUN(GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNormal3fVertex3fSUN, "glNormal3fVertex3fSUN");
  if (_driver.glNormal3fVertex3fSUN) {
    _driver.glNormal3fVertex3fSUN(nx, ny, nz, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNormal3fVertex3fSUN)(nx, ny, nz, x, y, z);
}

static void REGAL_CALL loader_glNormal3fVertex3fvSUN(const GLfloat *n, const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glNormal3fVertex3fvSUN, "glNormal3fVertex3fvSUN");
  if (_driver.glNormal3fVertex3fvSUN) {
    _driver.glNormal3fVertex3fvSUN(n, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glNormal3fVertex3fvSUN)(n, v);
}

static void REGAL_CALL loader_glReplacementCodeuiColor3fVertex3fSUN(GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glReplacementCodeuiColor3fVertex3fSUN, "glReplacementCodeuiColor3fVertex3fSUN");
  if (_driver.glReplacementCodeuiColor3fVertex3fSUN) {
    _driver.glReplacementCodeuiColor3fVertex3fSUN(rc, r, g, b, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glReplacementCodeuiColor3fVertex3fSUN)(rc, r, g, b, x, y, z);
}

static void REGAL_CALL loader_glReplacementCodeuiColor3fVertex3fvSUN(const GLuint *rc, const GLfloat *c, const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glReplacementCodeuiColor3fVertex3fvSUN, "glReplacementCodeuiColor3fVertex3fvSUN");
  if (_driver.glReplacementCodeuiColor3fVertex3fvSUN) {
    _driver.glReplacementCodeuiColor3fVertex3fvSUN(rc, c, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glReplacementCodeuiColor3fVertex3fvSUN)(rc, c, v);
}

static void REGAL_CALL loader_glReplacementCodeuiColor4fNormal3fVertex3fSUN(GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glReplacementCodeuiColor4fNormal3fVertex3fSUN, "glReplacementCodeuiColor4fNormal3fVertex3fSUN");
  if (_driver.glReplacementCodeuiColor4fNormal3fVertex3fSUN) {
    _driver.glReplacementCodeuiColor4fNormal3fVertex3fSUN(rc, r, g, b, a, nx, ny, nz, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glReplacementCodeuiColor4fNormal3fVertex3fSUN)(rc, r, g, b, a, nx, ny, nz, x, y, z);
}

static void REGAL_CALL loader_glReplacementCodeuiColor4fNormal3fVertex3fvSUN(const GLuint *rc, const GLfloat *c, const GLfloat *n, const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glReplacementCodeuiColor4fNormal3fVertex3fvSUN, "glReplacementCodeuiColor4fNormal3fVertex3fvSUN");
  if (_driver.glReplacementCodeuiColor4fNormal3fVertex3fvSUN) {
    _driver.glReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc, c, n, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glReplacementCodeuiColor4fNormal3fVertex3fvSUN)(rc, c, n, v);
}

static void REGAL_CALL loader_glReplacementCodeuiColor4ubVertex3fSUN(GLuint rc, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glReplacementCodeuiColor4ubVertex3fSUN, "glReplacementCodeuiColor4ubVertex3fSUN");
  if (_driver.glReplacementCodeuiColor4ubVertex3fSUN) {
    _driver.glReplacementCodeuiColor4ubVertex3fSUN(rc, r, g, b, a, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glReplacementCodeuiColor4ubVertex3fSUN)(rc, r, g, b, a, x, y, z);
}

static void REGAL_CALL loader_glReplacementCodeuiColor4ubVertex3fvSUN(const GLuint *rc, const GLubyte *c, const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glReplacementCodeuiColor4ubVertex3fvSUN, "glReplacementCodeuiColor4ubVertex3fvSUN");
  if (_driver.glReplacementCodeuiColor4ubVertex3fvSUN) {
    _driver.glReplacementCodeuiColor4ubVertex3fvSUN(rc, c, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glReplacementCodeuiColor4ubVertex3fvSUN)(rc, c, v);
}

static void REGAL_CALL loader_glReplacementCodeuiNormal3fVertex3fSUN(GLuint rc, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glReplacementCodeuiNormal3fVertex3fSUN, "glReplacementCodeuiNormal3fVertex3fSUN");
  if (_driver.glReplacementCodeuiNormal3fVertex3fSUN) {
    _driver.glReplacementCodeuiNormal3fVertex3fSUN(rc, nx, ny, nz, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glReplacementCodeuiNormal3fVertex3fSUN)(rc, nx, ny, nz, x, y, z);
}

static void REGAL_CALL loader_glReplacementCodeuiNormal3fVertex3fvSUN(const GLuint *rc, const GLfloat *n, const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glReplacementCodeuiNormal3fVertex3fvSUN, "glReplacementCodeuiNormal3fVertex3fvSUN");
  if (_driver.glReplacementCodeuiNormal3fVertex3fvSUN) {
    _driver.glReplacementCodeuiNormal3fVertex3fvSUN(rc, n, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glReplacementCodeuiNormal3fVertex3fvSUN)(rc, n, v);
}

static void REGAL_CALL loader_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(GLuint rc, GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN, "glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN");
  if (_driver.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN) {
    _driver.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(rc, s, t, r, g, b, a, nx, ny, nz, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN)(rc, s, t, r, g, b, a, nx, ny, nz, x, y, z);
}

static void REGAL_CALL loader_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(const GLuint *rc, const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN, "glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN");
  if (_driver.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN) {
    _driver.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc, c, n, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN)(rc, tc, c, n, v);
}

static void REGAL_CALL loader_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(GLuint rc, GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN, "glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN");
  if (_driver.glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN) {
    _driver.glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(rc, s, t, nx, ny, nz, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN)(rc, s, t, nx, ny, nz, x, y, z);
}

static void REGAL_CALL loader_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(const GLuint *rc, const GLfloat *tc, const GLfloat *n, const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN, "glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN");
  if (_driver.glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN) {
    _driver.glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc, tc, n, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN)(rc, tc, n, v);
}

static void REGAL_CALL loader_glReplacementCodeuiTexCoord2fVertex3fSUN(GLuint rc, GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glReplacementCodeuiTexCoord2fVertex3fSUN, "glReplacementCodeuiTexCoord2fVertex3fSUN");
  if (_driver.glReplacementCodeuiTexCoord2fVertex3fSUN) {
    _driver.glReplacementCodeuiTexCoord2fVertex3fSUN(rc, s, t, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glReplacementCodeuiTexCoord2fVertex3fSUN)(rc, s, t, x, y, z);
}

static void REGAL_CALL loader_glReplacementCodeuiTexCoord2fVertex3fvSUN(const GLuint *rc, const GLfloat *tc, const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glReplacementCodeuiTexCoord2fVertex3fvSUN, "glReplacementCodeuiTexCoord2fVertex3fvSUN");
  if (_driver.glReplacementCodeuiTexCoord2fVertex3fvSUN) {
    _driver.glReplacementCodeuiTexCoord2fVertex3fvSUN(rc, tc, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glReplacementCodeuiTexCoord2fVertex3fvSUN)(rc, tc, v);
}

static void REGAL_CALL loader_glReplacementCodeuiVertex3fSUN(GLuint rc, GLfloat x, GLfloat y, GLfloat z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glReplacementCodeuiVertex3fSUN, "glReplacementCodeuiVertex3fSUN");
  if (_driver.glReplacementCodeuiVertex3fSUN) {
    _driver.glReplacementCodeuiVertex3fSUN(rc, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glReplacementCodeuiVertex3fSUN)(rc, x, y, z);
}

static void REGAL_CALL loader_glReplacementCodeuiVertex3fvSUN(const GLuint *rc, const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glReplacementCodeuiVertex3fvSUN, "glReplacementCodeuiVertex3fvSUN");
  if (_driver.glReplacementCodeuiVertex3fvSUN) {
    _driver.glReplacementCodeuiVertex3fvSUN(rc, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glReplacementCodeuiVertex3fvSUN)(rc, v);
}

static void REGAL_CALL loader_glTexCoord2fColor3fVertex3fSUN(GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord2fColor3fVertex3fSUN, "glTexCoord2fColor3fVertex3fSUN");
  if (_driver.glTexCoord2fColor3fVertex3fSUN) {
    _driver.glTexCoord2fColor3fVertex3fSUN(s, t, r, g, b, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord2fColor3fVertex3fSUN)(s, t, r, g, b, x, y, z);
}

static void REGAL_CALL loader_glTexCoord2fColor3fVertex3fvSUN(const GLfloat *tc, const GLfloat *c, const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord2fColor3fVertex3fvSUN, "glTexCoord2fColor3fVertex3fvSUN");
  if (_driver.glTexCoord2fColor3fVertex3fvSUN) {
    _driver.glTexCoord2fColor3fVertex3fvSUN(tc, c, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord2fColor3fVertex3fvSUN)(tc, c, v);
}

static void REGAL_CALL loader_glTexCoord2fColor4fNormal3fVertex3fSUN(GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord2fColor4fNormal3fVertex3fSUN, "glTexCoord2fColor4fNormal3fVertex3fSUN");
  if (_driver.glTexCoord2fColor4fNormal3fVertex3fSUN) {
    _driver.glTexCoord2fColor4fNormal3fVertex3fSUN(s, t, r, g, b, a, nx, ny, nz, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord2fColor4fNormal3fVertex3fSUN)(s, t, r, g, b, a, nx, ny, nz, x, y, z);
}

static void REGAL_CALL loader_glTexCoord2fColor4fNormal3fVertex3fvSUN(const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord2fColor4fNormal3fVertex3fvSUN, "glTexCoord2fColor4fNormal3fVertex3fvSUN");
  if (_driver.glTexCoord2fColor4fNormal3fVertex3fvSUN) {
    _driver.glTexCoord2fColor4fNormal3fVertex3fvSUN(tc, c, n, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord2fColor4fNormal3fVertex3fvSUN)(tc, c, n, v);
}

static void REGAL_CALL loader_glTexCoord2fColor4ubVertex3fSUN(GLfloat s, GLfloat t, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord2fColor4ubVertex3fSUN, "glTexCoord2fColor4ubVertex3fSUN");
  if (_driver.glTexCoord2fColor4ubVertex3fSUN) {
    _driver.glTexCoord2fColor4ubVertex3fSUN(s, t, r, g, b, a, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord2fColor4ubVertex3fSUN)(s, t, r, g, b, a, x, y, z);
}

static void REGAL_CALL loader_glTexCoord2fColor4ubVertex3fvSUN(const GLfloat *tc, const GLubyte *c, const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord2fColor4ubVertex3fvSUN, "glTexCoord2fColor4ubVertex3fvSUN");
  if (_driver.glTexCoord2fColor4ubVertex3fvSUN) {
    _driver.glTexCoord2fColor4ubVertex3fvSUN(tc, c, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord2fColor4ubVertex3fvSUN)(tc, c, v);
}

static void REGAL_CALL loader_glTexCoord2fNormal3fVertex3fSUN(GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord2fNormal3fVertex3fSUN, "glTexCoord2fNormal3fVertex3fSUN");
  if (_driver.glTexCoord2fNormal3fVertex3fSUN) {
    _driver.glTexCoord2fNormal3fVertex3fSUN(s, t, nx, ny, nz, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord2fNormal3fVertex3fSUN)(s, t, nx, ny, nz, x, y, z);
}

static void REGAL_CALL loader_glTexCoord2fNormal3fVertex3fvSUN(const GLfloat *tc, const GLfloat *n, const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord2fNormal3fVertex3fvSUN, "glTexCoord2fNormal3fVertex3fvSUN");
  if (_driver.glTexCoord2fNormal3fVertex3fvSUN) {
    _driver.glTexCoord2fNormal3fVertex3fvSUN(tc, n, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord2fNormal3fVertex3fvSUN)(tc, n, v);
}

static void REGAL_CALL loader_glTexCoord2fVertex3fSUN(GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord2fVertex3fSUN, "glTexCoord2fVertex3fSUN");
  if (_driver.glTexCoord2fVertex3fSUN) {
    _driver.glTexCoord2fVertex3fSUN(s, t, x, y, z);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord2fVertex3fSUN)(s, t, x, y, z);
}

static void REGAL_CALL loader_glTexCoord2fVertex3fvSUN(const GLfloat *tc, const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord2fVertex3fvSUN, "glTexCoord2fVertex3fvSUN");
  if (_driver.glTexCoord2fVertex3fvSUN) {
    _driver.glTexCoord2fVertex3fvSUN(tc, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord2fVertex3fvSUN)(tc, v);
}

static void REGAL_CALL loader_glTexCoord4fColor4fNormal3fVertex4fSUN(GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord4fColor4fNormal3fVertex4fSUN, "glTexCoord4fColor4fNormal3fVertex4fSUN");
  if (_driver.glTexCoord4fColor4fNormal3fVertex4fSUN) {
    _driver.glTexCoord4fColor4fNormal3fVertex4fSUN(s, t, p, q, r, g, b, a, nx, ny, nz, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord4fColor4fNormal3fVertex4fSUN)(s, t, p, q, r, g, b, a, nx, ny, nz, x, y, z, w);
}

static void REGAL_CALL loader_glTexCoord4fColor4fNormal3fVertex4fvSUN(const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord4fColor4fNormal3fVertex4fvSUN, "glTexCoord4fColor4fNormal3fVertex4fvSUN");
  if (_driver.glTexCoord4fColor4fNormal3fVertex4fvSUN) {
    _driver.glTexCoord4fColor4fNormal3fVertex4fvSUN(tc, c, n, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord4fColor4fNormal3fVertex4fvSUN)(tc, c, n, v);
}

static void REGAL_CALL loader_glTexCoord4fVertex4fSUN(GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord4fVertex4fSUN, "glTexCoord4fVertex4fSUN");
  if (_driver.glTexCoord4fVertex4fSUN) {
    _driver.glTexCoord4fVertex4fSUN(s, t, p, q, x, y, z, w);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord4fVertex4fSUN)(s, t, p, q, x, y, z, w);
}

static void REGAL_CALL loader_glTexCoord4fVertex4fvSUN(const GLfloat *tc, const GLfloat *v)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glTexCoord4fVertex4fvSUN, "glTexCoord4fVertex4fvSUN");
  if (_driver.glTexCoord4fVertex4fvSUN) {
    _driver.glTexCoord4fVertex4fvSUN(tc, v);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glTexCoord4fVertex4fvSUN)(tc, v);
}

// GL_WIN_swap_hint

static void REGAL_CALL loader_glAddSwapHintRectWIN(GLint x, GLint y, GLsizei width, GLsizei height)
{
  RegalContext * _context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTable &_driver = _context->dispatcher.driver;
  GetProcAddress(_driver.glAddSwapHintRectWIN, "glAddSwapHintRectWIN");
  if (_driver.glAddSwapHintRectWIN) {
    _driver.glAddSwapHintRectWIN(x, y, width, height);
    return;
  }
  DispatchTable *_next = _driver._next;
  RegalAssert(_next);
  _next->call(&_next->glAddSwapHintRectWIN)(x, y, width, height);
}

void InitDispatchTableLoader(DispatchTable &tbl)
{

  // GL_VERSION_1_0

  tbl.glAccum = loader_glAccum;
  tbl.glAlphaFunc = loader_glAlphaFunc;
  tbl.glBegin = loader_glBegin;
  tbl.glBitmap = loader_glBitmap;
  tbl.glBlendFunc = loader_glBlendFunc;
  tbl.glCallList = loader_glCallList;
  tbl.glCallLists = loader_glCallLists;
  tbl.glClear = loader_glClear;
  tbl.glClearAccum = loader_glClearAccum;
  tbl.glClearColor = loader_glClearColor;
  tbl.glClearDepth = loader_glClearDepth;
  tbl.glClearIndex = loader_glClearIndex;
  tbl.glClearStencil = loader_glClearStencil;
  tbl.glClipPlane = loader_glClipPlane;
  tbl.glColor3b = loader_glColor3b;
  tbl.glColor3bv = loader_glColor3bv;
  tbl.glColor3d = loader_glColor3d;
  tbl.glColor3dv = loader_glColor3dv;
  tbl.glColor3f = loader_glColor3f;
  tbl.glColor3fv = loader_glColor3fv;
  tbl.glColor3i = loader_glColor3i;
  tbl.glColor3iv = loader_glColor3iv;
  tbl.glColor3s = loader_glColor3s;
  tbl.glColor3sv = loader_glColor3sv;
  tbl.glColor3ub = loader_glColor3ub;
  tbl.glColor3ubv = loader_glColor3ubv;
  tbl.glColor3ui = loader_glColor3ui;
  tbl.glColor3uiv = loader_glColor3uiv;
  tbl.glColor3us = loader_glColor3us;
  tbl.glColor3usv = loader_glColor3usv;
  tbl.glColor4b = loader_glColor4b;
  tbl.glColor4bv = loader_glColor4bv;
  tbl.glColor4d = loader_glColor4d;
  tbl.glColor4dv = loader_glColor4dv;
  tbl.glColor4f = loader_glColor4f;
  tbl.glColor4fv = loader_glColor4fv;
  tbl.glColor4i = loader_glColor4i;
  tbl.glColor4iv = loader_glColor4iv;
  tbl.glColor4s = loader_glColor4s;
  tbl.glColor4sv = loader_glColor4sv;
  tbl.glColor4ub = loader_glColor4ub;
  tbl.glColor4ubv = loader_glColor4ubv;
  tbl.glColor4ui = loader_glColor4ui;
  tbl.glColor4uiv = loader_glColor4uiv;
  tbl.glColor4us = loader_glColor4us;
  tbl.glColor4usv = loader_glColor4usv;
  tbl.glColorMask = loader_glColorMask;
  tbl.glColorMaterial = loader_glColorMaterial;
  tbl.glCopyPixels = loader_glCopyPixels;
  tbl.glCullFace = loader_glCullFace;
  tbl.glDeleteLists = loader_glDeleteLists;
  tbl.glDepthFunc = loader_glDepthFunc;
  tbl.glDepthMask = loader_glDepthMask;
  tbl.glDepthRange = loader_glDepthRange;
  tbl.glDisable = loader_glDisable;
  tbl.glDrawBuffer = loader_glDrawBuffer;
  tbl.glDrawPixels = loader_glDrawPixels;
  tbl.glEdgeFlag = loader_glEdgeFlag;
  tbl.glEdgeFlagv = loader_glEdgeFlagv;
  tbl.glEnable = loader_glEnable;
  tbl.glEnd = loader_glEnd;
  tbl.glEndList = loader_glEndList;
  tbl.glEvalCoord1d = loader_glEvalCoord1d;
  tbl.glEvalCoord1dv = loader_glEvalCoord1dv;
  tbl.glEvalCoord1f = loader_glEvalCoord1f;
  tbl.glEvalCoord1fv = loader_glEvalCoord1fv;
  tbl.glEvalCoord2d = loader_glEvalCoord2d;
  tbl.glEvalCoord2dv = loader_glEvalCoord2dv;
  tbl.glEvalCoord2f = loader_glEvalCoord2f;
  tbl.glEvalCoord2fv = loader_glEvalCoord2fv;
  tbl.glEvalMesh1 = loader_glEvalMesh1;
  tbl.glEvalMesh2 = loader_glEvalMesh2;
  tbl.glEvalPoint1 = loader_glEvalPoint1;
  tbl.glEvalPoint2 = loader_glEvalPoint2;
  tbl.glFeedbackBuffer = loader_glFeedbackBuffer;
  tbl.glFinish = loader_glFinish;
  tbl.glFlush = loader_glFlush;
  tbl.glFogf = loader_glFogf;
  tbl.glFogfv = loader_glFogfv;
  tbl.glFogi = loader_glFogi;
  tbl.glFogiv = loader_glFogiv;
  tbl.glFrontFace = loader_glFrontFace;
  tbl.glFrustum = loader_glFrustum;
  tbl.glGenLists = loader_glGenLists;
  tbl.glGetBooleanv = loader_glGetBooleanv;
  tbl.glGetClipPlane = loader_glGetClipPlane;
  tbl.glGetDoublev = loader_glGetDoublev;
  tbl.glGetError = loader_glGetError;
  tbl.glGetFloatv = loader_glGetFloatv;
  tbl.glGetIntegerv = loader_glGetIntegerv;
  tbl.glGetLightfv = loader_glGetLightfv;
  tbl.glGetLightiv = loader_glGetLightiv;
  tbl.glGetMapdv = loader_glGetMapdv;
  tbl.glGetMapfv = loader_glGetMapfv;
  tbl.glGetMapiv = loader_glGetMapiv;
  tbl.glGetMaterialfv = loader_glGetMaterialfv;
  tbl.glGetMaterialiv = loader_glGetMaterialiv;
  tbl.glGetPixelMapfv = loader_glGetPixelMapfv;
  tbl.glGetPixelMapuiv = loader_glGetPixelMapuiv;
  tbl.glGetPixelMapusv = loader_glGetPixelMapusv;
  tbl.glGetPolygonStipple = loader_glGetPolygonStipple;
  tbl.glGetString = loader_glGetString;
  tbl.glGetTexEnvfv = loader_glGetTexEnvfv;
  tbl.glGetTexEnviv = loader_glGetTexEnviv;
  tbl.glGetTexGendv = loader_glGetTexGendv;
  tbl.glGetTexGenfv = loader_glGetTexGenfv;
  tbl.glGetTexGeniv = loader_glGetTexGeniv;
  tbl.glGetTexImage = loader_glGetTexImage;
  tbl.glGetTexLevelParameterfv = loader_glGetTexLevelParameterfv;
  tbl.glGetTexLevelParameteriv = loader_glGetTexLevelParameteriv;
  tbl.glGetTexParameterfv = loader_glGetTexParameterfv;
  tbl.glGetTexParameteriv = loader_glGetTexParameteriv;
  tbl.glHint = loader_glHint;
  tbl.glIndexMask = loader_glIndexMask;
  tbl.glIndexd = loader_glIndexd;
  tbl.glIndexdv = loader_glIndexdv;
  tbl.glIndexf = loader_glIndexf;
  tbl.glIndexfv = loader_glIndexfv;
  tbl.glIndexi = loader_glIndexi;
  tbl.glIndexiv = loader_glIndexiv;
  tbl.glIndexs = loader_glIndexs;
  tbl.glIndexsv = loader_glIndexsv;
  tbl.glInitNames = loader_glInitNames;
  tbl.glIsEnabled = loader_glIsEnabled;
  tbl.glIsList = loader_glIsList;
  tbl.glLightModelf = loader_glLightModelf;
  tbl.glLightModelfv = loader_glLightModelfv;
  tbl.glLightModeli = loader_glLightModeli;
  tbl.glLightModeliv = loader_glLightModeliv;
  tbl.glLightf = loader_glLightf;
  tbl.glLightfv = loader_glLightfv;
  tbl.glLighti = loader_glLighti;
  tbl.glLightiv = loader_glLightiv;
  tbl.glLineStipple = loader_glLineStipple;
  tbl.glLineWidth = loader_glLineWidth;
  tbl.glListBase = loader_glListBase;
  tbl.glLoadIdentity = loader_glLoadIdentity;
  tbl.glLoadMatrixd = loader_glLoadMatrixd;
  tbl.glLoadMatrixf = loader_glLoadMatrixf;
  tbl.glLoadName = loader_glLoadName;
  tbl.glLogicOp = loader_glLogicOp;
  tbl.glMap1d = loader_glMap1d;
  tbl.glMap1f = loader_glMap1f;
  tbl.glMap2d = loader_glMap2d;
  tbl.glMap2f = loader_glMap2f;
  tbl.glMapGrid1d = loader_glMapGrid1d;
  tbl.glMapGrid1f = loader_glMapGrid1f;
  tbl.glMapGrid2d = loader_glMapGrid2d;
  tbl.glMapGrid2f = loader_glMapGrid2f;
  tbl.glMaterialf = loader_glMaterialf;
  tbl.glMaterialfv = loader_glMaterialfv;
  tbl.glMateriali = loader_glMateriali;
  tbl.glMaterialiv = loader_glMaterialiv;
  tbl.glMatrixMode = loader_glMatrixMode;
  tbl.glMultMatrixd = loader_glMultMatrixd;
  tbl.glMultMatrixf = loader_glMultMatrixf;
  tbl.glNewList = loader_glNewList;
  tbl.glNormal3b = loader_glNormal3b;
  tbl.glNormal3bv = loader_glNormal3bv;
  tbl.glNormal3d = loader_glNormal3d;
  tbl.glNormal3dv = loader_glNormal3dv;
  tbl.glNormal3f = loader_glNormal3f;
  tbl.glNormal3fv = loader_glNormal3fv;
  tbl.glNormal3i = loader_glNormal3i;
  tbl.glNormal3iv = loader_glNormal3iv;
  tbl.glNormal3s = loader_glNormal3s;
  tbl.glNormal3sv = loader_glNormal3sv;
  tbl.glOrtho = loader_glOrtho;
  tbl.glPassThrough = loader_glPassThrough;
  tbl.glPixelMapfv = loader_glPixelMapfv;
  tbl.glPixelMapuiv = loader_glPixelMapuiv;
  tbl.glPixelMapusv = loader_glPixelMapusv;
  tbl.glPixelStoref = loader_glPixelStoref;
  tbl.glPixelStorei = loader_glPixelStorei;
  tbl.glPixelTransferf = loader_glPixelTransferf;
  tbl.glPixelTransferi = loader_glPixelTransferi;
  tbl.glPixelZoom = loader_glPixelZoom;
  tbl.glPointSize = loader_glPointSize;
  tbl.glPolygonMode = loader_glPolygonMode;
  tbl.glPolygonStipple = loader_glPolygonStipple;
  tbl.glPopAttrib = loader_glPopAttrib;
  tbl.glPopMatrix = loader_glPopMatrix;
  tbl.glPopName = loader_glPopName;
  tbl.glPushAttrib = loader_glPushAttrib;
  tbl.glPushMatrix = loader_glPushMatrix;
  tbl.glPushName = loader_glPushName;
  tbl.glRasterPos2d = loader_glRasterPos2d;
  tbl.glRasterPos2dv = loader_glRasterPos2dv;
  tbl.glRasterPos2f = loader_glRasterPos2f;
  tbl.glRasterPos2fv = loader_glRasterPos2fv;
  tbl.glRasterPos2i = loader_glRasterPos2i;
  tbl.glRasterPos2iv = loader_glRasterPos2iv;
  tbl.glRasterPos2s = loader_glRasterPos2s;
  tbl.glRasterPos2sv = loader_glRasterPos2sv;
  tbl.glRasterPos3d = loader_glRasterPos3d;
  tbl.glRasterPos3dv = loader_glRasterPos3dv;
  tbl.glRasterPos3f = loader_glRasterPos3f;
  tbl.glRasterPos3fv = loader_glRasterPos3fv;
  tbl.glRasterPos3i = loader_glRasterPos3i;
  tbl.glRasterPos3iv = loader_glRasterPos3iv;
  tbl.glRasterPos3s = loader_glRasterPos3s;
  tbl.glRasterPos3sv = loader_glRasterPos3sv;
  tbl.glRasterPos4d = loader_glRasterPos4d;
  tbl.glRasterPos4dv = loader_glRasterPos4dv;
  tbl.glRasterPos4f = loader_glRasterPos4f;
  tbl.glRasterPos4fv = loader_glRasterPos4fv;
  tbl.glRasterPos4i = loader_glRasterPos4i;
  tbl.glRasterPos4iv = loader_glRasterPos4iv;
  tbl.glRasterPos4s = loader_glRasterPos4s;
  tbl.glRasterPos4sv = loader_glRasterPos4sv;
  tbl.glReadBuffer = loader_glReadBuffer;
  tbl.glReadPixels = loader_glReadPixels;
  tbl.glRectd = loader_glRectd;
  tbl.glRectdv = loader_glRectdv;
  tbl.glRectf = loader_glRectf;
  tbl.glRectfv = loader_glRectfv;
  tbl.glRecti = loader_glRecti;
  tbl.glRectiv = loader_glRectiv;
  tbl.glRects = loader_glRects;
  tbl.glRectsv = loader_glRectsv;
  tbl.glRenderMode = loader_glRenderMode;
  tbl.glRotated = loader_glRotated;
  tbl.glRotatef = loader_glRotatef;
  tbl.glScaled = loader_glScaled;
  tbl.glScalef = loader_glScalef;
  tbl.glScissor = loader_glScissor;
  tbl.glSelectBuffer = loader_glSelectBuffer;
  tbl.glShadeModel = loader_glShadeModel;
  tbl.glStencilFunc = loader_glStencilFunc;
  tbl.glStencilMask = loader_glStencilMask;
  tbl.glStencilOp = loader_glStencilOp;
  tbl.glTexCoord1d = loader_glTexCoord1d;
  tbl.glTexCoord1dv = loader_glTexCoord1dv;
  tbl.glTexCoord1f = loader_glTexCoord1f;
  tbl.glTexCoord1fv = loader_glTexCoord1fv;
  tbl.glTexCoord1i = loader_glTexCoord1i;
  tbl.glTexCoord1iv = loader_glTexCoord1iv;
  tbl.glTexCoord1s = loader_glTexCoord1s;
  tbl.glTexCoord1sv = loader_glTexCoord1sv;
  tbl.glTexCoord2d = loader_glTexCoord2d;
  tbl.glTexCoord2dv = loader_glTexCoord2dv;
  tbl.glTexCoord2f = loader_glTexCoord2f;
  tbl.glTexCoord2fv = loader_glTexCoord2fv;
  tbl.glTexCoord2i = loader_glTexCoord2i;
  tbl.glTexCoord2iv = loader_glTexCoord2iv;
  tbl.glTexCoord2s = loader_glTexCoord2s;
  tbl.glTexCoord2sv = loader_glTexCoord2sv;
  tbl.glTexCoord3d = loader_glTexCoord3d;
  tbl.glTexCoord3dv = loader_glTexCoord3dv;
  tbl.glTexCoord3f = loader_glTexCoord3f;
  tbl.glTexCoord3fv = loader_glTexCoord3fv;
  tbl.glTexCoord3i = loader_glTexCoord3i;
  tbl.glTexCoord3iv = loader_glTexCoord3iv;
  tbl.glTexCoord3s = loader_glTexCoord3s;
  tbl.glTexCoord3sv = loader_glTexCoord3sv;
  tbl.glTexCoord4d = loader_glTexCoord4d;
  tbl.glTexCoord4dv = loader_glTexCoord4dv;
  tbl.glTexCoord4f = loader_glTexCoord4f;
  tbl.glTexCoord4fv = loader_glTexCoord4fv;
  tbl.glTexCoord4i = loader_glTexCoord4i;
  tbl.glTexCoord4iv = loader_glTexCoord4iv;
  tbl.glTexCoord4s = loader_glTexCoord4s;
  tbl.glTexCoord4sv = loader_glTexCoord4sv;
  tbl.glTexEnvf = loader_glTexEnvf;
  tbl.glTexEnvfv = loader_glTexEnvfv;
  tbl.glTexEnvi = loader_glTexEnvi;
  tbl.glTexEnviv = loader_glTexEnviv;
  tbl.glTexGend = loader_glTexGend;
  tbl.glTexGendv = loader_glTexGendv;
  tbl.glTexGenf = loader_glTexGenf;
  tbl.glTexGenfv = loader_glTexGenfv;
  tbl.glTexGeni = loader_glTexGeni;
  tbl.glTexGeniv = loader_glTexGeniv;
  tbl.glTexImage1D = loader_glTexImage1D;
  tbl.glTexImage2D = loader_glTexImage2D;
  tbl.glTexParameterf = loader_glTexParameterf;
  tbl.glTexParameterfv = loader_glTexParameterfv;
  tbl.glTexParameteri = loader_glTexParameteri;
  tbl.glTexParameteriv = loader_glTexParameteriv;
  tbl.glTranslated = loader_glTranslated;
  tbl.glTranslatef = loader_glTranslatef;
  tbl.glVertex2d = loader_glVertex2d;
  tbl.glVertex2dv = loader_glVertex2dv;
  tbl.glVertex2f = loader_glVertex2f;
  tbl.glVertex2fv = loader_glVertex2fv;
  tbl.glVertex2i = loader_glVertex2i;
  tbl.glVertex2iv = loader_glVertex2iv;
  tbl.glVertex2s = loader_glVertex2s;
  tbl.glVertex2sv = loader_glVertex2sv;
  tbl.glVertex3d = loader_glVertex3d;
  tbl.glVertex3dv = loader_glVertex3dv;
  tbl.glVertex3f = loader_glVertex3f;
  tbl.glVertex3fv = loader_glVertex3fv;
  tbl.glVertex3i = loader_glVertex3i;
  tbl.glVertex3iv = loader_glVertex3iv;
  tbl.glVertex3s = loader_glVertex3s;
  tbl.glVertex3sv = loader_glVertex3sv;
  tbl.glVertex4d = loader_glVertex4d;
  tbl.glVertex4dv = loader_glVertex4dv;
  tbl.glVertex4f = loader_glVertex4f;
  tbl.glVertex4fv = loader_glVertex4fv;
  tbl.glVertex4i = loader_glVertex4i;
  tbl.glVertex4iv = loader_glVertex4iv;
  tbl.glVertex4s = loader_glVertex4s;
  tbl.glVertex4sv = loader_glVertex4sv;
  tbl.glViewport = loader_glViewport;

  // GL_VERSION_1_1

  tbl.glAreTexturesResident = loader_glAreTexturesResident;
  tbl.glArrayElement = loader_glArrayElement;
  tbl.glBindTexture = loader_glBindTexture;
  tbl.glColorPointer = loader_glColorPointer;
  tbl.glCopyTexImage1D = loader_glCopyTexImage1D;
  tbl.glCopyTexImage2D = loader_glCopyTexImage2D;
  tbl.glCopyTexSubImage1D = loader_glCopyTexSubImage1D;
  tbl.glCopyTexSubImage2D = loader_glCopyTexSubImage2D;
  tbl.glDeleteTextures = loader_glDeleteTextures;
  tbl.glDisableClientState = loader_glDisableClientState;
  tbl.glDrawArrays = loader_glDrawArrays;
  tbl.glDrawElements = loader_glDrawElements;
  tbl.glEdgeFlagPointer = loader_glEdgeFlagPointer;
  tbl.glEnableClientState = loader_glEnableClientState;
  tbl.glGenTextures = loader_glGenTextures;
  tbl.glGetPointerv = loader_glGetPointerv;
  tbl.glIndexPointer = loader_glIndexPointer;
  tbl.glIndexub = loader_glIndexub;
  tbl.glIndexubv = loader_glIndexubv;
  tbl.glInterleavedArrays = loader_glInterleavedArrays;
  tbl.glIsTexture = loader_glIsTexture;
  tbl.glNormalPointer = loader_glNormalPointer;
  tbl.glPolygonOffset = loader_glPolygonOffset;
  tbl.glPopClientAttrib = loader_glPopClientAttrib;
  tbl.glPrioritizeTextures = loader_glPrioritizeTextures;
  tbl.glPushClientAttrib = loader_glPushClientAttrib;
  tbl.glTexCoordPointer = loader_glTexCoordPointer;
  tbl.glTexSubImage1D = loader_glTexSubImage1D;
  tbl.glTexSubImage2D = loader_glTexSubImage2D;
  tbl.glVertexPointer = loader_glVertexPointer;

  // GL_VERSION_1_2

  tbl.glBlendColor = loader_glBlendColor;
  tbl.glBlendEquation = loader_glBlendEquation;
  tbl.glCopyTexSubImage3D = loader_glCopyTexSubImage3D;
  tbl.glDrawRangeElements = loader_glDrawRangeElements;
  tbl.glTexImage3D = loader_glTexImage3D;
  tbl.glTexSubImage3D = loader_glTexSubImage3D;

  // GL_VERSION_1_3

  tbl.glActiveTexture = loader_glActiveTexture;
  tbl.glClientActiveTexture = loader_glClientActiveTexture;
  tbl.glCompressedTexImage1D = loader_glCompressedTexImage1D;
  tbl.glCompressedTexImage2D = loader_glCompressedTexImage2D;
  tbl.glCompressedTexImage3D = loader_glCompressedTexImage3D;
  tbl.glCompressedTexSubImage1D = loader_glCompressedTexSubImage1D;
  tbl.glCompressedTexSubImage2D = loader_glCompressedTexSubImage2D;
  tbl.glCompressedTexSubImage3D = loader_glCompressedTexSubImage3D;
  tbl.glGetCompressedTexImage = loader_glGetCompressedTexImage;
  tbl.glLoadTransposeMatrixd = loader_glLoadTransposeMatrixd;
  tbl.glLoadTransposeMatrixf = loader_glLoadTransposeMatrixf;
  tbl.glMultTransposeMatrixd = loader_glMultTransposeMatrixd;
  tbl.glMultTransposeMatrixf = loader_glMultTransposeMatrixf;
  tbl.glMultiTexCoord1d = loader_glMultiTexCoord1d;
  tbl.glMultiTexCoord1dv = loader_glMultiTexCoord1dv;
  tbl.glMultiTexCoord1f = loader_glMultiTexCoord1f;
  tbl.glMultiTexCoord1fv = loader_glMultiTexCoord1fv;
  tbl.glMultiTexCoord1i = loader_glMultiTexCoord1i;
  tbl.glMultiTexCoord1iv = loader_glMultiTexCoord1iv;
  tbl.glMultiTexCoord1s = loader_glMultiTexCoord1s;
  tbl.glMultiTexCoord1sv = loader_glMultiTexCoord1sv;
  tbl.glMultiTexCoord2d = loader_glMultiTexCoord2d;
  tbl.glMultiTexCoord2dv = loader_glMultiTexCoord2dv;
  tbl.glMultiTexCoord2f = loader_glMultiTexCoord2f;
  tbl.glMultiTexCoord2fv = loader_glMultiTexCoord2fv;
  tbl.glMultiTexCoord2i = loader_glMultiTexCoord2i;
  tbl.glMultiTexCoord2iv = loader_glMultiTexCoord2iv;
  tbl.glMultiTexCoord2s = loader_glMultiTexCoord2s;
  tbl.glMultiTexCoord2sv = loader_glMultiTexCoord2sv;
  tbl.glMultiTexCoord3d = loader_glMultiTexCoord3d;
  tbl.glMultiTexCoord3dv = loader_glMultiTexCoord3dv;
  tbl.glMultiTexCoord3f = loader_glMultiTexCoord3f;
  tbl.glMultiTexCoord3fv = loader_glMultiTexCoord3fv;
  tbl.glMultiTexCoord3i = loader_glMultiTexCoord3i;
  tbl.glMultiTexCoord3iv = loader_glMultiTexCoord3iv;
  tbl.glMultiTexCoord3s = loader_glMultiTexCoord3s;
  tbl.glMultiTexCoord3sv = loader_glMultiTexCoord3sv;
  tbl.glMultiTexCoord4d = loader_glMultiTexCoord4d;
  tbl.glMultiTexCoord4dv = loader_glMultiTexCoord4dv;
  tbl.glMultiTexCoord4f = loader_glMultiTexCoord4f;
  tbl.glMultiTexCoord4fv = loader_glMultiTexCoord4fv;
  tbl.glMultiTexCoord4i = loader_glMultiTexCoord4i;
  tbl.glMultiTexCoord4iv = loader_glMultiTexCoord4iv;
  tbl.glMultiTexCoord4s = loader_glMultiTexCoord4s;
  tbl.glMultiTexCoord4sv = loader_glMultiTexCoord4sv;
  tbl.glSampleCoverage = loader_glSampleCoverage;

  // GL_VERSION_1_4

  tbl.glBlendFuncSeparate = loader_glBlendFuncSeparate;
  tbl.glFogCoordPointer = loader_glFogCoordPointer;
  tbl.glFogCoordd = loader_glFogCoordd;
  tbl.glFogCoorddv = loader_glFogCoorddv;
  tbl.glFogCoordf = loader_glFogCoordf;
  tbl.glFogCoordfv = loader_glFogCoordfv;
  tbl.glMultiDrawArrays = loader_glMultiDrawArrays;
  tbl.glMultiDrawElements = loader_glMultiDrawElements;
  tbl.glPointParameterf = loader_glPointParameterf;
  tbl.glPointParameterfv = loader_glPointParameterfv;
  tbl.glPointParameteri = loader_glPointParameteri;
  tbl.glPointParameteriv = loader_glPointParameteriv;
  tbl.glSecondaryColor3b = loader_glSecondaryColor3b;
  tbl.glSecondaryColor3bv = loader_glSecondaryColor3bv;
  tbl.glSecondaryColor3d = loader_glSecondaryColor3d;
  tbl.glSecondaryColor3dv = loader_glSecondaryColor3dv;
  tbl.glSecondaryColor3f = loader_glSecondaryColor3f;
  tbl.glSecondaryColor3fv = loader_glSecondaryColor3fv;
  tbl.glSecondaryColor3i = loader_glSecondaryColor3i;
  tbl.glSecondaryColor3iv = loader_glSecondaryColor3iv;
  tbl.glSecondaryColor3s = loader_glSecondaryColor3s;
  tbl.glSecondaryColor3sv = loader_glSecondaryColor3sv;
  tbl.glSecondaryColor3ub = loader_glSecondaryColor3ub;
  tbl.glSecondaryColor3ubv = loader_glSecondaryColor3ubv;
  tbl.glSecondaryColor3ui = loader_glSecondaryColor3ui;
  tbl.glSecondaryColor3uiv = loader_glSecondaryColor3uiv;
  tbl.glSecondaryColor3us = loader_glSecondaryColor3us;
  tbl.glSecondaryColor3usv = loader_glSecondaryColor3usv;
  tbl.glSecondaryColorPointer = loader_glSecondaryColorPointer;
  tbl.glWindowPos2d = loader_glWindowPos2d;
  tbl.glWindowPos2dv = loader_glWindowPos2dv;
  tbl.glWindowPos2f = loader_glWindowPos2f;
  tbl.glWindowPos2fv = loader_glWindowPos2fv;
  tbl.glWindowPos2i = loader_glWindowPos2i;
  tbl.glWindowPos2iv = loader_glWindowPos2iv;
  tbl.glWindowPos2s = loader_glWindowPos2s;
  tbl.glWindowPos2sv = loader_glWindowPos2sv;
  tbl.glWindowPos3d = loader_glWindowPos3d;
  tbl.glWindowPos3dv = loader_glWindowPos3dv;
  tbl.glWindowPos3f = loader_glWindowPos3f;
  tbl.glWindowPos3fv = loader_glWindowPos3fv;
  tbl.glWindowPos3i = loader_glWindowPos3i;
  tbl.glWindowPos3iv = loader_glWindowPos3iv;
  tbl.glWindowPos3s = loader_glWindowPos3s;
  tbl.glWindowPos3sv = loader_glWindowPos3sv;

  // GL_VERSION_1_5

  tbl.glBeginQuery = loader_glBeginQuery;
  tbl.glBindBuffer = loader_glBindBuffer;
  tbl.glBufferData = loader_glBufferData;
  tbl.glBufferSubData = loader_glBufferSubData;
  tbl.glDeleteBuffers = loader_glDeleteBuffers;
  tbl.glDeleteQueries = loader_glDeleteQueries;
  tbl.glEndQuery = loader_glEndQuery;
  tbl.glGenBuffers = loader_glGenBuffers;
  tbl.glGenQueries = loader_glGenQueries;
  tbl.glGetBufferParameteriv = loader_glGetBufferParameteriv;
  tbl.glGetBufferPointerv = loader_glGetBufferPointerv;
  tbl.glGetBufferSubData = loader_glGetBufferSubData;
  tbl.glGetQueryObjectiv = loader_glGetQueryObjectiv;
  tbl.glGetQueryObjectuiv = loader_glGetQueryObjectuiv;
  tbl.glGetQueryiv = loader_glGetQueryiv;
  tbl.glIsBuffer = loader_glIsBuffer;
  tbl.glIsQuery = loader_glIsQuery;
  tbl.glMapBuffer = loader_glMapBuffer;
  tbl.glUnmapBuffer = loader_glUnmapBuffer;

  // GL_VERSION_2_0

  tbl.glAttachShader = loader_glAttachShader;
  tbl.glBindAttribLocation = loader_glBindAttribLocation;
  tbl.glBlendEquationSeparate = loader_glBlendEquationSeparate;
  tbl.glCompileShader = loader_glCompileShader;
  tbl.glCreateProgram = loader_glCreateProgram;
  tbl.glCreateShader = loader_glCreateShader;
  tbl.glDeleteProgram = loader_glDeleteProgram;
  tbl.glDeleteShader = loader_glDeleteShader;
  tbl.glDetachShader = loader_glDetachShader;
  tbl.glDisableVertexAttribArray = loader_glDisableVertexAttribArray;
  tbl.glDrawBuffers = loader_glDrawBuffers;
  tbl.glEnableVertexAttribArray = loader_glEnableVertexAttribArray;
  tbl.glGetActiveAttrib = loader_glGetActiveAttrib;
  tbl.glGetActiveUniform = loader_glGetActiveUniform;
  tbl.glGetAttachedShaders = loader_glGetAttachedShaders;
  tbl.glGetAttribLocation = loader_glGetAttribLocation;
  tbl.glGetProgramInfoLog = loader_glGetProgramInfoLog;
  tbl.glGetProgramiv = loader_glGetProgramiv;
  tbl.glGetShaderInfoLog = loader_glGetShaderInfoLog;
  tbl.glGetShaderSource = loader_glGetShaderSource;
  tbl.glGetShaderiv = loader_glGetShaderiv;
  tbl.glGetUniformLocation = loader_glGetUniformLocation;
  tbl.glGetUniformfv = loader_glGetUniformfv;
  tbl.glGetUniformiv = loader_glGetUniformiv;
  tbl.glGetVertexAttribPointerv = loader_glGetVertexAttribPointerv;
  tbl.glGetVertexAttribdv = loader_glGetVertexAttribdv;
  tbl.glGetVertexAttribfv = loader_glGetVertexAttribfv;
  tbl.glGetVertexAttribiv = loader_glGetVertexAttribiv;
  tbl.glIsProgram = loader_glIsProgram;
  tbl.glIsShader = loader_glIsShader;
  tbl.glLinkProgram = loader_glLinkProgram;
  tbl.glShaderSource = loader_glShaderSource;
  tbl.glStencilFuncSeparate = loader_glStencilFuncSeparate;
  tbl.glStencilMaskSeparate = loader_glStencilMaskSeparate;
  tbl.glStencilOpSeparate = loader_glStencilOpSeparate;
  tbl.glUniform1f = loader_glUniform1f;
  tbl.glUniform1fv = loader_glUniform1fv;
  tbl.glUniform1i = loader_glUniform1i;
  tbl.glUniform1iv = loader_glUniform1iv;
  tbl.glUniform2f = loader_glUniform2f;
  tbl.glUniform2fv = loader_glUniform2fv;
  tbl.glUniform2i = loader_glUniform2i;
  tbl.glUniform2iv = loader_glUniform2iv;
  tbl.glUniform3f = loader_glUniform3f;
  tbl.glUniform3fv = loader_glUniform3fv;
  tbl.glUniform3i = loader_glUniform3i;
  tbl.glUniform3iv = loader_glUniform3iv;
  tbl.glUniform4f = loader_glUniform4f;
  tbl.glUniform4fv = loader_glUniform4fv;
  tbl.glUniform4i = loader_glUniform4i;
  tbl.glUniform4iv = loader_glUniform4iv;
  tbl.glUniformMatrix2fv = loader_glUniformMatrix2fv;
  tbl.glUniformMatrix3fv = loader_glUniformMatrix3fv;
  tbl.glUniformMatrix4fv = loader_glUniformMatrix4fv;
  tbl.glUseProgram = loader_glUseProgram;
  tbl.glValidateProgram = loader_glValidateProgram;
  tbl.glVertexAttrib1d = loader_glVertexAttrib1d;
  tbl.glVertexAttrib1dv = loader_glVertexAttrib1dv;
  tbl.glVertexAttrib1f = loader_glVertexAttrib1f;
  tbl.glVertexAttrib1fv = loader_glVertexAttrib1fv;
  tbl.glVertexAttrib1s = loader_glVertexAttrib1s;
  tbl.glVertexAttrib1sv = loader_glVertexAttrib1sv;
  tbl.glVertexAttrib2d = loader_glVertexAttrib2d;
  tbl.glVertexAttrib2dv = loader_glVertexAttrib2dv;
  tbl.glVertexAttrib2f = loader_glVertexAttrib2f;
  tbl.glVertexAttrib2fv = loader_glVertexAttrib2fv;
  tbl.glVertexAttrib2s = loader_glVertexAttrib2s;
  tbl.glVertexAttrib2sv = loader_glVertexAttrib2sv;
  tbl.glVertexAttrib3d = loader_glVertexAttrib3d;
  tbl.glVertexAttrib3dv = loader_glVertexAttrib3dv;
  tbl.glVertexAttrib3f = loader_glVertexAttrib3f;
  tbl.glVertexAttrib3fv = loader_glVertexAttrib3fv;
  tbl.glVertexAttrib3s = loader_glVertexAttrib3s;
  tbl.glVertexAttrib3sv = loader_glVertexAttrib3sv;
  tbl.glVertexAttrib4Nbv = loader_glVertexAttrib4Nbv;
  tbl.glVertexAttrib4Niv = loader_glVertexAttrib4Niv;
  tbl.glVertexAttrib4Nsv = loader_glVertexAttrib4Nsv;
  tbl.glVertexAttrib4Nub = loader_glVertexAttrib4Nub;
  tbl.glVertexAttrib4Nubv = loader_glVertexAttrib4Nubv;
  tbl.glVertexAttrib4Nuiv = loader_glVertexAttrib4Nuiv;
  tbl.glVertexAttrib4Nusv = loader_glVertexAttrib4Nusv;
  tbl.glVertexAttrib4bv = loader_glVertexAttrib4bv;
  tbl.glVertexAttrib4d = loader_glVertexAttrib4d;
  tbl.glVertexAttrib4dv = loader_glVertexAttrib4dv;
  tbl.glVertexAttrib4f = loader_glVertexAttrib4f;
  tbl.glVertexAttrib4fv = loader_glVertexAttrib4fv;
  tbl.glVertexAttrib4iv = loader_glVertexAttrib4iv;
  tbl.glVertexAttrib4s = loader_glVertexAttrib4s;
  tbl.glVertexAttrib4sv = loader_glVertexAttrib4sv;
  tbl.glVertexAttrib4ubv = loader_glVertexAttrib4ubv;
  tbl.glVertexAttrib4uiv = loader_glVertexAttrib4uiv;
  tbl.glVertexAttrib4usv = loader_glVertexAttrib4usv;
  tbl.glVertexAttribPointer = loader_glVertexAttribPointer;

  // GL_VERSION_2_1

  tbl.glUniformMatrix2x3fv = loader_glUniformMatrix2x3fv;
  tbl.glUniformMatrix2x4fv = loader_glUniformMatrix2x4fv;
  tbl.glUniformMatrix3x2fv = loader_glUniformMatrix3x2fv;
  tbl.glUniformMatrix3x4fv = loader_glUniformMatrix3x4fv;
  tbl.glUniformMatrix4x2fv = loader_glUniformMatrix4x2fv;
  tbl.glUniformMatrix4x3fv = loader_glUniformMatrix4x3fv;

  // GL_VERSION_3_0

  tbl.glBeginConditionalRender = loader_glBeginConditionalRender;
  tbl.glBeginTransformFeedback = loader_glBeginTransformFeedback;
  tbl.glBindFragDataLocation = loader_glBindFragDataLocation;
  tbl.glClampColor = loader_glClampColor;
  tbl.glClearBufferfi = loader_glClearBufferfi;
  tbl.glClearBufferfv = loader_glClearBufferfv;
  tbl.glClearBufferiv = loader_glClearBufferiv;
  tbl.glClearBufferuiv = loader_glClearBufferuiv;
  tbl.glColorMaski = loader_glColorMaski;
  tbl.glDisablei = loader_glDisablei;
  tbl.glEnablei = loader_glEnablei;
  tbl.glEndConditionalRender = loader_glEndConditionalRender;
  tbl.glEndTransformFeedback = loader_glEndTransformFeedback;
  tbl.glGetBooleani_v = loader_glGetBooleani_v;
  tbl.glGetFragDataLocation = loader_glGetFragDataLocation;
  tbl.glGetStringi = loader_glGetStringi;
  tbl.glGetTexParameterIiv = loader_glGetTexParameterIiv;
  tbl.glGetTexParameterIuiv = loader_glGetTexParameterIuiv;
  tbl.glGetTransformFeedbackVarying = loader_glGetTransformFeedbackVarying;
  tbl.glGetUniformuiv = loader_glGetUniformuiv;
  tbl.glGetVertexAttribIiv = loader_glGetVertexAttribIiv;
  tbl.glGetVertexAttribIuiv = loader_glGetVertexAttribIuiv;
  tbl.glIsEnabledi = loader_glIsEnabledi;
  tbl.glTexParameterIiv = loader_glTexParameterIiv;
  tbl.glTexParameterIuiv = loader_glTexParameterIuiv;
  tbl.glTransformFeedbackVaryings = loader_glTransformFeedbackVaryings;
  tbl.glUniform1ui = loader_glUniform1ui;
  tbl.glUniform1uiv = loader_glUniform1uiv;
  tbl.glUniform2ui = loader_glUniform2ui;
  tbl.glUniform2uiv = loader_glUniform2uiv;
  tbl.glUniform3ui = loader_glUniform3ui;
  tbl.glUniform3uiv = loader_glUniform3uiv;
  tbl.glUniform4ui = loader_glUniform4ui;
  tbl.glUniform4uiv = loader_glUniform4uiv;
  tbl.glVertexAttribI1i = loader_glVertexAttribI1i;
  tbl.glVertexAttribI1iv = loader_glVertexAttribI1iv;
  tbl.glVertexAttribI1ui = loader_glVertexAttribI1ui;
  tbl.glVertexAttribI1uiv = loader_glVertexAttribI1uiv;
  tbl.glVertexAttribI2i = loader_glVertexAttribI2i;
  tbl.glVertexAttribI2iv = loader_glVertexAttribI2iv;
  tbl.glVertexAttribI2ui = loader_glVertexAttribI2ui;
  tbl.glVertexAttribI2uiv = loader_glVertexAttribI2uiv;
  tbl.glVertexAttribI3i = loader_glVertexAttribI3i;
  tbl.glVertexAttribI3iv = loader_glVertexAttribI3iv;
  tbl.glVertexAttribI3ui = loader_glVertexAttribI3ui;
  tbl.glVertexAttribI3uiv = loader_glVertexAttribI3uiv;
  tbl.glVertexAttribI4bv = loader_glVertexAttribI4bv;
  tbl.glVertexAttribI4i = loader_glVertexAttribI4i;
  tbl.glVertexAttribI4iv = loader_glVertexAttribI4iv;
  tbl.glVertexAttribI4sv = loader_glVertexAttribI4sv;
  tbl.glVertexAttribI4ubv = loader_glVertexAttribI4ubv;
  tbl.glVertexAttribI4ui = loader_glVertexAttribI4ui;
  tbl.glVertexAttribI4uiv = loader_glVertexAttribI4uiv;
  tbl.glVertexAttribI4usv = loader_glVertexAttribI4usv;
  tbl.glVertexAttribIPointer = loader_glVertexAttribIPointer;

  // GL_VERSION_3_1

  tbl.glDrawArraysInstanced = loader_glDrawArraysInstanced;
  tbl.glDrawElementsInstanced = loader_glDrawElementsInstanced;
  tbl.glPrimitiveRestartIndex = loader_glPrimitiveRestartIndex;
  tbl.glTexBuffer = loader_glTexBuffer;

  // GL_VERSION_3_2

  tbl.glFramebufferTexture = loader_glFramebufferTexture;
  tbl.glFramebufferTextureFace = loader_glFramebufferTextureFace;
  tbl.glGetBufferParameteri64v = loader_glGetBufferParameteri64v;
  tbl.glGetInteger64i_v = loader_glGetInteger64i_v;

  // GL_VERSION_3_3

  tbl.glVertexAttribDivisor = loader_glVertexAttribDivisor;

  // GL_VERSION_4_0

  tbl.glBlendEquationSeparatei = loader_glBlendEquationSeparatei;
  tbl.glBlendEquationi = loader_glBlendEquationi;
  tbl.glBlendFuncSeparatei = loader_glBlendFuncSeparatei;
  tbl.glBlendFunci = loader_glBlendFunci;

  // GL_3DFX_tbuffer

  tbl.glTbufferMask3DFX = loader_glTbufferMask3DFX;

  // GL_AMD_debug_output

  tbl.glDebugMessageCallbackAMD = loader_glDebugMessageCallbackAMD;
  tbl.glDebugMessageEnableAMD = loader_glDebugMessageEnableAMD;
  tbl.glDebugMessageInsertAMD = loader_glDebugMessageInsertAMD;
  tbl.glGetDebugMessageLogAMD = loader_glGetDebugMessageLogAMD;

  // GL_AMD_draw_buffers_blend

  tbl.glBlendEquationIndexedAMD = loader_glBlendEquationIndexedAMD;
  tbl.glBlendEquationSeparateIndexedAMD = loader_glBlendEquationSeparateIndexedAMD;
  tbl.glBlendFuncIndexedAMD = loader_glBlendFuncIndexedAMD;
  tbl.glBlendFuncSeparateIndexedAMD = loader_glBlendFuncSeparateIndexedAMD;

  // GL_AMD_multi_draw_indirect

  tbl.glMultiDrawArraysIndirectAMD = loader_glMultiDrawArraysIndirectAMD;
  tbl.glMultiDrawElementsIndirectAMD = loader_glMultiDrawElementsIndirectAMD;

  // GL_AMD_name_gen_delete

  tbl.glDeleteNamesAMD = loader_glDeleteNamesAMD;
  tbl.glGenNamesAMD = loader_glGenNamesAMD;
  tbl.glIsNameAMD = loader_glIsNameAMD;

  // GL_AMD_performance_monitor

  tbl.glBeginPerfMonitorAMD = loader_glBeginPerfMonitorAMD;
  tbl.glDeletePerfMonitorsAMD = loader_glDeletePerfMonitorsAMD;
  tbl.glEndPerfMonitorAMD = loader_glEndPerfMonitorAMD;
  tbl.glGenPerfMonitorsAMD = loader_glGenPerfMonitorsAMD;
  tbl.glGetPerfMonitorCounterDataAMD = loader_glGetPerfMonitorCounterDataAMD;
  tbl.glGetPerfMonitorCounterInfoAMD = loader_glGetPerfMonitorCounterInfoAMD;
  tbl.glGetPerfMonitorCounterStringAMD = loader_glGetPerfMonitorCounterStringAMD;
  tbl.glGetPerfMonitorCountersAMD = loader_glGetPerfMonitorCountersAMD;
  tbl.glGetPerfMonitorGroupStringAMD = loader_glGetPerfMonitorGroupStringAMD;
  tbl.glGetPerfMonitorGroupsAMD = loader_glGetPerfMonitorGroupsAMD;
  tbl.glSelectPerfMonitorCountersAMD = loader_glSelectPerfMonitorCountersAMD;

  // GL_AMD_sample_positions

  tbl.glSetMultisamplefvAMD = loader_glSetMultisamplefvAMD;

  // GL_AMD_stencil_operation_extended

  tbl.glStencilOpValueAMD = loader_glStencilOpValueAMD;

  // GL_AMD_vertex_shader_tessellator

  tbl.glTessellationFactorAMD = loader_glTessellationFactorAMD;
  tbl.glTessellationModeAMD = loader_glTessellationModeAMD;

  // GL_ANGLE_framebuffer_blit

  tbl.glBlitFramebufferANGLE = loader_glBlitFramebufferANGLE;

  // GL_ANGLE_framebuffer_multisample

  tbl.glRenderbufferStorageMultisampleANGLE = loader_glRenderbufferStorageMultisampleANGLE;

  // GL_ANGLE_instanced_arrays

  tbl.glDrawArraysInstancedANGLE = loader_glDrawArraysInstancedANGLE;
  tbl.glDrawElementsInstancedANGLE = loader_glDrawElementsInstancedANGLE;
  tbl.glVertexAttribDivisorANGLE = loader_glVertexAttribDivisorANGLE;

  // GL_ANGLE_translated_shader_source

  tbl.glGetTranslatedShaderSourceANGLE = loader_glGetTranslatedShaderSourceANGLE;

  // GL_APPLE_copy_texture_levels

  tbl.glCopyTextureLevelsAPPLE = loader_glCopyTextureLevelsAPPLE;

  // GL_APPLE_element_array

  tbl.glDrawElementArrayAPPLE = loader_glDrawElementArrayAPPLE;
  tbl.glDrawRangeElementArrayAPPLE = loader_glDrawRangeElementArrayAPPLE;
  tbl.glElementPointerAPPLE = loader_glElementPointerAPPLE;
  tbl.glMultiDrawElementArrayAPPLE = loader_glMultiDrawElementArrayAPPLE;
  tbl.glMultiDrawRangeElementArrayAPPLE = loader_glMultiDrawRangeElementArrayAPPLE;

  // GL_APPLE_fence

  tbl.glDeleteFencesAPPLE = loader_glDeleteFencesAPPLE;
  tbl.glFinishFenceAPPLE = loader_glFinishFenceAPPLE;
  tbl.glFinishObjectAPPLE = loader_glFinishObjectAPPLE;
  tbl.glGenFencesAPPLE = loader_glGenFencesAPPLE;
  tbl.glIsFenceAPPLE = loader_glIsFenceAPPLE;
  tbl.glSetFenceAPPLE = loader_glSetFenceAPPLE;
  tbl.glTestFenceAPPLE = loader_glTestFenceAPPLE;
  tbl.glTestObjectAPPLE = loader_glTestObjectAPPLE;

  // GL_APPLE_flush_buffer_range

  tbl.glBufferParameteriAPPLE = loader_glBufferParameteriAPPLE;
  tbl.glFlushMappedBufferRangeAPPLE = loader_glFlushMappedBufferRangeAPPLE;

  // GL_APPLE_flush_render

  tbl.glFinishRenderAPPLE = loader_glFinishRenderAPPLE;
  tbl.glFlushRenderAPPLE = loader_glFlushRenderAPPLE;
  tbl.glSwapAPPLE = loader_glSwapAPPLE;

  // GL_APPLE_framebuffer_multisample

  tbl.glRenderbufferStorageMultisampleAPPLE = loader_glRenderbufferStorageMultisampleAPPLE;
  tbl.glResolveMultisampleFramebufferAPPLE = loader_glResolveMultisampleFramebufferAPPLE;

  // GL_APPLE_object_purgeable

  tbl.glGetObjectParameterivAPPLE = loader_glGetObjectParameterivAPPLE;
  tbl.glObjectPurgeableAPPLE = loader_glObjectPurgeableAPPLE;
  tbl.glObjectUnpurgeableAPPLE = loader_glObjectUnpurgeableAPPLE;

  // GL_APPLE_sync

  tbl.glClientWaitSyncAPPLE = loader_glClientWaitSyncAPPLE;
  tbl.glDeleteSyncAPPLE = loader_glDeleteSyncAPPLE;
  tbl.glFenceSyncAPPLE = loader_glFenceSyncAPPLE;
  tbl.glGetInteger64vAPPLE = loader_glGetInteger64vAPPLE;
  tbl.glGetSyncivAPPLE = loader_glGetSyncivAPPLE;
  tbl.glIsSyncAPPLE = loader_glIsSyncAPPLE;
  tbl.glWaitSyncAPPLE = loader_glWaitSyncAPPLE;

  // GL_APPLE_texture_range

  tbl.glGetTexParameterPointervAPPLE = loader_glGetTexParameterPointervAPPLE;
  tbl.glTextureRangeAPPLE = loader_glTextureRangeAPPLE;

  // GL_APPLE_vertex_array_object

  tbl.glBindVertexArrayAPPLE = loader_glBindVertexArrayAPPLE;
  tbl.glDeleteVertexArraysAPPLE = loader_glDeleteVertexArraysAPPLE;
  tbl.glGenVertexArraysAPPLE = loader_glGenVertexArraysAPPLE;
  tbl.glIsVertexArrayAPPLE = loader_glIsVertexArrayAPPLE;

  // GL_APPLE_vertex_array_range

  tbl.glFlushVertexArrayRangeAPPLE = loader_glFlushVertexArrayRangeAPPLE;
  tbl.glVertexArrayParameteriAPPLE = loader_glVertexArrayParameteriAPPLE;
  tbl.glVertexArrayRangeAPPLE = loader_glVertexArrayRangeAPPLE;

  // GL_APPLE_vertex_program_evaluators

  tbl.glDisableVertexAttribAPPLE = loader_glDisableVertexAttribAPPLE;
  tbl.glEnableVertexAttribAPPLE = loader_glEnableVertexAttribAPPLE;
  tbl.glIsVertexAttribEnabledAPPLE = loader_glIsVertexAttribEnabledAPPLE;
  tbl.glMapVertexAttrib1dAPPLE = loader_glMapVertexAttrib1dAPPLE;
  tbl.glMapVertexAttrib1fAPPLE = loader_glMapVertexAttrib1fAPPLE;
  tbl.glMapVertexAttrib2dAPPLE = loader_glMapVertexAttrib2dAPPLE;
  tbl.glMapVertexAttrib2fAPPLE = loader_glMapVertexAttrib2fAPPLE;

  // GL_ARB_ES2_compatibility

  tbl.glClearDepthf = loader_glClearDepthf;
  tbl.glDepthRangef = loader_glDepthRangef;
  tbl.glGetShaderPrecisionFormat = loader_glGetShaderPrecisionFormat;
  tbl.glReleaseShaderCompiler = loader_glReleaseShaderCompiler;
  tbl.glShaderBinary = loader_glShaderBinary;

  // GL_ARB_base_instance

  tbl.glDrawArraysInstancedBaseInstance = loader_glDrawArraysInstancedBaseInstance;
  tbl.glDrawElementsInstancedBaseInstance = loader_glDrawElementsInstancedBaseInstance;
  tbl.glDrawElementsInstancedBaseVertexBaseInstance = loader_glDrawElementsInstancedBaseVertexBaseInstance;

  // GL_ARB_blend_func_extended

  tbl.glBindFragDataLocationIndexed = loader_glBindFragDataLocationIndexed;
  tbl.glGetFragDataIndex = loader_glGetFragDataIndex;

  // GL_ARB_cl_event

  tbl.glCreateSyncFromCLeventARB = loader_glCreateSyncFromCLeventARB;

  // GL_ARB_clear_buffer_object

  tbl.glClearBufferData = loader_glClearBufferData;
  tbl.glClearBufferSubData = loader_glClearBufferSubData;
  tbl.glClearNamedBufferDataEXT = loader_glClearNamedBufferDataEXT;
  tbl.glClearNamedBufferSubDataEXT = loader_glClearNamedBufferSubDataEXT;

  // GL_ARB_color_buffer_float

  tbl.glClampColorARB = loader_glClampColorARB;

  // GL_ARB_compute_shader

  tbl.glDispatchCompute = loader_glDispatchCompute;
  tbl.glDispatchComputeIndirect = loader_glDispatchComputeIndirect;

  // GL_ARB_copy_buffer

  tbl.glCopyBufferSubData = loader_glCopyBufferSubData;

  // GL_ARB_copy_image

  tbl.glCopyImageSubData = loader_glCopyImageSubData;

  // GL_ARB_debug_output

  tbl.glDebugMessageCallbackARB = loader_glDebugMessageCallbackARB;
  tbl.glDebugMessageControlARB = loader_glDebugMessageControlARB;
  tbl.glDebugMessageInsertARB = loader_glDebugMessageInsertARB;
  tbl.glGetDebugMessageLogARB = loader_glGetDebugMessageLogARB;

  // GL_ARB_draw_buffers

  tbl.glDrawBuffersARB = loader_glDrawBuffersARB;

  // GL_ARB_draw_buffers_blend

  tbl.glBlendEquationSeparateiARB = loader_glBlendEquationSeparateiARB;
  tbl.glBlendEquationiARB = loader_glBlendEquationiARB;
  tbl.glBlendFuncSeparateiARB = loader_glBlendFuncSeparateiARB;
  tbl.glBlendFunciARB = loader_glBlendFunciARB;

  // GL_ARB_draw_elements_base_vertex

  tbl.glDrawElementsBaseVertex = loader_glDrawElementsBaseVertex;
  tbl.glDrawElementsInstancedBaseVertex = loader_glDrawElementsInstancedBaseVertex;
  tbl.glDrawRangeElementsBaseVertex = loader_glDrawRangeElementsBaseVertex;
  tbl.glMultiDrawElementsBaseVertex = loader_glMultiDrawElementsBaseVertex;

  // GL_ARB_draw_indirect

  tbl.glDrawArraysIndirect = loader_glDrawArraysIndirect;
  tbl.glDrawElementsIndirect = loader_glDrawElementsIndirect;

  // GL_ARB_draw_instanced

  tbl.glDrawArraysInstancedARB = loader_glDrawArraysInstancedARB;
  tbl.glDrawElementsInstancedARB = loader_glDrawElementsInstancedARB;

  // GL_ARB_framebuffer_no_attachments

  tbl.glFramebufferParameteri = loader_glFramebufferParameteri;
  tbl.glGetFramebufferParameteriv = loader_glGetFramebufferParameteriv;
  tbl.glGetNamedFramebufferParameterivEXT = loader_glGetNamedFramebufferParameterivEXT;
  tbl.glNamedFramebufferParameteriEXT = loader_glNamedFramebufferParameteriEXT;

  // GL_ARB_framebuffer_object

  tbl.glBindFramebuffer = loader_glBindFramebuffer;
  tbl.glBindRenderbuffer = loader_glBindRenderbuffer;
  tbl.glBlitFramebuffer = loader_glBlitFramebuffer;
  tbl.glCheckFramebufferStatus = loader_glCheckFramebufferStatus;
  tbl.glDeleteFramebuffers = loader_glDeleteFramebuffers;
  tbl.glDeleteRenderbuffers = loader_glDeleteRenderbuffers;
  tbl.glFramebufferRenderbuffer = loader_glFramebufferRenderbuffer;
  tbl.glFramebufferTexture1D = loader_glFramebufferTexture1D;
  tbl.glFramebufferTexture2D = loader_glFramebufferTexture2D;
  tbl.glFramebufferTexture3D = loader_glFramebufferTexture3D;
  tbl.glFramebufferTextureLayer = loader_glFramebufferTextureLayer;
  tbl.glGenFramebuffers = loader_glGenFramebuffers;
  tbl.glGenRenderbuffers = loader_glGenRenderbuffers;
  tbl.glGenerateMipmap = loader_glGenerateMipmap;
  tbl.glGetFramebufferAttachmentParameteriv = loader_glGetFramebufferAttachmentParameteriv;
  tbl.glGetRenderbufferParameteriv = loader_glGetRenderbufferParameteriv;
  tbl.glIsFramebuffer = loader_glIsFramebuffer;
  tbl.glIsRenderbuffer = loader_glIsRenderbuffer;
  tbl.glRenderbufferStorage = loader_glRenderbufferStorage;
  tbl.glRenderbufferStorageMultisample = loader_glRenderbufferStorageMultisample;

  // GL_ARB_geometry_shader4

  tbl.glFramebufferTextureARB = loader_glFramebufferTextureARB;
  tbl.glFramebufferTextureFaceARB = loader_glFramebufferTextureFaceARB;
  tbl.glFramebufferTextureLayerARB = loader_glFramebufferTextureLayerARB;
  tbl.glProgramParameteriARB = loader_glProgramParameteriARB;

  // GL_ARB_get_program_binary

  tbl.glGetProgramBinary = loader_glGetProgramBinary;
  tbl.glProgramBinary = loader_glProgramBinary;
  tbl.glProgramParameteri = loader_glProgramParameteri;

  // GL_ARB_gpu_shader_fp64

  tbl.glGetUniformdv = loader_glGetUniformdv;
  tbl.glUniform1d = loader_glUniform1d;
  tbl.glUniform1dv = loader_glUniform1dv;
  tbl.glUniform2d = loader_glUniform2d;
  tbl.glUniform2dv = loader_glUniform2dv;
  tbl.glUniform3d = loader_glUniform3d;
  tbl.glUniform3dv = loader_glUniform3dv;
  tbl.glUniform4d = loader_glUniform4d;
  tbl.glUniform4dv = loader_glUniform4dv;
  tbl.glUniformMatrix2dv = loader_glUniformMatrix2dv;
  tbl.glUniformMatrix2x3dv = loader_glUniformMatrix2x3dv;
  tbl.glUniformMatrix2x4dv = loader_glUniformMatrix2x4dv;
  tbl.glUniformMatrix3dv = loader_glUniformMatrix3dv;
  tbl.glUniformMatrix3x2dv = loader_glUniformMatrix3x2dv;
  tbl.glUniformMatrix3x4dv = loader_glUniformMatrix3x4dv;
  tbl.glUniformMatrix4dv = loader_glUniformMatrix4dv;
  tbl.glUniformMatrix4x2dv = loader_glUniformMatrix4x2dv;
  tbl.glUniformMatrix4x3dv = loader_glUniformMatrix4x3dv;

  // GL_ARB_imaging

  tbl.glColorSubTable = loader_glColorSubTable;
  tbl.glColorTable = loader_glColorTable;
  tbl.glColorTableParameterfv = loader_glColorTableParameterfv;
  tbl.glColorTableParameteriv = loader_glColorTableParameteriv;
  tbl.glConvolutionFilter1D = loader_glConvolutionFilter1D;
  tbl.glConvolutionFilter2D = loader_glConvolutionFilter2D;
  tbl.glConvolutionParameterf = loader_glConvolutionParameterf;
  tbl.glConvolutionParameterfv = loader_glConvolutionParameterfv;
  tbl.glConvolutionParameteri = loader_glConvolutionParameteri;
  tbl.glConvolutionParameteriv = loader_glConvolutionParameteriv;
  tbl.glCopyColorSubTable = loader_glCopyColorSubTable;
  tbl.glCopyColorTable = loader_glCopyColorTable;
  tbl.glCopyConvolutionFilter1D = loader_glCopyConvolutionFilter1D;
  tbl.glCopyConvolutionFilter2D = loader_glCopyConvolutionFilter2D;
  tbl.glGetColorTable = loader_glGetColorTable;
  tbl.glGetColorTableParameterfv = loader_glGetColorTableParameterfv;
  tbl.glGetColorTableParameteriv = loader_glGetColorTableParameteriv;
  tbl.glGetConvolutionFilter = loader_glGetConvolutionFilter;
  tbl.glGetConvolutionParameterfv = loader_glGetConvolutionParameterfv;
  tbl.glGetConvolutionParameteriv = loader_glGetConvolutionParameteriv;
  tbl.glGetHistogram = loader_glGetHistogram;
  tbl.glGetHistogramParameterfv = loader_glGetHistogramParameterfv;
  tbl.glGetHistogramParameteriv = loader_glGetHistogramParameteriv;
  tbl.glGetMinmax = loader_glGetMinmax;
  tbl.glGetMinmaxParameterfv = loader_glGetMinmaxParameterfv;
  tbl.glGetMinmaxParameteriv = loader_glGetMinmaxParameteriv;
  tbl.glGetSeparableFilter = loader_glGetSeparableFilter;
  tbl.glHistogram = loader_glHistogram;
  tbl.glMinmax = loader_glMinmax;
  tbl.glResetHistogram = loader_glResetHistogram;
  tbl.glResetMinmax = loader_glResetMinmax;
  tbl.glSeparableFilter2D = loader_glSeparableFilter2D;

  // GL_ARB_instanced_arrays

  tbl.glVertexAttribDivisorARB = loader_glVertexAttribDivisorARB;

  // GL_ARB_internalformat_query

  tbl.glGetInternalformativ = loader_glGetInternalformativ;

  // GL_ARB_internalformat_query2

  tbl.glGetInternalformati64v = loader_glGetInternalformati64v;

  // GL_ARB_invalidate_subdata

  tbl.glInvalidateBufferData = loader_glInvalidateBufferData;
  tbl.glInvalidateBufferSubData = loader_glInvalidateBufferSubData;
  tbl.glInvalidateFramebuffer = loader_glInvalidateFramebuffer;
  tbl.glInvalidateSubFramebuffer = loader_glInvalidateSubFramebuffer;
  tbl.glInvalidateTexImage = loader_glInvalidateTexImage;
  tbl.glInvalidateTexSubImage = loader_glInvalidateTexSubImage;

  // GL_ARB_map_buffer_range

  tbl.glFlushMappedBufferRange = loader_glFlushMappedBufferRange;
  tbl.glMapBufferRange = loader_glMapBufferRange;

  // GL_ARB_matrix_palette

  tbl.glCurrentPaletteMatrixARB = loader_glCurrentPaletteMatrixARB;
  tbl.glMatrixIndexPointerARB = loader_glMatrixIndexPointerARB;
  tbl.glMatrixIndexubvARB = loader_glMatrixIndexubvARB;
  tbl.glMatrixIndexuivARB = loader_glMatrixIndexuivARB;
  tbl.glMatrixIndexusvARB = loader_glMatrixIndexusvARB;

  // GL_ARB_multi_draw_indirect

  tbl.glMultiDrawArraysIndirect = loader_glMultiDrawArraysIndirect;
  tbl.glMultiDrawElementsIndirect = loader_glMultiDrawElementsIndirect;

  // GL_ARB_multisample

  tbl.glSampleCoverageARB = loader_glSampleCoverageARB;

  // GL_ARB_multitexture

  tbl.glActiveTextureARB = loader_glActiveTextureARB;
  tbl.glClientActiveTextureARB = loader_glClientActiveTextureARB;
  tbl.glMultiTexCoord1dARB = loader_glMultiTexCoord1dARB;
  tbl.glMultiTexCoord1dvARB = loader_glMultiTexCoord1dvARB;
  tbl.glMultiTexCoord1fARB = loader_glMultiTexCoord1fARB;
  tbl.glMultiTexCoord1fvARB = loader_glMultiTexCoord1fvARB;
  tbl.glMultiTexCoord1iARB = loader_glMultiTexCoord1iARB;
  tbl.glMultiTexCoord1ivARB = loader_glMultiTexCoord1ivARB;
  tbl.glMultiTexCoord1sARB = loader_glMultiTexCoord1sARB;
  tbl.glMultiTexCoord1svARB = loader_glMultiTexCoord1svARB;
  tbl.glMultiTexCoord2dARB = loader_glMultiTexCoord2dARB;
  tbl.glMultiTexCoord2dvARB = loader_glMultiTexCoord2dvARB;
  tbl.glMultiTexCoord2fARB = loader_glMultiTexCoord2fARB;
  tbl.glMultiTexCoord2fvARB = loader_glMultiTexCoord2fvARB;
  tbl.glMultiTexCoord2iARB = loader_glMultiTexCoord2iARB;
  tbl.glMultiTexCoord2ivARB = loader_glMultiTexCoord2ivARB;
  tbl.glMultiTexCoord2sARB = loader_glMultiTexCoord2sARB;
  tbl.glMultiTexCoord2svARB = loader_glMultiTexCoord2svARB;
  tbl.glMultiTexCoord3dARB = loader_glMultiTexCoord3dARB;
  tbl.glMultiTexCoord3dvARB = loader_glMultiTexCoord3dvARB;
  tbl.glMultiTexCoord3fARB = loader_glMultiTexCoord3fARB;
  tbl.glMultiTexCoord3fvARB = loader_glMultiTexCoord3fvARB;
  tbl.glMultiTexCoord3iARB = loader_glMultiTexCoord3iARB;
  tbl.glMultiTexCoord3ivARB = loader_glMultiTexCoord3ivARB;
  tbl.glMultiTexCoord3sARB = loader_glMultiTexCoord3sARB;
  tbl.glMultiTexCoord3svARB = loader_glMultiTexCoord3svARB;
  tbl.glMultiTexCoord4dARB = loader_glMultiTexCoord4dARB;
  tbl.glMultiTexCoord4dvARB = loader_glMultiTexCoord4dvARB;
  tbl.glMultiTexCoord4fARB = loader_glMultiTexCoord4fARB;
  tbl.glMultiTexCoord4fvARB = loader_glMultiTexCoord4fvARB;
  tbl.glMultiTexCoord4iARB = loader_glMultiTexCoord4iARB;
  tbl.glMultiTexCoord4ivARB = loader_glMultiTexCoord4ivARB;
  tbl.glMultiTexCoord4sARB = loader_glMultiTexCoord4sARB;
  tbl.glMultiTexCoord4svARB = loader_glMultiTexCoord4svARB;

  // GL_ARB_occlusion_query

  tbl.glBeginQueryARB = loader_glBeginQueryARB;
  tbl.glDeleteQueriesARB = loader_glDeleteQueriesARB;
  tbl.glEndQueryARB = loader_glEndQueryARB;
  tbl.glGenQueriesARB = loader_glGenQueriesARB;
  tbl.glGetQueryObjectivARB = loader_glGetQueryObjectivARB;
  tbl.glGetQueryObjectuivARB = loader_glGetQueryObjectuivARB;
  tbl.glGetQueryivARB = loader_glGetQueryivARB;
  tbl.glIsQueryARB = loader_glIsQueryARB;

  // GL_ARB_point_parameters

  tbl.glPointParameterfARB = loader_glPointParameterfARB;
  tbl.glPointParameterfvARB = loader_glPointParameterfvARB;

  // GL_ARB_program_interface_query

  tbl.glGetProgramInterfaceiv = loader_glGetProgramInterfaceiv;
  tbl.glGetProgramResourceIndex = loader_glGetProgramResourceIndex;
  tbl.glGetProgramResourceLocation = loader_glGetProgramResourceLocation;
  tbl.glGetProgramResourceLocationIndex = loader_glGetProgramResourceLocationIndex;
  tbl.glGetProgramResourceName = loader_glGetProgramResourceName;
  tbl.glGetProgramResourceiv = loader_glGetProgramResourceiv;

  // GL_ARB_provoking_vertex

  tbl.glProvokingVertex = loader_glProvokingVertex;

  // GL_ARB_robustness

  tbl.glGetGraphicsResetStatusARB = loader_glGetGraphicsResetStatusARB;
  tbl.glGetnColorTableARB = loader_glGetnColorTableARB;
  tbl.glGetnCompressedTexImageARB = loader_glGetnCompressedTexImageARB;
  tbl.glGetnConvolutionFilterARB = loader_glGetnConvolutionFilterARB;
  tbl.glGetnHistogramARB = loader_glGetnHistogramARB;
  tbl.glGetnMapdvARB = loader_glGetnMapdvARB;
  tbl.glGetnMapfvARB = loader_glGetnMapfvARB;
  tbl.glGetnMapivARB = loader_glGetnMapivARB;
  tbl.glGetnMinmaxARB = loader_glGetnMinmaxARB;
  tbl.glGetnPixelMapfvARB = loader_glGetnPixelMapfvARB;
  tbl.glGetnPixelMapuivARB = loader_glGetnPixelMapuivARB;
  tbl.glGetnPixelMapusvARB = loader_glGetnPixelMapusvARB;
  tbl.glGetnPolygonStippleARB = loader_glGetnPolygonStippleARB;
  tbl.glGetnSeparableFilterARB = loader_glGetnSeparableFilterARB;
  tbl.glGetnTexImageARB = loader_glGetnTexImageARB;
  tbl.glGetnUniformdvARB = loader_glGetnUniformdvARB;
  tbl.glGetnUniformfvARB = loader_glGetnUniformfvARB;
  tbl.glGetnUniformivARB = loader_glGetnUniformivARB;
  tbl.glGetnUniformuivARB = loader_glGetnUniformuivARB;
  tbl.glReadnPixelsARB = loader_glReadnPixelsARB;

  // GL_ARB_sample_shading

  tbl.glMinSampleShading = loader_glMinSampleShading;
  tbl.glMinSampleShadingARB = loader_glMinSampleShadingARB;

  // GL_ARB_sampler_objects

  tbl.glBindSampler = loader_glBindSampler;
  tbl.glDeleteSamplers = loader_glDeleteSamplers;
  tbl.glGenSamplers = loader_glGenSamplers;
  tbl.glGetSamplerParameterIiv = loader_glGetSamplerParameterIiv;
  tbl.glGetSamplerParameterIuiv = loader_glGetSamplerParameterIuiv;
  tbl.glGetSamplerParameterfv = loader_glGetSamplerParameterfv;
  tbl.glGetSamplerParameteriv = loader_glGetSamplerParameteriv;
  tbl.glIsSampler = loader_glIsSampler;
  tbl.glSamplerParameterIiv = loader_glSamplerParameterIiv;
  tbl.glSamplerParameterIuiv = loader_glSamplerParameterIuiv;
  tbl.glSamplerParameterf = loader_glSamplerParameterf;
  tbl.glSamplerParameterfv = loader_glSamplerParameterfv;
  tbl.glSamplerParameteri = loader_glSamplerParameteri;
  tbl.glSamplerParameteriv = loader_glSamplerParameteriv;

  // GL_ARB_separate_shader_objects

  tbl.glActiveShaderProgram = loader_glActiveShaderProgram;
  tbl.glBindProgramPipeline = loader_glBindProgramPipeline;
  tbl.glCreateShaderProgramv = loader_glCreateShaderProgramv;
  tbl.glDeleteProgramPipelines = loader_glDeleteProgramPipelines;
  tbl.glGenProgramPipelines = loader_glGenProgramPipelines;
  tbl.glGetProgramPipelineInfoLog = loader_glGetProgramPipelineInfoLog;
  tbl.glGetProgramPipelineiv = loader_glGetProgramPipelineiv;
  tbl.glIsProgramPipeline = loader_glIsProgramPipeline;
  tbl.glProgramUniform1d = loader_glProgramUniform1d;
  tbl.glProgramUniform1dv = loader_glProgramUniform1dv;
  tbl.glProgramUniform1f = loader_glProgramUniform1f;
  tbl.glProgramUniform1fv = loader_glProgramUniform1fv;
  tbl.glProgramUniform1i = loader_glProgramUniform1i;
  tbl.glProgramUniform1iv = loader_glProgramUniform1iv;
  tbl.glProgramUniform1ui = loader_glProgramUniform1ui;
  tbl.glProgramUniform1uiv = loader_glProgramUniform1uiv;
  tbl.glProgramUniform2d = loader_glProgramUniform2d;
  tbl.glProgramUniform2dv = loader_glProgramUniform2dv;
  tbl.glProgramUniform2f = loader_glProgramUniform2f;
  tbl.glProgramUniform2fv = loader_glProgramUniform2fv;
  tbl.glProgramUniform2i = loader_glProgramUniform2i;
  tbl.glProgramUniform2iv = loader_glProgramUniform2iv;
  tbl.glProgramUniform2ui = loader_glProgramUniform2ui;
  tbl.glProgramUniform2uiv = loader_glProgramUniform2uiv;
  tbl.glProgramUniform3d = loader_glProgramUniform3d;
  tbl.glProgramUniform3dv = loader_glProgramUniform3dv;
  tbl.glProgramUniform3f = loader_glProgramUniform3f;
  tbl.glProgramUniform3fv = loader_glProgramUniform3fv;
  tbl.glProgramUniform3i = loader_glProgramUniform3i;
  tbl.glProgramUniform3iv = loader_glProgramUniform3iv;
  tbl.glProgramUniform3ui = loader_glProgramUniform3ui;
  tbl.glProgramUniform3uiv = loader_glProgramUniform3uiv;
  tbl.glProgramUniform4d = loader_glProgramUniform4d;
  tbl.glProgramUniform4dv = loader_glProgramUniform4dv;
  tbl.glProgramUniform4f = loader_glProgramUniform4f;
  tbl.glProgramUniform4fv = loader_glProgramUniform4fv;
  tbl.glProgramUniform4i = loader_glProgramUniform4i;
  tbl.glProgramUniform4iv = loader_glProgramUniform4iv;
  tbl.glProgramUniform4ui = loader_glProgramUniform4ui;
  tbl.glProgramUniform4uiv = loader_glProgramUniform4uiv;
  tbl.glProgramUniformMatrix2dv = loader_glProgramUniformMatrix2dv;
  tbl.glProgramUniformMatrix2fv = loader_glProgramUniformMatrix2fv;
  tbl.glProgramUniformMatrix2x3dv = loader_glProgramUniformMatrix2x3dv;
  tbl.glProgramUniformMatrix2x3fv = loader_glProgramUniformMatrix2x3fv;
  tbl.glProgramUniformMatrix2x4dv = loader_glProgramUniformMatrix2x4dv;
  tbl.glProgramUniformMatrix2x4fv = loader_glProgramUniformMatrix2x4fv;
  tbl.glProgramUniformMatrix3dv = loader_glProgramUniformMatrix3dv;
  tbl.glProgramUniformMatrix3fv = loader_glProgramUniformMatrix3fv;
  tbl.glProgramUniformMatrix3x2dv = loader_glProgramUniformMatrix3x2dv;
  tbl.glProgramUniformMatrix3x2fv = loader_glProgramUniformMatrix3x2fv;
  tbl.glProgramUniformMatrix3x4dv = loader_glProgramUniformMatrix3x4dv;
  tbl.glProgramUniformMatrix3x4fv = loader_glProgramUniformMatrix3x4fv;
  tbl.glProgramUniformMatrix4dv = loader_glProgramUniformMatrix4dv;
  tbl.glProgramUniformMatrix4fv = loader_glProgramUniformMatrix4fv;
  tbl.glProgramUniformMatrix4x2dv = loader_glProgramUniformMatrix4x2dv;
  tbl.glProgramUniformMatrix4x2fv = loader_glProgramUniformMatrix4x2fv;
  tbl.glProgramUniformMatrix4x3dv = loader_glProgramUniformMatrix4x3dv;
  tbl.glProgramUniformMatrix4x3fv = loader_glProgramUniformMatrix4x3fv;
  tbl.glUseProgramStages = loader_glUseProgramStages;
  tbl.glValidateProgramPipeline = loader_glValidateProgramPipeline;

  // GL_ARB_shader_atomic_counters

  tbl.glGetActiveAtomicCounterBufferiv = loader_glGetActiveAtomicCounterBufferiv;

  // GL_ARB_shader_image_load_store

  tbl.glBindImageTexture = loader_glBindImageTexture;
  tbl.glMemoryBarrier = loader_glMemoryBarrier;

  // GL_ARB_shader_objects

  tbl.glAttachObjectARB = loader_glAttachObjectARB;
  tbl.glCompileShaderARB = loader_glCompileShaderARB;
  tbl.glCreateProgramObjectARB = loader_glCreateProgramObjectARB;
  tbl.glCreateShaderObjectARB = loader_glCreateShaderObjectARB;
  tbl.glDeleteObjectARB = loader_glDeleteObjectARB;
  tbl.glDetachObjectARB = loader_glDetachObjectARB;
  tbl.glGetActiveUniformARB = loader_glGetActiveUniformARB;
  tbl.glGetAttachedObjectsARB = loader_glGetAttachedObjectsARB;
  tbl.glGetHandleARB = loader_glGetHandleARB;
  tbl.glGetInfoLogARB = loader_glGetInfoLogARB;
  tbl.glGetObjectParameterfvARB = loader_glGetObjectParameterfvARB;
  tbl.glGetObjectParameterivARB = loader_glGetObjectParameterivARB;
  tbl.glGetShaderSourceARB = loader_glGetShaderSourceARB;
  tbl.glGetUniformLocationARB = loader_glGetUniformLocationARB;
  tbl.glGetUniformfvARB = loader_glGetUniformfvARB;
  tbl.glGetUniformivARB = loader_glGetUniformivARB;
  tbl.glLinkProgramARB = loader_glLinkProgramARB;
  tbl.glShaderSourceARB = loader_glShaderSourceARB;
  tbl.glUniform1fARB = loader_glUniform1fARB;
  tbl.glUniform1fvARB = loader_glUniform1fvARB;
  tbl.glUniform1iARB = loader_glUniform1iARB;
  tbl.glUniform1ivARB = loader_glUniform1ivARB;
  tbl.glUniform2fARB = loader_glUniform2fARB;
  tbl.glUniform2fvARB = loader_glUniform2fvARB;
  tbl.glUniform2iARB = loader_glUniform2iARB;
  tbl.glUniform2ivARB = loader_glUniform2ivARB;
  tbl.glUniform3fARB = loader_glUniform3fARB;
  tbl.glUniform3fvARB = loader_glUniform3fvARB;
  tbl.glUniform3iARB = loader_glUniform3iARB;
  tbl.glUniform3ivARB = loader_glUniform3ivARB;
  tbl.glUniform4fARB = loader_glUniform4fARB;
  tbl.glUniform4fvARB = loader_glUniform4fvARB;
  tbl.glUniform4iARB = loader_glUniform4iARB;
  tbl.glUniform4ivARB = loader_glUniform4ivARB;
  tbl.glUniformMatrix2fvARB = loader_glUniformMatrix2fvARB;
  tbl.glUniformMatrix3fvARB = loader_glUniformMatrix3fvARB;
  tbl.glUniformMatrix4fvARB = loader_glUniformMatrix4fvARB;
  tbl.glUseProgramObjectARB = loader_glUseProgramObjectARB;
  tbl.glValidateProgramARB = loader_glValidateProgramARB;

  // GL_ARB_shader_storage_buffer_object

  tbl.glShaderStorageBlockBinding = loader_glShaderStorageBlockBinding;

  // GL_ARB_shader_subroutine

  tbl.glGetActiveSubroutineName = loader_glGetActiveSubroutineName;
  tbl.glGetActiveSubroutineUniformName = loader_glGetActiveSubroutineUniformName;
  tbl.glGetActiveSubroutineUniformiv = loader_glGetActiveSubroutineUniformiv;
  tbl.glGetProgramStageiv = loader_glGetProgramStageiv;
  tbl.glGetSubroutineIndex = loader_glGetSubroutineIndex;
  tbl.glGetSubroutineUniformLocation = loader_glGetSubroutineUniformLocation;
  tbl.glGetUniformSubroutineuiv = loader_glGetUniformSubroutineuiv;
  tbl.glUniformSubroutinesuiv = loader_glUniformSubroutinesuiv;

  // GL_ARB_shading_language_include

  tbl.glCompileShaderIncludeARB = loader_glCompileShaderIncludeARB;
  tbl.glDeleteNamedStringARB = loader_glDeleteNamedStringARB;
  tbl.glGetNamedStringARB = loader_glGetNamedStringARB;
  tbl.glGetNamedStringivARB = loader_glGetNamedStringivARB;
  tbl.glIsNamedStringARB = loader_glIsNamedStringARB;
  tbl.glNamedStringARB = loader_glNamedStringARB;

  // GL_ARB_sync

  tbl.glClientWaitSync = loader_glClientWaitSync;
  tbl.glDeleteSync = loader_glDeleteSync;
  tbl.glFenceSync = loader_glFenceSync;
  tbl.glGetInteger64v = loader_glGetInteger64v;
  tbl.glGetSynciv = loader_glGetSynciv;
  tbl.glIsSync = loader_glIsSync;
  tbl.glWaitSync = loader_glWaitSync;

  // GL_ARB_tessellation_shader

  tbl.glPatchParameterfv = loader_glPatchParameterfv;
  tbl.glPatchParameteri = loader_glPatchParameteri;

  // GL_ARB_texture_buffer_object

  tbl.glTexBufferARB = loader_glTexBufferARB;

  // GL_ARB_texture_buffer_range

  tbl.glTexBufferRange = loader_glTexBufferRange;
  tbl.glTextureBufferRangeEXT = loader_glTextureBufferRangeEXT;

  // GL_ARB_texture_compression

  tbl.glCompressedTexImage1DARB = loader_glCompressedTexImage1DARB;
  tbl.glCompressedTexImage2DARB = loader_glCompressedTexImage2DARB;
  tbl.glCompressedTexImage3DARB = loader_glCompressedTexImage3DARB;
  tbl.glCompressedTexSubImage1DARB = loader_glCompressedTexSubImage1DARB;
  tbl.glCompressedTexSubImage2DARB = loader_glCompressedTexSubImage2DARB;
  tbl.glCompressedTexSubImage3DARB = loader_glCompressedTexSubImage3DARB;
  tbl.glGetCompressedTexImageARB = loader_glGetCompressedTexImageARB;

  // GL_ARB_texture_multisample

  tbl.glGetMultisamplefv = loader_glGetMultisamplefv;
  tbl.glSampleMaski = loader_glSampleMaski;
  tbl.glTexImage2DMultisample = loader_glTexImage2DMultisample;
  tbl.glTexImage3DMultisample = loader_glTexImage3DMultisample;

  // GL_ARB_texture_storage

  tbl.glTexStorage1D = loader_glTexStorage1D;
  tbl.glTexStorage2D = loader_glTexStorage2D;
  tbl.glTexStorage3D = loader_glTexStorage3D;
  tbl.glTextureStorage1DEXT = loader_glTextureStorage1DEXT;
  tbl.glTextureStorage2DEXT = loader_glTextureStorage2DEXT;
  tbl.glTextureStorage3DEXT = loader_glTextureStorage3DEXT;

  // GL_ARB_texture_storage_multisample

  tbl.glTexStorage2DMultisample = loader_glTexStorage2DMultisample;
  tbl.glTexStorage3DMultisample = loader_glTexStorage3DMultisample;
  tbl.glTextureStorage2DMultisampleEXT = loader_glTextureStorage2DMultisampleEXT;
  tbl.glTextureStorage3DMultisampleEXT = loader_glTextureStorage3DMultisampleEXT;

  // GL_ARB_texture_view

  tbl.glTextureView = loader_glTextureView;

  // GL_ARB_timer_query

  tbl.glGetQueryObjecti64v = loader_glGetQueryObjecti64v;
  tbl.glGetQueryObjectui64v = loader_glGetQueryObjectui64v;
  tbl.glQueryCounter = loader_glQueryCounter;

  // GL_ARB_transform_feedback2

  tbl.glBindTransformFeedback = loader_glBindTransformFeedback;
  tbl.glDeleteTransformFeedbacks = loader_glDeleteTransformFeedbacks;
  tbl.glDrawTransformFeedback = loader_glDrawTransformFeedback;
  tbl.glGenTransformFeedbacks = loader_glGenTransformFeedbacks;
  tbl.glIsTransformFeedback = loader_glIsTransformFeedback;
  tbl.glPauseTransformFeedback = loader_glPauseTransformFeedback;
  tbl.glResumeTransformFeedback = loader_glResumeTransformFeedback;

  // GL_ARB_transform_feedback3

  tbl.glBeginQueryIndexed = loader_glBeginQueryIndexed;
  tbl.glDrawTransformFeedbackStream = loader_glDrawTransformFeedbackStream;
  tbl.glEndQueryIndexed = loader_glEndQueryIndexed;
  tbl.glGetQueryIndexediv = loader_glGetQueryIndexediv;

  // GL_ARB_transform_feedback_instanced

  tbl.glDrawTransformFeedbackInstanced = loader_glDrawTransformFeedbackInstanced;
  tbl.glDrawTransformFeedbackStreamInstanced = loader_glDrawTransformFeedbackStreamInstanced;

  // GL_ARB_transpose_matrix

  tbl.glLoadTransposeMatrixdARB = loader_glLoadTransposeMatrixdARB;
  tbl.glLoadTransposeMatrixfARB = loader_glLoadTransposeMatrixfARB;
  tbl.glMultTransposeMatrixdARB = loader_glMultTransposeMatrixdARB;
  tbl.glMultTransposeMatrixfARB = loader_glMultTransposeMatrixfARB;

  // GL_ARB_uniform_buffer_object

  tbl.glBindBufferBase = loader_glBindBufferBase;
  tbl.glBindBufferRange = loader_glBindBufferRange;
  tbl.glGetActiveUniformBlockName = loader_glGetActiveUniformBlockName;
  tbl.glGetActiveUniformBlockiv = loader_glGetActiveUniformBlockiv;
  tbl.glGetActiveUniformName = loader_glGetActiveUniformName;
  tbl.glGetActiveUniformsiv = loader_glGetActiveUniformsiv;
  tbl.glGetIntegeri_v = loader_glGetIntegeri_v;
  tbl.glGetUniformBlockIndex = loader_glGetUniformBlockIndex;
  tbl.glGetUniformIndices = loader_glGetUniformIndices;
  tbl.glUniformBlockBinding = loader_glUniformBlockBinding;

  // GL_ARB_vertex_array_object

  tbl.glBindVertexArray = loader_glBindVertexArray;
  tbl.glDeleteVertexArrays = loader_glDeleteVertexArrays;
  tbl.glGenVertexArrays = loader_glGenVertexArrays;
  tbl.glIsVertexArray = loader_glIsVertexArray;

  // GL_ARB_vertex_attrib_64bit

  tbl.glGetVertexAttribLdv = loader_glGetVertexAttribLdv;
  tbl.glVertexAttribL1d = loader_glVertexAttribL1d;
  tbl.glVertexAttribL1dv = loader_glVertexAttribL1dv;
  tbl.glVertexAttribL2d = loader_glVertexAttribL2d;
  tbl.glVertexAttribL2dv = loader_glVertexAttribL2dv;
  tbl.glVertexAttribL3d = loader_glVertexAttribL3d;
  tbl.glVertexAttribL3dv = loader_glVertexAttribL3dv;
  tbl.glVertexAttribL4d = loader_glVertexAttribL4d;
  tbl.glVertexAttribL4dv = loader_glVertexAttribL4dv;
  tbl.glVertexAttribLPointer = loader_glVertexAttribLPointer;

  // GL_ARB_vertex_attrib_binding

  tbl.glBindVertexBuffer = loader_glBindVertexBuffer;
  tbl.glVertexAttribBinding = loader_glVertexAttribBinding;
  tbl.glVertexAttribFormat = loader_glVertexAttribFormat;
  tbl.glVertexAttribIFormat = loader_glVertexAttribIFormat;
  tbl.glVertexAttribLFormat = loader_glVertexAttribLFormat;
  tbl.glVertexBindingDivisor = loader_glVertexBindingDivisor;

  // GL_ARB_vertex_blend

  tbl.glVertexBlendARB = loader_glVertexBlendARB;
  tbl.glWeightPointerARB = loader_glWeightPointerARB;
  tbl.glWeightbvARB = loader_glWeightbvARB;
  tbl.glWeightdvARB = loader_glWeightdvARB;
  tbl.glWeightfvARB = loader_glWeightfvARB;
  tbl.glWeightivARB = loader_glWeightivARB;
  tbl.glWeightsvARB = loader_glWeightsvARB;
  tbl.glWeightubvARB = loader_glWeightubvARB;
  tbl.glWeightuivARB = loader_glWeightuivARB;
  tbl.glWeightusvARB = loader_glWeightusvARB;

  // GL_ARB_vertex_buffer_object

  tbl.glBindBufferARB = loader_glBindBufferARB;
  tbl.glBufferDataARB = loader_glBufferDataARB;
  tbl.glBufferSubDataARB = loader_glBufferSubDataARB;
  tbl.glDeleteBuffersARB = loader_glDeleteBuffersARB;
  tbl.glGenBuffersARB = loader_glGenBuffersARB;
  tbl.glGetBufferParameterivARB = loader_glGetBufferParameterivARB;
  tbl.glGetBufferPointervARB = loader_glGetBufferPointervARB;
  tbl.glGetBufferSubDataARB = loader_glGetBufferSubDataARB;
  tbl.glIsBufferARB = loader_glIsBufferARB;
  tbl.glMapBufferARB = loader_glMapBufferARB;
  tbl.glUnmapBufferARB = loader_glUnmapBufferARB;

  // GL_ARB_vertex_program

  tbl.glBindProgramARB = loader_glBindProgramARB;
  tbl.glDeleteProgramsARB = loader_glDeleteProgramsARB;
  tbl.glDisableVertexAttribArrayARB = loader_glDisableVertexAttribArrayARB;
  tbl.glEnableVertexAttribArrayARB = loader_glEnableVertexAttribArrayARB;
  tbl.glGenProgramsARB = loader_glGenProgramsARB;
  tbl.glGetProgramEnvParameterdvARB = loader_glGetProgramEnvParameterdvARB;
  tbl.glGetProgramEnvParameterfvARB = loader_glGetProgramEnvParameterfvARB;
  tbl.glGetProgramLocalParameterdvARB = loader_glGetProgramLocalParameterdvARB;
  tbl.glGetProgramLocalParameterfvARB = loader_glGetProgramLocalParameterfvARB;
  tbl.glGetProgramStringARB = loader_glGetProgramStringARB;
  tbl.glGetProgramivARB = loader_glGetProgramivARB;
  tbl.glGetVertexAttribPointervARB = loader_glGetVertexAttribPointervARB;
  tbl.glGetVertexAttribdvARB = loader_glGetVertexAttribdvARB;
  tbl.glGetVertexAttribfvARB = loader_glGetVertexAttribfvARB;
  tbl.glGetVertexAttribivARB = loader_glGetVertexAttribivARB;
  tbl.glIsProgramARB = loader_glIsProgramARB;
  tbl.glProgramEnvParameter4dARB = loader_glProgramEnvParameter4dARB;
  tbl.glProgramEnvParameter4dvARB = loader_glProgramEnvParameter4dvARB;
  tbl.glProgramEnvParameter4fARB = loader_glProgramEnvParameter4fARB;
  tbl.glProgramEnvParameter4fvARB = loader_glProgramEnvParameter4fvARB;
  tbl.glProgramLocalParameter4dARB = loader_glProgramLocalParameter4dARB;
  tbl.glProgramLocalParameter4dvARB = loader_glProgramLocalParameter4dvARB;
  tbl.glProgramLocalParameter4fARB = loader_glProgramLocalParameter4fARB;
  tbl.glProgramLocalParameter4fvARB = loader_glProgramLocalParameter4fvARB;
  tbl.glProgramStringARB = loader_glProgramStringARB;
  tbl.glVertexAttrib1dARB = loader_glVertexAttrib1dARB;
  tbl.glVertexAttrib1dvARB = loader_glVertexAttrib1dvARB;
  tbl.glVertexAttrib1fARB = loader_glVertexAttrib1fARB;
  tbl.glVertexAttrib1fvARB = loader_glVertexAttrib1fvARB;
  tbl.glVertexAttrib1sARB = loader_glVertexAttrib1sARB;
  tbl.glVertexAttrib1svARB = loader_glVertexAttrib1svARB;
  tbl.glVertexAttrib2dARB = loader_glVertexAttrib2dARB;
  tbl.glVertexAttrib2dvARB = loader_glVertexAttrib2dvARB;
  tbl.glVertexAttrib2fARB = loader_glVertexAttrib2fARB;
  tbl.glVertexAttrib2fvARB = loader_glVertexAttrib2fvARB;
  tbl.glVertexAttrib2sARB = loader_glVertexAttrib2sARB;
  tbl.glVertexAttrib2svARB = loader_glVertexAttrib2svARB;
  tbl.glVertexAttrib3dARB = loader_glVertexAttrib3dARB;
  tbl.glVertexAttrib3dvARB = loader_glVertexAttrib3dvARB;
  tbl.glVertexAttrib3fARB = loader_glVertexAttrib3fARB;
  tbl.glVertexAttrib3fvARB = loader_glVertexAttrib3fvARB;
  tbl.glVertexAttrib3sARB = loader_glVertexAttrib3sARB;
  tbl.glVertexAttrib3svARB = loader_glVertexAttrib3svARB;
  tbl.glVertexAttrib4NbvARB = loader_glVertexAttrib4NbvARB;
  tbl.glVertexAttrib4NivARB = loader_glVertexAttrib4NivARB;
  tbl.glVertexAttrib4NsvARB = loader_glVertexAttrib4NsvARB;
  tbl.glVertexAttrib4NubARB = loader_glVertexAttrib4NubARB;
  tbl.glVertexAttrib4NubvARB = loader_glVertexAttrib4NubvARB;
  tbl.glVertexAttrib4NuivARB = loader_glVertexAttrib4NuivARB;
  tbl.glVertexAttrib4NusvARB = loader_glVertexAttrib4NusvARB;
  tbl.glVertexAttrib4bvARB = loader_glVertexAttrib4bvARB;
  tbl.glVertexAttrib4dARB = loader_glVertexAttrib4dARB;
  tbl.glVertexAttrib4dvARB = loader_glVertexAttrib4dvARB;
  tbl.glVertexAttrib4fARB = loader_glVertexAttrib4fARB;
  tbl.glVertexAttrib4fvARB = loader_glVertexAttrib4fvARB;
  tbl.glVertexAttrib4ivARB = loader_glVertexAttrib4ivARB;
  tbl.glVertexAttrib4sARB = loader_glVertexAttrib4sARB;
  tbl.glVertexAttrib4svARB = loader_glVertexAttrib4svARB;
  tbl.glVertexAttrib4ubvARB = loader_glVertexAttrib4ubvARB;
  tbl.glVertexAttrib4uivARB = loader_glVertexAttrib4uivARB;
  tbl.glVertexAttrib4usvARB = loader_glVertexAttrib4usvARB;
  tbl.glVertexAttribPointerARB = loader_glVertexAttribPointerARB;

  // GL_ARB_vertex_shader

  tbl.glBindAttribLocationARB = loader_glBindAttribLocationARB;
  tbl.glGetActiveAttribARB = loader_glGetActiveAttribARB;
  tbl.glGetAttribLocationARB = loader_glGetAttribLocationARB;

  // GL_ARB_vertex_type_2_10_10_10_rev

  tbl.glColorP3ui = loader_glColorP3ui;
  tbl.glColorP3uiv = loader_glColorP3uiv;
  tbl.glColorP4ui = loader_glColorP4ui;
  tbl.glColorP4uiv = loader_glColorP4uiv;
  tbl.glMultiTexCoordP1ui = loader_glMultiTexCoordP1ui;
  tbl.glMultiTexCoordP1uiv = loader_glMultiTexCoordP1uiv;
  tbl.glMultiTexCoordP2ui = loader_glMultiTexCoordP2ui;
  tbl.glMultiTexCoordP2uiv = loader_glMultiTexCoordP2uiv;
  tbl.glMultiTexCoordP3ui = loader_glMultiTexCoordP3ui;
  tbl.glMultiTexCoordP3uiv = loader_glMultiTexCoordP3uiv;
  tbl.glMultiTexCoordP4ui = loader_glMultiTexCoordP4ui;
  tbl.glMultiTexCoordP4uiv = loader_glMultiTexCoordP4uiv;
  tbl.glNormalP3ui = loader_glNormalP3ui;
  tbl.glNormalP3uiv = loader_glNormalP3uiv;
  tbl.glSecondaryColorP3ui = loader_glSecondaryColorP3ui;
  tbl.glSecondaryColorP3uiv = loader_glSecondaryColorP3uiv;
  tbl.glTexCoordP1ui = loader_glTexCoordP1ui;
  tbl.glTexCoordP1uiv = loader_glTexCoordP1uiv;
  tbl.glTexCoordP2ui = loader_glTexCoordP2ui;
  tbl.glTexCoordP2uiv = loader_glTexCoordP2uiv;
  tbl.glTexCoordP3ui = loader_glTexCoordP3ui;
  tbl.glTexCoordP3uiv = loader_glTexCoordP3uiv;
  tbl.glTexCoordP4ui = loader_glTexCoordP4ui;
  tbl.glTexCoordP4uiv = loader_glTexCoordP4uiv;
  tbl.glVertexAttribP1ui = loader_glVertexAttribP1ui;
  tbl.glVertexAttribP1uiv = loader_glVertexAttribP1uiv;
  tbl.glVertexAttribP2ui = loader_glVertexAttribP2ui;
  tbl.glVertexAttribP2uiv = loader_glVertexAttribP2uiv;
  tbl.glVertexAttribP3ui = loader_glVertexAttribP3ui;
  tbl.glVertexAttribP3uiv = loader_glVertexAttribP3uiv;
  tbl.glVertexAttribP4ui = loader_glVertexAttribP4ui;
  tbl.glVertexAttribP4uiv = loader_glVertexAttribP4uiv;
  tbl.glVertexP2ui = loader_glVertexP2ui;
  tbl.glVertexP2uiv = loader_glVertexP2uiv;
  tbl.glVertexP3ui = loader_glVertexP3ui;
  tbl.glVertexP3uiv = loader_glVertexP3uiv;
  tbl.glVertexP4ui = loader_glVertexP4ui;
  tbl.glVertexP4uiv = loader_glVertexP4uiv;

  // GL_ARB_viewport_array

  tbl.glDepthRangeArrayv = loader_glDepthRangeArrayv;
  tbl.glDepthRangeIndexed = loader_glDepthRangeIndexed;
  tbl.glGetDoublei_v = loader_glGetDoublei_v;
  tbl.glGetFloati_v = loader_glGetFloati_v;
  tbl.glScissorArrayv = loader_glScissorArrayv;
  tbl.glScissorIndexed = loader_glScissorIndexed;
  tbl.glScissorIndexedv = loader_glScissorIndexedv;
  tbl.glViewportArrayv = loader_glViewportArrayv;
  tbl.glViewportIndexedf = loader_glViewportIndexedf;
  tbl.glViewportIndexedfv = loader_glViewportIndexedfv;

  // GL_ARB_window_pos

  tbl.glWindowPos2dARB = loader_glWindowPos2dARB;
  tbl.glWindowPos2dvARB = loader_glWindowPos2dvARB;
  tbl.glWindowPos2fARB = loader_glWindowPos2fARB;
  tbl.glWindowPos2fvARB = loader_glWindowPos2fvARB;
  tbl.glWindowPos2iARB = loader_glWindowPos2iARB;
  tbl.glWindowPos2ivARB = loader_glWindowPos2ivARB;
  tbl.glWindowPos2sARB = loader_glWindowPos2sARB;
  tbl.glWindowPos2svARB = loader_glWindowPos2svARB;
  tbl.glWindowPos3dARB = loader_glWindowPos3dARB;
  tbl.glWindowPos3dvARB = loader_glWindowPos3dvARB;
  tbl.glWindowPos3fARB = loader_glWindowPos3fARB;
  tbl.glWindowPos3fvARB = loader_glWindowPos3fvARB;
  tbl.glWindowPos3iARB = loader_glWindowPos3iARB;
  tbl.glWindowPos3ivARB = loader_glWindowPos3ivARB;
  tbl.glWindowPos3sARB = loader_glWindowPos3sARB;
  tbl.glWindowPos3svARB = loader_glWindowPos3svARB;

  // GL_ATI_draw_buffers

  tbl.glDrawBuffersATI = loader_glDrawBuffersATI;

  // GL_ATI_element_array

  tbl.glDrawElementArrayATI = loader_glDrawElementArrayATI;
  tbl.glDrawRangeElementArrayATI = loader_glDrawRangeElementArrayATI;
  tbl.glElementPointerATI = loader_glElementPointerATI;

  // GL_ATI_envmap_bumpmap

  tbl.glGetTexBumpParameterfvATI = loader_glGetTexBumpParameterfvATI;
  tbl.glGetTexBumpParameterivATI = loader_glGetTexBumpParameterivATI;
  tbl.glTexBumpParameterfvATI = loader_glTexBumpParameterfvATI;
  tbl.glTexBumpParameterivATI = loader_glTexBumpParameterivATI;

  // GL_ATI_fragment_shader

  tbl.glAlphaFragmentOp1ATI = loader_glAlphaFragmentOp1ATI;
  tbl.glAlphaFragmentOp2ATI = loader_glAlphaFragmentOp2ATI;
  tbl.glAlphaFragmentOp3ATI = loader_glAlphaFragmentOp3ATI;
  tbl.glBeginFragmentShaderATI = loader_glBeginFragmentShaderATI;
  tbl.glBindFragmentShaderATI = loader_glBindFragmentShaderATI;
  tbl.glColorFragmentOp1ATI = loader_glColorFragmentOp1ATI;
  tbl.glColorFragmentOp2ATI = loader_glColorFragmentOp2ATI;
  tbl.glColorFragmentOp3ATI = loader_glColorFragmentOp3ATI;
  tbl.glDeleteFragmentShaderATI = loader_glDeleteFragmentShaderATI;
  tbl.glEndFragmentShaderATI = loader_glEndFragmentShaderATI;
  tbl.glGenFragmentShadersATI = loader_glGenFragmentShadersATI;
  tbl.glPassTexCoordATI = loader_glPassTexCoordATI;
  tbl.glSampleMapATI = loader_glSampleMapATI;
  tbl.glSetFragmentShaderConstantATI = loader_glSetFragmentShaderConstantATI;

  // GL_ATI_map_object_buffer

  tbl.glMapObjectBufferATI = loader_glMapObjectBufferATI;
  tbl.glUnmapObjectBufferATI = loader_glUnmapObjectBufferATI;

  // GL_ATI_pn_triangles

  tbl.glPNTrianglesfATI = loader_glPNTrianglesfATI;
  tbl.glPNTrianglesiATI = loader_glPNTrianglesiATI;

  // GL_ATI_separate_stencil

  tbl.glStencilFuncSeparateATI = loader_glStencilFuncSeparateATI;
  tbl.glStencilOpSeparateATI = loader_glStencilOpSeparateATI;

  // GL_ATI_vertex_array_object

  tbl.glArrayObjectATI = loader_glArrayObjectATI;
  tbl.glFreeObjectBufferATI = loader_glFreeObjectBufferATI;
  tbl.glGetArrayObjectfvATI = loader_glGetArrayObjectfvATI;
  tbl.glGetArrayObjectivATI = loader_glGetArrayObjectivATI;
  tbl.glGetObjectBufferfvATI = loader_glGetObjectBufferfvATI;
  tbl.glGetObjectBufferivATI = loader_glGetObjectBufferivATI;
  tbl.glGetVariantArrayObjectfvATI = loader_glGetVariantArrayObjectfvATI;
  tbl.glGetVariantArrayObjectivATI = loader_glGetVariantArrayObjectivATI;
  tbl.glIsObjectBufferATI = loader_glIsObjectBufferATI;
  tbl.glNewObjectBufferATI = loader_glNewObjectBufferATI;
  tbl.glUpdateObjectBufferATI = loader_glUpdateObjectBufferATI;
  tbl.glVariantArrayObjectATI = loader_glVariantArrayObjectATI;

  // GL_ATI_vertex_attrib_array_object

  tbl.glGetVertexAttribArrayObjectfvATI = loader_glGetVertexAttribArrayObjectfvATI;
  tbl.glGetVertexAttribArrayObjectivATI = loader_glGetVertexAttribArrayObjectivATI;
  tbl.glVertexAttribArrayObjectATI = loader_glVertexAttribArrayObjectATI;

  // GL_ATI_vertex_streams

  tbl.glClientActiveVertexStreamATI = loader_glClientActiveVertexStreamATI;
  tbl.glNormalStream3bATI = loader_glNormalStream3bATI;
  tbl.glNormalStream3bvATI = loader_glNormalStream3bvATI;
  tbl.glNormalStream3dATI = loader_glNormalStream3dATI;
  tbl.glNormalStream3dvATI = loader_glNormalStream3dvATI;
  tbl.glNormalStream3fATI = loader_glNormalStream3fATI;
  tbl.glNormalStream3fvATI = loader_glNormalStream3fvATI;
  tbl.glNormalStream3iATI = loader_glNormalStream3iATI;
  tbl.glNormalStream3ivATI = loader_glNormalStream3ivATI;
  tbl.glNormalStream3sATI = loader_glNormalStream3sATI;
  tbl.glNormalStream3svATI = loader_glNormalStream3svATI;
  tbl.glVertexBlendEnvfATI = loader_glVertexBlendEnvfATI;
  tbl.glVertexBlendEnviATI = loader_glVertexBlendEnviATI;
  tbl.glVertexStream1dATI = loader_glVertexStream1dATI;
  tbl.glVertexStream1dvATI = loader_glVertexStream1dvATI;
  tbl.glVertexStream1fATI = loader_glVertexStream1fATI;
  tbl.glVertexStream1fvATI = loader_glVertexStream1fvATI;
  tbl.glVertexStream1iATI = loader_glVertexStream1iATI;
  tbl.glVertexStream1ivATI = loader_glVertexStream1ivATI;
  tbl.glVertexStream1sATI = loader_glVertexStream1sATI;
  tbl.glVertexStream1svATI = loader_glVertexStream1svATI;
  tbl.glVertexStream2dATI = loader_glVertexStream2dATI;
  tbl.glVertexStream2dvATI = loader_glVertexStream2dvATI;
  tbl.glVertexStream2fATI = loader_glVertexStream2fATI;
  tbl.glVertexStream2fvATI = loader_glVertexStream2fvATI;
  tbl.glVertexStream2iATI = loader_glVertexStream2iATI;
  tbl.glVertexStream2ivATI = loader_glVertexStream2ivATI;
  tbl.glVertexStream2sATI = loader_glVertexStream2sATI;
  tbl.glVertexStream2svATI = loader_glVertexStream2svATI;
  tbl.glVertexStream3dATI = loader_glVertexStream3dATI;
  tbl.glVertexStream3dvATI = loader_glVertexStream3dvATI;
  tbl.glVertexStream3fATI = loader_glVertexStream3fATI;
  tbl.glVertexStream3fvATI = loader_glVertexStream3fvATI;
  tbl.glVertexStream3iATI = loader_glVertexStream3iATI;
  tbl.glVertexStream3ivATI = loader_glVertexStream3ivATI;
  tbl.glVertexStream3sATI = loader_glVertexStream3sATI;
  tbl.glVertexStream3svATI = loader_glVertexStream3svATI;
  tbl.glVertexStream4dATI = loader_glVertexStream4dATI;
  tbl.glVertexStream4dvATI = loader_glVertexStream4dvATI;
  tbl.glVertexStream4fATI = loader_glVertexStream4fATI;
  tbl.glVertexStream4fvATI = loader_glVertexStream4fvATI;
  tbl.glVertexStream4iATI = loader_glVertexStream4iATI;
  tbl.glVertexStream4ivATI = loader_glVertexStream4ivATI;
  tbl.glVertexStream4sATI = loader_glVertexStream4sATI;
  tbl.glVertexStream4svATI = loader_glVertexStream4svATI;

  // GL_EXT_bindable_uniform

  tbl.glGetUniformBufferSizeEXT = loader_glGetUniformBufferSizeEXT;
  tbl.glGetUniformOffsetEXT = loader_glGetUniformOffsetEXT;
  tbl.glUniformBufferEXT = loader_glUniformBufferEXT;

  // GL_EXT_blend_color

  tbl.glBlendColorEXT = loader_glBlendColorEXT;

  // GL_EXT_blend_equation_separate

  tbl.glBlendEquationSeparateEXT = loader_glBlendEquationSeparateEXT;

  // GL_EXT_blend_func_separate

  tbl.glBlendFuncSeparateEXT = loader_glBlendFuncSeparateEXT;

  // GL_EXT_blend_minmax

  tbl.glBlendEquationEXT = loader_glBlendEquationEXT;

  // GL_EXT_color_subtable

  tbl.glColorSubTableEXT = loader_glColorSubTableEXT;
  tbl.glCopyColorSubTableEXT = loader_glCopyColorSubTableEXT;

  // GL_EXT_compiled_vertex_array

  tbl.glLockArraysEXT = loader_glLockArraysEXT;
  tbl.glUnlockArraysEXT = loader_glUnlockArraysEXT;

  // GL_EXT_convolution

  tbl.glConvolutionFilter1DEXT = loader_glConvolutionFilter1DEXT;
  tbl.glConvolutionFilter2DEXT = loader_glConvolutionFilter2DEXT;
  tbl.glConvolutionParameterfEXT = loader_glConvolutionParameterfEXT;
  tbl.glConvolutionParameterfvEXT = loader_glConvolutionParameterfvEXT;
  tbl.glConvolutionParameteriEXT = loader_glConvolutionParameteriEXT;
  tbl.glConvolutionParameterivEXT = loader_glConvolutionParameterivEXT;
  tbl.glCopyConvolutionFilter1DEXT = loader_glCopyConvolutionFilter1DEXT;
  tbl.glCopyConvolutionFilter2DEXT = loader_glCopyConvolutionFilter2DEXT;
  tbl.glGetConvolutionFilterEXT = loader_glGetConvolutionFilterEXT;
  tbl.glGetConvolutionParameterfvEXT = loader_glGetConvolutionParameterfvEXT;
  tbl.glGetConvolutionParameterivEXT = loader_glGetConvolutionParameterivEXT;
  tbl.glGetSeparableFilterEXT = loader_glGetSeparableFilterEXT;
  tbl.glSeparableFilter2DEXT = loader_glSeparableFilter2DEXT;

  // GL_EXT_coordinate_frame

  tbl.glBinormal3bEXT = loader_glBinormal3bEXT;
  tbl.glBinormal3bvEXT = loader_glBinormal3bvEXT;
  tbl.glBinormal3dEXT = loader_glBinormal3dEXT;
  tbl.glBinormal3dvEXT = loader_glBinormal3dvEXT;
  tbl.glBinormal3fEXT = loader_glBinormal3fEXT;
  tbl.glBinormal3fvEXT = loader_glBinormal3fvEXT;
  tbl.glBinormal3iEXT = loader_glBinormal3iEXT;
  tbl.glBinormal3ivEXT = loader_glBinormal3ivEXT;
  tbl.glBinormal3sEXT = loader_glBinormal3sEXT;
  tbl.glBinormal3svEXT = loader_glBinormal3svEXT;
  tbl.glBinormalPointerEXT = loader_glBinormalPointerEXT;
  tbl.glTangent3bEXT = loader_glTangent3bEXT;
  tbl.glTangent3bvEXT = loader_glTangent3bvEXT;
  tbl.glTangent3dEXT = loader_glTangent3dEXT;
  tbl.glTangent3dvEXT = loader_glTangent3dvEXT;
  tbl.glTangent3fEXT = loader_glTangent3fEXT;
  tbl.glTangent3fvEXT = loader_glTangent3fvEXT;
  tbl.glTangent3iEXT = loader_glTangent3iEXT;
  tbl.glTangent3ivEXT = loader_glTangent3ivEXT;
  tbl.glTangent3sEXT = loader_glTangent3sEXT;
  tbl.glTangent3svEXT = loader_glTangent3svEXT;
  tbl.glTangentPointerEXT = loader_glTangentPointerEXT;

  // GL_EXT_copy_texture

  tbl.glCopyTexImage1DEXT = loader_glCopyTexImage1DEXT;
  tbl.glCopyTexImage2DEXT = loader_glCopyTexImage2DEXT;
  tbl.glCopyTexSubImage1DEXT = loader_glCopyTexSubImage1DEXT;
  tbl.glCopyTexSubImage2DEXT = loader_glCopyTexSubImage2DEXT;
  tbl.glCopyTexSubImage3DEXT = loader_glCopyTexSubImage3DEXT;

  // GL_EXT_cull_vertex

  tbl.glCullParameterdvEXT = loader_glCullParameterdvEXT;
  tbl.glCullParameterfvEXT = loader_glCullParameterfvEXT;

  // GL_EXT_debug_label

  tbl.glGetObjectLabelEXT = loader_glGetObjectLabelEXT;
  tbl.glLabelObjectEXT = loader_glLabelObjectEXT;

  // GL_EXT_debug_marker

  tbl.glInsertEventMarkerEXT = loader_glInsertEventMarkerEXT;
  tbl.glPopGroupMarkerEXT = loader_glPopGroupMarkerEXT;
  tbl.glPushGroupMarkerEXT = loader_glPushGroupMarkerEXT;

  // GL_EXT_depth_bounds_test

  tbl.glDepthBoundsEXT = loader_glDepthBoundsEXT;

  // GL_EXT_direct_state_access

  tbl.glBindMultiTextureEXT = loader_glBindMultiTextureEXT;
  tbl.glCheckNamedFramebufferStatusEXT = loader_glCheckNamedFramebufferStatusEXT;
  tbl.glClientAttribDefaultEXT = loader_glClientAttribDefaultEXT;
  tbl.glCompressedMultiTexImage1DEXT = loader_glCompressedMultiTexImage1DEXT;
  tbl.glCompressedMultiTexImage2DEXT = loader_glCompressedMultiTexImage2DEXT;
  tbl.glCompressedMultiTexImage3DEXT = loader_glCompressedMultiTexImage3DEXT;
  tbl.glCompressedMultiTexSubImage1DEXT = loader_glCompressedMultiTexSubImage1DEXT;
  tbl.glCompressedMultiTexSubImage2DEXT = loader_glCompressedMultiTexSubImage2DEXT;
  tbl.glCompressedMultiTexSubImage3DEXT = loader_glCompressedMultiTexSubImage3DEXT;
  tbl.glCompressedTextureImage1DEXT = loader_glCompressedTextureImage1DEXT;
  tbl.glCompressedTextureImage2DEXT = loader_glCompressedTextureImage2DEXT;
  tbl.glCompressedTextureImage3DEXT = loader_glCompressedTextureImage3DEXT;
  tbl.glCompressedTextureSubImage1DEXT = loader_glCompressedTextureSubImage1DEXT;
  tbl.glCompressedTextureSubImage2DEXT = loader_glCompressedTextureSubImage2DEXT;
  tbl.glCompressedTextureSubImage3DEXT = loader_glCompressedTextureSubImage3DEXT;
  tbl.glCopyMultiTexImage1DEXT = loader_glCopyMultiTexImage1DEXT;
  tbl.glCopyMultiTexImage2DEXT = loader_glCopyMultiTexImage2DEXT;
  tbl.glCopyMultiTexSubImage1DEXT = loader_glCopyMultiTexSubImage1DEXT;
  tbl.glCopyMultiTexSubImage2DEXT = loader_glCopyMultiTexSubImage2DEXT;
  tbl.glCopyMultiTexSubImage3DEXT = loader_glCopyMultiTexSubImage3DEXT;
  tbl.glCopyTextureImage1DEXT = loader_glCopyTextureImage1DEXT;
  tbl.glCopyTextureImage2DEXT = loader_glCopyTextureImage2DEXT;
  tbl.glCopyTextureSubImage1DEXT = loader_glCopyTextureSubImage1DEXT;
  tbl.glCopyTextureSubImage2DEXT = loader_glCopyTextureSubImage2DEXT;
  tbl.glCopyTextureSubImage3DEXT = loader_glCopyTextureSubImage3DEXT;
  tbl.glDisableClientStateIndexedEXT = loader_glDisableClientStateIndexedEXT;
  tbl.glDisableClientStateiEXT = loader_glDisableClientStateiEXT;
  tbl.glDisableVertexArrayAttribEXT = loader_glDisableVertexArrayAttribEXT;
  tbl.glDisableVertexArrayEXT = loader_glDisableVertexArrayEXT;
  tbl.glEnableClientStateIndexedEXT = loader_glEnableClientStateIndexedEXT;
  tbl.glEnableClientStateiEXT = loader_glEnableClientStateiEXT;
  tbl.glEnableVertexArrayAttribEXT = loader_glEnableVertexArrayAttribEXT;
  tbl.glEnableVertexArrayEXT = loader_glEnableVertexArrayEXT;
  tbl.glFlushMappedNamedBufferRangeEXT = loader_glFlushMappedNamedBufferRangeEXT;
  tbl.glFramebufferDrawBufferEXT = loader_glFramebufferDrawBufferEXT;
  tbl.glFramebufferDrawBuffersEXT = loader_glFramebufferDrawBuffersEXT;
  tbl.glFramebufferReadBufferEXT = loader_glFramebufferReadBufferEXT;
  tbl.glGenerateMultiTexMipmapEXT = loader_glGenerateMultiTexMipmapEXT;
  tbl.glGenerateTextureMipmapEXT = loader_glGenerateTextureMipmapEXT;
  tbl.glGetCompressedMultiTexImageEXT = loader_glGetCompressedMultiTexImageEXT;
  tbl.glGetCompressedTextureImageEXT = loader_glGetCompressedTextureImageEXT;
  tbl.glGetDoubleIndexedvEXT = loader_glGetDoubleIndexedvEXT;
  tbl.glGetDoublei_vEXT = loader_glGetDoublei_vEXT;
  tbl.glGetFloatIndexedvEXT = loader_glGetFloatIndexedvEXT;
  tbl.glGetFloati_vEXT = loader_glGetFloati_vEXT;
  tbl.glGetFramebufferParameterivEXT = loader_glGetFramebufferParameterivEXT;
  tbl.glGetMultiTexEnvfvEXT = loader_glGetMultiTexEnvfvEXT;
  tbl.glGetMultiTexEnvivEXT = loader_glGetMultiTexEnvivEXT;
  tbl.glGetMultiTexGendvEXT = loader_glGetMultiTexGendvEXT;
  tbl.glGetMultiTexGenfvEXT = loader_glGetMultiTexGenfvEXT;
  tbl.glGetMultiTexGenivEXT = loader_glGetMultiTexGenivEXT;
  tbl.glGetMultiTexImageEXT = loader_glGetMultiTexImageEXT;
  tbl.glGetMultiTexLevelParameterfvEXT = loader_glGetMultiTexLevelParameterfvEXT;
  tbl.glGetMultiTexLevelParameterivEXT = loader_glGetMultiTexLevelParameterivEXT;
  tbl.glGetMultiTexParameterIivEXT = loader_glGetMultiTexParameterIivEXT;
  tbl.glGetMultiTexParameterIuivEXT = loader_glGetMultiTexParameterIuivEXT;
  tbl.glGetMultiTexParameterfvEXT = loader_glGetMultiTexParameterfvEXT;
  tbl.glGetMultiTexParameterivEXT = loader_glGetMultiTexParameterivEXT;
  tbl.glGetNamedBufferParameterivEXT = loader_glGetNamedBufferParameterivEXT;
  tbl.glGetNamedBufferPointervEXT = loader_glGetNamedBufferPointervEXT;
  tbl.glGetNamedBufferSubDataEXT = loader_glGetNamedBufferSubDataEXT;
  tbl.glGetNamedFramebufferAttachmentParameterivEXT = loader_glGetNamedFramebufferAttachmentParameterivEXT;
  tbl.glGetNamedProgramLocalParameterIivEXT = loader_glGetNamedProgramLocalParameterIivEXT;
  tbl.glGetNamedProgramLocalParameterIuivEXT = loader_glGetNamedProgramLocalParameterIuivEXT;
  tbl.glGetNamedProgramLocalParameterdvEXT = loader_glGetNamedProgramLocalParameterdvEXT;
  tbl.glGetNamedProgramLocalParameterfvEXT = loader_glGetNamedProgramLocalParameterfvEXT;
  tbl.glGetNamedProgramStringEXT = loader_glGetNamedProgramStringEXT;
  tbl.glGetNamedProgramivEXT = loader_glGetNamedProgramivEXT;
  tbl.glGetNamedRenderbufferParameterivEXT = loader_glGetNamedRenderbufferParameterivEXT;
  tbl.glGetPointerIndexedvEXT = loader_glGetPointerIndexedvEXT;
  tbl.glGetPointeri_vEXT = loader_glGetPointeri_vEXT;
  tbl.glGetTextureImageEXT = loader_glGetTextureImageEXT;
  tbl.glGetTextureLevelParameterfvEXT = loader_glGetTextureLevelParameterfvEXT;
  tbl.glGetTextureLevelParameterivEXT = loader_glGetTextureLevelParameterivEXT;
  tbl.glGetTextureParameterIivEXT = loader_glGetTextureParameterIivEXT;
  tbl.glGetTextureParameterIuivEXT = loader_glGetTextureParameterIuivEXT;
  tbl.glGetTextureParameterfvEXT = loader_glGetTextureParameterfvEXT;
  tbl.glGetTextureParameterivEXT = loader_glGetTextureParameterivEXT;
  tbl.glGetVertexArrayIntegeri_vEXT = loader_glGetVertexArrayIntegeri_vEXT;
  tbl.glGetVertexArrayIntegervEXT = loader_glGetVertexArrayIntegervEXT;
  tbl.glGetVertexArrayPointeri_vEXT = loader_glGetVertexArrayPointeri_vEXT;
  tbl.glGetVertexArrayPointervEXT = loader_glGetVertexArrayPointervEXT;
  tbl.glMapNamedBufferEXT = loader_glMapNamedBufferEXT;
  tbl.glMapNamedBufferRangeEXT = loader_glMapNamedBufferRangeEXT;
  tbl.glMatrixFrustumEXT = loader_glMatrixFrustumEXT;
  tbl.glMatrixLoadIdentityEXT = loader_glMatrixLoadIdentityEXT;
  tbl.glMatrixLoadTransposedEXT = loader_glMatrixLoadTransposedEXT;
  tbl.glMatrixLoadTransposefEXT = loader_glMatrixLoadTransposefEXT;
  tbl.glMatrixLoaddEXT = loader_glMatrixLoaddEXT;
  tbl.glMatrixLoadfEXT = loader_glMatrixLoadfEXT;
  tbl.glMatrixMultTransposedEXT = loader_glMatrixMultTransposedEXT;
  tbl.glMatrixMultTransposefEXT = loader_glMatrixMultTransposefEXT;
  tbl.glMatrixMultdEXT = loader_glMatrixMultdEXT;
  tbl.glMatrixMultfEXT = loader_glMatrixMultfEXT;
  tbl.glMatrixOrthoEXT = loader_glMatrixOrthoEXT;
  tbl.glMatrixPopEXT = loader_glMatrixPopEXT;
  tbl.glMatrixPushEXT = loader_glMatrixPushEXT;
  tbl.glMatrixRotatedEXT = loader_glMatrixRotatedEXT;
  tbl.glMatrixRotatefEXT = loader_glMatrixRotatefEXT;
  tbl.glMatrixScaledEXT = loader_glMatrixScaledEXT;
  tbl.glMatrixScalefEXT = loader_glMatrixScalefEXT;
  tbl.glMatrixTranslatedEXT = loader_glMatrixTranslatedEXT;
  tbl.glMatrixTranslatefEXT = loader_glMatrixTranslatefEXT;
  tbl.glMultiTexBufferEXT = loader_glMultiTexBufferEXT;
  tbl.glMultiTexCoordPointerEXT = loader_glMultiTexCoordPointerEXT;
  tbl.glMultiTexEnvfEXT = loader_glMultiTexEnvfEXT;
  tbl.glMultiTexEnvfvEXT = loader_glMultiTexEnvfvEXT;
  tbl.glMultiTexEnviEXT = loader_glMultiTexEnviEXT;
  tbl.glMultiTexEnvivEXT = loader_glMultiTexEnvivEXT;
  tbl.glMultiTexGendEXT = loader_glMultiTexGendEXT;
  tbl.glMultiTexGendvEXT = loader_glMultiTexGendvEXT;
  tbl.glMultiTexGenfEXT = loader_glMultiTexGenfEXT;
  tbl.glMultiTexGenfvEXT = loader_glMultiTexGenfvEXT;
  tbl.glMultiTexGeniEXT = loader_glMultiTexGeniEXT;
  tbl.glMultiTexGenivEXT = loader_glMultiTexGenivEXT;
  tbl.glMultiTexImage1DEXT = loader_glMultiTexImage1DEXT;
  tbl.glMultiTexImage2DEXT = loader_glMultiTexImage2DEXT;
  tbl.glMultiTexImage3DEXT = loader_glMultiTexImage3DEXT;
  tbl.glMultiTexParameterIivEXT = loader_glMultiTexParameterIivEXT;
  tbl.glMultiTexParameterIuivEXT = loader_glMultiTexParameterIuivEXT;
  tbl.glMultiTexParameterfEXT = loader_glMultiTexParameterfEXT;
  tbl.glMultiTexParameterfvEXT = loader_glMultiTexParameterfvEXT;
  tbl.glMultiTexParameteriEXT = loader_glMultiTexParameteriEXT;
  tbl.glMultiTexParameterivEXT = loader_glMultiTexParameterivEXT;
  tbl.glMultiTexRenderbufferEXT = loader_glMultiTexRenderbufferEXT;
  tbl.glMultiTexSubImage1DEXT = loader_glMultiTexSubImage1DEXT;
  tbl.glMultiTexSubImage2DEXT = loader_glMultiTexSubImage2DEXT;
  tbl.glMultiTexSubImage3DEXT = loader_glMultiTexSubImage3DEXT;
  tbl.glNamedBufferDataEXT = loader_glNamedBufferDataEXT;
  tbl.glNamedBufferSubDataEXT = loader_glNamedBufferSubDataEXT;
  tbl.glNamedCopyBufferSubDataEXT = loader_glNamedCopyBufferSubDataEXT;
  tbl.glNamedFramebufferRenderbufferEXT = loader_glNamedFramebufferRenderbufferEXT;
  tbl.glNamedFramebufferTexture1DEXT = loader_glNamedFramebufferTexture1DEXT;
  tbl.glNamedFramebufferTexture2DEXT = loader_glNamedFramebufferTexture2DEXT;
  tbl.glNamedFramebufferTexture3DEXT = loader_glNamedFramebufferTexture3DEXT;
  tbl.glNamedFramebufferTextureEXT = loader_glNamedFramebufferTextureEXT;
  tbl.glNamedFramebufferTextureFaceEXT = loader_glNamedFramebufferTextureFaceEXT;
  tbl.glNamedFramebufferTextureLayerEXT = loader_glNamedFramebufferTextureLayerEXT;
  tbl.glNamedProgramLocalParameter4dEXT = loader_glNamedProgramLocalParameter4dEXT;
  tbl.glNamedProgramLocalParameter4dvEXT = loader_glNamedProgramLocalParameter4dvEXT;
  tbl.glNamedProgramLocalParameter4fEXT = loader_glNamedProgramLocalParameter4fEXT;
  tbl.glNamedProgramLocalParameter4fvEXT = loader_glNamedProgramLocalParameter4fvEXT;
  tbl.glNamedProgramLocalParameterI4iEXT = loader_glNamedProgramLocalParameterI4iEXT;
  tbl.glNamedProgramLocalParameterI4ivEXT = loader_glNamedProgramLocalParameterI4ivEXT;
  tbl.glNamedProgramLocalParameterI4uiEXT = loader_glNamedProgramLocalParameterI4uiEXT;
  tbl.glNamedProgramLocalParameterI4uivEXT = loader_glNamedProgramLocalParameterI4uivEXT;
  tbl.glNamedProgramLocalParameters4fvEXT = loader_glNamedProgramLocalParameters4fvEXT;
  tbl.glNamedProgramLocalParametersI4ivEXT = loader_glNamedProgramLocalParametersI4ivEXT;
  tbl.glNamedProgramLocalParametersI4uivEXT = loader_glNamedProgramLocalParametersI4uivEXT;
  tbl.glNamedProgramStringEXT = loader_glNamedProgramStringEXT;
  tbl.glNamedRenderbufferStorageEXT = loader_glNamedRenderbufferStorageEXT;
  tbl.glNamedRenderbufferStorageMultisampleCoverageEXT = loader_glNamedRenderbufferStorageMultisampleCoverageEXT;
  tbl.glNamedRenderbufferStorageMultisampleEXT = loader_glNamedRenderbufferStorageMultisampleEXT;
  tbl.glProgramUniform1dEXT = loader_glProgramUniform1dEXT;
  tbl.glProgramUniform1dvEXT = loader_glProgramUniform1dvEXT;
  tbl.glProgramUniform1fEXT = loader_glProgramUniform1fEXT;
  tbl.glProgramUniform1fvEXT = loader_glProgramUniform1fvEXT;
  tbl.glProgramUniform1iEXT = loader_glProgramUniform1iEXT;
  tbl.glProgramUniform1ivEXT = loader_glProgramUniform1ivEXT;
  tbl.glProgramUniform1uiEXT = loader_glProgramUniform1uiEXT;
  tbl.glProgramUniform1uivEXT = loader_glProgramUniform1uivEXT;
  tbl.glProgramUniform2dEXT = loader_glProgramUniform2dEXT;
  tbl.glProgramUniform2dvEXT = loader_glProgramUniform2dvEXT;
  tbl.glProgramUniform2fEXT = loader_glProgramUniform2fEXT;
  tbl.glProgramUniform2fvEXT = loader_glProgramUniform2fvEXT;
  tbl.glProgramUniform2iEXT = loader_glProgramUniform2iEXT;
  tbl.glProgramUniform2ivEXT = loader_glProgramUniform2ivEXT;
  tbl.glProgramUniform2uiEXT = loader_glProgramUniform2uiEXT;
  tbl.glProgramUniform2uivEXT = loader_glProgramUniform2uivEXT;
  tbl.glProgramUniform3dEXT = loader_glProgramUniform3dEXT;
  tbl.glProgramUniform3dvEXT = loader_glProgramUniform3dvEXT;
  tbl.glProgramUniform3fEXT = loader_glProgramUniform3fEXT;
  tbl.glProgramUniform3fvEXT = loader_glProgramUniform3fvEXT;
  tbl.glProgramUniform3iEXT = loader_glProgramUniform3iEXT;
  tbl.glProgramUniform3ivEXT = loader_glProgramUniform3ivEXT;
  tbl.glProgramUniform3uiEXT = loader_glProgramUniform3uiEXT;
  tbl.glProgramUniform3uivEXT = loader_glProgramUniform3uivEXT;
  tbl.glProgramUniform4dEXT = loader_glProgramUniform4dEXT;
  tbl.glProgramUniform4dvEXT = loader_glProgramUniform4dvEXT;
  tbl.glProgramUniform4fEXT = loader_glProgramUniform4fEXT;
  tbl.glProgramUniform4fvEXT = loader_glProgramUniform4fvEXT;
  tbl.glProgramUniform4iEXT = loader_glProgramUniform4iEXT;
  tbl.glProgramUniform4ivEXT = loader_glProgramUniform4ivEXT;
  tbl.glProgramUniform4uiEXT = loader_glProgramUniform4uiEXT;
  tbl.glProgramUniform4uivEXT = loader_glProgramUniform4uivEXT;
  tbl.glProgramUniformMatrix2dvEXT = loader_glProgramUniformMatrix2dvEXT;
  tbl.glProgramUniformMatrix2fvEXT = loader_glProgramUniformMatrix2fvEXT;
  tbl.glProgramUniformMatrix2x3dvEXT = loader_glProgramUniformMatrix2x3dvEXT;
  tbl.glProgramUniformMatrix2x3fvEXT = loader_glProgramUniformMatrix2x3fvEXT;
  tbl.glProgramUniformMatrix2x4dvEXT = loader_glProgramUniformMatrix2x4dvEXT;
  tbl.glProgramUniformMatrix2x4fvEXT = loader_glProgramUniformMatrix2x4fvEXT;
  tbl.glProgramUniformMatrix3dvEXT = loader_glProgramUniformMatrix3dvEXT;
  tbl.glProgramUniformMatrix3fvEXT = loader_glProgramUniformMatrix3fvEXT;
  tbl.glProgramUniformMatrix3x2dvEXT = loader_glProgramUniformMatrix3x2dvEXT;
  tbl.glProgramUniformMatrix3x2fvEXT = loader_glProgramUniformMatrix3x2fvEXT;
  tbl.glProgramUniformMatrix3x4dvEXT = loader_glProgramUniformMatrix3x4dvEXT;
  tbl.glProgramUniformMatrix3x4fvEXT = loader_glProgramUniformMatrix3x4fvEXT;
  tbl.glProgramUniformMatrix4dvEXT = loader_glProgramUniformMatrix4dvEXT;
  tbl.glProgramUniformMatrix4fvEXT = loader_glProgramUniformMatrix4fvEXT;
  tbl.glProgramUniformMatrix4x2dvEXT = loader_glProgramUniformMatrix4x2dvEXT;
  tbl.glProgramUniformMatrix4x2fvEXT = loader_glProgramUniformMatrix4x2fvEXT;
  tbl.glProgramUniformMatrix4x3dvEXT = loader_glProgramUniformMatrix4x3dvEXT;
  tbl.glProgramUniformMatrix4x3fvEXT = loader_glProgramUniformMatrix4x3fvEXT;
  tbl.glPushClientAttribDefaultEXT = loader_glPushClientAttribDefaultEXT;
  tbl.glTextureBufferEXT = loader_glTextureBufferEXT;
  tbl.glTextureImage1DEXT = loader_glTextureImage1DEXT;
  tbl.glTextureImage2DEXT = loader_glTextureImage2DEXT;
  tbl.glTextureImage3DEXT = loader_glTextureImage3DEXT;
  tbl.glTextureParameterIivEXT = loader_glTextureParameterIivEXT;
  tbl.glTextureParameterIuivEXT = loader_glTextureParameterIuivEXT;
  tbl.glTextureParameterfEXT = loader_glTextureParameterfEXT;
  tbl.glTextureParameterfvEXT = loader_glTextureParameterfvEXT;
  tbl.glTextureParameteriEXT = loader_glTextureParameteriEXT;
  tbl.glTextureParameterivEXT = loader_glTextureParameterivEXT;
  tbl.glTextureRenderbufferEXT = loader_glTextureRenderbufferEXT;
  tbl.glTextureSubImage1DEXT = loader_glTextureSubImage1DEXT;
  tbl.glTextureSubImage2DEXT = loader_glTextureSubImage2DEXT;
  tbl.glTextureSubImage3DEXT = loader_glTextureSubImage3DEXT;
  tbl.glUnmapNamedBufferEXT = loader_glUnmapNamedBufferEXT;
  tbl.glVertexArrayColorOffsetEXT = loader_glVertexArrayColorOffsetEXT;
  tbl.glVertexArrayEdgeFlagOffsetEXT = loader_glVertexArrayEdgeFlagOffsetEXT;
  tbl.glVertexArrayFogCoordOffsetEXT = loader_glVertexArrayFogCoordOffsetEXT;
  tbl.glVertexArrayIndexOffsetEXT = loader_glVertexArrayIndexOffsetEXT;
  tbl.glVertexArrayMultiTexCoordOffsetEXT = loader_glVertexArrayMultiTexCoordOffsetEXT;
  tbl.glVertexArrayNormalOffsetEXT = loader_glVertexArrayNormalOffsetEXT;
  tbl.glVertexArraySecondaryColorOffsetEXT = loader_glVertexArraySecondaryColorOffsetEXT;
  tbl.glVertexArrayTexCoordOffsetEXT = loader_glVertexArrayTexCoordOffsetEXT;
  tbl.glVertexArrayVertexAttribIOffsetEXT = loader_glVertexArrayVertexAttribIOffsetEXT;
  tbl.glVertexArrayVertexAttribOffsetEXT = loader_glVertexArrayVertexAttribOffsetEXT;
  tbl.glVertexArrayVertexOffsetEXT = loader_glVertexArrayVertexOffsetEXT;

  // GL_EXT_discard_framebuffer

  tbl.glDiscardFramebufferEXT = loader_glDiscardFramebufferEXT;

  // GL_EXT_draw_buffers2

  tbl.glColorMaskIndexedEXT = loader_glColorMaskIndexedEXT;
  tbl.glDisableIndexedEXT = loader_glDisableIndexedEXT;
  tbl.glEnableIndexedEXT = loader_glEnableIndexedEXT;
  tbl.glGetBooleanIndexedvEXT = loader_glGetBooleanIndexedvEXT;
  tbl.glGetIntegerIndexedvEXT = loader_glGetIntegerIndexedvEXT;
  tbl.glIsEnabledIndexedEXT = loader_glIsEnabledIndexedEXT;

  // GL_EXT_draw_instanced

  tbl.glDrawArraysInstancedEXT = loader_glDrawArraysInstancedEXT;
  tbl.glDrawElementsInstancedEXT = loader_glDrawElementsInstancedEXT;

  // GL_EXT_draw_range_elements

  tbl.glDrawRangeElementsEXT = loader_glDrawRangeElementsEXT;

  // GL_EXT_fog_coord

  tbl.glFogCoordPointerEXT = loader_glFogCoordPointerEXT;
  tbl.glFogCoorddEXT = loader_glFogCoorddEXT;
  tbl.glFogCoorddvEXT = loader_glFogCoorddvEXT;
  tbl.glFogCoordfEXT = loader_glFogCoordfEXT;
  tbl.glFogCoordfvEXT = loader_glFogCoordfvEXT;

  // GL_EXT_fragment_lighting

  tbl.glFragmentColorMaterialEXT = loader_glFragmentColorMaterialEXT;
  tbl.glFragmentLightModelfEXT = loader_glFragmentLightModelfEXT;
  tbl.glFragmentLightModelfvEXT = loader_glFragmentLightModelfvEXT;
  tbl.glFragmentLightModeliEXT = loader_glFragmentLightModeliEXT;
  tbl.glFragmentLightModelivEXT = loader_glFragmentLightModelivEXT;
  tbl.glFragmentLightfEXT = loader_glFragmentLightfEXT;
  tbl.glFragmentLightfvEXT = loader_glFragmentLightfvEXT;
  tbl.glFragmentLightiEXT = loader_glFragmentLightiEXT;
  tbl.glFragmentLightivEXT = loader_glFragmentLightivEXT;
  tbl.glFragmentMaterialfEXT = loader_glFragmentMaterialfEXT;
  tbl.glFragmentMaterialfvEXT = loader_glFragmentMaterialfvEXT;
  tbl.glFragmentMaterialiEXT = loader_glFragmentMaterialiEXT;
  tbl.glFragmentMaterialivEXT = loader_glFragmentMaterialivEXT;
  tbl.glGetFragmentLightfvEXT = loader_glGetFragmentLightfvEXT;
  tbl.glGetFragmentLightivEXT = loader_glGetFragmentLightivEXT;
  tbl.glGetFragmentMaterialfvEXT = loader_glGetFragmentMaterialfvEXT;
  tbl.glGetFragmentMaterialivEXT = loader_glGetFragmentMaterialivEXT;
  tbl.glLightEnviEXT = loader_glLightEnviEXT;

  // GL_EXT_framebuffer_blit

  tbl.glBlitFramebufferEXT = loader_glBlitFramebufferEXT;

  // GL_EXT_framebuffer_multisample

  tbl.glRenderbufferStorageMultisampleEXT = loader_glRenderbufferStorageMultisampleEXT;

  // GL_EXT_framebuffer_object

  tbl.glBindFramebufferEXT = loader_glBindFramebufferEXT;
  tbl.glBindRenderbufferEXT = loader_glBindRenderbufferEXT;
  tbl.glCheckFramebufferStatusEXT = loader_glCheckFramebufferStatusEXT;
  tbl.glDeleteFramebuffersEXT = loader_glDeleteFramebuffersEXT;
  tbl.glDeleteRenderbuffersEXT = loader_glDeleteRenderbuffersEXT;
  tbl.glFramebufferRenderbufferEXT = loader_glFramebufferRenderbufferEXT;
  tbl.glFramebufferTexture1DEXT = loader_glFramebufferTexture1DEXT;
  tbl.glFramebufferTexture2DEXT = loader_glFramebufferTexture2DEXT;
  tbl.glFramebufferTexture3DEXT = loader_glFramebufferTexture3DEXT;
  tbl.glGenFramebuffersEXT = loader_glGenFramebuffersEXT;
  tbl.glGenRenderbuffersEXT = loader_glGenRenderbuffersEXT;
  tbl.glGenerateMipmapEXT = loader_glGenerateMipmapEXT;
  tbl.glGetFramebufferAttachmentParameterivEXT = loader_glGetFramebufferAttachmentParameterivEXT;
  tbl.glGetRenderbufferParameterivEXT = loader_glGetRenderbufferParameterivEXT;
  tbl.glIsFramebufferEXT = loader_glIsFramebufferEXT;
  tbl.glIsRenderbufferEXT = loader_glIsRenderbufferEXT;
  tbl.glRenderbufferStorageEXT = loader_glRenderbufferStorageEXT;

  // GL_EXT_geometry_shader4

  tbl.glFramebufferTextureEXT = loader_glFramebufferTextureEXT;
  tbl.glFramebufferTextureFaceEXT = loader_glFramebufferTextureFaceEXT;
  tbl.glProgramParameteriEXT = loader_glProgramParameteriEXT;

  // GL_EXT_gpu_program_parameters

  tbl.glProgramEnvParameters4fvEXT = loader_glProgramEnvParameters4fvEXT;
  tbl.glProgramLocalParameters4fvEXT = loader_glProgramLocalParameters4fvEXT;

  // GL_EXT_gpu_shader4

  tbl.glBindFragDataLocationEXT = loader_glBindFragDataLocationEXT;
  tbl.glGetFragDataLocationEXT = loader_glGetFragDataLocationEXT;
  tbl.glGetUniformuivEXT = loader_glGetUniformuivEXT;
  tbl.glGetVertexAttribIivEXT = loader_glGetVertexAttribIivEXT;
  tbl.glGetVertexAttribIuivEXT = loader_glGetVertexAttribIuivEXT;
  tbl.glUniform1uiEXT = loader_glUniform1uiEXT;
  tbl.glUniform1uivEXT = loader_glUniform1uivEXT;
  tbl.glUniform2uiEXT = loader_glUniform2uiEXT;
  tbl.glUniform2uivEXT = loader_glUniform2uivEXT;
  tbl.glUniform3uiEXT = loader_glUniform3uiEXT;
  tbl.glUniform3uivEXT = loader_glUniform3uivEXT;
  tbl.glUniform4uiEXT = loader_glUniform4uiEXT;
  tbl.glUniform4uivEXT = loader_glUniform4uivEXT;
  tbl.glVertexAttribI1iEXT = loader_glVertexAttribI1iEXT;
  tbl.glVertexAttribI1ivEXT = loader_glVertexAttribI1ivEXT;
  tbl.glVertexAttribI1uiEXT = loader_glVertexAttribI1uiEXT;
  tbl.glVertexAttribI1uivEXT = loader_glVertexAttribI1uivEXT;
  tbl.glVertexAttribI2iEXT = loader_glVertexAttribI2iEXT;
  tbl.glVertexAttribI2ivEXT = loader_glVertexAttribI2ivEXT;
  tbl.glVertexAttribI2uiEXT = loader_glVertexAttribI2uiEXT;
  tbl.glVertexAttribI2uivEXT = loader_glVertexAttribI2uivEXT;
  tbl.glVertexAttribI3iEXT = loader_glVertexAttribI3iEXT;
  tbl.glVertexAttribI3ivEXT = loader_glVertexAttribI3ivEXT;
  tbl.glVertexAttribI3uiEXT = loader_glVertexAttribI3uiEXT;
  tbl.glVertexAttribI3uivEXT = loader_glVertexAttribI3uivEXT;
  tbl.glVertexAttribI4bvEXT = loader_glVertexAttribI4bvEXT;
  tbl.glVertexAttribI4iEXT = loader_glVertexAttribI4iEXT;
  tbl.glVertexAttribI4ivEXT = loader_glVertexAttribI4ivEXT;
  tbl.glVertexAttribI4svEXT = loader_glVertexAttribI4svEXT;
  tbl.glVertexAttribI4ubvEXT = loader_glVertexAttribI4ubvEXT;
  tbl.glVertexAttribI4uiEXT = loader_glVertexAttribI4uiEXT;
  tbl.glVertexAttribI4uivEXT = loader_glVertexAttribI4uivEXT;
  tbl.glVertexAttribI4usvEXT = loader_glVertexAttribI4usvEXT;
  tbl.glVertexAttribIPointerEXT = loader_glVertexAttribIPointerEXT;

  // GL_EXT_histogram

  tbl.glGetHistogramEXT = loader_glGetHistogramEXT;
  tbl.glGetHistogramParameterfvEXT = loader_glGetHistogramParameterfvEXT;
  tbl.glGetHistogramParameterivEXT = loader_glGetHistogramParameterivEXT;
  tbl.glGetMinmaxEXT = loader_glGetMinmaxEXT;
  tbl.glGetMinmaxParameterfvEXT = loader_glGetMinmaxParameterfvEXT;
  tbl.glGetMinmaxParameterivEXT = loader_glGetMinmaxParameterivEXT;
  tbl.glHistogramEXT = loader_glHistogramEXT;
  tbl.glMinmaxEXT = loader_glMinmaxEXT;
  tbl.glResetHistogramEXT = loader_glResetHistogramEXT;
  tbl.glResetMinmaxEXT = loader_glResetMinmaxEXT;

  // GL_EXT_index_func

  tbl.glIndexFuncEXT = loader_glIndexFuncEXT;

  // GL_EXT_index_material

  tbl.glIndexMaterialEXT = loader_glIndexMaterialEXT;

  // GL_EXT_light_texture

  tbl.glApplyTextureEXT = loader_glApplyTextureEXT;
  tbl.glTextureLightEXT = loader_glTextureLightEXT;
  tbl.glTextureMaterialEXT = loader_glTextureMaterialEXT;

  // GL_EXT_map_buffer_range

  tbl.glFlushMappedBufferRangeEXT = loader_glFlushMappedBufferRangeEXT;
  tbl.glMapBufferRangeEXT = loader_glMapBufferRangeEXT;

  // GL_EXT_multi_draw_arrays

  tbl.glMultiDrawArraysEXT = loader_glMultiDrawArraysEXT;
  tbl.glMultiDrawElementsEXT = loader_glMultiDrawElementsEXT;

  // GL_EXT_multisample

  tbl.glSampleMaskEXT = loader_glSampleMaskEXT;
  tbl.glSamplePatternEXT = loader_glSamplePatternEXT;

  // GL_EXT_multisampled_render_to_texture

  tbl.glFramebufferTexture2DMultisampleEXT = loader_glFramebufferTexture2DMultisampleEXT;

  // GL_EXT_multiview_draw_buffers

  tbl.glDrawBuffersIndexedEXT = loader_glDrawBuffersIndexedEXT;
  tbl.glGetIntegeri_vEXT = loader_glGetIntegeri_vEXT;
  tbl.glReadBufferIndexedEXT = loader_glReadBufferIndexedEXT;

  // GL_EXT_occlusion_query_boolean

  tbl.glBeginQueryEXT = loader_glBeginQueryEXT;
  tbl.glDeleteQueriesEXT = loader_glDeleteQueriesEXT;
  tbl.glEndQueryEXT = loader_glEndQueryEXT;
  tbl.glGenQueriesEXT = loader_glGenQueriesEXT;
  tbl.glGetQueryObjectuivEXT = loader_glGetQueryObjectuivEXT;
  tbl.glGetQueryivEXT = loader_glGetQueryivEXT;
  tbl.glIsQueryEXT = loader_glIsQueryEXT;

  // GL_EXT_paletted_texture

  tbl.glColorTableEXT = loader_glColorTableEXT;
  tbl.glGetColorTableEXT = loader_glGetColorTableEXT;
  tbl.glGetColorTableParameterfvEXT = loader_glGetColorTableParameterfvEXT;
  tbl.glGetColorTableParameterivEXT = loader_glGetColorTableParameterivEXT;

  // GL_EXT_pixel_transform

  tbl.glGetPixelTransformParameterfvEXT = loader_glGetPixelTransformParameterfvEXT;
  tbl.glGetPixelTransformParameterivEXT = loader_glGetPixelTransformParameterivEXT;
  tbl.glPixelTransformParameterfEXT = loader_glPixelTransformParameterfEXT;
  tbl.glPixelTransformParameterfvEXT = loader_glPixelTransformParameterfvEXT;
  tbl.glPixelTransformParameteriEXT = loader_glPixelTransformParameteriEXT;
  tbl.glPixelTransformParameterivEXT = loader_glPixelTransformParameterivEXT;

  // GL_EXT_point_parameters

  tbl.glPointParameterfEXT = loader_glPointParameterfEXT;
  tbl.glPointParameterfvEXT = loader_glPointParameterfvEXT;

  // GL_EXT_polygon_offset

  tbl.glPolygonOffsetEXT = loader_glPolygonOffsetEXT;

  // GL_EXT_provoking_vertex

  tbl.glProvokingVertexEXT = loader_glProvokingVertexEXT;

  // GL_EXT_robustness

  tbl.glGetnUniformfvEXT = loader_glGetnUniformfvEXT;
  tbl.glGetnUniformivEXT = loader_glGetnUniformivEXT;
  tbl.glReadnPixelsEXT = loader_glReadnPixelsEXT;

  // GL_EXT_scene_marker

  tbl.glBeginSceneEXT = loader_glBeginSceneEXT;
  tbl.glEndSceneEXT = loader_glEndSceneEXT;

  // GL_EXT_secondary_color

  tbl.glSecondaryColor3bEXT = loader_glSecondaryColor3bEXT;
  tbl.glSecondaryColor3bvEXT = loader_glSecondaryColor3bvEXT;
  tbl.glSecondaryColor3dEXT = loader_glSecondaryColor3dEXT;
  tbl.glSecondaryColor3dvEXT = loader_glSecondaryColor3dvEXT;
  tbl.glSecondaryColor3fEXT = loader_glSecondaryColor3fEXT;
  tbl.glSecondaryColor3fvEXT = loader_glSecondaryColor3fvEXT;
  tbl.glSecondaryColor3iEXT = loader_glSecondaryColor3iEXT;
  tbl.glSecondaryColor3ivEXT = loader_glSecondaryColor3ivEXT;
  tbl.glSecondaryColor3sEXT = loader_glSecondaryColor3sEXT;
  tbl.glSecondaryColor3svEXT = loader_glSecondaryColor3svEXT;
  tbl.glSecondaryColor3ubEXT = loader_glSecondaryColor3ubEXT;
  tbl.glSecondaryColor3ubvEXT = loader_glSecondaryColor3ubvEXT;
  tbl.glSecondaryColor3uiEXT = loader_glSecondaryColor3uiEXT;
  tbl.glSecondaryColor3uivEXT = loader_glSecondaryColor3uivEXT;
  tbl.glSecondaryColor3usEXT = loader_glSecondaryColor3usEXT;
  tbl.glSecondaryColor3usvEXT = loader_glSecondaryColor3usvEXT;
  tbl.glSecondaryColorPointerEXT = loader_glSecondaryColorPointerEXT;

  // GL_EXT_separate_shader_objects

  tbl.glActiveProgramEXT = loader_glActiveProgramEXT;
  tbl.glCreateShaderProgramEXT = loader_glCreateShaderProgramEXT;
  tbl.glUseShaderProgramEXT = loader_glUseShaderProgramEXT;

  // GL_EXT_shader_image_load_store

  tbl.glBindImageTextureEXT = loader_glBindImageTextureEXT;
  tbl.glMemoryBarrierEXT = loader_glMemoryBarrierEXT;

  // GL_EXT_stencil_clear_tag

  tbl.glStencilClearTagEXT = loader_glStencilClearTagEXT;

  // GL_EXT_stencil_two_side

  tbl.glActiveStencilFaceEXT = loader_glActiveStencilFaceEXT;

  // GL_EXT_subtexture

  tbl.glTexSubImage1DEXT = loader_glTexSubImage1DEXT;
  tbl.glTexSubImage2DEXT = loader_glTexSubImage2DEXT;
  tbl.glTexSubImage3DEXT = loader_glTexSubImage3DEXT;

  // GL_EXT_texture3D

  tbl.glTexImage3DEXT = loader_glTexImage3DEXT;

  // GL_EXT_texture_array

  tbl.glFramebufferTextureLayerEXT = loader_glFramebufferTextureLayerEXT;

  // GL_EXT_texture_buffer_object

  tbl.glTexBufferEXT = loader_glTexBufferEXT;

  // GL_EXT_texture_integer

  tbl.glClearColorIiEXT = loader_glClearColorIiEXT;
  tbl.glClearColorIuiEXT = loader_glClearColorIuiEXT;
  tbl.glGetTexParameterIivEXT = loader_glGetTexParameterIivEXT;
  tbl.glGetTexParameterIuivEXT = loader_glGetTexParameterIuivEXT;
  tbl.glTexParameterIivEXT = loader_glTexParameterIivEXT;
  tbl.glTexParameterIuivEXT = loader_glTexParameterIuivEXT;

  // GL_EXT_texture_object

  tbl.glAreTexturesResidentEXT = loader_glAreTexturesResidentEXT;
  tbl.glBindTextureEXT = loader_glBindTextureEXT;
  tbl.glDeleteTexturesEXT = loader_glDeleteTexturesEXT;
  tbl.glGenTexturesEXT = loader_glGenTexturesEXT;
  tbl.glIsTextureEXT = loader_glIsTextureEXT;
  tbl.glPrioritizeTexturesEXT = loader_glPrioritizeTexturesEXT;

  // GL_EXT_texture_perturb_normal

  tbl.glTextureNormalEXT = loader_glTextureNormalEXT;

  // GL_EXT_texture_storage

  tbl.glTexStorage1DEXT = loader_glTexStorage1DEXT;
  tbl.glTexStorage2DEXT = loader_glTexStorage2DEXT;
  tbl.glTexStorage3DEXT = loader_glTexStorage3DEXT;

  // GL_EXT_timer_query

  tbl.glGetQueryObjecti64vEXT = loader_glGetQueryObjecti64vEXT;
  tbl.glGetQueryObjectui64vEXT = loader_glGetQueryObjectui64vEXT;

  // GL_EXT_transform_feedback

  tbl.glBeginTransformFeedbackEXT = loader_glBeginTransformFeedbackEXT;
  tbl.glBindBufferBaseEXT = loader_glBindBufferBaseEXT;
  tbl.glBindBufferOffsetEXT = loader_glBindBufferOffsetEXT;
  tbl.glBindBufferRangeEXT = loader_glBindBufferRangeEXT;
  tbl.glEndTransformFeedbackEXT = loader_glEndTransformFeedbackEXT;
  tbl.glGetTransformFeedbackVaryingEXT = loader_glGetTransformFeedbackVaryingEXT;
  tbl.glTransformFeedbackVaryingsEXT = loader_glTransformFeedbackVaryingsEXT;

  // GL_EXT_vertex_array

  tbl.glArrayElementEXT = loader_glArrayElementEXT;
  tbl.glColorPointerEXT = loader_glColorPointerEXT;
  tbl.glDrawArraysEXT = loader_glDrawArraysEXT;
  tbl.glEdgeFlagPointerEXT = loader_glEdgeFlagPointerEXT;
  tbl.glGetPointervEXT = loader_glGetPointervEXT;
  tbl.glIndexPointerEXT = loader_glIndexPointerEXT;
  tbl.glNormalPointerEXT = loader_glNormalPointerEXT;
  tbl.glTexCoordPointerEXT = loader_glTexCoordPointerEXT;
  tbl.glVertexPointerEXT = loader_glVertexPointerEXT;

  // GL_EXT_vertex_attrib_64bit

  tbl.glGetVertexAttribLdvEXT = loader_glGetVertexAttribLdvEXT;
  tbl.glVertexArrayVertexAttribLOffsetEXT = loader_glVertexArrayVertexAttribLOffsetEXT;
  tbl.glVertexAttribL1dEXT = loader_glVertexAttribL1dEXT;
  tbl.glVertexAttribL1dvEXT = loader_glVertexAttribL1dvEXT;
  tbl.glVertexAttribL2dEXT = loader_glVertexAttribL2dEXT;
  tbl.glVertexAttribL2dvEXT = loader_glVertexAttribL2dvEXT;
  tbl.glVertexAttribL3dEXT = loader_glVertexAttribL3dEXT;
  tbl.glVertexAttribL3dvEXT = loader_glVertexAttribL3dvEXT;
  tbl.glVertexAttribL4dEXT = loader_glVertexAttribL4dEXT;
  tbl.glVertexAttribL4dvEXT = loader_glVertexAttribL4dvEXT;
  tbl.glVertexAttribLPointerEXT = loader_glVertexAttribLPointerEXT;

  // GL_EXT_vertex_shader

  tbl.glBeginVertexShaderEXT = loader_glBeginVertexShaderEXT;
  tbl.glBindLightParameterEXT = loader_glBindLightParameterEXT;
  tbl.glBindMaterialParameterEXT = loader_glBindMaterialParameterEXT;
  tbl.glBindParameterEXT = loader_glBindParameterEXT;
  tbl.glBindTexGenParameterEXT = loader_glBindTexGenParameterEXT;
  tbl.glBindTextureUnitParameterEXT = loader_glBindTextureUnitParameterEXT;
  tbl.glBindVertexShaderEXT = loader_glBindVertexShaderEXT;
  tbl.glDeleteVertexShaderEXT = loader_glDeleteVertexShaderEXT;
  tbl.glDisableVariantClientStateEXT = loader_glDisableVariantClientStateEXT;
  tbl.glEnableVariantClientStateEXT = loader_glEnableVariantClientStateEXT;
  tbl.glEndVertexShaderEXT = loader_glEndVertexShaderEXT;
  tbl.glExtractComponentEXT = loader_glExtractComponentEXT;
  tbl.glGenSymbolsEXT = loader_glGenSymbolsEXT;
  tbl.glGenVertexShadersEXT = loader_glGenVertexShadersEXT;
  tbl.glGetInvariantBooleanvEXT = loader_glGetInvariantBooleanvEXT;
  tbl.glGetInvariantFloatvEXT = loader_glGetInvariantFloatvEXT;
  tbl.glGetInvariantIntegervEXT = loader_glGetInvariantIntegervEXT;
  tbl.glGetLocalConstantBooleanvEXT = loader_glGetLocalConstantBooleanvEXT;
  tbl.glGetLocalConstantFloatvEXT = loader_glGetLocalConstantFloatvEXT;
  tbl.glGetLocalConstantIntegervEXT = loader_glGetLocalConstantIntegervEXT;
  tbl.glGetVariantBooleanvEXT = loader_glGetVariantBooleanvEXT;
  tbl.glGetVariantFloatvEXT = loader_glGetVariantFloatvEXT;
  tbl.glGetVariantIntegervEXT = loader_glGetVariantIntegervEXT;
  tbl.glGetVariantPointervEXT = loader_glGetVariantPointervEXT;
  tbl.glInsertComponentEXT = loader_glInsertComponentEXT;
  tbl.glIsVariantEnabledEXT = loader_glIsVariantEnabledEXT;
  tbl.glSetInvariantEXT = loader_glSetInvariantEXT;
  tbl.glSetLocalConstantEXT = loader_glSetLocalConstantEXT;
  tbl.glShaderOp1EXT = loader_glShaderOp1EXT;
  tbl.glShaderOp2EXT = loader_glShaderOp2EXT;
  tbl.glShaderOp3EXT = loader_glShaderOp3EXT;
  tbl.glSwizzleEXT = loader_glSwizzleEXT;
  tbl.glVariantPointerEXT = loader_glVariantPointerEXT;
  tbl.glVariantbvEXT = loader_glVariantbvEXT;
  tbl.glVariantdvEXT = loader_glVariantdvEXT;
  tbl.glVariantfvEXT = loader_glVariantfvEXT;
  tbl.glVariantivEXT = loader_glVariantivEXT;
  tbl.glVariantsvEXT = loader_glVariantsvEXT;
  tbl.glVariantubvEXT = loader_glVariantubvEXT;
  tbl.glVariantuivEXT = loader_glVariantuivEXT;
  tbl.glVariantusvEXT = loader_glVariantusvEXT;
  tbl.glWriteMaskEXT = loader_glWriteMaskEXT;

  // GL_EXT_vertex_weighting

  tbl.glVertexWeightPointerEXT = loader_glVertexWeightPointerEXT;
  tbl.glVertexWeightfEXT = loader_glVertexWeightfEXT;
  tbl.glVertexWeightfvEXT = loader_glVertexWeightfvEXT;

  // GL_EXT_x11_sync_object

  tbl.glImportSyncEXT = loader_glImportSyncEXT;

  // GL_GREMEDY_frame_terminator

  tbl.glFrameTerminatorGREMEDY = loader_glFrameTerminatorGREMEDY;

  // GL_GREMEDY_string_marker

  tbl.glStringMarkerGREMEDY = loader_glStringMarkerGREMEDY;

  // GL_HP_image_transform

  tbl.glGetImageTransformParameterfvHP = loader_glGetImageTransformParameterfvHP;
  tbl.glGetImageTransformParameterivHP = loader_glGetImageTransformParameterivHP;
  tbl.glImageTransformParameterfHP = loader_glImageTransformParameterfHP;
  tbl.glImageTransformParameterfvHP = loader_glImageTransformParameterfvHP;
  tbl.glImageTransformParameteriHP = loader_glImageTransformParameteriHP;
  tbl.glImageTransformParameterivHP = loader_glImageTransformParameterivHP;

  // GL_IBM_multimode_draw_arrays

  tbl.glMultiModeDrawArraysIBM = loader_glMultiModeDrawArraysIBM;
  tbl.glMultiModeDrawElementsIBM = loader_glMultiModeDrawElementsIBM;

  // GL_IBM_vertex_array_lists

  tbl.glColorPointerListIBM = loader_glColorPointerListIBM;
  tbl.glEdgeFlagPointerListIBM = loader_glEdgeFlagPointerListIBM;
  tbl.glFogCoordPointerListIBM = loader_glFogCoordPointerListIBM;
  tbl.glIndexPointerListIBM = loader_glIndexPointerListIBM;
  tbl.glNormalPointerListIBM = loader_glNormalPointerListIBM;
  tbl.glSecondaryColorPointerListIBM = loader_glSecondaryColorPointerListIBM;
  tbl.glTexCoordPointerListIBM = loader_glTexCoordPointerListIBM;
  tbl.glVertexPointerListIBM = loader_glVertexPointerListIBM;

  // GL_IMG_multisampled_render_to_texture

  tbl.glFramebufferTexture2DMultisampleIMG = loader_glFramebufferTexture2DMultisampleIMG;
  tbl.glRenderbufferStorageMultisampleIMG = loader_glRenderbufferStorageMultisampleIMG;

  // GL_INGR_blend_func_separate

  tbl.glBlendFuncSeparateINGR = loader_glBlendFuncSeparateINGR;

  // GL_INTEL_parallel_arrays

  tbl.glColorPointervINTEL = loader_glColorPointervINTEL;
  tbl.glNormalPointervINTEL = loader_glNormalPointervINTEL;
  tbl.glTexCoordPointervINTEL = loader_glTexCoordPointervINTEL;
  tbl.glVertexPointervINTEL = loader_glVertexPointervINTEL;

  // GL_INTEL_texture_scissor

  tbl.glTexScissorFuncINTEL = loader_glTexScissorFuncINTEL;
  tbl.glTexScissorINTEL = loader_glTexScissorINTEL;

  // GL_KHR_debug

  tbl.glDebugMessageCallback = loader_glDebugMessageCallback;
  tbl.glDebugMessageControl = loader_glDebugMessageControl;
  tbl.glDebugMessageInsert = loader_glDebugMessageInsert;
  tbl.glGetDebugMessageLog = loader_glGetDebugMessageLog;
  tbl.glGetObjectLabel = loader_glGetObjectLabel;
  tbl.glGetObjectPtrLabel = loader_glGetObjectPtrLabel;
  tbl.glObjectLabel = loader_glObjectLabel;
  tbl.glObjectPtrLabel = loader_glObjectPtrLabel;
  tbl.glPopDebugGroup = loader_glPopDebugGroup;
  tbl.glPushDebugGroup = loader_glPushDebugGroup;

  // GL_KTX_buffer_region

  tbl.glBufferRegionEnabled = loader_glBufferRegionEnabled;
  tbl.glDeleteBufferRegion = loader_glDeleteBufferRegion;
  tbl.glDrawBufferRegion = loader_glDrawBufferRegion;
  tbl.glNewBufferRegion = loader_glNewBufferRegion;
  tbl.glReadBufferRegion = loader_glReadBufferRegion;

  // GL_MESA_resize_buffers

  tbl.glResizeBuffersMESA = loader_glResizeBuffersMESA;

  // GL_MESA_window_pos

  tbl.glWindowPos2dMESA = loader_glWindowPos2dMESA;
  tbl.glWindowPos2dvMESA = loader_glWindowPos2dvMESA;
  tbl.glWindowPos2fMESA = loader_glWindowPos2fMESA;
  tbl.glWindowPos2fvMESA = loader_glWindowPos2fvMESA;
  tbl.glWindowPos2iMESA = loader_glWindowPos2iMESA;
  tbl.glWindowPos2ivMESA = loader_glWindowPos2ivMESA;
  tbl.glWindowPos2sMESA = loader_glWindowPos2sMESA;
  tbl.glWindowPos2svMESA = loader_glWindowPos2svMESA;
  tbl.glWindowPos3dMESA = loader_glWindowPos3dMESA;
  tbl.glWindowPos3dvMESA = loader_glWindowPos3dvMESA;
  tbl.glWindowPos3fMESA = loader_glWindowPos3fMESA;
  tbl.glWindowPos3fvMESA = loader_glWindowPos3fvMESA;
  tbl.glWindowPos3iMESA = loader_glWindowPos3iMESA;
  tbl.glWindowPos3ivMESA = loader_glWindowPos3ivMESA;
  tbl.glWindowPos3sMESA = loader_glWindowPos3sMESA;
  tbl.glWindowPos3svMESA = loader_glWindowPos3svMESA;
  tbl.glWindowPos4dMESA = loader_glWindowPos4dMESA;
  tbl.glWindowPos4dvMESA = loader_glWindowPos4dvMESA;
  tbl.glWindowPos4fMESA = loader_glWindowPos4fMESA;
  tbl.glWindowPos4fvMESA = loader_glWindowPos4fvMESA;
  tbl.glWindowPos4iMESA = loader_glWindowPos4iMESA;
  tbl.glWindowPos4ivMESA = loader_glWindowPos4ivMESA;
  tbl.glWindowPos4sMESA = loader_glWindowPos4sMESA;
  tbl.glWindowPos4svMESA = loader_glWindowPos4svMESA;

  // GL_NVX_conditional_render

  tbl.glBeginConditionalRenderNVX = loader_glBeginConditionalRenderNVX;
  tbl.glEndConditionalRenderNVX = loader_glEndConditionalRenderNVX;

  // GL_NV_bindless_texture

  tbl.glGetImageHandleNV = loader_glGetImageHandleNV;
  tbl.glGetTextureHandleNV = loader_glGetTextureHandleNV;
  tbl.glGetTextureSamplerHandleNV = loader_glGetTextureSamplerHandleNV;
  tbl.glIsImageHandleResidentNV = loader_glIsImageHandleResidentNV;
  tbl.glIsTextureHandleResidentNV = loader_glIsTextureHandleResidentNV;
  tbl.glMakeImageHandleNonResidentNV = loader_glMakeImageHandleNonResidentNV;
  tbl.glMakeImageHandleResidentNV = loader_glMakeImageHandleResidentNV;
  tbl.glMakeTextureHandleNonResidentNV = loader_glMakeTextureHandleNonResidentNV;
  tbl.glMakeTextureHandleResidentNV = loader_glMakeTextureHandleResidentNV;
  tbl.glProgramUniformHandleui64NV = loader_glProgramUniformHandleui64NV;
  tbl.glProgramUniformHandleui64vNV = loader_glProgramUniformHandleui64vNV;
  tbl.glUniformHandleui64NV = loader_glUniformHandleui64NV;
  tbl.glUniformHandleui64vNV = loader_glUniformHandleui64vNV;

  // GL_NV_conditional_render

  tbl.glBeginConditionalRenderNV = loader_glBeginConditionalRenderNV;
  tbl.glEndConditionalRenderNV = loader_glEndConditionalRenderNV;

  // GL_NV_copy_image

  tbl.glCopyImageSubDataNV = loader_glCopyImageSubDataNV;

  // GL_NV_coverage_sample

  tbl.glCoverageMaskNV = loader_glCoverageMaskNV;
  tbl.glCoverageOperationNV = loader_glCoverageOperationNV;

  // GL_NV_depth_buffer_float

  tbl.glClearDepthdNV = loader_glClearDepthdNV;
  tbl.glDepthBoundsdNV = loader_glDepthBoundsdNV;
  tbl.glDepthRangedNV = loader_glDepthRangedNV;

  // GL_NV_draw_buffers

  tbl.glDrawBuffersNV = loader_glDrawBuffersNV;

  // GL_NV_evaluators

  tbl.glEvalMapsNV = loader_glEvalMapsNV;
  tbl.glGetMapAttribParameterfvNV = loader_glGetMapAttribParameterfvNV;
  tbl.glGetMapAttribParameterivNV = loader_glGetMapAttribParameterivNV;
  tbl.glGetMapControlPointsNV = loader_glGetMapControlPointsNV;
  tbl.glGetMapParameterfvNV = loader_glGetMapParameterfvNV;
  tbl.glGetMapParameterivNV = loader_glGetMapParameterivNV;
  tbl.glMapControlPointsNV = loader_glMapControlPointsNV;
  tbl.glMapParameterfvNV = loader_glMapParameterfvNV;
  tbl.glMapParameterivNV = loader_glMapParameterivNV;

  // GL_NV_explicit_multisample

  tbl.glGetMultisamplefvNV = loader_glGetMultisamplefvNV;
  tbl.glSampleMaskIndexedNV = loader_glSampleMaskIndexedNV;
  tbl.glTexRenderbufferNV = loader_glTexRenderbufferNV;

  // GL_NV_fence

  tbl.glDeleteFencesNV = loader_glDeleteFencesNV;
  tbl.glFinishFenceNV = loader_glFinishFenceNV;
  tbl.glGenFencesNV = loader_glGenFencesNV;
  tbl.glGetFenceivNV = loader_glGetFenceivNV;
  tbl.glIsFenceNV = loader_glIsFenceNV;
  tbl.glSetFenceNV = loader_glSetFenceNV;
  tbl.glTestFenceNV = loader_glTestFenceNV;

  // GL_NV_fragment_program

  tbl.glGetProgramNamedParameterdvNV = loader_glGetProgramNamedParameterdvNV;
  tbl.glGetProgramNamedParameterfvNV = loader_glGetProgramNamedParameterfvNV;
  tbl.glProgramNamedParameter4dNV = loader_glProgramNamedParameter4dNV;
  tbl.glProgramNamedParameter4dvNV = loader_glProgramNamedParameter4dvNV;
  tbl.glProgramNamedParameter4fNV = loader_glProgramNamedParameter4fNV;
  tbl.glProgramNamedParameter4fvNV = loader_glProgramNamedParameter4fvNV;

  // GL_NV_framebuffer_multisample_coverage

  tbl.glRenderbufferStorageMultisampleCoverageNV = loader_glRenderbufferStorageMultisampleCoverageNV;

  // GL_NV_geometry_program4

  tbl.glProgramVertexLimitNV = loader_glProgramVertexLimitNV;

  // GL_NV_gpu_program4

  tbl.glGetProgramEnvParameterIivNV = loader_glGetProgramEnvParameterIivNV;
  tbl.glGetProgramEnvParameterIuivNV = loader_glGetProgramEnvParameterIuivNV;
  tbl.glGetProgramLocalParameterIivNV = loader_glGetProgramLocalParameterIivNV;
  tbl.glGetProgramLocalParameterIuivNV = loader_glGetProgramLocalParameterIuivNV;
  tbl.glProgramEnvParameterI4iNV = loader_glProgramEnvParameterI4iNV;
  tbl.glProgramEnvParameterI4ivNV = loader_glProgramEnvParameterI4ivNV;
  tbl.glProgramEnvParameterI4uiNV = loader_glProgramEnvParameterI4uiNV;
  tbl.glProgramEnvParameterI4uivNV = loader_glProgramEnvParameterI4uivNV;
  tbl.glProgramEnvParametersI4ivNV = loader_glProgramEnvParametersI4ivNV;
  tbl.glProgramEnvParametersI4uivNV = loader_glProgramEnvParametersI4uivNV;
  tbl.glProgramLocalParameterI4iNV = loader_glProgramLocalParameterI4iNV;
  tbl.glProgramLocalParameterI4ivNV = loader_glProgramLocalParameterI4ivNV;
  tbl.glProgramLocalParameterI4uiNV = loader_glProgramLocalParameterI4uiNV;
  tbl.glProgramLocalParameterI4uivNV = loader_glProgramLocalParameterI4uivNV;
  tbl.glProgramLocalParametersI4ivNV = loader_glProgramLocalParametersI4ivNV;
  tbl.glProgramLocalParametersI4uivNV = loader_glProgramLocalParametersI4uivNV;

  // GL_NV_gpu_shader5

  tbl.glGetUniformi64vNV = loader_glGetUniformi64vNV;
  tbl.glProgramUniform1i64NV = loader_glProgramUniform1i64NV;
  tbl.glProgramUniform1i64vNV = loader_glProgramUniform1i64vNV;
  tbl.glProgramUniform1ui64NV = loader_glProgramUniform1ui64NV;
  tbl.glProgramUniform1ui64vNV = loader_glProgramUniform1ui64vNV;
  tbl.glProgramUniform2i64NV = loader_glProgramUniform2i64NV;
  tbl.glProgramUniform2i64vNV = loader_glProgramUniform2i64vNV;
  tbl.glProgramUniform2ui64NV = loader_glProgramUniform2ui64NV;
  tbl.glProgramUniform2ui64vNV = loader_glProgramUniform2ui64vNV;
  tbl.glProgramUniform3i64NV = loader_glProgramUniform3i64NV;
  tbl.glProgramUniform3i64vNV = loader_glProgramUniform3i64vNV;
  tbl.glProgramUniform3ui64NV = loader_glProgramUniform3ui64NV;
  tbl.glProgramUniform3ui64vNV = loader_glProgramUniform3ui64vNV;
  tbl.glProgramUniform4i64NV = loader_glProgramUniform4i64NV;
  tbl.glProgramUniform4i64vNV = loader_glProgramUniform4i64vNV;
  tbl.glProgramUniform4ui64NV = loader_glProgramUniform4ui64NV;
  tbl.glProgramUniform4ui64vNV = loader_glProgramUniform4ui64vNV;
  tbl.glUniform1i64NV = loader_glUniform1i64NV;
  tbl.glUniform1i64vNV = loader_glUniform1i64vNV;
  tbl.glUniform1ui64NV = loader_glUniform1ui64NV;
  tbl.glUniform1ui64vNV = loader_glUniform1ui64vNV;
  tbl.glUniform2i64NV = loader_glUniform2i64NV;
  tbl.glUniform2i64vNV = loader_glUniform2i64vNV;
  tbl.glUniform2ui64NV = loader_glUniform2ui64NV;
  tbl.glUniform2ui64vNV = loader_glUniform2ui64vNV;
  tbl.glUniform3i64NV = loader_glUniform3i64NV;
  tbl.glUniform3i64vNV = loader_glUniform3i64vNV;
  tbl.glUniform3ui64NV = loader_glUniform3ui64NV;
  tbl.glUniform3ui64vNV = loader_glUniform3ui64vNV;
  tbl.glUniform4i64NV = loader_glUniform4i64NV;
  tbl.glUniform4i64vNV = loader_glUniform4i64vNV;
  tbl.glUniform4ui64NV = loader_glUniform4ui64NV;
  tbl.glUniform4ui64vNV = loader_glUniform4ui64vNV;

  // GL_NV_half_float

  tbl.glColor3hNV = loader_glColor3hNV;
  tbl.glColor3hvNV = loader_glColor3hvNV;
  tbl.glColor4hNV = loader_glColor4hNV;
  tbl.glColor4hvNV = loader_glColor4hvNV;
  tbl.glFogCoordhNV = loader_glFogCoordhNV;
  tbl.glFogCoordhvNV = loader_glFogCoordhvNV;
  tbl.glMultiTexCoord1hNV = loader_glMultiTexCoord1hNV;
  tbl.glMultiTexCoord1hvNV = loader_glMultiTexCoord1hvNV;
  tbl.glMultiTexCoord2hNV = loader_glMultiTexCoord2hNV;
  tbl.glMultiTexCoord2hvNV = loader_glMultiTexCoord2hvNV;
  tbl.glMultiTexCoord3hNV = loader_glMultiTexCoord3hNV;
  tbl.glMultiTexCoord3hvNV = loader_glMultiTexCoord3hvNV;
  tbl.glMultiTexCoord4hNV = loader_glMultiTexCoord4hNV;
  tbl.glMultiTexCoord4hvNV = loader_glMultiTexCoord4hvNV;
  tbl.glNormal3hNV = loader_glNormal3hNV;
  tbl.glNormal3hvNV = loader_glNormal3hvNV;
  tbl.glSecondaryColor3hNV = loader_glSecondaryColor3hNV;
  tbl.glSecondaryColor3hvNV = loader_glSecondaryColor3hvNV;
  tbl.glTexCoord1hNV = loader_glTexCoord1hNV;
  tbl.glTexCoord1hvNV = loader_glTexCoord1hvNV;
  tbl.glTexCoord2hNV = loader_glTexCoord2hNV;
  tbl.glTexCoord2hvNV = loader_glTexCoord2hvNV;
  tbl.glTexCoord3hNV = loader_glTexCoord3hNV;
  tbl.glTexCoord3hvNV = loader_glTexCoord3hvNV;
  tbl.glTexCoord4hNV = loader_glTexCoord4hNV;
  tbl.glTexCoord4hvNV = loader_glTexCoord4hvNV;
  tbl.glVertex2hNV = loader_glVertex2hNV;
  tbl.glVertex2hvNV = loader_glVertex2hvNV;
  tbl.glVertex3hNV = loader_glVertex3hNV;
  tbl.glVertex3hvNV = loader_glVertex3hvNV;
  tbl.glVertex4hNV = loader_glVertex4hNV;
  tbl.glVertex4hvNV = loader_glVertex4hvNV;
  tbl.glVertexAttrib1hNV = loader_glVertexAttrib1hNV;
  tbl.glVertexAttrib1hvNV = loader_glVertexAttrib1hvNV;
  tbl.glVertexAttrib2hNV = loader_glVertexAttrib2hNV;
  tbl.glVertexAttrib2hvNV = loader_glVertexAttrib2hvNV;
  tbl.glVertexAttrib3hNV = loader_glVertexAttrib3hNV;
  tbl.glVertexAttrib3hvNV = loader_glVertexAttrib3hvNV;
  tbl.glVertexAttrib4hNV = loader_glVertexAttrib4hNV;
  tbl.glVertexAttrib4hvNV = loader_glVertexAttrib4hvNV;
  tbl.glVertexAttribs1hvNV = loader_glVertexAttribs1hvNV;
  tbl.glVertexAttribs2hvNV = loader_glVertexAttribs2hvNV;
  tbl.glVertexAttribs3hvNV = loader_glVertexAttribs3hvNV;
  tbl.glVertexAttribs4hvNV = loader_glVertexAttribs4hvNV;
  tbl.glVertexWeighthNV = loader_glVertexWeighthNV;
  tbl.glVertexWeighthvNV = loader_glVertexWeighthvNV;

  // GL_NV_occlusion_query

  tbl.glBeginOcclusionQueryNV = loader_glBeginOcclusionQueryNV;
  tbl.glDeleteOcclusionQueriesNV = loader_glDeleteOcclusionQueriesNV;
  tbl.glEndOcclusionQueryNV = loader_glEndOcclusionQueryNV;
  tbl.glGenOcclusionQueriesNV = loader_glGenOcclusionQueriesNV;
  tbl.glGetOcclusionQueryivNV = loader_glGetOcclusionQueryivNV;
  tbl.glGetOcclusionQueryuivNV = loader_glGetOcclusionQueryuivNV;
  tbl.glIsOcclusionQueryNV = loader_glIsOcclusionQueryNV;

  // GL_NV_parameter_buffer_object

  tbl.glProgramBufferParametersIivNV = loader_glProgramBufferParametersIivNV;
  tbl.glProgramBufferParametersIuivNV = loader_glProgramBufferParametersIuivNV;
  tbl.glProgramBufferParametersfvNV = loader_glProgramBufferParametersfvNV;

  // GL_NV_path_rendering

  tbl.glCopyPathNV = loader_glCopyPathNV;
  tbl.glCoverFillPathInstancedNV = loader_glCoverFillPathInstancedNV;
  tbl.glCoverFillPathNV = loader_glCoverFillPathNV;
  tbl.glCoverStrokePathInstancedNV = loader_glCoverStrokePathInstancedNV;
  tbl.glCoverStrokePathNV = loader_glCoverStrokePathNV;
  tbl.glDeletePathsNV = loader_glDeletePathsNV;
  tbl.glGenPathsNV = loader_glGenPathsNV;
  tbl.glGetPathColorGenfvNV = loader_glGetPathColorGenfvNV;
  tbl.glGetPathColorGenivNV = loader_glGetPathColorGenivNV;
  tbl.glGetPathCommandsNV = loader_glGetPathCommandsNV;
  tbl.glGetPathCoordsNV = loader_glGetPathCoordsNV;
  tbl.glGetPathDashArrayNV = loader_glGetPathDashArrayNV;
  tbl.glGetPathLengthNV = loader_glGetPathLengthNV;
  tbl.glGetPathMetricRangeNV = loader_glGetPathMetricRangeNV;
  tbl.glGetPathMetricsNV = loader_glGetPathMetricsNV;
  tbl.glGetPathParameterfvNV = loader_glGetPathParameterfvNV;
  tbl.glGetPathParameterivNV = loader_glGetPathParameterivNV;
  tbl.glGetPathSpacingNV = loader_glGetPathSpacingNV;
  tbl.glGetPathTexGenfvNV = loader_glGetPathTexGenfvNV;
  tbl.glGetPathTexGenivNV = loader_glGetPathTexGenivNV;
  tbl.glInterpolatePathsNV = loader_glInterpolatePathsNV;
  tbl.glIsPathNV = loader_glIsPathNV;
  tbl.glIsPointInFillPathNV = loader_glIsPointInFillPathNV;
  tbl.glIsPointInStrokePathNV = loader_glIsPointInStrokePathNV;
  tbl.glPathColorGenNV = loader_glPathColorGenNV;
  tbl.glPathCommandsNV = loader_glPathCommandsNV;
  tbl.glPathCoordsNV = loader_glPathCoordsNV;
  tbl.glPathCoverDepthFuncNV = loader_glPathCoverDepthFuncNV;
  tbl.glPathDashArrayNV = loader_glPathDashArrayNV;
  tbl.glPathFogGenNV = loader_glPathFogGenNV;
  tbl.glPathGlyphRangeNV = loader_glPathGlyphRangeNV;
  tbl.glPathGlyphsNV = loader_glPathGlyphsNV;
  tbl.glPathParameterfNV = loader_glPathParameterfNV;
  tbl.glPathParameterfvNV = loader_glPathParameterfvNV;
  tbl.glPathParameteriNV = loader_glPathParameteriNV;
  tbl.glPathParameterivNV = loader_glPathParameterivNV;
  tbl.glPathStencilDepthOffsetNV = loader_glPathStencilDepthOffsetNV;
  tbl.glPathStencilFuncNV = loader_glPathStencilFuncNV;
  tbl.glPathStringNV = loader_glPathStringNV;
  tbl.glPathSubCommandsNV = loader_glPathSubCommandsNV;
  tbl.glPathSubCoordsNV = loader_glPathSubCoordsNV;
  tbl.glPathTexGenNV = loader_glPathTexGenNV;
  tbl.glPointAlongPathNV = loader_glPointAlongPathNV;
  tbl.glStencilFillPathInstancedNV = loader_glStencilFillPathInstancedNV;
  tbl.glStencilFillPathNV = loader_glStencilFillPathNV;
  tbl.glStencilStrokePathInstancedNV = loader_glStencilStrokePathInstancedNV;
  tbl.glStencilStrokePathNV = loader_glStencilStrokePathNV;
  tbl.glTransformPathNV = loader_glTransformPathNV;
  tbl.glWeightPathsNV = loader_glWeightPathsNV;

  // GL_NV_pixel_data_range

  tbl.glFlushPixelDataRangeNV = loader_glFlushPixelDataRangeNV;
  tbl.glPixelDataRangeNV = loader_glPixelDataRangeNV;

  // GL_NV_point_sprite

  tbl.glPointParameteriNV = loader_glPointParameteriNV;
  tbl.glPointParameterivNV = loader_glPointParameterivNV;

  // GL_NV_present_video

  tbl.glGetVideoi64vNV = loader_glGetVideoi64vNV;
  tbl.glGetVideoivNV = loader_glGetVideoivNV;
  tbl.glGetVideoui64vNV = loader_glGetVideoui64vNV;
  tbl.glGetVideouivNV = loader_glGetVideouivNV;
  tbl.glPresentFrameDualFillNV = loader_glPresentFrameDualFillNV;
  tbl.glPresentFrameKeyedNV = loader_glPresentFrameKeyedNV;

  // GL_NV_primitive_restart

  tbl.glPrimitiveRestartIndexNV = loader_glPrimitiveRestartIndexNV;
  tbl.glPrimitiveRestartNV = loader_glPrimitiveRestartNV;

  // GL_NV_read_buffer

  tbl.glReadBufferNV = loader_glReadBufferNV;

  // GL_NV_register_combiners

  tbl.glCombinerInputNV = loader_glCombinerInputNV;
  tbl.glCombinerOutputNV = loader_glCombinerOutputNV;
  tbl.glCombinerParameterfNV = loader_glCombinerParameterfNV;
  tbl.glCombinerParameterfvNV = loader_glCombinerParameterfvNV;
  tbl.glCombinerParameteriNV = loader_glCombinerParameteriNV;
  tbl.glCombinerParameterivNV = loader_glCombinerParameterivNV;
  tbl.glFinalCombinerInputNV = loader_glFinalCombinerInputNV;
  tbl.glGetCombinerInputParameterfvNV = loader_glGetCombinerInputParameterfvNV;
  tbl.glGetCombinerInputParameterivNV = loader_glGetCombinerInputParameterivNV;
  tbl.glGetCombinerOutputParameterfvNV = loader_glGetCombinerOutputParameterfvNV;
  tbl.glGetCombinerOutputParameterivNV = loader_glGetCombinerOutputParameterivNV;
  tbl.glGetFinalCombinerInputParameterfvNV = loader_glGetFinalCombinerInputParameterfvNV;
  tbl.glGetFinalCombinerInputParameterivNV = loader_glGetFinalCombinerInputParameterivNV;

  // GL_NV_register_combiners2

  tbl.glCombinerStageParameterfvNV = loader_glCombinerStageParameterfvNV;
  tbl.glGetCombinerStageParameterfvNV = loader_glGetCombinerStageParameterfvNV;

  // GL_NV_shader_buffer_load

  tbl.glGetBufferParameterui64vNV = loader_glGetBufferParameterui64vNV;
  tbl.glGetIntegerui64vNV = loader_glGetIntegerui64vNV;
  tbl.glGetNamedBufferParameterui64vNV = loader_glGetNamedBufferParameterui64vNV;
  tbl.glGetUniformui64vNV = loader_glGetUniformui64vNV;
  tbl.glIsBufferResidentNV = loader_glIsBufferResidentNV;
  tbl.glIsNamedBufferResidentNV = loader_glIsNamedBufferResidentNV;
  tbl.glMakeBufferNonResidentNV = loader_glMakeBufferNonResidentNV;
  tbl.glMakeBufferResidentNV = loader_glMakeBufferResidentNV;
  tbl.glMakeNamedBufferNonResidentNV = loader_glMakeNamedBufferNonResidentNV;
  tbl.glMakeNamedBufferResidentNV = loader_glMakeNamedBufferResidentNV;
  tbl.glProgramUniformui64NV = loader_glProgramUniformui64NV;
  tbl.glProgramUniformui64vNV = loader_glProgramUniformui64vNV;
  tbl.glUniformui64NV = loader_glUniformui64NV;
  tbl.glUniformui64vNV = loader_glUniformui64vNV;

  // GL_NV_texture_barrier

  tbl.glTextureBarrierNV = loader_glTextureBarrierNV;

  // GL_NV_texture_multisample

  tbl.glTexImage2DMultisampleCoverageNV = loader_glTexImage2DMultisampleCoverageNV;
  tbl.glTexImage3DMultisampleCoverageNV = loader_glTexImage3DMultisampleCoverageNV;
  tbl.glTextureImage2DMultisampleCoverageNV = loader_glTextureImage2DMultisampleCoverageNV;
  tbl.glTextureImage2DMultisampleNV = loader_glTextureImage2DMultisampleNV;
  tbl.glTextureImage3DMultisampleCoverageNV = loader_glTextureImage3DMultisampleCoverageNV;
  tbl.glTextureImage3DMultisampleNV = loader_glTextureImage3DMultisampleNV;

  // GL_NV_transform_feedback

  tbl.glActiveVaryingNV = loader_glActiveVaryingNV;
  tbl.glBeginTransformFeedbackNV = loader_glBeginTransformFeedbackNV;
  tbl.glBindBufferBaseNV = loader_glBindBufferBaseNV;
  tbl.glBindBufferOffsetNV = loader_glBindBufferOffsetNV;
  tbl.glBindBufferRangeNV = loader_glBindBufferRangeNV;
  tbl.glEndTransformFeedbackNV = loader_glEndTransformFeedbackNV;
  tbl.glGetActiveVaryingNV = loader_glGetActiveVaryingNV;
  tbl.glGetTransformFeedbackVaryingNV = loader_glGetTransformFeedbackVaryingNV;
  tbl.glGetVaryingLocationNV = loader_glGetVaryingLocationNV;
  tbl.glTransformFeedbackAttribsNV = loader_glTransformFeedbackAttribsNV;
  tbl.glTransformFeedbackVaryingsNV = loader_glTransformFeedbackVaryingsNV;

  // GL_NV_transform_feedback2

  tbl.glBindTransformFeedbackNV = loader_glBindTransformFeedbackNV;
  tbl.glDeleteTransformFeedbacksNV = loader_glDeleteTransformFeedbacksNV;
  tbl.glDrawTransformFeedbackNV = loader_glDrawTransformFeedbackNV;
  tbl.glGenTransformFeedbacksNV = loader_glGenTransformFeedbacksNV;
  tbl.glIsTransformFeedbackNV = loader_glIsTransformFeedbackNV;
  tbl.glPauseTransformFeedbackNV = loader_glPauseTransformFeedbackNV;
  tbl.glResumeTransformFeedbackNV = loader_glResumeTransformFeedbackNV;

  // GL_NV_vdpau_interop

  tbl.glVDPAUFiniNV = loader_glVDPAUFiniNV;
  tbl.glVDPAUGetSurfaceivNV = loader_glVDPAUGetSurfaceivNV;
  tbl.glVDPAUInitNV = loader_glVDPAUInitNV;
  tbl.glVDPAUIsSurfaceNV = loader_glVDPAUIsSurfaceNV;
  tbl.glVDPAUMapSurfacesNV = loader_glVDPAUMapSurfacesNV;
  tbl.glVDPAURegisterOutputSurfaceNV = loader_glVDPAURegisterOutputSurfaceNV;
  tbl.glVDPAURegisterVideoSurfaceNV = loader_glVDPAURegisterVideoSurfaceNV;
  tbl.glVDPAUSurfaceAccessNV = loader_glVDPAUSurfaceAccessNV;
  tbl.glVDPAUUnmapSurfacesNV = loader_glVDPAUUnmapSurfacesNV;
  tbl.glVDPAUUnregisterSurfaceNV = loader_glVDPAUUnregisterSurfaceNV;

  // GL_NV_vertex_array_range

  tbl.glFlushVertexArrayRangeNV = loader_glFlushVertexArrayRangeNV;
  tbl.glVertexArrayRangeNV = loader_glVertexArrayRangeNV;

  // GL_NV_vertex_attrib_integer_64bit

  tbl.glGetVertexAttribLi64vNV = loader_glGetVertexAttribLi64vNV;
  tbl.glGetVertexAttribLui64vNV = loader_glGetVertexAttribLui64vNV;
  tbl.glVertexAttribL1i64NV = loader_glVertexAttribL1i64NV;
  tbl.glVertexAttribL1i64vNV = loader_glVertexAttribL1i64vNV;
  tbl.glVertexAttribL1ui64NV = loader_glVertexAttribL1ui64NV;
  tbl.glVertexAttribL1ui64vNV = loader_glVertexAttribL1ui64vNV;
  tbl.glVertexAttribL2i64NV = loader_glVertexAttribL2i64NV;
  tbl.glVertexAttribL2i64vNV = loader_glVertexAttribL2i64vNV;
  tbl.glVertexAttribL2ui64NV = loader_glVertexAttribL2ui64NV;
  tbl.glVertexAttribL2ui64vNV = loader_glVertexAttribL2ui64vNV;
  tbl.glVertexAttribL3i64NV = loader_glVertexAttribL3i64NV;
  tbl.glVertexAttribL3i64vNV = loader_glVertexAttribL3i64vNV;
  tbl.glVertexAttribL3ui64NV = loader_glVertexAttribL3ui64NV;
  tbl.glVertexAttribL3ui64vNV = loader_glVertexAttribL3ui64vNV;
  tbl.glVertexAttribL4i64NV = loader_glVertexAttribL4i64NV;
  tbl.glVertexAttribL4i64vNV = loader_glVertexAttribL4i64vNV;
  tbl.glVertexAttribL4ui64NV = loader_glVertexAttribL4ui64NV;
  tbl.glVertexAttribL4ui64vNV = loader_glVertexAttribL4ui64vNV;
  tbl.glVertexAttribLFormatNV = loader_glVertexAttribLFormatNV;

  // GL_NV_vertex_buffer_unified_memory

  tbl.glBufferAddressRangeNV = loader_glBufferAddressRangeNV;
  tbl.glColorFormatNV = loader_glColorFormatNV;
  tbl.glEdgeFlagFormatNV = loader_glEdgeFlagFormatNV;
  tbl.glFogCoordFormatNV = loader_glFogCoordFormatNV;
  tbl.glGetIntegerui64i_vNV = loader_glGetIntegerui64i_vNV;
  tbl.glIndexFormatNV = loader_glIndexFormatNV;
  tbl.glNormalFormatNV = loader_glNormalFormatNV;
  tbl.glSecondaryColorFormatNV = loader_glSecondaryColorFormatNV;
  tbl.glTexCoordFormatNV = loader_glTexCoordFormatNV;
  tbl.glVertexAttribFormatNV = loader_glVertexAttribFormatNV;
  tbl.glVertexAttribIFormatNV = loader_glVertexAttribIFormatNV;
  tbl.glVertexFormatNV = loader_glVertexFormatNV;

  // GL_NV_vertex_program

  tbl.glAreProgramsResidentNV = loader_glAreProgramsResidentNV;
  tbl.glBindProgramNV = loader_glBindProgramNV;
  tbl.glDeleteProgramsNV = loader_glDeleteProgramsNV;
  tbl.glExecuteProgramNV = loader_glExecuteProgramNV;
  tbl.glGenProgramsNV = loader_glGenProgramsNV;
  tbl.glGetProgramParameterdvNV = loader_glGetProgramParameterdvNV;
  tbl.glGetProgramParameterfvNV = loader_glGetProgramParameterfvNV;
  tbl.glGetProgramStringNV = loader_glGetProgramStringNV;
  tbl.glGetProgramivNV = loader_glGetProgramivNV;
  tbl.glGetTrackMatrixivNV = loader_glGetTrackMatrixivNV;
  tbl.glGetVertexAttribPointervNV = loader_glGetVertexAttribPointervNV;
  tbl.glGetVertexAttribdvNV = loader_glGetVertexAttribdvNV;
  tbl.glGetVertexAttribfvNV = loader_glGetVertexAttribfvNV;
  tbl.glGetVertexAttribivNV = loader_glGetVertexAttribivNV;
  tbl.glIsProgramNV = loader_glIsProgramNV;
  tbl.glLoadProgramNV = loader_glLoadProgramNV;
  tbl.glProgramParameter4dNV = loader_glProgramParameter4dNV;
  tbl.glProgramParameter4dvNV = loader_glProgramParameter4dvNV;
  tbl.glProgramParameter4fNV = loader_glProgramParameter4fNV;
  tbl.glProgramParameter4fvNV = loader_glProgramParameter4fvNV;
  tbl.glProgramParameters4dvNV = loader_glProgramParameters4dvNV;
  tbl.glProgramParameters4fvNV = loader_glProgramParameters4fvNV;
  tbl.glRequestResidentProgramsNV = loader_glRequestResidentProgramsNV;
  tbl.glTrackMatrixNV = loader_glTrackMatrixNV;
  tbl.glVertexAttrib1dNV = loader_glVertexAttrib1dNV;
  tbl.glVertexAttrib1dvNV = loader_glVertexAttrib1dvNV;
  tbl.glVertexAttrib1fNV = loader_glVertexAttrib1fNV;
  tbl.glVertexAttrib1fvNV = loader_glVertexAttrib1fvNV;
  tbl.glVertexAttrib1sNV = loader_glVertexAttrib1sNV;
  tbl.glVertexAttrib1svNV = loader_glVertexAttrib1svNV;
  tbl.glVertexAttrib2dNV = loader_glVertexAttrib2dNV;
  tbl.glVertexAttrib2dvNV = loader_glVertexAttrib2dvNV;
  tbl.glVertexAttrib2fNV = loader_glVertexAttrib2fNV;
  tbl.glVertexAttrib2fvNV = loader_glVertexAttrib2fvNV;
  tbl.glVertexAttrib2sNV = loader_glVertexAttrib2sNV;
  tbl.glVertexAttrib2svNV = loader_glVertexAttrib2svNV;
  tbl.glVertexAttrib3dNV = loader_glVertexAttrib3dNV;
  tbl.glVertexAttrib3dvNV = loader_glVertexAttrib3dvNV;
  tbl.glVertexAttrib3fNV = loader_glVertexAttrib3fNV;
  tbl.glVertexAttrib3fvNV = loader_glVertexAttrib3fvNV;
  tbl.glVertexAttrib3sNV = loader_glVertexAttrib3sNV;
  tbl.glVertexAttrib3svNV = loader_glVertexAttrib3svNV;
  tbl.glVertexAttrib4dNV = loader_glVertexAttrib4dNV;
  tbl.glVertexAttrib4dvNV = loader_glVertexAttrib4dvNV;
  tbl.glVertexAttrib4fNV = loader_glVertexAttrib4fNV;
  tbl.glVertexAttrib4fvNV = loader_glVertexAttrib4fvNV;
  tbl.glVertexAttrib4sNV = loader_glVertexAttrib4sNV;
  tbl.glVertexAttrib4svNV = loader_glVertexAttrib4svNV;
  tbl.glVertexAttrib4ubNV = loader_glVertexAttrib4ubNV;
  tbl.glVertexAttrib4ubvNV = loader_glVertexAttrib4ubvNV;
  tbl.glVertexAttribPointerNV = loader_glVertexAttribPointerNV;
  tbl.glVertexAttribs1dvNV = loader_glVertexAttribs1dvNV;
  tbl.glVertexAttribs1fvNV = loader_glVertexAttribs1fvNV;
  tbl.glVertexAttribs1svNV = loader_glVertexAttribs1svNV;
  tbl.glVertexAttribs2dvNV = loader_glVertexAttribs2dvNV;
  tbl.glVertexAttribs2fvNV = loader_glVertexAttribs2fvNV;
  tbl.glVertexAttribs2svNV = loader_glVertexAttribs2svNV;
  tbl.glVertexAttribs3dvNV = loader_glVertexAttribs3dvNV;
  tbl.glVertexAttribs3fvNV = loader_glVertexAttribs3fvNV;
  tbl.glVertexAttribs3svNV = loader_glVertexAttribs3svNV;
  tbl.glVertexAttribs4dvNV = loader_glVertexAttribs4dvNV;
  tbl.glVertexAttribs4fvNV = loader_glVertexAttribs4fvNV;
  tbl.glVertexAttribs4svNV = loader_glVertexAttribs4svNV;
  tbl.glVertexAttribs4ubvNV = loader_glVertexAttribs4ubvNV;

  // GL_NV_video_capture

  tbl.glBeginVideoCaptureNV = loader_glBeginVideoCaptureNV;
  tbl.glBindVideoCaptureStreamBufferNV = loader_glBindVideoCaptureStreamBufferNV;
  tbl.glBindVideoCaptureStreamTextureNV = loader_glBindVideoCaptureStreamTextureNV;
  tbl.glEndVideoCaptureNV = loader_glEndVideoCaptureNV;
  tbl.glGetVideoCaptureStreamdvNV = loader_glGetVideoCaptureStreamdvNV;
  tbl.glGetVideoCaptureStreamfvNV = loader_glGetVideoCaptureStreamfvNV;
  tbl.glGetVideoCaptureStreamivNV = loader_glGetVideoCaptureStreamivNV;
  tbl.glGetVideoCaptureivNV = loader_glGetVideoCaptureivNV;
  tbl.glVideoCaptureNV = loader_glVideoCaptureNV;
  tbl.glVideoCaptureStreamParameterdvNV = loader_glVideoCaptureStreamParameterdvNV;
  tbl.glVideoCaptureStreamParameterfvNV = loader_glVideoCaptureStreamParameterfvNV;
  tbl.glVideoCaptureStreamParameterivNV = loader_glVideoCaptureStreamParameterivNV;

  // GL_OES_blend_equation_separate

  tbl.glBlendEquationSeparateOES = loader_glBlendEquationSeparateOES;

  // GL_OES_blend_func_separate

  tbl.glBlendFuncSeparateOES = loader_glBlendFuncSeparateOES;

  // GL_OES_blend_subtract

  tbl.glBlendEquationOES = loader_glBlendEquationOES;

  // GL_OES_framebuffer_object

  tbl.glBindFramebufferOES = loader_glBindFramebufferOES;
  tbl.glBindRenderbufferOES = loader_glBindRenderbufferOES;
  tbl.glCheckFramebufferStatusOES = loader_glCheckFramebufferStatusOES;
  tbl.glDeleteFramebuffersOES = loader_glDeleteFramebuffersOES;
  tbl.glDeleteRenderbuffersOES = loader_glDeleteRenderbuffersOES;
  tbl.glFramebufferRenderbufferOES = loader_glFramebufferRenderbufferOES;
  tbl.glFramebufferTexture2DOES = loader_glFramebufferTexture2DOES;
  tbl.glGenFramebuffersOES = loader_glGenFramebuffersOES;
  tbl.glGenRenderbuffersOES = loader_glGenRenderbuffersOES;
  tbl.glGenerateMipmapOES = loader_glGenerateMipmapOES;
  tbl.glGetFramebufferAttachmentParameterivOES = loader_glGetFramebufferAttachmentParameterivOES;
  tbl.glGetRenderbufferParameterivOES = loader_glGetRenderbufferParameterivOES;
  tbl.glIsFramebufferOES = loader_glIsFramebufferOES;
  tbl.glIsRenderbufferOES = loader_glIsRenderbufferOES;
  tbl.glRenderbufferStorageOES = loader_glRenderbufferStorageOES;

  // GL_OES_get_program_binary

  tbl.glGetProgramBinaryOES = loader_glGetProgramBinaryOES;
  tbl.glProgramBinaryOES = loader_glProgramBinaryOES;

  // GL_OES_mapbuffer

  tbl.glGetBufferPointervOES = loader_glGetBufferPointervOES;
  tbl.glMapBufferOES = loader_glMapBufferOES;
  tbl.glUnmapBufferOES = loader_glUnmapBufferOES;

  // GL_OES_matrix_palette

  tbl.glCurrentPaletteMatrixOES = loader_glCurrentPaletteMatrixOES;
  tbl.glMatrixIndexPointerOES = loader_glMatrixIndexPointerOES;
  tbl.glWeightPointerOES = loader_glWeightPointerOES;

  // GL_OES_single_precision

  tbl.glClearDepthfOES = loader_glClearDepthfOES;
  tbl.glClipPlanefOES = loader_glClipPlanefOES;
  tbl.glDepthRangefOES = loader_glDepthRangefOES;
  tbl.glFrustumfOES = loader_glFrustumfOES;
  tbl.glGetClipPlanefOES = loader_glGetClipPlanefOES;
  tbl.glOrthofOES = loader_glOrthofOES;

  // GL_OES_texture_3D

  tbl.glCompressedTexImage3DOES = loader_glCompressedTexImage3DOES;
  tbl.glCompressedTexSubImage3DOES = loader_glCompressedTexSubImage3DOES;
  tbl.glCopyTexSubImage3DOES = loader_glCopyTexSubImage3DOES;
  tbl.glFramebufferTexture3DOES = loader_glFramebufferTexture3DOES;
  tbl.glTexImage3DOES = loader_glTexImage3DOES;
  tbl.glTexSubImage3DOES = loader_glTexSubImage3DOES;

  // GL_OES_texture_cube_map

  tbl.glGetTexGenfvOES = loader_glGetTexGenfvOES;
  tbl.glGetTexGenivOES = loader_glGetTexGenivOES;
  tbl.glGetTexGenxvOES = loader_glGetTexGenxvOES;
  tbl.glTexGenfOES = loader_glTexGenfOES;
  tbl.glTexGenfvOES = loader_glTexGenfvOES;
  tbl.glTexGeniOES = loader_glTexGeniOES;
  tbl.glTexGenivOES = loader_glTexGenivOES;
  tbl.glTexGenxOES = loader_glTexGenxOES;
  tbl.glTexGenxvOES = loader_glTexGenxvOES;

  // GL_OES_vertex_array_object

  tbl.glBindVertexArrayOES = loader_glBindVertexArrayOES;
  tbl.glDeleteVertexArraysOES = loader_glDeleteVertexArraysOES;
  tbl.glGenVertexArraysOES = loader_glGenVertexArraysOES;
  tbl.glIsVertexArrayOES = loader_glIsVertexArrayOES;

  // GL_PGI_misc_hints

  tbl.glHintPGI = loader_glHintPGI;

  // GL_QCOM_alpha_test

  tbl.glAlphaFuncQCOM = loader_glAlphaFuncQCOM;

  // GL_QCOM_driver_control

  tbl.glDisableDriverControlQCOM = loader_glDisableDriverControlQCOM;
  tbl.glEnableDriverControlQCOM = loader_glEnableDriverControlQCOM;
  tbl.glGetDriverControlStringQCOM = loader_glGetDriverControlStringQCOM;
  tbl.glGetDriverControlsQCOM = loader_glGetDriverControlsQCOM;

  // GL_QCOM_extended_get

  tbl.glExtGetBufferPointervQCOM = loader_glExtGetBufferPointervQCOM;
  tbl.glExtGetBuffersQCOM = loader_glExtGetBuffersQCOM;
  tbl.glExtGetFramebuffersQCOM = loader_glExtGetFramebuffersQCOM;
  tbl.glExtGetRenderbuffersQCOM = loader_glExtGetRenderbuffersQCOM;
  tbl.glExtGetTexLevelParameterivQCOM = loader_glExtGetTexLevelParameterivQCOM;
  tbl.glExtGetTexSubImageQCOM = loader_glExtGetTexSubImageQCOM;
  tbl.glExtGetTexturesQCOM = loader_glExtGetTexturesQCOM;
  tbl.glExtTexObjectStateOverrideiQCOM = loader_glExtTexObjectStateOverrideiQCOM;

  // GL_QCOM_extended_get2

  tbl.glExtGetProgramBinarySourceQCOM = loader_glExtGetProgramBinarySourceQCOM;
  tbl.glExtGetProgramsQCOM = loader_glExtGetProgramsQCOM;
  tbl.glExtGetShadersQCOM = loader_glExtGetShadersQCOM;
  tbl.glExtIsProgramBinaryQCOM = loader_glExtIsProgramBinaryQCOM;

  // GL_QCOM_tiled_rendering

  tbl.glEndTilingQCOM = loader_glEndTilingQCOM;
  tbl.glStartTilingQCOM = loader_glStartTilingQCOM;

  // GL_REGAL_ES1_1_compatibility

  tbl.glPointSizePointerOES = loader_glPointSizePointerOES;

  // GL_REGAL_log

  tbl.glLogMessageCallbackREGAL = loader_glLogMessageCallbackREGAL;

  // GL_SGIS_detail_texture

  tbl.glDetailTexFuncSGIS = loader_glDetailTexFuncSGIS;
  tbl.glGetDetailTexFuncSGIS = loader_glGetDetailTexFuncSGIS;

  // GL_SGIS_fog_function

  tbl.glFogFuncSGIS = loader_glFogFuncSGIS;
  tbl.glGetFogFuncSGIS = loader_glGetFogFuncSGIS;

  // GL_SGIS_multisample

  tbl.glSampleMaskSGIS = loader_glSampleMaskSGIS;
  tbl.glSamplePatternSGIS = loader_glSamplePatternSGIS;

  // GL_SGIS_pixel_texture

  tbl.glGetPixelTexGenParameterfvSGIS = loader_glGetPixelTexGenParameterfvSGIS;
  tbl.glGetPixelTexGenParameterivSGIS = loader_glGetPixelTexGenParameterivSGIS;
  tbl.glPixelTexGenParameterfSGIS = loader_glPixelTexGenParameterfSGIS;
  tbl.glPixelTexGenParameterfvSGIS = loader_glPixelTexGenParameterfvSGIS;
  tbl.glPixelTexGenParameteriSGIS = loader_glPixelTexGenParameteriSGIS;
  tbl.glPixelTexGenParameterivSGIS = loader_glPixelTexGenParameterivSGIS;

  // GL_SGIS_point_parameters

  tbl.glPointParameterfSGIS = loader_glPointParameterfSGIS;
  tbl.glPointParameterfvSGIS = loader_glPointParameterfvSGIS;

  // GL_SGIS_sharpen_texture

  tbl.glGetSharpenTexFuncSGIS = loader_glGetSharpenTexFuncSGIS;
  tbl.glSharpenTexFuncSGIS = loader_glSharpenTexFuncSGIS;

  // GL_SGIS_texture4D

  tbl.glTexImage4DSGIS = loader_glTexImage4DSGIS;
  tbl.glTexSubImage4DSGIS = loader_glTexSubImage4DSGIS;

  // GL_SGIS_texture_color_mask

  tbl.glTextureColorMaskSGIS = loader_glTextureColorMaskSGIS;

  // GL_SGIS_texture_filter4

  tbl.glGetTexFilterFuncSGIS = loader_glGetTexFilterFuncSGIS;
  tbl.glTexFilterFuncSGIS = loader_glTexFilterFuncSGIS;

  // GL_SGIX_async

  tbl.glAsyncMarkerSGIX = loader_glAsyncMarkerSGIX;
  tbl.glDeleteAsyncMarkersSGIX = loader_glDeleteAsyncMarkersSGIX;
  tbl.glFinishAsyncSGIX = loader_glFinishAsyncSGIX;
  tbl.glGenAsyncMarkersSGIX = loader_glGenAsyncMarkersSGIX;
  tbl.glIsAsyncMarkerSGIX = loader_glIsAsyncMarkerSGIX;
  tbl.glPollAsyncSGIX = loader_glPollAsyncSGIX;

  // GL_SGIX_flush_raster

  tbl.glFlushRasterSGIX = loader_glFlushRasterSGIX;

  // GL_SGIX_fog_texture

  tbl.glTextureFogSGIX = loader_glTextureFogSGIX;

  // GL_SGIX_fragment_lighting

  tbl.glFragmentColorMaterialSGIX = loader_glFragmentColorMaterialSGIX;
  tbl.glFragmentLightModelfSGIX = loader_glFragmentLightModelfSGIX;
  tbl.glFragmentLightModelfvSGIX = loader_glFragmentLightModelfvSGIX;
  tbl.glFragmentLightModeliSGIX = loader_glFragmentLightModeliSGIX;
  tbl.glFragmentLightModelivSGIX = loader_glFragmentLightModelivSGIX;
  tbl.glFragmentLightfSGIX = loader_glFragmentLightfSGIX;
  tbl.glFragmentLightfvSGIX = loader_glFragmentLightfvSGIX;
  tbl.glFragmentLightiSGIX = loader_glFragmentLightiSGIX;
  tbl.glFragmentLightivSGIX = loader_glFragmentLightivSGIX;
  tbl.glFragmentMaterialfSGIX = loader_glFragmentMaterialfSGIX;
  tbl.glFragmentMaterialfvSGIX = loader_glFragmentMaterialfvSGIX;
  tbl.glFragmentMaterialiSGIX = loader_glFragmentMaterialiSGIX;
  tbl.glFragmentMaterialivSGIX = loader_glFragmentMaterialivSGIX;
  tbl.glGetFragmentLightfvSGIX = loader_glGetFragmentLightfvSGIX;
  tbl.glGetFragmentLightivSGIX = loader_glGetFragmentLightivSGIX;
  tbl.glGetFragmentMaterialfvSGIX = loader_glGetFragmentMaterialfvSGIX;
  tbl.glGetFragmentMaterialivSGIX = loader_glGetFragmentMaterialivSGIX;
  tbl.glLightEnviSGIX = loader_glLightEnviSGIX;

  // GL_SGIX_framezoom

  tbl.glFrameZoomSGIX = loader_glFrameZoomSGIX;

  // GL_SGIX_igloo_interface

  tbl.glIglooInterfaceSGIX = loader_glIglooInterfaceSGIX;

  // GL_SGIX_instruments

  tbl.glGetInstrumentsSGIX = loader_glGetInstrumentsSGIX;
  tbl.glInstrumentsBufferSGIX = loader_glInstrumentsBufferSGIX;
  tbl.glPollInstrumentsSGIX = loader_glPollInstrumentsSGIX;
  tbl.glReadInstrumentsSGIX = loader_glReadInstrumentsSGIX;
  tbl.glStartInstrumentsSGIX = loader_glStartInstrumentsSGIX;
  tbl.glStopInstrumentsSGIX = loader_glStopInstrumentsSGIX;

  // GL_SGIX_list_priority

  tbl.glGetListParameterfvSGIX = loader_glGetListParameterfvSGIX;
  tbl.glGetListParameterivSGIX = loader_glGetListParameterivSGIX;
  tbl.glListParameterfSGIX = loader_glListParameterfSGIX;
  tbl.glListParameterfvSGIX = loader_glListParameterfvSGIX;
  tbl.glListParameteriSGIX = loader_glListParameteriSGIX;
  tbl.glListParameterivSGIX = loader_glListParameterivSGIX;

  // GL_SGIX_pixel_texture

  tbl.glPixelTexGenSGIX = loader_glPixelTexGenSGIX;

  // GL_SGIX_polynomial_ffd

  tbl.glDeformSGIX = loader_glDeformSGIX;
  tbl.glDeformationMap3dSGIX = loader_glDeformationMap3dSGIX;
  tbl.glDeformationMap3fSGIX = loader_glDeformationMap3fSGIX;
  tbl.glLoadIdentityDeformationMapSGIX = loader_glLoadIdentityDeformationMapSGIX;

  // GL_SGIX_reference_plane

  tbl.glReferencePlaneSGIX = loader_glReferencePlaneSGIX;

  // GL_SGIX_sprite

  tbl.glSpriteParameterfSGIX = loader_glSpriteParameterfSGIX;
  tbl.glSpriteParameterfvSGIX = loader_glSpriteParameterfvSGIX;
  tbl.glSpriteParameteriSGIX = loader_glSpriteParameteriSGIX;
  tbl.glSpriteParameterivSGIX = loader_glSpriteParameterivSGIX;

  // GL_SGIX_tag_sample_buffer

  tbl.glTagSampleBufferSGIX = loader_glTagSampleBufferSGIX;

  // GL_SGI_color_table

  tbl.glColorTableParameterfvSGI = loader_glColorTableParameterfvSGI;
  tbl.glColorTableParameterivSGI = loader_glColorTableParameterivSGI;
  tbl.glColorTableSGI = loader_glColorTableSGI;
  tbl.glCopyColorTableSGI = loader_glCopyColorTableSGI;
  tbl.glGetColorTableParameterfvSGI = loader_glGetColorTableParameterfvSGI;
  tbl.glGetColorTableParameterivSGI = loader_glGetColorTableParameterivSGI;
  tbl.glGetColorTableSGI = loader_glGetColorTableSGI;

  // GL_SUNX_constant_data

  tbl.glFinishTextureSUNX = loader_glFinishTextureSUNX;

  // GL_SUN_global_alpha

  tbl.glGlobalAlphaFactorbSUN = loader_glGlobalAlphaFactorbSUN;
  tbl.glGlobalAlphaFactordSUN = loader_glGlobalAlphaFactordSUN;
  tbl.glGlobalAlphaFactorfSUN = loader_glGlobalAlphaFactorfSUN;
  tbl.glGlobalAlphaFactoriSUN = loader_glGlobalAlphaFactoriSUN;
  tbl.glGlobalAlphaFactorsSUN = loader_glGlobalAlphaFactorsSUN;
  tbl.glGlobalAlphaFactorubSUN = loader_glGlobalAlphaFactorubSUN;
  tbl.glGlobalAlphaFactoruiSUN = loader_glGlobalAlphaFactoruiSUN;
  tbl.glGlobalAlphaFactorusSUN = loader_glGlobalAlphaFactorusSUN;

  // GL_SUN_mesh_array

  tbl.glDrawMeshArraysSUN = loader_glDrawMeshArraysSUN;

  // GL_SUN_read_video_pixels

  tbl.glReadVideoPixelsSUN = loader_glReadVideoPixelsSUN;

  // GL_SUN_triangle_list

  tbl.glReplacementCodePointerSUN = loader_glReplacementCodePointerSUN;
  tbl.glReplacementCodeubSUN = loader_glReplacementCodeubSUN;
  tbl.glReplacementCodeubvSUN = loader_glReplacementCodeubvSUN;
  tbl.glReplacementCodeuiSUN = loader_glReplacementCodeuiSUN;
  tbl.glReplacementCodeuivSUN = loader_glReplacementCodeuivSUN;
  tbl.glReplacementCodeusSUN = loader_glReplacementCodeusSUN;
  tbl.glReplacementCodeusvSUN = loader_glReplacementCodeusvSUN;

  // GL_SUN_vertex

  tbl.glColor3fVertex3fSUN = loader_glColor3fVertex3fSUN;
  tbl.glColor3fVertex3fvSUN = loader_glColor3fVertex3fvSUN;
  tbl.glColor4fNormal3fVertex3fSUN = loader_glColor4fNormal3fVertex3fSUN;
  tbl.glColor4fNormal3fVertex3fvSUN = loader_glColor4fNormal3fVertex3fvSUN;
  tbl.glColor4ubVertex2fSUN = loader_glColor4ubVertex2fSUN;
  tbl.glColor4ubVertex2fvSUN = loader_glColor4ubVertex2fvSUN;
  tbl.glColor4ubVertex3fSUN = loader_glColor4ubVertex3fSUN;
  tbl.glColor4ubVertex3fvSUN = loader_glColor4ubVertex3fvSUN;
  tbl.glNormal3fVertex3fSUN = loader_glNormal3fVertex3fSUN;
  tbl.glNormal3fVertex3fvSUN = loader_glNormal3fVertex3fvSUN;
  tbl.glReplacementCodeuiColor3fVertex3fSUN = loader_glReplacementCodeuiColor3fVertex3fSUN;
  tbl.glReplacementCodeuiColor3fVertex3fvSUN = loader_glReplacementCodeuiColor3fVertex3fvSUN;
  tbl.glReplacementCodeuiColor4fNormal3fVertex3fSUN = loader_glReplacementCodeuiColor4fNormal3fVertex3fSUN;
  tbl.glReplacementCodeuiColor4fNormal3fVertex3fvSUN = loader_glReplacementCodeuiColor4fNormal3fVertex3fvSUN;
  tbl.glReplacementCodeuiColor4ubVertex3fSUN = loader_glReplacementCodeuiColor4ubVertex3fSUN;
  tbl.glReplacementCodeuiColor4ubVertex3fvSUN = loader_glReplacementCodeuiColor4ubVertex3fvSUN;
  tbl.glReplacementCodeuiNormal3fVertex3fSUN = loader_glReplacementCodeuiNormal3fVertex3fSUN;
  tbl.glReplacementCodeuiNormal3fVertex3fvSUN = loader_glReplacementCodeuiNormal3fVertex3fvSUN;
  tbl.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN = loader_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN;
  tbl.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN = loader_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN;
  tbl.glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN = loader_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN;
  tbl.glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN = loader_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN;
  tbl.glReplacementCodeuiTexCoord2fVertex3fSUN = loader_glReplacementCodeuiTexCoord2fVertex3fSUN;
  tbl.glReplacementCodeuiTexCoord2fVertex3fvSUN = loader_glReplacementCodeuiTexCoord2fVertex3fvSUN;
  tbl.glReplacementCodeuiVertex3fSUN = loader_glReplacementCodeuiVertex3fSUN;
  tbl.glReplacementCodeuiVertex3fvSUN = loader_glReplacementCodeuiVertex3fvSUN;
  tbl.glTexCoord2fColor3fVertex3fSUN = loader_glTexCoord2fColor3fVertex3fSUN;
  tbl.glTexCoord2fColor3fVertex3fvSUN = loader_glTexCoord2fColor3fVertex3fvSUN;
  tbl.glTexCoord2fColor4fNormal3fVertex3fSUN = loader_glTexCoord2fColor4fNormal3fVertex3fSUN;
  tbl.glTexCoord2fColor4fNormal3fVertex3fvSUN = loader_glTexCoord2fColor4fNormal3fVertex3fvSUN;
  tbl.glTexCoord2fColor4ubVertex3fSUN = loader_glTexCoord2fColor4ubVertex3fSUN;
  tbl.glTexCoord2fColor4ubVertex3fvSUN = loader_glTexCoord2fColor4ubVertex3fvSUN;
  tbl.glTexCoord2fNormal3fVertex3fSUN = loader_glTexCoord2fNormal3fVertex3fSUN;
  tbl.glTexCoord2fNormal3fVertex3fvSUN = loader_glTexCoord2fNormal3fVertex3fvSUN;
  tbl.glTexCoord2fVertex3fSUN = loader_glTexCoord2fVertex3fSUN;
  tbl.glTexCoord2fVertex3fvSUN = loader_glTexCoord2fVertex3fvSUN;
  tbl.glTexCoord4fColor4fNormal3fVertex4fSUN = loader_glTexCoord4fColor4fNormal3fVertex4fSUN;
  tbl.glTexCoord4fColor4fNormal3fVertex4fvSUN = loader_glTexCoord4fColor4fNormal3fVertex4fvSUN;
  tbl.glTexCoord4fVertex4fSUN = loader_glTexCoord4fVertex4fSUN;
  tbl.glTexCoord4fVertex4fvSUN = loader_glTexCoord4fVertex4fvSUN;

  // GL_WIN_swap_hint

  tbl.glAddSwapHintRectWIN = loader_glAddSwapHintRectWIN;

}

REGAL_NAMESPACE_END

#endif
