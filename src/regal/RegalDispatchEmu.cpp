/* NOTE: Do not edit this file, it is generated by a script:
   Export.py --api gl 4.4 --api wgl 4.4 --api glx 4.4 --api cgl 1.4 --api egl 1.0 --outdir .
*/

/*
  Copyright (c) 2011-2013 NVIDIA Corporation
  Copyright (c) 2011-2013 Cass Everitt
  Copyright (c) 2012-2013 Scott Nations
  Copyright (c) 2012 Mathias Schott
  Copyright (c) 2012-2013 Nigel Stewart
  Copyright (c) 2012-2013 Google Inc.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without modification,
  are permitted provided that the following conditions are met:

    Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.

    Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
  OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
  Intended formatting conventions:
  $ astyle --style=allman --indent=spaces=2 --indent-switches
*/

#include "pch.h" /* For MS precompiled header support */

#include "RegalUtil.h"

#if REGAL_EMULATION

REGAL_GLOBAL_BEGIN

#include <string>
using namespace std;

#include "RegalLog.h"
#include "RegalBreak.h"
#include "RegalPush.h"
#include "RegalToken.h"
#include "RegalHelper.h"
#include "RegalPrivate.h"
#include "RegalContext.h"

#include "RegalBreak.h"
#include "RegalBin.h"
#include "RegalTexSto.h"
#include "RegalXfer.h"
#include "RegalEmu.h"
#include "RegalPpa.h"
#include "RegalPpca.h"
#include "RegalRect.h"
#include "RegalHint.h"
#include "RegalIff.h"
#include "RegalQuads.h"
#include "RegalMarker.h"
#include "RegalObj.h"
#include "RegalDsa.h"
#include "RegalSo.h"
#include "RegalTexC.h"
#include "RegalVao.h"
#include "RegalBaseVertex.h"
#include "RegalFilt.h"

REGAL_GLOBAL_END

REGAL_NAMESPACE_BEGIN

using namespace ::REGAL_NAMESPACE_INTERNAL::Logging;
using namespace ::REGAL_NAMESPACE_INTERNAL::Token;

// GL_VERSION_1_0

static void REGAL_CALL emu_glAccum(GLenum op, GLfloat value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glAccum for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glAccum)(op, value);
      break;
    }

  }

}

static void REGAL_CALL emu_glAlphaFunc(GLenum func, GLclampf ref)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glAlphaFunc( func, ref );
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AlphaFunc( func, ref );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glAlphaFunc)(func, ref);
      break;
    }

  }

}

static void REGAL_CALL emu_glBegin(GLenum mode)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->Restore( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Begin( _context, mode );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glBegin)(mode);
      break;
    }

  }

}

static void REGAL_CALL emu_glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glBitmap for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glBitmap)(width, height, xorig, yorig, xmove, ymove, bitmap);
      break;
    }

  }

}

static void REGAL_CALL emu_glBlendFunc(GLenum sfactor, GLenum dfactor)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glBlendFunc( sfactor, dfactor );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glBlendFunc)(sfactor, dfactor);
}

static void REGAL_CALL emu_glCallList(GLuint list)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glCallList for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glCallList)(list);
      break;
    }

  }

}

static void REGAL_CALL emu_glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glClearAccum( red, green, blue, alpha );
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glClearAccum for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glClearAccum)(red, green, blue, alpha);
      break;
    }

  }

}

static void REGAL_CALL emu_glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glClearColor( red, green, blue, alpha );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glClearColor)(red, green, blue, alpha);
}

static void REGAL_CALL emu_glClearDepth(GLclampd depth)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glClearDepth( depth );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  if (_context->isES2())
    _next->call(& _next->glClearDepthf)((GLclampf)depth);
   else
     _next->call(& _next->glClearDepth)(depth);
}

static void REGAL_CALL emu_glClearIndex(GLfloat c)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glClearIndex( c );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glClearIndex)(c);
}

static void REGAL_CALL emu_glClearStencil(GLint s)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glClearStencil( s );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glClearStencil)(s);
}

static void REGAL_CALL emu_glClipPlane(GLenum plane, const GLdouble *equation)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glClipPlane( plane, equation );
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->ClipPlane( plane, equation );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glClipPlane)(plane, equation);
      break;
    }

  }

}

static void REGAL_CALL emu_glColor3b(GLbyte red, GLbyte green, GLbyte blue)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<3>( _context, _context->iff->AttrIndex( RFF2A_Color ), red, green, blue );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glColor3b)(red, green, blue);
      break;
    }

  }

}

static void REGAL_CALL emu_glColor3bv(const GLbyte *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<3>( _context, _context->iff->AttrIndex( RFF2A_Color ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glColor3bv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glColor3d(GLdouble red, GLdouble green, GLdouble blue)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, _context->iff->AttrIndex( RFF2A_Color ), red, green, blue );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glColor3d)(red, green, blue);
      break;
    }

  }

}

static void REGAL_CALL emu_glColor3dv(const GLdouble *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, _context->iff->AttrIndex( RFF2A_Color ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glColor3dv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glColor3f(GLfloat red, GLfloat green, GLfloat blue)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, _context->iff->AttrIndex( RFF2A_Color ), red, green, blue );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glColor3f)(red, green, blue);
      break;
    }

  }

}

static void REGAL_CALL emu_glColor3fv(const GLfloat *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, _context->iff->AttrIndex( RFF2A_Color ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glColor3fv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glColor3i(GLint red, GLint green, GLint blue)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<3>( _context, _context->iff->AttrIndex( RFF2A_Color ), red, green, blue );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glColor3i)(red, green, blue);
      break;
    }

  }

}

static void REGAL_CALL emu_glColor3iv(const GLint *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<3>( _context, _context->iff->AttrIndex( RFF2A_Color ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glColor3iv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glColor3s(GLshort red, GLshort green, GLshort blue)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<3>( _context, _context->iff->AttrIndex( RFF2A_Color ), red, green, blue );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glColor3s)(red, green, blue);
      break;
    }

  }

}

static void REGAL_CALL emu_glColor3sv(const GLshort *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<3>( _context, _context->iff->AttrIndex( RFF2A_Color ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glColor3sv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glColor3ub(GLubyte red, GLubyte green, GLubyte blue)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<3>( _context, _context->iff->AttrIndex( RFF2A_Color ), red, green, blue );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glColor3ub)(red, green, blue);
      break;
    }

  }

}

static void REGAL_CALL emu_glColor3ubv(const GLubyte *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<3>( _context, _context->iff->AttrIndex( RFF2A_Color ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glColor3ubv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glColor3ui(GLuint red, GLuint green, GLuint blue)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<3>( _context, _context->iff->AttrIndex( RFF2A_Color ), red, green, blue );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glColor3ui)(red, green, blue);
      break;
    }

  }

}

static void REGAL_CALL emu_glColor3uiv(const GLuint *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<3>( _context, _context->iff->AttrIndex( RFF2A_Color ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glColor3uiv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glColor3us(GLushort red, GLushort green, GLushort blue)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<3>( _context, _context->iff->AttrIndex( RFF2A_Color ), red, green, blue );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glColor3us)(red, green, blue);
      break;
    }

  }

}

static void REGAL_CALL emu_glColor3usv(const GLushort *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<3>( _context, _context->iff->AttrIndex( RFF2A_Color ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glColor3usv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<4>( _context, _context->iff->AttrIndex( RFF2A_Color ), red, green, blue, alpha );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glColor4b)(red, green, blue, alpha);
      break;
    }

  }

}

static void REGAL_CALL emu_glColor4bv(const GLbyte *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<4>( _context, _context->iff->AttrIndex( RFF2A_Color ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glColor4bv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, _context->iff->AttrIndex( RFF2A_Color ), red, green, blue, alpha );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glColor4d)(red, green, blue, alpha);
      break;
    }

  }

}

static void REGAL_CALL emu_glColor4dv(const GLdouble *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, _context->iff->AttrIndex( RFF2A_Color ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glColor4dv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, _context->iff->AttrIndex( RFF2A_Color ), red, green, blue, alpha );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glColor4f)(red, green, blue, alpha);
      break;
    }

  }

}

static void REGAL_CALL emu_glColor4fv(const GLfloat *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, _context->iff->AttrIndex( RFF2A_Color ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glColor4fv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glColor4i(GLint red, GLint green, GLint blue, GLint alpha)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<4>( _context, _context->iff->AttrIndex( RFF2A_Color ), red, green, blue, alpha );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glColor4i)(red, green, blue, alpha);
      break;
    }

  }

}

static void REGAL_CALL emu_glColor4iv(const GLint *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<4>( _context, _context->iff->AttrIndex( RFF2A_Color ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glColor4iv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<4>( _context, _context->iff->AttrIndex( RFF2A_Color ), red, green, blue, alpha );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glColor4s)(red, green, blue, alpha);
      break;
    }

  }

}

static void REGAL_CALL emu_glColor4sv(const GLshort *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<4>( _context, _context->iff->AttrIndex( RFF2A_Color ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glColor4sv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<4>( _context, _context->iff->AttrIndex( RFF2A_Color ), red, green, blue, alpha );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glColor4ub)(red, green, blue, alpha);
      break;
    }

  }

}

static void REGAL_CALL emu_glColor4ubv(const GLubyte *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<4>( _context, _context->iff->AttrIndex( RFF2A_Color ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glColor4ubv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<4>( _context, _context->iff->AttrIndex( RFF2A_Color ), red, green, blue, alpha );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glColor4ui)(red, green, blue, alpha);
      break;
    }

  }

}

static void REGAL_CALL emu_glColor4uiv(const GLuint *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<4>( _context, _context->iff->AttrIndex( RFF2A_Color ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glColor4uiv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<4>( _context, _context->iff->AttrIndex( RFF2A_Color ), red, green, blue, alpha );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glColor4us)(red, green, blue, alpha);
      break;
    }

  }

}

static void REGAL_CALL emu_glColor4usv(const GLushort *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<4>( _context, _context->iff->AttrIndex( RFF2A_Color ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glColor4usv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glColorMask( red, green, blue, alpha );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glColorMask)(red, green, blue, alpha);
}

static void REGAL_CALL emu_glColorMaterial(GLenum face, GLenum mode)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glColorMaterial( face, mode );
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->ColorMaterial( face, mode );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glColorMaterial)(face, mode);
      break;
    }

  }

}

static void REGAL_CALL emu_glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glCopyPixels for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glCopyPixels)(x, y, width, height, type);
      break;
    }

  }

}

static void REGAL_CALL emu_glCullFace(GLenum mode)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glCullFace( mode );
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
      #if REGAL_EMU_QUADS
      if (_context->quads)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 5;
        _context->quads->glCullFace( mode );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glCullFace)(mode);
}

static void REGAL_CALL emu_glDeleteLists(GLuint list, GLsizei range)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glDeleteLists for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glDeleteLists)(list, range);
      break;
    }

  }

}

static void REGAL_CALL emu_glDepthFunc(GLenum func)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glDepthFunc( func );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glDepthFunc)(func);
}

static void REGAL_CALL emu_glDepthMask(GLboolean flag)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glDepthMask( flag );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glDepthMask)(flag);
}

static void REGAL_CALL emu_glDepthRange(GLclampd zNear, GLclampd zFar)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glDepthRange( zNear, zFar );
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->DepthRange( GLfloat(zNear), GLfloat(zFar) );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  if (_context->isES2())
    _next->call(& _next->glDepthRangef)((GLclampf)zNear,(GLclampf)zFar);
   else
     _next->call(& _next->glDepthRange)(zNear, zFar);
}

static void REGAL_CALL emu_glDisable(GLenum cap)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa) break;
      #endif
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glDisable( cap );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glDisable( cap );
      }
      #endif
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
      #if REGAL_EMU_QUADS
      if (_context->quads)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 5;
        _context->quads->glDisable( cap );
      }
      #endif
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreActiveTexture( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        if( ! _context->ppa->Disable( _context, cap ) ) {
          _context->dispatcher.emulation.glDisable( cap );
        }
        return;
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        if( ! _context->iff->ShadowDisable( cap ) ) {
            _context->dispatcher.emulation.glDisable( cap );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
       if (_context->isES2())
         switch (cap)
         {
           case GL_BLEND:
           case GL_CULL_FACE:
           case GL_DEPTH_TEST:
           case GL_DITHER:
           case GL_FRAMEBUFFER_SRGB:
           case GL_POLYGON_OFFSET_FILL:
           case GL_SAMPLE_ALPHA_TO_COVERAGE:
           case GL_SAMPLE_COVERAGE:
           case GL_SCISSOR_TEST:
           case GL_STENCIL_TEST:
           case GL_TEXTURE_2D:
             break;
           default:
             Warning("glDisable does not support ",GLenumToString(cap)," for ES 2.0.");
             return;
         }
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glDisable)(cap);
      break;
    }

  }

}

static void REGAL_CALL emu_glDrawBuffer(GLenum mode)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa) break;
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        if( !_context->isES2() ) {
          _context->ppa->glDrawBuffer( mode );
          _context->dispatcher.emulation.glDrawBuffer( mode );
        }
        return;
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2())
        {
          DispatchTableGL *_next = _context->dispatcher.emulation.next();
          RegalAssert(_next);
          if (_context->info->gl_nv_framebuffer_blit || _context->info->gl_ext_framebuffer_blit)
            return _next->call(&_next->glDrawBuffer)(mode);
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glDrawBuffer)(mode);
      break;
    }

  }

}

static void REGAL_CALL emu_glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glDrawPixels for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glDrawPixels)(width, height, format, type, pixels);
      break;
    }

  }

}

static void REGAL_CALL emu_glEdgeFlag(GLboolean flag)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glEdgeFlag for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glEdgeFlag)(flag);
      break;
    }

  }

}

static void REGAL_CALL emu_glEnable(GLenum cap)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa) break;
      #endif
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glEnable( cap );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glEnable( cap );
      }
      #endif
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
      #if REGAL_EMU_QUADS
      if (_context->quads)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 5;
        _context->quads->glEnable( cap );
      }
      #endif
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreActiveTexture( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        if( ! _context->ppa->Enable( _context, cap ) ) {
          _context->dispatcher.emulation.glEnable( cap );
        }
        return;
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        if( ! _context->iff->ShadowEnable( cap ) ) {
            _context->dispatcher.emulation.glEnable( cap );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
       if (_context->isES2())
         switch (cap)
         {
           case GL_BLEND:
           case GL_CULL_FACE:
           case GL_DEPTH_TEST:
           case GL_DITHER:
           case GL_FRAMEBUFFER_SRGB:
           case GL_POLYGON_OFFSET_FILL:
           case GL_SAMPLE_ALPHA_TO_COVERAGE:
           case GL_SAMPLE_COVERAGE:
           case GL_SCISSOR_TEST:
           case GL_STENCIL_TEST:
           case GL_TEXTURE_2D:
             break;
           default:
             Warning("glEnable does not support ",GLenumToString(cap)," for ES 2.0.");
             return;
         }
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glEnable)(cap);
      break;
    }

  }

}

static void REGAL_CALL emu_glEnd(void)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->End( _context );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glEnd)();
      break;
    }

  }

}

static void REGAL_CALL emu_glEndList(void)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glEndList for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glEndList)();
      break;
    }

  }

}

static void REGAL_CALL emu_glEvalCoord1d(GLdouble u)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glEvalCoord1d for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glEvalCoord1d)(u);
      break;
    }

  }

}

static void REGAL_CALL emu_glEvalCoord1dv(const GLdouble *u)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glEvalCoord1dv for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glEvalCoord1dv)(u);
      break;
    }

  }

}

static void REGAL_CALL emu_glEvalCoord1f(GLfloat u)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glEvalCoord1f for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glEvalCoord1f)(u);
      break;
    }

  }

}

static void REGAL_CALL emu_glEvalCoord1fv(const GLfloat *u)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glEvalCoord1fv for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glEvalCoord1fv)(u);
      break;
    }

  }

}

static void REGAL_CALL emu_glEvalCoord2d(GLdouble u, GLdouble v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glEvalCoord2d for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glEvalCoord2d)(u, v);
      break;
    }

  }

}

static void REGAL_CALL emu_glEvalCoord2dv(const GLdouble *u)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glEvalCoord2dv for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glEvalCoord2dv)(u);
      break;
    }

  }

}

static void REGAL_CALL emu_glEvalCoord2f(GLfloat u, GLfloat v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glEvalCoord2f for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glEvalCoord2f)(u, v);
      break;
    }

  }

}

static void REGAL_CALL emu_glEvalCoord2fv(const GLfloat *u)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glEvalCoord2fv for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glEvalCoord2fv)(u);
      break;
    }

  }

}

static void REGAL_CALL emu_glEvalMesh1(GLenum mode, GLint i1, GLint i2)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glEvalMesh1 for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glEvalMesh1)(mode, i1, i2);
      break;
    }

  }

}

static void REGAL_CALL emu_glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glEvalMesh2 for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glEvalMesh2)(mode, i1, i2, j1, j2);
      break;
    }

  }

}

static void REGAL_CALL emu_glEvalPoint1(GLint i)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glEvalPoint1 for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glEvalPoint1)(i);
      break;
    }

  }

}

static void REGAL_CALL emu_glEvalPoint2(GLint i, GLint j)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glEvalPoint2 for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glEvalPoint2)(i, j);
      break;
    }

  }

}

static void REGAL_CALL emu_glFogf(GLenum pname, GLfloat param)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Fog( pname, param );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glFogf)(pname, param);
      break;
    }

  }

}

static void REGAL_CALL emu_glFogfv(GLenum pname, const GLfloat *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Fog( pname, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glFogfv)(pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glFogi(GLenum pname, GLint param)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Fog( pname, param );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glFogi)(pname, param);
      break;
    }

  }

}

static void REGAL_CALL emu_glFogiv(GLenum pname, const GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Fog( pname, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glFogiv)(pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glFrontFace(GLenum mode)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glFrontFace( mode );
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
      #if REGAL_EMU_QUADS
      if (_context->quads)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 5;
        _context->quads->glFrontFace( mode );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glFrontFace)(mode);
}

static void REGAL_CALL emu_glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Frustum( left, right, bottom, top, zNear, zFar );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glFrustum)(left, right, bottom, top, zNear, zFar);
      break;
    }

  }

}

static GLuint REGAL_CALL emu_glGenLists(GLsizei range)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glGenLists for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return (( GLuint  )0);
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      return _next->call(&_next->glGenLists)(range);
    }

  }

}

static void REGAL_CALL emu_glGetBooleanv(GLenum pname, GLboolean *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
      #if REGAL_EMU_HINT
      if (_context->hint) break;
      #endif
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa) break;
      #endif
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca) break;
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGet( _context, pname );
      }
      #endif
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao) break;
      #endif
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
      #if REGAL_EMU_HINT
      if (_context->hint)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 14;
        if( ! _context->hint->glGetv( *_context, pname, params ) ) {
          _context->dispatcher.emulation.glGetBooleanv( pname, params );
        }
        return;
      }
      #endif
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        if( ! _context->ppa->glGetv( _context, pname, params ) ) {
          _context->dispatcher.emulation.glGetBooleanv( pname, params );
        }
        return;
      }
      #endif
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        if ( ! _context->ppca->glGetv( *_context, pname, params ) ) {
          _context->dispatcher.emulation.glGetBooleanv( pname, params );
        }
        return;
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->RestoreVao( _context );
        if ( ! _context->iff->glGetBooleanv( _context, pname, params ) ) {
            _context->dispatcher.emulation.glGetBooleanv( pname, params );
        }
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        if( !_context->vao->Get( pname, params ) ) {
           _context->dispatcher.emulation.glGetBooleanv( pname, params );
        }
        return;
      }
      #endif
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->filt->Get(*_context, pname, params))
        {
          #if REGAL_BREAK
          Break::Filter();
          #endif
          return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetBooleanv)(pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetDoublev(GLenum pname, GLdouble *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
      #if REGAL_EMU_HINT
      if (_context->hint) break;
      #endif
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa) break;
      #endif
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca) break;
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so) break;
      #endif
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGet( _context, pname );
      }
      #endif
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao) break;
      #endif
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
      #if REGAL_EMU_HINT
      if (_context->hint)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 14;
        if( ! _context->hint->glGetv( *_context, pname, params ) ) {
          _context->dispatcher.emulation.glGetDoublev( pname, params );
        }
        return;
      }
      #endif
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        if( ! _context->ppa->glGetv( _context, pname, params ) ) {
          _context->dispatcher.emulation.glGetDoublev( pname, params );
        }
        return;
      }
      #endif
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        if ( ! _context->ppca->glGetv( *_context, pname, params ) ) {
          _context->dispatcher.emulation.glGetDoublev( pname, params );
        }
        return;
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->RestoreVao( _context );
        if ( ! _context->iff->Get( _context, pname, params ) ) {
            _context->dispatcher.emulation.glGetDoublev( pname, params );
        }
        return;
      }
      #endif
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        if ( !_context->so->Get( pname, params ) ) {
           _context->dispatcher.emulation.glGetDoublev( pname, params );
        }
        return;
      }
      #endif
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        if( !_context->vao->Get( pname, params ) ) {
           _context->dispatcher.emulation.glGetDoublev( pname, params );
        }
        return;
      }
      #endif
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->filt->Get(*_context, pname, params))
        {
          #if REGAL_BREAK
          Break::Filter();
          #endif
          return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetDoublev)(pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetFloatv(GLenum pname, GLfloat *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
      #if REGAL_EMU_HINT
      if (_context->hint) break;
      #endif
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa) break;
      #endif
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca) break;
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so) break;
      #endif
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGet( _context, pname );
      }
      #endif
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao) break;
      #endif
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
      #if REGAL_EMU_HINT
      if (_context->hint)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 14;
        if( ! _context->hint->glGetv( *_context, pname, params ) ) {
          _context->dispatcher.emulation.glGetFloatv( pname, params );
        }
        return;
      }
      #endif
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        if( ! _context->ppa->glGetv( _context, pname, params ) ) {
          _context->dispatcher.emulation.glGetFloatv( pname, params );
        }
        return;
      }
      #endif
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        if ( ! _context->ppca->glGetv( *_context, pname, params ) ) {
          _context->dispatcher.emulation.glGetFloatv( pname, params );
        }
        return;
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->RestoreVao( _context );
        if ( ! _context->iff->Get( _context, pname, params ) ) {
            _context->dispatcher.emulation.glGetFloatv( pname, params );
        }
        return;
      }
      #endif
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        if ( !_context->so->Get( pname, params ) ) {
           _context->dispatcher.emulation.glGetFloatv( pname, params );
        }
        return;
      }
      #endif
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        if( !_context->vao->Get( pname, params ) ) {
           _context->dispatcher.emulation.glGetFloatv( pname, params );
        }
        return;
      }
      #endif
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->filt->Get(*_context, pname, params))
        {
          #if REGAL_BREAK
          Break::Filter();
          #endif
          return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetFloatv)(pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetIntegerv(GLenum pname, GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
      #if REGAL_EMU_HINT
      if (_context->hint) break;
      #endif
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa) break;
      #endif
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca) break;
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so) break;
      #endif
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGet( _context, pname );
      }
      #endif
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao) break;
      #endif
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
      #if REGAL_EMU_HINT
      if (_context->hint)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 14;
        if( ! _context->hint->glGetv( *_context, pname, params ) ) {
          _context->dispatcher.emulation.glGetIntegerv( pname, params );
        }
        return;
      }
      #endif
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        if( ! _context->ppa->glGetv( _context, pname, params ) ) {
          _context->dispatcher.emulation.glGetIntegerv( pname, params );
        }
        return;
      }
      #endif
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        if ( ! _context->ppca->glGetv( *_context, pname, params ) ) {
          _context->dispatcher.emulation.glGetIntegerv( pname, params );
        }
        return;
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->RestoreVao( _context );
        if ( ! _context->iff->Get( _context, pname, params ) ) {
            _context->dispatcher.emulation.glGetIntegerv( pname, params );
        }
        return;
      }
      #endif
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        if ( !_context->so->Get( pname, params ) ) {
           _context->dispatcher.emulation.glGetIntegerv( pname, params );
        }
        return;
      }
      #endif
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        if( !_context->vao->Get( pname, params ) ) {
           _context->dispatcher.emulation.glGetIntegerv( pname, params );
        }
        return;
      }
      #endif
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->filt->Get(*_context, pname, params))
        {
          #if REGAL_BREAK
          Break::Filter();
          #endif
          return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetIntegerv)(pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetLightfv(GLenum light, GLenum pname, GLfloat *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        if( ! _context->ppa->glGetLightv( _context, light, pname, params ) ) {
          _context->dispatcher.emulation.glGetLightfv( light, pname, params );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetLightfv)(light, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetLightiv(GLenum light, GLenum pname, GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        if( ! _context->ppa->glGetLightv( _context, light, pname, params ) ) {
          _context->dispatcher.emulation.glGetLightiv( light, pname, params );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetLightiv)(light, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetMaterialfv(GLenum face, GLenum pname, GLfloat *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa) break;
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        if( ! _context->ppa->glGetMaterialv( _context, face, pname, params ) ) {
          _context->dispatcher.emulation.glGetMaterialfv( face, pname, params );
        }
        return;
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->GetMaterial( face, pname, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetMaterialfv)(face, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetMaterialiv(GLenum face, GLenum pname, GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa) break;
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        if( ! _context->ppa->glGetMaterialv( _context, face, pname, params ) ) {
          _context->dispatcher.emulation.glGetMaterialiv( face, pname, params );
        }
        return;
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->GetMaterial( face, pname, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetMaterialiv)(face, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetPolygonStipple(GLubyte *mask)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        if( ! _context->ppa->glGetPolygonStipple( _context, mask ) ) {
          _context->dispatcher.emulation.glGetPolygonStipple( mask );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetPolygonStipple)(mask);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetTexEnvfv(GLenum target, GLenum pname, GLfloat *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa) break;
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreTexture( _context );
        _context->dsa->RestoreActiveTexture( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        if( ! _context->ppa->glGetTexEnvv( _context, target, pname, params ) ) {
          _context->dispatcher.emulation.glGetTexEnvfv( target, pname, params );
        }
        return;
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->RestoreVao( _context );
        if ( ! _context->iff->GetTexEnv( target, pname, params ) ) {
            _context->dispatcher.emulation.glGetTexEnvfv( target, pname, params );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetTexEnvfv)(target, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetTexEnviv(GLenum target, GLenum pname, GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa) break;
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreTexture( _context );
        _context->dsa->RestoreActiveTexture( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        if( ! _context->ppa->glGetTexEnvv( _context, target, pname, params ) ) {
          _context->dispatcher.emulation.glGetTexEnviv( target, pname, params );
        }
        return;
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->RestoreVao( _context );
        if ( ! _context->iff->GetTexEnv( target, pname, params ) ) {
            _context->dispatcher.emulation.glGetTexEnviv( target, pname, params );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetTexEnviv)(target, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetTexGendv(GLenum coord, GLenum pname, GLdouble *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->RestoreVao( _context );
        if ( ! _context->iff->GetTexGenv( _context, coord, pname, params ) ) {
            _context->dispatcher.emulation.glGetTexGendv( coord, pname, params );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetTexGendv)(coord, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetTexGenfv(GLenum coord, GLenum pname, GLfloat *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->RestoreVao( _context );
        if ( ! _context->iff->GetTexGenv( _context, coord, pname, params ) ) {
            _context->dispatcher.emulation.glGetTexGenfv( coord, pname, params );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetTexGenfv)(coord, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetTexGeniv(GLenum coord, GLenum pname, GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->RestoreVao( _context );
        if ( ! _context->iff->GetTexGenv( _context, coord, pname, params ) ) {
            _context->dispatcher.emulation.glGetTexGeniv( coord, pname, params );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetTexGeniv)(coord, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2())
        {
          Warning("Regal does not support glGetTexImage for ES 2.0 - skipping.");
          #if REGAL_BREAK
          Break::Filter();
          #endif
          return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetTexImage)(target, level, format, type, pixels);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glGetTexLevelParameterfv for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetTexLevelParameterfv)(target, level, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glGetTexLevelParameteriv for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetTexLevelParameteriv)(target, level, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetTexParameterfv(GLenum target, GLenum pname, GLfloat *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
      #if REGAL_EMU_TEXSTO
      if (_context->texsto) break;
      #endif
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so) break;
      #endif
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreTexture( _context );
        _context->dsa->RestoreActiveTexture( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
      #if REGAL_EMU_TEXSTO
      if (_context->texsto)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 9;
        RegalAssert(_context);
        if ( !_context->texsto->GetTexParameterv( _context, target, pname, params ) ) {
           _context->dispatcher.emulation.glGetTexParameterfv( target, pname, params );
        }
        return;
      }
      #endif
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        if ( !_context->so->GetTexParameterv( *_context, target, pname, params ) ) {
           _context->dispatcher.emulation.glGetTexParameterfv( target, pname, params );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetTexParameterfv)(target, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetTexParameteriv(GLenum target, GLenum pname, GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
      #if REGAL_EMU_TEXSTO
      if (_context->texsto) break;
      #endif
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so) break;
      #endif
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreTexture( _context );
        _context->dsa->RestoreActiveTexture( _context );
      }
      #endif
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
      #if REGAL_EMU_TEXSTO
      if (_context->texsto)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 9;
        RegalAssert(_context);
        if ( !_context->texsto->GetTexParameterv( _context, target, pname, params ) ) {
           _context->dispatcher.emulation.glGetTexParameteriv( target, pname, params );
        }
        return;
      }
      #endif
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        if ( !_context->so->GetTexParameterv( *_context, target, pname, params ) ) {
           _context->dispatcher.emulation.glGetTexParameteriv( target, pname, params );
        }
        return;
      }
      #endif
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->filt->GetTexParameteriv(*_context, target, pname, params))
        {
          #if REGAL_BREAK
          Break::Filter();
          #endif
          return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetTexParameteriv)(target, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glHint(GLenum target, GLenum mode)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
      #if REGAL_EMU_HINT
      if (_context->hint) break;
      #endif
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glHint( target, mode );
      }
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
      #if REGAL_EMU_HINT
      if (_context->hint)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 14;
        if( ! _context->hint->glHint( *_context, target, mode ) ) {
          _context->dispatcher.emulation.glHint( target, mode );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glHint)(target, mode);
      break;
    }

  }

}

static void REGAL_CALL emu_glIndexMask(GLuint mask)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glIndexMask( mask );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glIndexMask)(mask);
}

static GLboolean REGAL_CALL emu_glIsEnabled(GLenum cap)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa) break;
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreIsEnabled( _context, cap );
      }
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        {
          GLboolean enabled;
          if( ! _context->ppa->glIsEnabled( _context, enabled, cap ) )
            return _context->dispatcher.emulation.glIsEnabled( cap );
          return enabled;
        }
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        {
            GLboolean enabled;
            if ( !_context->iff->IsEnabled( _context, cap, enabled ) )
                return _context->dispatcher.emulation.glIsEnabled( cap );
            return enabled;
        }
      }
      #endif
    case 1 :
    default:
    {
       if (_context->isES2())
         switch (cap)
         {
           case GL_BLEND:
           case GL_CULL_FACE:
           case GL_DEPTH_TEST:
           case GL_DITHER:
           case GL_FRAMEBUFFER_SRGB:
           case GL_POLYGON_OFFSET_FILL:
           case GL_SAMPLE_ALPHA_TO_COVERAGE:
           case GL_SAMPLE_COVERAGE:
           case GL_SCISSOR_TEST:
           case GL_STENCIL_TEST:
           case GL_TEXTURE_2D:
             break;
           default:
             Warning("glIsEnabled does not support ",GLenumToString(cap)," for ES 2.0.");
             return GL_FALSE;
         }
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      return _next->call(&_next->glIsEnabled)(cap);
    }

  }

}

static void REGAL_CALL emu_glLightModelf(GLenum pname, GLfloat param)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glLightModel( pname, param );
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->LightModel( pname, param );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glLightModelf)(pname, param);
      break;
    }

  }

}

static void REGAL_CALL emu_glLightModelfv(GLenum pname, const GLfloat *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glLightModelv( pname, params );
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->LightModel( pname, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glLightModelfv)(pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glLightModeli(GLenum pname, GLint param)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glLightModel( pname, param );
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->LightModel( pname, param );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glLightModeli)(pname, param);
      break;
    }

  }

}

static void REGAL_CALL emu_glLightModeliv(GLenum pname, const GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glLightModelv( pname, params );
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->LightModel( pname, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glLightModeliv)(pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glLightf(GLenum light, GLenum pname, GLfloat param)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glLight( light, pname, param );
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Light( light, pname, param );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glLightf)(light, pname, param);
      break;
    }

  }

}

static void REGAL_CALL emu_glLightfv(GLenum light, GLenum pname, const GLfloat *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glLightv( light, pname, params );
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Light( light, pname, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glLightfv)(light, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glLighti(GLenum light, GLenum pname, GLint param)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glLight( light, pname, param );
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Light( light, pname, param );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glLighti)(light, pname, param);
      break;
    }

  }

}

static void REGAL_CALL emu_glLightiv(GLenum light, GLenum pname, const GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glLightv( light, pname, params );
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Light( light, pname, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glLightiv)(light, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glLineStipple(GLint factor, GLushort pattern)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glLineStipple( factor, pattern );
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glLineStipple for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glLineStipple)(factor, pattern);
      break;
    }

  }

}

static void REGAL_CALL emu_glLineWidth(GLfloat width)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glLineWidth( width );
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isCore())
        {
           Warning("Regal does not support glLineWidth for core profile - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glLineWidth)(width);
      break;
    }

  }

}

static void REGAL_CALL emu_glListBase(GLuint base)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glListBase( base );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glListBase)(base);
}

static void REGAL_CALL emu_glLoadIdentity(void)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreMatrixMode( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->LoadIdentity(  );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glLoadIdentity)();
      break;
    }

  }

}

static void REGAL_CALL emu_glLoadMatrixd(const GLdouble *m)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreMatrixMode( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->LoadMatrix( m );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glLoadMatrixd)(m);
      break;
    }

  }

}

static void REGAL_CALL emu_glLoadMatrixf(const GLfloat *m)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreMatrixMode( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->LoadMatrix( m );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glLoadMatrixf)(m);
      break;
    }

  }

}

static void REGAL_CALL emu_glLogicOp(GLenum opcode)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glLogicOp( opcode );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glLogicOp)(opcode);
}

static void REGAL_CALL emu_glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glMap1d for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMap1d)(target, u1, u2, stride, order, points);
      break;
    }

  }

}

static void REGAL_CALL emu_glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glMap1f for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMap1f)(target, u1, u2, stride, order, points);
      break;
    }

  }

}

static void REGAL_CALL emu_glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glMap2d for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMap2d)(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
      break;
    }

  }

}

static void REGAL_CALL emu_glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glMap2f for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMap2f)(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
      break;
    }

  }

}

static void REGAL_CALL emu_glMapGrid1d(GLint un, GLdouble u1, GLdouble u2)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glMapGrid1( un, u1, u2 );
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glMapGrid1d for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMapGrid1d)(un, u1, u2);
      break;
    }

  }

}

static void REGAL_CALL emu_glMapGrid1f(GLint un, GLfloat u1, GLfloat u2)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glMapGrid1( un, u1, u2 );
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glMapGrid1f for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMapGrid1f)(un, u1, u2);
      break;
    }

  }

}

static void REGAL_CALL emu_glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glMapGrid2( un, u1, u2, vn, v1, v2 );
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glMapGrid2d for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMapGrid2d)(un, u1, u2, vn, v1, v2);
      break;
    }

  }

}

static void REGAL_CALL emu_glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glMapGrid2( un, u1, u2, vn, v1, v2 );
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glMapGrid2f for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMapGrid2f)(un, u1, u2, vn, v1, v2);
      break;
    }

  }

}

static void REGAL_CALL emu_glMaterialf(GLenum face, GLenum pname, GLfloat param)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glMaterial( face, pname, param );
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Material( face, pname, param );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMaterialf)(face, pname, param);
      break;
    }

  }

}

static void REGAL_CALL emu_glMaterialfv(GLenum face, GLenum pname, const GLfloat *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glMaterialv( face, pname, params );
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Material( face, pname, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMaterialfv)(face, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glMateriali(GLenum face, GLenum pname, GLint param)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glMaterial( face, pname, param );
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Material( face, pname, param );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMateriali)(face, pname, param);
      break;
    }

  }

}

static void REGAL_CALL emu_glMaterialiv(GLenum face, GLenum pname, const GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glMaterialv( face, pname, params );
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Material( face, pname, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMaterialiv)(face, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glMatrixMode(GLenum mode)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glMatrixMode( mode );
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        if( ! _context->iff->ShadowMatrixMode( mode ) ) {
            _context->dispatcher.emulation.glMatrixMode( mode );
        }
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        if (!_context->dsa->ShadowMatrixMode(mode)) {
          _dispatch.call(&_dispatch.glMatrixMode)(mode);
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMatrixMode)(mode);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultMatrixd(const GLdouble *m)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreMatrixMode( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->MultMatrix( m );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultMatrixd)(m);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultMatrixf(const GLfloat *m)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreMatrixMode( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->MultMatrix( m );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultMatrixf)(m);
      break;
    }

  }

}

static void REGAL_CALL emu_glNewList(GLuint list, GLenum mode)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glNewList for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glNewList)(list, mode);
      break;
    }

  }

}

static void REGAL_CALL emu_glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<3>( _context, _context->iff->AttrIndex( RFF2A_Normal ), nx, ny, nz );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glNormal3b)(nx, ny, nz);
      break;
    }

  }

}

static void REGAL_CALL emu_glNormal3bv(const GLbyte *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<3>( _context, _context->iff->AttrIndex( RFF2A_Normal ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glNormal3bv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, _context->iff->AttrIndex( RFF2A_Normal ), nx, ny, nz );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glNormal3d)(nx, ny, nz);
      break;
    }

  }

}

static void REGAL_CALL emu_glNormal3dv(const GLdouble *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, _context->iff->AttrIndex( RFF2A_Normal ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glNormal3dv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, _context->iff->AttrIndex( RFF2A_Normal ), nx, ny, nz );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glNormal3f)(nx, ny, nz);
      break;
    }

  }

}

static void REGAL_CALL emu_glNormal3fv(const GLfloat *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, _context->iff->AttrIndex( RFF2A_Normal ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glNormal3fv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glNormal3i(GLint nx, GLint ny, GLint nz)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<3>( _context, _context->iff->AttrIndex( RFF2A_Normal ), nx, ny, nz );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glNormal3i)(nx, ny, nz);
      break;
    }

  }

}

static void REGAL_CALL emu_glNormal3iv(const GLint *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<3>( _context, _context->iff->AttrIndex( RFF2A_Normal ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glNormal3iv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glNormal3s(GLshort nx, GLshort ny, GLshort nz)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<3>( _context, _context->iff->AttrIndex( RFF2A_Normal ), nx, ny, nz );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glNormal3s)(nx, ny, nz);
      break;
    }

  }

}

static void REGAL_CALL emu_glNormal3sv(const GLshort *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<3>( _context, _context->iff->AttrIndex( RFF2A_Normal ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glNormal3sv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Ortho( left, right, bottom, top, zNear, zFar );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glOrtho)(left, right, bottom, top, zNear, zFar);
      break;
    }

  }

}

static void REGAL_CALL emu_glPixelStoref(GLenum pname, GLfloat param)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glPixelStore( pname, param );
      }
      #endif
    case 12 :
    case 11 :
      #if REGAL_EMU_XFER
      if (_context->xfer)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 10;
        _context->xfer->PixelStore( _context, pname, param );
      }
      #endif
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glPixelStoref for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glPixelStoref)(pname, param);
      break;
    }

  }

}

static void REGAL_CALL emu_glPixelStorei(GLenum pname, GLint param)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glPixelStore( pname, param );
      }
      #endif
    case 12 :
    case 11 :
      #if REGAL_EMU_XFER
      if (_context->xfer)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 10;
        _context->xfer->PixelStore( _context, pname, param );
      }
      #endif
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
      #if REGAL_EMU_TEXC
      if (_context->texc)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 1;
        _context->texc->ShadowPixelStore( pname, param );
      }
      #endif
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->filt->PixelStorei(*_context, pname, param))
        {
          #if REGAL_BREAK
          Break::Filter();
          #endif
          return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glPixelStorei)(pname, param);
      break;
    }

  }

}

static void REGAL_CALL emu_glPixelTransferf(GLenum pname, GLfloat param)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glPixelTransfer( pname, param );
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glPixelTransferf for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glPixelTransferf)(pname, param);
      break;
    }

  }

}

static void REGAL_CALL emu_glPixelTransferi(GLenum pname, GLint param)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glPixelTransfer( pname, param );
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glPixelTransferi for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glPixelTransferi)(pname, param);
      break;
    }

  }

}

static void REGAL_CALL emu_glPixelZoom(GLfloat xfactor, GLfloat yfactor)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glPixelZoom( xfactor, yfactor );
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glPixelZoom for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glPixelZoom)(xfactor, yfactor);
      break;
    }

  }

}

static void REGAL_CALL emu_glPointSize(GLfloat size)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glPointSize( size );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glPointSize)(size);
}

static void REGAL_CALL emu_glPolygonMode(GLenum face, GLenum mode)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glPolygonMode( face, mode );
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
      #if REGAL_EMU_QUADS
      if (_context->quads)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 5;
        _context->quads->glPolygonMode( face, mode );
      }
      #endif
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->filt->PolygonMode(*_context, face, mode))
        {
          #if REGAL_BREAK
          Break::Filter();
          #endif
          return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glPolygonMode)(face, mode);
      break;
    }

  }

}

static void REGAL_CALL emu_glPolygonStipple(const GLubyte *mask)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glPolygonStipple( mask );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glPolygonStipple)(mask);
}

static void REGAL_CALL emu_glPopAttrib(void)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->PopAttrib( _context );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glPopAttrib)();
      break;
    }

  }

}

static void REGAL_CALL emu_glPopMatrix(void)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreMatrixMode( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->PopMatrix(  );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glPopMatrix)();
      break;
    }

  }

}

static void REGAL_CALL emu_glPushAttrib(GLbitfield mask)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->PushAttrib( _context, mask );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glPushAttrib)(mask);
      break;
    }

  }

}

static void REGAL_CALL emu_glPushMatrix(void)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreMatrixMode( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->PushMatrix(  );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glPushMatrix)();
      break;
    }

  }

}

static void REGAL_CALL emu_glRasterPos2d(GLdouble x, GLdouble y)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->RasterPosition( _context, x, y );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glRasterPos2d for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glRasterPos2d)(x, y);
      break;
    }

  }

}

static void REGAL_CALL emu_glRasterPos2dv(const GLdouble *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glRasterPos2dv for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glRasterPos2dv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glRasterPos2f(GLfloat x, GLfloat y)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->RasterPosition( _context, x, y );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glRasterPos2f for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glRasterPos2f)(x, y);
      break;
    }

  }

}

static void REGAL_CALL emu_glRasterPos2fv(const GLfloat *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glRasterPos2fv for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glRasterPos2fv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glRasterPos2i(GLint x, GLint y)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->RasterPosition( _context, x, y );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glRasterPos2i for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glRasterPos2i)(x, y);
      break;
    }

  }

}

static void REGAL_CALL emu_glRasterPos2iv(const GLint *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glRasterPos2iv for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glRasterPos2iv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glRasterPos2s(GLshort x, GLshort y)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->RasterPosition( _context, x, y );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glRasterPos2s for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glRasterPos2s)(x, y);
      break;
    }

  }

}

static void REGAL_CALL emu_glRasterPos2sv(const GLshort *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glRasterPos2sv for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glRasterPos2sv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glRasterPos3d(GLdouble x, GLdouble y, GLdouble z)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->RasterPosition( _context, x, y, z );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glRasterPos3d for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glRasterPos3d)(x, y, z);
      break;
    }

  }

}

static void REGAL_CALL emu_glRasterPos3dv(const GLdouble *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glRasterPos3dv for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glRasterPos3dv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glRasterPos3f(GLfloat x, GLfloat y, GLfloat z)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->RasterPosition( _context, x, y, z );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glRasterPos3f for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glRasterPos3f)(x, y, z);
      break;
    }

  }

}

static void REGAL_CALL emu_glRasterPos3fv(const GLfloat *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glRasterPos3fv for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glRasterPos3fv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glRasterPos3i(GLint x, GLint y, GLint z)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->RasterPosition( _context, x, y, z );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glRasterPos3i for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glRasterPos3i)(x, y, z);
      break;
    }

  }

}

static void REGAL_CALL emu_glRasterPos3iv(const GLint *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glRasterPos3iv for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glRasterPos3iv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glRasterPos3s(GLshort x, GLshort y, GLshort z)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->RasterPosition( _context, x, y, z );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glRasterPos3s for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glRasterPos3s)(x, y, z);
      break;
    }

  }

}

static void REGAL_CALL emu_glRasterPos3sv(const GLshort *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glRasterPos3sv for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glRasterPos3sv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glRasterPos4d for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glRasterPos4d)(x, y, z, w);
      break;
    }

  }

}

static void REGAL_CALL emu_glRasterPos4dv(const GLdouble *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glRasterPos4dv for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glRasterPos4dv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glRasterPos4f for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glRasterPos4f)(x, y, z, w);
      break;
    }

  }

}

static void REGAL_CALL emu_glRasterPos4fv(const GLfloat *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glRasterPos4fv for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glRasterPos4fv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glRasterPos4i(GLint x, GLint y, GLint z, GLint w)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glRasterPos4i for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glRasterPos4i)(x, y, z, w);
      break;
    }

  }

}

static void REGAL_CALL emu_glRasterPos4iv(const GLint *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glRasterPos4iv for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glRasterPos4iv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glRasterPos4s for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glRasterPos4s)(x, y, z, w);
      break;
    }

  }

}

static void REGAL_CALL emu_glRasterPos4sv(const GLshort *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glRasterPos4sv for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glRasterPos4sv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glReadBuffer(GLenum mode)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glReadBuffer( mode );
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        DispatchTableGL *_next = _context->dispatcher.emulation.next();
        RegalAssert(_next);
        if (_context->filt->ReadBuffer(*_context, mode))
        {
          #if REGAL_BREAK
          Break::Filter();
          #endif
          return ;
        }
        if (_context->isES2() && _context->info->gl_nv_read_buffer)
          _next->call(&_next->glReadBufferNV)(mode);
        else
          _next->call(&_next->glReadBuffer)(mode);
        return;
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glReadBuffer)(mode);
      break;
    }

  }

}

static void REGAL_CALL emu_glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
      #if REGAL_EMU_RECT
      if (_context->rect) break;
      #endif
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
      #if REGAL_EMU_RECT
      if (_context->rect)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 7;
        _context->rect->glRect( _context, x1, y1, x2, y2 );
        return;
      }
      #endif
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glRectd for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glRectd)(x1, y1, x2, y2);
      break;
    }

  }

}

static void REGAL_CALL emu_glRectdv(const GLdouble *v1, const GLdouble *v2)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
      #if REGAL_EMU_RECT
      if (_context->rect) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
      #if REGAL_EMU_RECT
      if (_context->rect)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 7;
        _context->rect->glRectv( _context, v1, v2 );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glRectdv)(v1, v2);
      break;
    }

  }

}

static void REGAL_CALL emu_glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
      #if REGAL_EMU_RECT
      if (_context->rect) break;
      #endif
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
      #if REGAL_EMU_RECT
      if (_context->rect)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 7;
        _context->rect->glRect( _context, x1, y1, x2, y2 );
        return;
      }
      #endif
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glRectf for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glRectf)(x1, y1, x2, y2);
      break;
    }

  }

}

static void REGAL_CALL emu_glRectfv(const GLfloat *v1, const GLfloat *v2)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
      #if REGAL_EMU_RECT
      if (_context->rect) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
      #if REGAL_EMU_RECT
      if (_context->rect)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 7;
        _context->rect->glRectv( _context, v1, v2 );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glRectfv)(v1, v2);
      break;
    }

  }

}

static void REGAL_CALL emu_glRecti(GLint x1, GLint y1, GLint x2, GLint y2)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
      #if REGAL_EMU_RECT
      if (_context->rect) break;
      #endif
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
      #if REGAL_EMU_RECT
      if (_context->rect)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 7;
        _context->rect->glRect( _context, x1, y1, x2, y2 );
        return;
      }
      #endif
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glRecti for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glRecti)(x1, y1, x2, y2);
      break;
    }

  }

}

static void REGAL_CALL emu_glRectiv(const GLint *v1, const GLint *v2)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
      #if REGAL_EMU_RECT
      if (_context->rect) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
      #if REGAL_EMU_RECT
      if (_context->rect)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 7;
        _context->rect->glRectv( _context, v1, v2 );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glRectiv)(v1, v2);
      break;
    }

  }

}

static void REGAL_CALL emu_glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
      #if REGAL_EMU_RECT
      if (_context->rect) break;
      #endif
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
      #if REGAL_EMU_RECT
      if (_context->rect)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 7;
        _context->rect->glRect( _context, x1, y1, x2, y2 );
        return;
      }
      #endif
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glRects for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glRects)(x1, y1, x2, y2);
      break;
    }

  }

}

static void REGAL_CALL emu_glRectsv(const GLshort *v1, const GLshort *v2)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
      #if REGAL_EMU_RECT
      if (_context->rect) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
      #if REGAL_EMU_RECT
      if (_context->rect)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 7;
        _context->rect->glRectv( _context, v1, v2 );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glRectsv)(v1, v2);
      break;
    }

  }

}

static GLint REGAL_CALL emu_glRenderMode(GLenum mode)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->filt->RenderMode(*_context, mode))
        {
          #if REGAL_BREAK
          Break::Filter();
          #endif
          return (( GLint  )0);
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      return _next->call(&_next->glRenderMode)(mode);
    }

  }

}

static void REGAL_CALL emu_glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreMatrixMode( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Rotate( angle, x, y, z );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glRotated)(angle, x, y, z);
      break;
    }

  }

}

static void REGAL_CALL emu_glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreMatrixMode( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Rotate( angle, x, y, z );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glRotatef)(angle, x, y, z);
      break;
    }

  }

}

static void REGAL_CALL emu_glScaled(GLdouble x, GLdouble y, GLdouble z)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreMatrixMode( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Scale( x, y, z );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glScaled)(x, y, z);
      break;
    }

  }

}

static void REGAL_CALL emu_glScalef(GLfloat x, GLfloat y, GLfloat z)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreMatrixMode( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Scale( x, y, z );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glScalef)(x, y, z);
      break;
    }

  }

}

static void REGAL_CALL emu_glScissor(GLint x, GLint y, GLsizei width, GLsizei height)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glScissor( x, y, width, height );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glScissor)(x, y, width, height);
}

static void REGAL_CALL emu_glShadeModel(GLenum mode)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glShadeModel( mode );
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
      #if REGAL_EMU_QUADS
      if (_context->quads)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 5;
        _context->quads->glShadeModel( mode );
      }
      #endif
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->ShadeModel( mode );
        if( !_context->isCore() && !_context->isES2() ) {
          _context->dispatcher.emulation.glShadeModel(mode);
        }
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glShadeModel for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glShadeModel)(mode);
      break;
    }

  }

}

static void REGAL_CALL emu_glStencilFunc(GLenum func, GLint ref, GLuint mask)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glStencilFunc( func, ref, mask );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glStencilFunc)(func, ref, mask);
}

static void REGAL_CALL emu_glStencilMask(GLuint mask)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glStencilMask( mask );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glStencilMask)(mask);
}

static void REGAL_CALL emu_glStencilOp(GLenum fail, GLenum zfail, GLenum zpass)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glStencilOp( fail, zfail, zpass );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glStencilOp)(fail, zfail, zpass);
}

static void REGAL_CALL emu_glTexCoord1d(GLdouble s)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<1>( _context, _context->iff->AttrIndex( RFF2A_TexCoord ), s );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexCoord1d)(s);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexCoord1dv(const GLdouble *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<1>( _context, _context->iff->AttrIndex( RFF2A_TexCoord ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexCoord1dv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexCoord1f(GLfloat s)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<1>( _context, _context->iff->AttrIndex( RFF2A_TexCoord ), s );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexCoord1f)(s);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexCoord1fv(const GLfloat *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<1>( _context, _context->iff->AttrIndex( RFF2A_TexCoord ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexCoord1fv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexCoord1i(GLint s)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<1>( _context, _context->iff->AttrIndex( RFF2A_TexCoord ), s );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexCoord1i)(s);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexCoord1iv(const GLint *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<1>( _context, _context->iff->AttrIndex( RFF2A_TexCoord ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexCoord1iv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexCoord1s(GLshort s)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<1>( _context, _context->iff->AttrIndex( RFF2A_TexCoord ), s );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexCoord1s)(s);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexCoord1sv(const GLshort *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<1>( _context, _context->iff->AttrIndex( RFF2A_TexCoord ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexCoord1sv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexCoord2d(GLdouble s, GLdouble t)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<2>( _context, _context->iff->AttrIndex( RFF2A_TexCoord ), s, t );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexCoord2d)(s, t);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexCoord2dv(const GLdouble *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<2>( _context, _context->iff->AttrIndex( RFF2A_TexCoord ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexCoord2dv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexCoord2f(GLfloat s, GLfloat t)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<2>( _context, _context->iff->AttrIndex( RFF2A_TexCoord ), s, t );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexCoord2f)(s, t);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexCoord2fv(const GLfloat *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<2>( _context, _context->iff->AttrIndex( RFF2A_TexCoord ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexCoord2fv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexCoord2i(GLint s, GLint t)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<2>( _context, _context->iff->AttrIndex( RFF2A_TexCoord ), s, t );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexCoord2i)(s, t);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexCoord2iv(const GLint *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<2>( _context, _context->iff->AttrIndex( RFF2A_TexCoord ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexCoord2iv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexCoord2s(GLshort s, GLshort t)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<2>( _context, _context->iff->AttrIndex( RFF2A_TexCoord ), s, t );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexCoord2s)(s, t);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexCoord2sv(const GLshort *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<2>( _context, _context->iff->AttrIndex( RFF2A_TexCoord ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexCoord2sv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexCoord3d(GLdouble s, GLdouble t, GLdouble r)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, _context->iff->AttrIndex( RFF2A_TexCoord ), s, t, r );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexCoord3d)(s, t, r);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexCoord3dv(const GLdouble *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, _context->iff->AttrIndex( RFF2A_TexCoord ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexCoord3dv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexCoord3f(GLfloat s, GLfloat t, GLfloat r)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, _context->iff->AttrIndex( RFF2A_TexCoord ), s, t, r );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexCoord3f)(s, t, r);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexCoord3fv(const GLfloat *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, _context->iff->AttrIndex( RFF2A_TexCoord ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexCoord3fv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexCoord3i(GLint s, GLint t, GLint r)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, _context->iff->AttrIndex( RFF2A_TexCoord ), s, t, r );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexCoord3i)(s, t, r);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexCoord3iv(const GLint *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, _context->iff->AttrIndex( RFF2A_TexCoord ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexCoord3iv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexCoord3s(GLshort s, GLshort t, GLshort r)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, _context->iff->AttrIndex( RFF2A_TexCoord ), s, t, r );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexCoord3s)(s, t, r);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexCoord3sv(const GLshort *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, _context->iff->AttrIndex( RFF2A_TexCoord ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexCoord3sv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, _context->iff->AttrIndex( RFF2A_TexCoord ), s, t, r, q );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexCoord4d)(s, t, r, q);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexCoord4dv(const GLdouble *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, _context->iff->AttrIndex( RFF2A_TexCoord ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexCoord4dv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, _context->iff->AttrIndex( RFF2A_TexCoord ), s, t, r, q );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexCoord4f)(s, t, r, q);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexCoord4fv(const GLfloat *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, _context->iff->AttrIndex( RFF2A_TexCoord ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexCoord4fv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexCoord4i(GLint s, GLint t, GLint r, GLint q)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, _context->iff->AttrIndex( RFF2A_TexCoord ), s, t, r, q );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexCoord4i)(s, t, r, q);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexCoord4iv(const GLint *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, _context->iff->AttrIndex( RFF2A_TexCoord ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexCoord4iv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, _context->iff->AttrIndex( RFF2A_TexCoord ), s, t, r, q );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexCoord4s)(s, t, r, q);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexCoord4sv(const GLshort *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, _context->iff->AttrIndex( RFF2A_TexCoord ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexCoord4sv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexEnvf(GLenum target, GLenum pname, GLfloat param)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glTexEnv( target, pname, param );
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreTexture( _context );
        _context->dsa->RestoreActiveTexture( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->TexEnv( target, pname, param );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexEnvf)(target, pname, param);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexEnvfv(GLenum target, GLenum pname, const GLfloat *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glTexEnvv( target, pname, params );
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreTexture( _context );
        _context->dsa->RestoreActiveTexture( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->TexEnv( target, pname, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexEnvfv)(target, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexEnvi(GLenum target, GLenum pname, GLint param)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glTexEnv( target, pname, param );
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreTexture( _context );
        _context->dsa->RestoreActiveTexture( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->TexEnv( target, pname, param );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexEnvi)(target, pname, param);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexEnviv(GLenum target, GLenum pname, const GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glTexEnvv( target, pname, params );
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreTexture( _context );
        _context->dsa->RestoreActiveTexture( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->TexEnv( target, pname, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexEnviv)(target, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexGend(GLenum coord, GLenum pname, GLdouble param)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        if ( ! _context->iff->TexGen( coord, pname, param ) ) {
            _context->dispatcher.emulation.glTexGend( coord, pname, param );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexGend)(coord, pname, param);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexGendv(GLenum coord, GLenum pname, const GLdouble *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        if ( ! _context->iff->TexGen( coord, pname, params ) ) {
            _context->dispatcher.emulation.glTexGendv( coord, pname, params );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexGendv)(coord, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexGenf(GLenum coord, GLenum pname, GLfloat param)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreActiveTexture( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        if ( ! _context->iff->TexGen( coord, pname, param ) ) {
            _context->dispatcher.emulation.glTexGenf( coord, pname, param );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexGenf)(coord, pname, param);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexGenfv(GLenum coord, GLenum pname, const GLfloat *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreActiveTexture( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        if ( ! _context->iff->TexGen( coord, pname, params ) ) {
            _context->dispatcher.emulation.glTexGenfv( coord, pname, params );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexGenfv)(coord, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexGeni(GLenum coord, GLenum pname, GLint param)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreActiveTexture( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        if ( ! _context->iff->TexGen( coord, pname, param ) ) {
            _context->dispatcher.emulation.glTexGeni( coord, pname, param );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexGeni)(coord, pname, param);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexGeniv(GLenum coord, GLenum pname, const GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreActiveTexture( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        if ( ! _context->iff->TexGen( coord, pname, params ) ) {
            _context->dispatcher.emulation.glTexGeniv( coord, pname, params );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexGeniv)(coord, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexImage1D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->ShadowTexInfo( target, internalformat );
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2())
        {
          Warning("Regal does not support glTexImage1D for ES 2.0 - skipping.");
          #if REGAL_BREAK
          Break::Filter();
          #endif
          return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexImage1D)(target, level, internalformat, width, border, format, type, pixels);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
      #if REGAL_EMU_XFER
      if (_context->xfer) break;
      #endif
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->ShadowTexInfo( target, internalformat );
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
      #if REGAL_EMU_TEXC
      if (_context->texc)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 1;
        _context->texc->ShadowTexImage2D( target, level, format, type );
      }
      #endif
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
      #if REGAL_EMU_XFER
      if (_context->xfer)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 10;
        _context->xfer->TexImage2D( _context, target, level, internalformat, width, height, border, format, type, pixels );
        return;
      }
      #endif
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->filt->TexImage2D(*_context, target, level, internalformat, width, height, border, format, type, pixels))
        {
          #if REGAL_BREAK
          Break::Filter();
          #endif
          return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexImage2D)(target, level, internalformat, width, height, border, format, type, pixels);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexParameterf(GLenum target, GLenum pname, GLfloat param)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so) break;
      #endif
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreTexture( _context );
        _context->dsa->RestoreActiveTexture( _context );
      }
      #endif
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        if ( !_context->so->TexParameter( *_context, target, pname, param ) ) {
           _context->dispatcher.emulation.glTexParameterf( target, pname, param );
        }
        return;
      }
      #endif
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;

        DispatchTableGL *_next = _context->dispatcher.emulation.next();
        RegalAssert(_next);
        if (_context->filt->TexParameter(*_context, target, pname))
          return;
        GLfloat newparam;
        if (_context->filt->FilterTexParameter(*_context, target, pname, static_cast<GLfloat>(param), newparam))
          _next->call(&_next->glTexParameterf)(target, pname, newparam);
        else
          _next->call(&_next->glTexParameterf)(target, pname, param);
        return;
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexParameterf)(target, pname, param);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexParameterfv(GLenum target, GLenum pname, const GLfloat *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so) break;
      #endif
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreTexture( _context );
        _context->dsa->RestoreActiveTexture( _context );
      }
      #endif
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        if ( !_context->so->TexParameterv( *_context, target, pname, params ) ) {
           _context->dispatcher.emulation.glTexParameterfv( target, pname, params );
        }
        return;
      }
      #endif
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;

        DispatchTableGL *_next = _context->dispatcher.emulation.next();
        RegalAssert(_next);
        if (_context->filt->TexParameter(*_context, target, pname))
          return;
        GLfloat newparam;
        if (params && _context->filt->FilterTexParameter(*_context, target, pname, static_cast<GLfloat>(params[0]), newparam))
          _next->call(&_next->glTexParameterf)(target, pname, newparam);
        else
          _next->call(&_next->glTexParameterfv)(target, pname, params);
        return;
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexParameterfv)(target, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexParameteri(GLenum target, GLenum pname, GLint param)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so) break;
      #endif
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreTexture( _context );
        _context->dsa->RestoreActiveTexture( _context );
      }
      #endif
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        if ( !_context->so->TexParameter( *_context, target, pname, param ) ) {
           _context->dispatcher.emulation.glTexParameteri( target, pname, param );
        }
        return;
      }
      #endif
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;

        DispatchTableGL *_next = _context->dispatcher.emulation.next();
        RegalAssert(_next);
        if (_context->filt->TexParameter(*_context, target, pname))
          return;
        GLfloat newparam;
        if (_context->filt->FilterTexParameter(*_context, target, pname, static_cast<GLfloat>(param), newparam))
          _next->call(&_next->glTexParameterf)(target, pname, newparam);
        else
          _next->call(&_next->glTexParameteri)(target, pname, param);
        return;
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexParameteri)(target, pname, param);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexParameteriv(GLenum target, GLenum pname, const GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so) break;
      #endif
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreTexture( _context );
        _context->dsa->RestoreActiveTexture( _context );
      }
      #endif
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        if ( !_context->so->TexParameterv( *_context, target, pname, params ) ) {
           _context->dispatcher.emulation.glTexParameteriv( target, pname, params );
        }
        return;
      }
      #endif
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;

        DispatchTableGL *_next = _context->dispatcher.emulation.next();
        RegalAssert(_next);
        if (_context->filt->TexParameter(*_context, target, pname))
          return;
        GLfloat newparam;
        if (params && _context->filt->FilterTexParameter(*_context, target, pname, static_cast<GLfloat>(params[0]), newparam))
          _next->call(&_next->glTexParameterf)(target, pname, newparam);
        else
          _next->call(&_next->glTexParameteriv)(target, pname, params);
        return;
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexParameteriv)(target, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glTranslated(GLdouble x, GLdouble y, GLdouble z)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreMatrixMode( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Translate( x, y, z );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTranslated)(x, y, z);
      break;
    }

  }

}

static void REGAL_CALL emu_glTranslatef(GLfloat x, GLfloat y, GLfloat z)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreMatrixMode( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Translate( x, y, z );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTranslatef)(x, y, z);
      break;
    }

  }

}

static void REGAL_CALL emu_glVertex2d(GLdouble x, GLdouble y)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<2>( _context, _context->iff->AttrIndex( RFF2A_Vertex ), x, y );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glVertex2d)(x, y);
      break;
    }

  }

}

static void REGAL_CALL emu_glVertex2dv(const GLdouble *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<2>( _context, _context->iff->AttrIndex( RFF2A_Vertex ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glVertex2dv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glVertex2f(GLfloat x, GLfloat y)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<2>( _context, _context->iff->AttrIndex( RFF2A_Vertex ), x, y );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glVertex2f)(x, y);
      break;
    }

  }

}

static void REGAL_CALL emu_glVertex2fv(const GLfloat *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<2>( _context, _context->iff->AttrIndex( RFF2A_Vertex ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glVertex2fv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glVertex2i(GLint x, GLint y)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<2>( _context, _context->iff->AttrIndex( RFF2A_Vertex ), x, y );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glVertex2i)(x, y);
      break;
    }

  }

}

static void REGAL_CALL emu_glVertex2iv(const GLint *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<2>( _context, _context->iff->AttrIndex( RFF2A_Vertex ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glVertex2iv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glVertex2s(GLshort x, GLshort y)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<2>( _context, _context->iff->AttrIndex( RFF2A_Vertex ), x, y );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glVertex2s)(x, y);
      break;
    }

  }

}

static void REGAL_CALL emu_glVertex2sv(const GLshort *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<2>( _context, _context->iff->AttrIndex( RFF2A_Vertex ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glVertex2sv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glVertex3d(GLdouble x, GLdouble y, GLdouble z)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, _context->iff->AttrIndex( RFF2A_Vertex ), x, y, z );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glVertex3d)(x, y, z);
      break;
    }

  }

}

static void REGAL_CALL emu_glVertex3dv(const GLdouble *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, _context->iff->AttrIndex( RFF2A_Vertex ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glVertex3dv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glVertex3f(GLfloat x, GLfloat y, GLfloat z)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, _context->iff->AttrIndex( RFF2A_Vertex ), x, y, z );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glVertex3f)(x, y, z);
      break;
    }

  }

}

static void REGAL_CALL emu_glVertex3fv(const GLfloat *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, _context->iff->AttrIndex( RFF2A_Vertex ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glVertex3fv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glVertex3i(GLint x, GLint y, GLint z)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, _context->iff->AttrIndex( RFF2A_Vertex ), x, y, z );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glVertex3i)(x, y, z);
      break;
    }

  }

}

static void REGAL_CALL emu_glVertex3iv(const GLint *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, _context->iff->AttrIndex( RFF2A_Vertex ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glVertex3iv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glVertex3s(GLshort x, GLshort y, GLshort z)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, _context->iff->AttrIndex( RFF2A_Vertex ), x, y, z );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glVertex3s)(x, y, z);
      break;
    }

  }

}

static void REGAL_CALL emu_glVertex3sv(const GLshort *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, _context->iff->AttrIndex( RFF2A_Vertex ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glVertex3sv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, _context->iff->AttrIndex( RFF2A_Vertex ), x, y, z, w );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glVertex4d)(x, y, z, w);
      break;
    }

  }

}

static void REGAL_CALL emu_glVertex4dv(const GLdouble *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, _context->iff->AttrIndex( RFF2A_Vertex ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glVertex4dv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, _context->iff->AttrIndex( RFF2A_Vertex ), x, y, z, w );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glVertex4f)(x, y, z, w);
      break;
    }

  }

}

static void REGAL_CALL emu_glVertex4fv(const GLfloat *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, _context->iff->AttrIndex( RFF2A_Vertex ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glVertex4fv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glVertex4i(GLint x, GLint y, GLint z, GLint w)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, _context->iff->AttrIndex( RFF2A_Vertex ), x, y, z, w );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glVertex4i)(x, y, z, w);
      break;
    }

  }

}

static void REGAL_CALL emu_glVertex4iv(const GLint *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, _context->iff->AttrIndex( RFF2A_Vertex ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glVertex4iv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, _context->iff->AttrIndex( RFF2A_Vertex ), x, y, z, w );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glVertex4s)(x, y, z, w);
      break;
    }

  }

}

static void REGAL_CALL emu_glVertex4sv(const GLshort *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, _context->iff->AttrIndex( RFF2A_Vertex ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glVertex4sv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glViewport(GLint x, GLint y, GLsizei width, GLsizei height)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glViewport( x, y, width, height );
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Viewport( x, y, width, height );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glViewport)(x, y, width, height);
}

// GL_VERSION_1_1

static void REGAL_CALL emu_glBindTexture(GLenum target, GLuint texture)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
      #if REGAL_EMU_OBJ
      if (_context->obj) break;
      #endif
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->ShadowTexBinding( target, texture );
      }
      #endif
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so) break;
      #endif
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 3 :
    case 2 :
      #if REGAL_EMU_TEXC
      if (_context->texc)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 1;
        _context->texc->ShadowBindTexture( target, texture );
      }
      #endif
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
      #if REGAL_EMU_OBJ
      if (_context->obj)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 15;
        _context->obj->BindTexture(*_context, target, texture);
        return;
      }
      #endif
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        if ( !_context->so->BindTexture( *_context, target, texture ) ) {
           _context->dispatcher.emulation.glBindTexture( target, texture );
        }
        return;
      }
      #endif
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        if (!_context->dsa->ShadowTexture( target, texture )) {
            _dispatch.call(&_dispatch.glBindTexture)( target, texture );
        }
        return;
      }
      #endif
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->filt->BindTexture(*_context, target, texture))
        {
          #if REGAL_BREAK
          Break::Filter();
          #endif
          return ;
        }
      }
      #endif
    default:
    {
       if (_context->isES2())
         switch (target)
         {
           case GL_TEXTURE_2D:
           case GL_TEXTURE_CUBE_MAP:
             break;
           default:
             Warning("glBindTexture does not support ",GLenumToString(target)," for ES 2.0.");
             return;
         }
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glBindTexture)(target, texture);
      break;
    }

  }

}

static void REGAL_CALL emu_glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glColorPointer( size, type, stride, pointer );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glColorPointer( size, type, stride, pointer );
      }
      #endif
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreBuffer( _context );
      }
      #endif
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->ColorPointer( _context, size, type, stride, pointer );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        _context->vao->ColorPointer(*_context, size, type, stride, pointer );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glColorPointer)(size, type, stride, pointer);
      break;
    }

  }

}

static void REGAL_CALL emu_glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->ShadowTexInfo( target, internalformat );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glCopyTexImage2D)(target, level, internalformat, x, y, width, height, border);
}

static void REGAL_CALL emu_glDeleteTextures(GLsizei n, const GLuint *textures)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
      #if REGAL_EMU_OBJ
      if (_context->obj) break;
      #endif
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
      #if REGAL_EMU_TEXSTO
      if (_context->texsto)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 9;
        RegalAssert(_context);
        _context->texsto->DeleteTextures( _context, n, textures );
      }
      #endif
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        _context->so->DeleteTextures( *_context, n, textures );
      }
      #endif
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DeleteTextures( _context, n, textures );
      }
      #endif
    case 3 :
    case 2 :
      #if REGAL_EMU_TEXC
      if (_context->texc)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 1;
        _context->texc->ShadowDeleteTextures( n, textures );
      }
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
      #if REGAL_EMU_OBJ
      if (_context->obj)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 15;
        _context->obj->DeleteTextures(*_context, n, textures);
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glDeleteTextures)(n, textures);
      break;
    }

  }

}

static void REGAL_CALL emu_glDisableClientState(GLenum cap)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glDisableClientState( cap );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glDisableClientState( cap );
      }
      #endif
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreClientActiveTexture( _context );
        _context->dsa->RestoreBuffer( _context );
      }
      #endif
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->DisableClientState( _context, cap );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        _context->vao->DisableClientState(*_context, cap );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glDisableClientState)(cap);
      break;
    }

  }

}

static void REGAL_CALL emu_glDrawArrays(GLenum mode, GLint first, GLsizei count)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->PreDraw( _context );
      }
      #endif
    case 6 :
      #if REGAL_EMU_QUADS
      if (_context->quads) break;
      #endif
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        _context->so->PreDraw( *_context );
      }
      #endif
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->Restore( _context );
      }
      #endif
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        // _context->vao->Validate(*_context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
      #if REGAL_EMU_QUADS
      if (_context->quads)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 5;

        if ( ! _context->quads->glDrawArrays( _context, mode, first, count ) ) {
          DispatchTableGL *_next = _context->dispatcher.emulation.next();
          RegalAssert(_next);
          return _next->call(&_next->glDrawArrays)( mode, first, count );
        }

        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glDrawArrays)(mode, first, count);
      break;
    }

  }

}

static void REGAL_CALL emu_glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->PreDraw( _context );
      }
      #endif
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        _context->so->PreDraw( *_context );
      }
      #endif
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->Restore( _context );
      }
      #endif
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        // _context->vao->Validate(*_context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glDrawElements)(mode, count, type, indices);
}

static void REGAL_CALL emu_glEdgeFlagPointer(GLsizei stride, const GLvoid *pointer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glEdgeFlagPointer( stride, pointer );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glEdgeFlagPointer( stride, pointer );
      }
      #endif
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->EdgeFlagPointer( _context, stride, pointer );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glEdgeFlagPointer)(stride, pointer);
      break;
    }

  }

}

static void REGAL_CALL emu_glEnableClientState(GLenum cap)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glEnableClientState( cap );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glEnableClientState( cap );
      }
      #endif
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreClientActiveTexture( _context );
        _context->dsa->RestoreBuffer( _context );
      }
      #endif
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->EnableClientState( _context, cap );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        _context->vao->EnableClientState(*_context, cap );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glEnableClientState)(cap);
      break;
    }

  }

}

static void REGAL_CALL emu_glGenTextures(GLsizei n, GLuint *textures)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
      #if REGAL_EMU_OBJ
      if (_context->obj) break;
      #endif
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so) break;
      #endif
    case 4 :
    case 3 :
    case 2 :
      #if REGAL_EMU_TEXC
      if (_context->texc) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
      #if REGAL_EMU_OBJ
      if (_context->obj)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 15;
        _context->obj->GenTextures(*_context, n, textures);
        return;
      }
      #endif
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        _context->so->GenTextures( *_context, n, textures );
        return;
      }
      #endif
    case 4 :
    case 3 :
    case 2 :
      #if REGAL_EMU_TEXC
      if (_context->texc)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 1;

        _context->dispatcher.emulation.glGenTextures( n, textures );
        _context->texc->ShadowGenTextures( n, textures );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGenTextures)(n, textures);
      break;
    }

  }

}

static void REGAL_CALL emu_glIndexPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glIndexPointer( type, stride, pointer );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glIndexPointer( type, stride, pointer );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glIndexPointer)(type, stride, pointer);
}

static void REGAL_CALL emu_glInterleavedArrays(GLenum format, GLsizei stride, const GLvoid *pointer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glInterleavedArrays( format, stride, pointer );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glInterleavedArrays( format, stride, pointer );
      }
      #endif
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        _context->vao->InterleavedArrays(*_context, format, stride, pointer );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glInterleavedArrays)(format, stride, pointer);
      break;
    }

  }

}

static GLboolean REGAL_CALL emu_glIsTexture(GLuint texture)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
      #if REGAL_EMU_OBJ
      if (_context->obj) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
      #if REGAL_EMU_OBJ
      if (_context->obj)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 15;
        return _context->obj->IsTexture(*_context, texture);
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      return _next->call(&_next->glIsTexture)(texture);
    }

  }

}

static void REGAL_CALL emu_glNormalPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glNormalPointer( type, stride, pointer );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glNormalPointer( type, stride, pointer );
      }
      #endif
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreBuffer( _context );
      }
      #endif
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->NormalPointer( _context, type, stride, pointer );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        _context->vao->NormalPointer(*_context, type, stride, pointer );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glNormalPointer)(type, stride, pointer);
      break;
    }

  }

}

static void REGAL_CALL emu_glPolygonOffset(GLfloat factor, GLfloat units)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glPolygonOffset( factor, units );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glPolygonOffset)(factor, units);
}

static void REGAL_CALL emu_glPopClientAttrib(void)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glPopClientAttrib( *_context );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glPopClientAttrib)();
      break;
    }

  }

}

static void REGAL_CALL emu_glPushClientAttrib(GLbitfield mask)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glPushClientAttrib( *_context, mask );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glPushClientAttrib)(mask);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glTexCoordPointer( size, type, stride, pointer );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glTexCoordPointer( size, type, stride, pointer );
      }
      #endif
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreClientActiveTexture( _context );
        _context->dsa->RestoreBuffer( _context );
      }
      #endif
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->TexCoordPointer( _context, size, type, stride, pointer );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        _context->vao->TexCoordPointer(*_context, size, type, stride, pointer );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexCoordPointer)(size, type, stride, pointer);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
      #if REGAL_EMU_XFER
      if (_context->xfer) break;
      #endif
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
      #if REGAL_EMU_TEXC
      if (_context->texc) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
      #if REGAL_EMU_XFER
      if (_context->xfer)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 10;
        _context->xfer->TexSubImage2D( _context, target, level, xoffset, yoffset, width, height, format, type, pixels );
        return;
      }
      #endif
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
      #if REGAL_EMU_TEXC
      if (_context->texc)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 1;

        GLenum targetFormat;
        GLenum targetType;
        _context->texc->GetFormatAndType( target, level, &targetFormat, &targetType );
        Emu::ConvertedBuffer _buffer( _context->texc->unpackPSS, targetFormat, targetType );
        if ( _buffer.ConvertFrom( width, height, format, type, pixels ) )
        {
          if (_context->texc->unpackPSS.alignment != 4)
            _context->dispatcher.emulation.glPixelStorei( GL_UNPACK_ALIGNMENT, 4 );
          _context->dispatcher.emulation.glTexSubImage2D( target, level, xoffset, yoffset, width, height, targetFormat, targetType, _buffer.Get() );
          if (_context->texc->unpackPSS.alignment != 4)
            _context->dispatcher.emulation.glPixelStorei( GL_UNPACK_ALIGNMENT, _context->texc->unpackPSS.alignment );
        }
        else
        {
          _context->dispatcher.emulation.glTexSubImage2D( target, level, xoffset, yoffset, width, height, format, type, pixels );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
       if (_context->isES2())
         switch (target)
         {
           case GL_TEXTURE_2D:
           case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
           case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
           case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
           case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
           case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
           case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
             break;
           default:
             Warning("glTexSubImage2D does not support ",GLenumToString(target)," for ES 2.0.");
             return;
         }
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexSubImage2D)(target, level, xoffset, yoffset, width, height, format, type, pixels);
      break;
    }

  }

}

static void REGAL_CALL emu_glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glVertexPointer( size, type, stride, pointer );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glVertexPointer( size, type, stride, pointer );
      }
      #endif
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreBuffer( _context );
      }
      #endif
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->VertexPointer( _context, size, type, stride, pointer );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        _context->vao->VertexPointer(*_context, size, type, stride, pointer );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glVertexPointer)(size, type, stride, pointer);
      break;
    }

  }

}

// GL_VERSION_1_2

static void REGAL_CALL emu_glBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glBlendColor( red, green, blue, alpha );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glBlendColor)(red, green, blue, alpha);
}

static void REGAL_CALL emu_glBlendEquation(GLenum mode)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glBlendEquation( mode );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glBlendEquation)(mode);
}

static void REGAL_CALL emu_glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->PreDraw( _context );
      }
      #endif
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        _context->so->PreDraw( *_context );
      }
      #endif
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2())
        {
          DispatchTableGL *_next = _context->dispatcher.emulation.next();
          RegalAssert(_next);
          return _next->call(&_next->glDrawElements)(mode, count, type, indices);
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glDrawRangeElements)(mode, start, end, count, type, indices);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->ShadowTexInfo( target, internalformat );
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2())
        {
          Warning("Regal does not support glTexImage3D for ES 2.0 - skipping.");
          #if REGAL_BREAK
          Break::Filter();
          #endif
          return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexImage3D)(target, level, internalformat, width, height, depth, border, format, type, pixels);
      break;
    }

  }

}

// GL_VERSION_1_3

static void REGAL_CALL emu_glActiveTexture(GLenum texture)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glActiveTexture( texture );
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
      #if REGAL_EMU_XFER
      if (_context->xfer)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 10;
        _context->xfer->ShadowActiveTexture( texture );
      }
      #endif
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->ShadowActiveTexture( texture );
      }
      #endif
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so) break;
      #endif
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 3 :
    case 2 :
      #if REGAL_EMU_TEXC
      if (_context->texc)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 1;
        _context->texc->ShadowActiveTexture( texture );
      }
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        if ( !_context->so->ActiveTexture( *_context, texture ) ) {
           _context->dispatcher.emulation.glActiveTexture( texture );
        }
        return;
      }
      #endif
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        if( false == _context->dsa->ShadowActiveTexture( texture ) ) {
            _dispatch.call(&_dispatch.glActiveTexture)( texture );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glActiveTexture)(texture);
      break;
    }

  }

}

static void REGAL_CALL emu_glClientActiveTexture(GLenum texture)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glClientActiveTexture( texture );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glClientActiveTexture( texture );
      }
      #endif
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->ShadowClientActiveTexture( texture );
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        _context->vao->ClientActiveTexture(*_context, texture );
      }
      #endif
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        if (!_context->dsa->ShadowClientActiveTexture( texture )) {
          _dispatch.call(&_dispatch.glClientActiveTexture)( texture );
        }
        return;
      }
      #endif
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2())
        {
          Warning("Regal does not support glClientActiveTexture for ES 2.0 - skipping.");
          #if REGAL_BREAK
          Break::Filter();
          #endif
          return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glClientActiveTexture)(texture);
      break;
    }

  }

}

static void REGAL_CALL emu_glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
      #if REGAL_EMU_XFER
      if (_context->xfer) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
      #if REGAL_EMU_XFER
      if (_context->xfer)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 10;
        _context->xfer->CompressedTexImage2D( _context, target, level, internalformat, width, height, border, imageSize, data );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glCompressedTexImage2D)(target, level, internalformat, width, height, border, imageSize, data);
      break;
    }

  }

}

static void REGAL_CALL emu_glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
      #if REGAL_EMU_XFER
      if (_context->xfer) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
      #if REGAL_EMU_XFER
      if (_context->xfer)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 10;
        _context->xfer->CompressedTexSubImage2D( _context, target, level, xoffset, yoffset, width, height, format, imageSize, data );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glCompressedTexSubImage2D)(target, level, xoffset, yoffset, width, height, format, imageSize, data);
      break;
    }

  }

}

static void REGAL_CALL emu_glLoadTransposeMatrixd(const GLdouble *m)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreMatrixMode( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->LoadTransposeMatrix( m );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glLoadTransposeMatrixd)(m);
      break;
    }

  }

}

static void REGAL_CALL emu_glLoadTransposeMatrixf(const GLfloat *m)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreMatrixMode( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->LoadTransposeMatrix( m );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glLoadTransposeMatrixf)(m);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultTransposeMatrixd(const GLdouble *m)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreMatrixMode( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->MultTransposeMatrix( m );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultTransposeMatrixd)(m);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultTransposeMatrixf(const GLfloat *m)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreMatrixMode( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->MultTransposeMatrix( m );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultTransposeMatrixf)(m);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord1d(GLenum target, GLdouble s)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<1>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), s );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord1d)(target, s);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord1dv(GLenum target, const GLdouble *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<1>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord1dv)(target, v);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord1f(GLenum target, GLfloat s)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<1>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), s );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord1f)(target, s);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord1fv(GLenum target, const GLfloat *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<1>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord1fv)(target, v);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord1i(GLenum target, GLint s)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<1>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), s );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord1i)(target, s);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord1iv(GLenum target, const GLint *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<1>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord1iv)(target, v);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord1s(GLenum target, GLshort s)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<1>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), s );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord1s)(target, s);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord1sv(GLenum target, const GLshort *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<1>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord1sv)(target, v);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord2d(GLenum target, GLdouble s, GLdouble t)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<2>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), s, t );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord2d)(target, s, t);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord2dv(GLenum target, const GLdouble *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<2>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord2dv)(target, v);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord2f(GLenum target, GLfloat s, GLfloat t)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<2>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), s, t );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord2f)(target, s, t);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord2fv(GLenum target, const GLfloat *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<2>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord2fv)(target, v);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord2i(GLenum target, GLint s, GLint t)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<2>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), s, t );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord2i)(target, s, t);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord2iv(GLenum target, const GLint *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<2>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord2iv)(target, v);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord2s(GLenum target, GLshort s, GLshort t)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<2>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), s, t );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord2s)(target, s, t);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord2sv(GLenum target, const GLshort *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<2>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord2sv)(target, v);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord3d(GLenum target, GLdouble s, GLdouble t, GLdouble r)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), s, t, r );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord3d)(target, s, t, r);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord3dv(GLenum target, const GLdouble *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord3dv)(target, v);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord3f(GLenum target, GLfloat s, GLfloat t, GLfloat r)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), s, t, r );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord3f)(target, s, t, r);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord3fv(GLenum target, const GLfloat *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord3fv)(target, v);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord3i(GLenum target, GLint s, GLint t, GLint r)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), s, t, r );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord3i)(target, s, t, r);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord3iv(GLenum target, const GLint *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord3iv)(target, v);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord3s(GLenum target, GLshort s, GLshort t, GLshort r)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), s, t, r );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord3s)(target, s, t, r);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord3sv(GLenum target, const GLshort *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord3sv)(target, v);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord4d(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), s, t, r, q );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord4d)(target, s, t, r, q);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord4dv(GLenum target, const GLdouble *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord4dv)(target, v);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord4f(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), s, t, r, q );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord4f)(target, s, t, r, q);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord4fv(GLenum target, const GLfloat *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord4fv)(target, v);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord4i(GLenum target, GLint s, GLint t, GLint r, GLint q)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), s, t, r, q );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord4i)(target, s, t, r, q);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord4iv(GLenum target, const GLint *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord4iv)(target, v);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord4s(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), s, t, r, q );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord4s)(target, s, t, r, q);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord4sv(GLenum target, const GLshort *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord4sv)(target, v);
      break;
    }

  }

}

static void REGAL_CALL emu_glSampleCoverage(GLclampf value, GLboolean invert)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glSampleCoverage( value, invert );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glSampleCoverage)(value, invert);
}

// GL_VERSION_1_4

static void REGAL_CALL emu_glBlendFuncSeparate(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glBlendFuncSeparate( sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glBlendFuncSeparate)(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
}

static void REGAL_CALL emu_glFogCoordPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glFogCoordPointer( type, stride, pointer );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glFogCoordPointer( type, stride, pointer );
      }
      #endif
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->FogCoordPointer( _context, type, stride, pointer );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        _context->vao->FogCoordPointer(*_context, type, stride, pointer );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glFogCoordPointer)(type, stride, pointer);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiDrawArrays(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->PreDraw( _context );
      }
      #endif
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        _context->so->PreDraw( *_context );
      }
      #endif
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->Restore( _context );
      }
      #endif
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        // _context->vao->Validate(*_context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glMultiDrawArrays)(mode, first, count, primcount);
}

static void REGAL_CALL emu_glMultiDrawElements(GLenum mode, const GLsizei *count, GLenum type, const GLvoid * const *indices, GLsizei primcount)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->PreDraw( _context );
      }
      #endif
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        _context->so->PreDraw( *_context );
      }
      #endif
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->Restore( _context );
      }
      #endif
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        // _context->vao->Validate(*_context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glMultiDrawElements)(mode, count, type, indices, primcount);
}

static void REGAL_CALL emu_glPointParameterf(GLenum pname, GLfloat param)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glPointParameter( pname, param );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glPointParameterf)(pname, param);
}

static void REGAL_CALL emu_glPointParameterfv(GLenum pname, const GLfloat *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glPointParameterv( pname, params );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glPointParameterfv)(pname, params);
}

static void REGAL_CALL emu_glPointParameteri(GLenum pname, GLint param)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glPointParameter( pname, param );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glPointParameteri)(pname, param);
}

static void REGAL_CALL emu_glPointParameteriv(GLenum pname, const GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glPointParameterv( pname, params );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glPointParameteriv)(pname, params);
}

static void REGAL_CALL emu_glSecondaryColor3b(GLbyte red, GLbyte green, GLbyte blue)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<3>( _context, _context->iff->AttrIndex( RFF2A_SecondaryColor ), red, green, blue );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glSecondaryColor3b)(red, green, blue);
      break;
    }

  }

}

static void REGAL_CALL emu_glSecondaryColor3bv(const GLbyte *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<3>( _context, _context->iff->AttrIndex( RFF2A_SecondaryColor ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glSecondaryColor3bv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glSecondaryColor3d(GLdouble red, GLdouble green, GLdouble blue)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, _context->iff->AttrIndex( RFF2A_SecondaryColor ), red, green, blue );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glSecondaryColor3d)(red, green, blue);
      break;
    }

  }

}

static void REGAL_CALL emu_glSecondaryColor3dv(const GLdouble *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, _context->iff->AttrIndex( RFF2A_SecondaryColor ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glSecondaryColor3dv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glSecondaryColor3f(GLfloat red, GLfloat green, GLfloat blue)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, _context->iff->AttrIndex( RFF2A_SecondaryColor ), red, green, blue );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glSecondaryColor3f)(red, green, blue);
      break;
    }

  }

}

static void REGAL_CALL emu_glSecondaryColor3fv(const GLfloat *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, _context->iff->AttrIndex( RFF2A_SecondaryColor ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glSecondaryColor3fv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glSecondaryColor3i(GLint red, GLint green, GLint blue)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<3>( _context, _context->iff->AttrIndex( RFF2A_SecondaryColor ), red, green, blue );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glSecondaryColor3i)(red, green, blue);
      break;
    }

  }

}

static void REGAL_CALL emu_glSecondaryColor3iv(const GLint *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<3>( _context, _context->iff->AttrIndex( RFF2A_SecondaryColor ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glSecondaryColor3iv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glSecondaryColor3s(GLshort red, GLshort green, GLshort blue)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<3>( _context, _context->iff->AttrIndex( RFF2A_SecondaryColor ), red, green, blue );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glSecondaryColor3s)(red, green, blue);
      break;
    }

  }

}

static void REGAL_CALL emu_glSecondaryColor3sv(const GLshort *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<3>( _context, _context->iff->AttrIndex( RFF2A_SecondaryColor ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glSecondaryColor3sv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glSecondaryColor3ub(GLubyte red, GLubyte green, GLubyte blue)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<3>( _context, _context->iff->AttrIndex( RFF2A_SecondaryColor ), red, green, blue );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glSecondaryColor3ub)(red, green, blue);
      break;
    }

  }

}

static void REGAL_CALL emu_glSecondaryColor3ubv(const GLubyte *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<3>( _context, _context->iff->AttrIndex( RFF2A_SecondaryColor ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glSecondaryColor3ubv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glSecondaryColor3ui(GLuint red, GLuint green, GLuint blue)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<3>( _context, _context->iff->AttrIndex( RFF2A_SecondaryColor ), red, green, blue );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glSecondaryColor3ui)(red, green, blue);
      break;
    }

  }

}

static void REGAL_CALL emu_glSecondaryColor3uiv(const GLuint *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<3>( _context, _context->iff->AttrIndex( RFF2A_SecondaryColor ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glSecondaryColor3uiv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glSecondaryColor3us(GLushort red, GLushort green, GLushort blue)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<3>( _context, _context->iff->AttrIndex( RFF2A_SecondaryColor ), red, green, blue );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glSecondaryColor3us)(red, green, blue);
      break;
    }

  }

}

static void REGAL_CALL emu_glSecondaryColor3usv(const GLushort *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<3>( _context, _context->iff->AttrIndex( RFF2A_SecondaryColor ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glSecondaryColor3usv)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glSecondaryColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glSecondaryColorPointer( size, type, stride, pointer );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glSecondaryColorPointer( size, type, stride, pointer );
      }
      #endif
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreBuffer( _context );
      }
      #endif
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->SecondaryColorPointer( _context, size, type, stride, pointer );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        _context->vao->SecondaryColorPointer(*_context, size, type, stride, pointer );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glSecondaryColorPointer)(size, type, stride, pointer);
      break;
    }

  }

}

static void REGAL_CALL emu_glWindowPos2d(GLdouble x, GLdouble y)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->WindowPosition( _context, x, y );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glWindowPos2d for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glWindowPos2d)(x, y);
      break;
    }

  }

}

static void REGAL_CALL emu_glWindowPos2dv(const GLdouble *p)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glWindowPos2dv for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glWindowPos2dv)(p);
      break;
    }

  }

}

static void REGAL_CALL emu_glWindowPos2f(GLfloat x, GLfloat y)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->WindowPosition( _context, x, y );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glWindowPos2f for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glWindowPos2f)(x, y);
      break;
    }

  }

}

static void REGAL_CALL emu_glWindowPos2fv(const GLfloat *p)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glWindowPos2fv for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glWindowPos2fv)(p);
      break;
    }

  }

}

static void REGAL_CALL emu_glWindowPos2i(GLint x, GLint y)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->WindowPosition( _context, x, y );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glWindowPos2i for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glWindowPos2i)(x, y);
      break;
    }

  }

}

static void REGAL_CALL emu_glWindowPos2iv(const GLint *p)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glWindowPos2iv for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glWindowPos2iv)(p);
      break;
    }

  }

}

static void REGAL_CALL emu_glWindowPos2s(GLshort x, GLshort y)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->WindowPosition( _context, x, y );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glWindowPos2s for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glWindowPos2s)(x, y);
      break;
    }

  }

}

static void REGAL_CALL emu_glWindowPos2sv(const GLshort *p)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glWindowPos2sv for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glWindowPos2sv)(p);
      break;
    }

  }

}

static void REGAL_CALL emu_glWindowPos3d(GLdouble x, GLdouble y, GLdouble z)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->WindowPosition( _context, x, y, z );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glWindowPos3d for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glWindowPos3d)(x, y, z);
      break;
    }

  }

}

static void REGAL_CALL emu_glWindowPos3dv(const GLdouble *p)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glWindowPos3dv for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glWindowPos3dv)(p);
      break;
    }

  }

}

static void REGAL_CALL emu_glWindowPos3f(GLfloat x, GLfloat y, GLfloat z)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->WindowPosition( _context, x, y, z );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glWindowPos3f for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glWindowPos3f)(x, y, z);
      break;
    }

  }

}

static void REGAL_CALL emu_glWindowPos3fv(const GLfloat *p)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glWindowPos3fv for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glWindowPos3fv)(p);
      break;
    }

  }

}

static void REGAL_CALL emu_glWindowPos3i(GLint x, GLint y, GLint z)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->WindowPosition( _context, x, y, z );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glWindowPos3i for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glWindowPos3i)(x, y, z);
      break;
    }

  }

}

static void REGAL_CALL emu_glWindowPos3iv(const GLint *p)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glWindowPos3iv for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glWindowPos3iv)(p);
      break;
    }

  }

}

static void REGAL_CALL emu_glWindowPos3s(GLshort x, GLshort y, GLshort z)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->WindowPosition( _context, x, y, z );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glWindowPos3s for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glWindowPos3s)(x, y, z);
      break;
    }

  }

}

static void REGAL_CALL emu_glWindowPos3sv(const GLshort *p)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || _context->isCore())
        {
           Warning("Regal does not support glWindowPos3sv for core or ES2 profiles - skipping.");
           #if REGAL_BREAK
           Break::Filter();
           #endif
           return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glWindowPos3sv)(p);
      break;
    }

  }

}

// GL_VERSION_1_5

static void REGAL_CALL emu_glBindBuffer(GLenum target, GLuint buffer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
      #if REGAL_EMU_OBJ
      if (_context->obj) break;
      #endif
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glBindBuffer( target, buffer );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glBindBuffer( target, buffer );
      }
      #endif
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->RestoreVao( _context );
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        _context->vao->ShadowBufferBinding( target, buffer );
      }
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
      #if REGAL_EMU_OBJ
      if (_context->obj)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 15;
        _context->obj->BindBuffer(*_context, target, buffer);
        return;
      }
      #endif
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        if (!_context->dsa->ShadowBuffer( target, buffer ) ) {
            _dispatch.call(&_dispatch.glBindBuffer)(target, buffer);
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glBindBuffer)(target, buffer);
      break;
    }

  }

}

static void REGAL_CALL emu_glBufferData(GLenum target, GLsizeiptr size, const GLvoid *data, GLenum usage)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreBuffer( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glBufferData)(target, size, data, usage);
}

static void REGAL_CALL emu_glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *data)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreBuffer( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glBufferSubData)(target, offset, size, data);
}

static void REGAL_CALL emu_glDeleteBuffers(GLsizei n, const GLuint *buffers)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
      #if REGAL_EMU_OBJ
      if (_context->obj) break;
      #endif
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glDeleteBuffers( n, buffers );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DeleteBuffers( _context, n, buffers );
      }
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
      #if REGAL_EMU_OBJ
      if (_context->obj)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 15;
        _context->obj->DeleteBuffers(*_context, n, buffers);
        return;
      }
      #endif
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->glDeleteBuffers( _context, n, buffers );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glDeleteBuffers)(n, buffers);
      break;
    }

  }

}

static void REGAL_CALL emu_glGenBuffers(GLsizei n, GLuint *buffers)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
      #if REGAL_EMU_OBJ
      if (_context->obj) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
      #if REGAL_EMU_OBJ
      if (_context->obj)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 15;
        _context->obj->GenBuffers(*_context, n, buffers);
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGenBuffers)(n, buffers);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetBufferParameteriv(GLenum target, GLenum pname, GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreBuffer( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glGetBufferParameteriv)(target, pname, params);
}

static void REGAL_CALL emu_glGetBufferPointerv(GLenum target, GLenum pname, GLvoid **params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreBuffer( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glGetBufferPointerv)(target, pname, params);
}

static void REGAL_CALL emu_glGetBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, GLvoid *data)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreBuffer( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glGetBufferSubData)(target, offset, size, data);
}

static GLboolean REGAL_CALL emu_glIsBuffer(GLuint buffer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
      #if REGAL_EMU_OBJ
      if (_context->obj) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
      #if REGAL_EMU_OBJ
      if (_context->obj)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 15;
        return _context->obj->IsBuffer(*_context, buffer);
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      return _next->call(&_next->glIsBuffer)(buffer);
    }

  }

}

static GLvoid *REGAL_CALL emu_glMapBuffer(GLenum target, GLenum access)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreBuffer( _context );
      }
      #endif
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2())
        {
          DispatchTableGL *_next = _context->dispatcher.emulation.next();
          RegalAssert(_next);
          return _next->call(&_next->glMapBufferOES)(target, access);
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      return _next->call(&_next->glMapBuffer)(target, access);
    }

  }

}

static GLboolean REGAL_CALL emu_glUnmapBuffer(GLenum target)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreBuffer( _context );
      }
      #endif
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2())
        {
          DispatchTableGL *_next = _context->dispatcher.emulation.next();
          RegalAssert(_next);
          return _next->call(&_next->glUnmapBufferOES)(target);
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      return _next->call(&_next->glUnmapBuffer)(target);
    }

  }

}

// GL_VERSION_2_0

static void REGAL_CALL emu_glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glBlendEquationSeparate( modeRGB, modeAlpha );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glBlendEquationSeparate)(modeRGB, modeAlpha);
}

static GLuint REGAL_CALL emu_glCreateShader(GLenum type)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        return _context->iff->CreateShader( _context, type );
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      return _next->call(&_next->glCreateShader)(type);
    }

  }

}

static void REGAL_CALL emu_glDeleteProgram(GLuint program)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DeleteGlslProgram( _context, program );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glDeleteProgram)(program);
}

static void REGAL_CALL emu_glDisableVertexAttribArray(GLuint index)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glDisableVertexAttribArray( index );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glDisableVertexAttribArray( index );
      }
      #endif
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->RestoreVao( _context );
        _context->iff->DisableArray( _context, index );
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        return _context->vao->DisableVertexAttribArray(*_context, index );
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glDisableVertexAttribArray)(index);
      break;
    }

  }

}

static void REGAL_CALL emu_glDrawBuffers(GLsizei n, const GLenum *bufs)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa) break;
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        if( !_context->isES2() ) {
          _context->ppa->glDrawBuffers( n, bufs );
          _context->dispatcher.emulation.glDrawBuffers( n, bufs );
        }
        return;
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->filt->DrawBuffers(*_context, n, bufs))
        {
          #if REGAL_BREAK
          Break::Filter();
          #endif
          return ;
        }
        if (_context->isES2())
        {
          DispatchTableGL *_next = _context->dispatcher.emulation.next();
          RegalAssert(_next);
          if (_context->info->gl_nv_draw_buffers)
          {
            _next->call(&_next->glDrawBuffersNV)(n, bufs);
            return;
          }
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glDrawBuffers)(n, bufs);
      break;
    }

  }

}

static void REGAL_CALL emu_glEnableVertexAttribArray(GLuint index)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glEnableVertexAttribArray( index );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glEnableVertexAttribArray( index );
      }
      #endif
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->RestoreVao( _context );
        _context->iff->EnableArray( _context, index );
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        return _context->vao->EnableVertexAttribArray(*_context, index );
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glEnableVertexAttribArray)(index);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetVertexAttribPointerv(GLuint index, GLenum pname, GLvoid **pointer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->RestoreVao( _context );
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        _context->vao->GetAttrib( index, pname, pointer );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetVertexAttribPointerv)(index, pname, pointer);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetVertexAttribdv(GLuint index, GLenum pname, GLdouble *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->RestoreVao( _context );
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        _context->vao->GetAttrib( index, pname, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetVertexAttribdv)(index, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetVertexAttribfv(GLuint index, GLenum pname, GLfloat *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->RestoreVao( _context );
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        _context->vao->GetAttrib( index, pname, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetVertexAttribfv)(index, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetVertexAttribiv(GLuint index, GLenum pname, GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->RestoreVao( _context );
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        _context->vao->GetAttrib( index, pname, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetVertexAttribiv)(index, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glLinkProgram(GLuint program)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->LinkProgram( _context, program );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glLinkProgram)(program);
      break;
    }

  }

}

static void REGAL_CALL emu_glShaderSource(GLuint shader, GLsizei count, const GLchar * const *string, const GLint *length)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->ShaderSource( _context, shader, count, string, length );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glShaderSource)(shader, count, string, length);
      break;
    }

  }

}

static void REGAL_CALL emu_glStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glStencilFuncSeparate( face, func, ref, mask );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glStencilFuncSeparate)(face, func, ref, mask);
}

static void REGAL_CALL emu_glStencilMaskSeparate(GLenum face, GLuint mask)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glStencilMaskSeparate( face, mask );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glStencilMaskSeparate)(face, mask);
}

static void REGAL_CALL emu_glStencilOpSeparate(GLenum face, GLenum fail, GLenum zfail, GLenum zpass)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glStencilOpSeparate( face, fail, zfail, zpass );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glStencilOpSeparate)(face, fail, zfail, zpass);
}

static void REGAL_CALL emu_glUniform1f(GLint location, GLfloat v0)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGlslProgram( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glUniform1f)(location, v0);
}

static void REGAL_CALL emu_glUniform1fv(GLint location, GLsizei count, const GLfloat *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGlslProgram( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glUniform1fv)(location, count, value);
}

static void REGAL_CALL emu_glUniform1i(GLint location, GLint v0)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGlslProgram( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glUniform1i)(location, v0);
}

static void REGAL_CALL emu_glUniform1iv(GLint location, GLsizei count, const GLint *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGlslProgram( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glUniform1iv)(location, count, value);
}

static void REGAL_CALL emu_glUniform2f(GLint location, GLfloat v0, GLfloat v1)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGlslProgram( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glUniform2f)(location, v0, v1);
}

static void REGAL_CALL emu_glUniform2fv(GLint location, GLsizei count, const GLfloat *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGlslProgram( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glUniform2fv)(location, count, value);
}

static void REGAL_CALL emu_glUniform2i(GLint location, GLint v0, GLint v1)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGlslProgram( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glUniform2i)(location, v0, v1);
}

static void REGAL_CALL emu_glUniform2iv(GLint location, GLsizei count, const GLint *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGlslProgram( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glUniform2iv)(location, count, value);
}

static void REGAL_CALL emu_glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGlslProgram( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glUniform3f)(location, v0, v1, v2);
}

static void REGAL_CALL emu_glUniform3fv(GLint location, GLsizei count, const GLfloat *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGlslProgram( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glUniform3fv)(location, count, value);
}

static void REGAL_CALL emu_glUniform3i(GLint location, GLint v0, GLint v1, GLint v2)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGlslProgram( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glUniform3i)(location, v0, v1, v2);
}

static void REGAL_CALL emu_glUniform3iv(GLint location, GLsizei count, const GLint *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGlslProgram( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glUniform3iv)(location, count, value);
}

static void REGAL_CALL emu_glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGlslProgram( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glUniform4f)(location, v0, v1, v2, v3);
}

static void REGAL_CALL emu_glUniform4fv(GLint location, GLsizei count, const GLfloat *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGlslProgram( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glUniform4fv)(location, count, value);
}

static void REGAL_CALL emu_glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGlslProgram( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glUniform4i)(location, v0, v1, v2, v3);
}

static void REGAL_CALL emu_glUniform4iv(GLint location, GLsizei count, const GLint *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGlslProgram( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glUniform4iv)(location, count, value);
}

static void REGAL_CALL emu_glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGlslProgram( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glUniformMatrix2fv)(location, count, transpose, value);
}

static void REGAL_CALL emu_glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGlslProgram( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glUniformMatrix3fv)(location, count, transpose, value);
}

static void REGAL_CALL emu_glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGlslProgram( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glUniformMatrix4fv)(location, count, transpose, value);
}

static void REGAL_CALL emu_glUseProgram(GLuint program)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        if( ! _context->iff->ShadowUseProgram( program ) ) {
            _context->dispatcher.emulation.glUseProgram( program );
        }
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        if( false == _context->dsa->ShadowGlslProgram( program ) ) {
          _dispatch.call(&_dispatch.glUseProgram)(program);
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glUseProgram)(program);
      break;
    }

  }

}

static void REGAL_CALL emu_glVertexAttrib1d(GLuint index, GLdouble x)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<1>( _context, index, x );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib1d)(index, x);
}

static void REGAL_CALL emu_glVertexAttrib1dv(GLuint index, const GLdouble *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<1>( _context, index, v );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib1dv)(index, v);
}

static void REGAL_CALL emu_glVertexAttrib1f(GLuint index, GLfloat x)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<1>( _context, index, x );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib1f)(index, x);
}

static void REGAL_CALL emu_glVertexAttrib1fv(GLuint index, const GLfloat *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<1>( _context, index, v );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib1fv)(index, v);
}

static void REGAL_CALL emu_glVertexAttrib1s(GLuint index, GLshort x)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<1>( _context, index, x );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib1s)(index, x);
}

static void REGAL_CALL emu_glVertexAttrib1sv(GLuint index, const GLshort *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<1>( _context, index, v );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib1sv)(index, v);
}

static void REGAL_CALL emu_glVertexAttrib2d(GLuint index, GLdouble x, GLdouble y)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<2>( _context, index, x, y );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib2d)(index, x, y);
}

static void REGAL_CALL emu_glVertexAttrib2dv(GLuint index, const GLdouble *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<2>( _context, index, v );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib2dv)(index, v);
}

static void REGAL_CALL emu_glVertexAttrib2f(GLuint index, GLfloat x, GLfloat y)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<2>( _context, index, x, y );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib2f)(index, x, y);
}

static void REGAL_CALL emu_glVertexAttrib2fv(GLuint index, const GLfloat *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<2>( _context, index, v );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib2fv)(index, v);
}

static void REGAL_CALL emu_glVertexAttrib2s(GLuint index, GLshort x, GLshort y)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<2>( _context, index, x, y );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib2s)(index, x, y);
}

static void REGAL_CALL emu_glVertexAttrib2sv(GLuint index, const GLshort *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<2>( _context, index, v );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib2sv)(index, v);
}

static void REGAL_CALL emu_glVertexAttrib3d(GLuint index, GLdouble x, GLdouble y, GLdouble z)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, index, x, y, z );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib3d)(index, x, y, z);
}

static void REGAL_CALL emu_glVertexAttrib3dv(GLuint index, const GLdouble *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, index, v );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib3dv)(index, v);
}

static void REGAL_CALL emu_glVertexAttrib3f(GLuint index, GLfloat x, GLfloat y, GLfloat z)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, index, x, y, z );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib3f)(index, x, y, z);
}

static void REGAL_CALL emu_glVertexAttrib3fv(GLuint index, const GLfloat *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, index, v );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib3fv)(index, v);
}

static void REGAL_CALL emu_glVertexAttrib3s(GLuint index, GLshort x, GLshort y, GLshort z)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, index, x, y, z );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib3s)(index, x, y, z);
}

static void REGAL_CALL emu_glVertexAttrib3sv(GLuint index, const GLshort *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, index, v );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib3sv)(index, v);
}

static void REGAL_CALL emu_glVertexAttrib4Nbv(GLuint index, const GLbyte *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<4>( _context, index, v );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib4Nbv)(index, v);
}

static void REGAL_CALL emu_glVertexAttrib4Niv(GLuint index, const GLint *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<4>( _context, index, v );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib4Niv)(index, v);
}

static void REGAL_CALL emu_glVertexAttrib4Nsv(GLuint index, const GLshort *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<4>( _context, index, v );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib4Nsv)(index, v);
}

static void REGAL_CALL emu_glVertexAttrib4Nub(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<4>( _context, index, x, y, z, w );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib4Nub)(index, x, y, z, w);
}

static void REGAL_CALL emu_glVertexAttrib4Nubv(GLuint index, const GLubyte *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<4>( _context, index, v );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib4Nubv)(index, v);
}

static void REGAL_CALL emu_glVertexAttrib4Nusv(GLuint index, const GLushort *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<4>( _context, index, v );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib4Nusv)(index, v);
}

static void REGAL_CALL emu_glVertexAttrib4bv(GLuint index, const GLbyte *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, index, v );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib4bv)(index, v);
}

static void REGAL_CALL emu_glVertexAttrib4d(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, index, x, y, z, w );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib4d)(index, x, y, z, w);
}

static void REGAL_CALL emu_glVertexAttrib4dv(GLuint index, const GLdouble *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, index, v );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib4dv)(index, v);
}

static void REGAL_CALL emu_glVertexAttrib4f(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, index, x, y, z, w );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib4f)(index, x, y, z, w);
}

static void REGAL_CALL emu_glVertexAttrib4fv(GLuint index, const GLfloat *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, index, v );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib4fv)(index, v);
}

static void REGAL_CALL emu_glVertexAttrib4iv(GLuint index, const GLint *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, index, v );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib4iv)(index, v);
}

static void REGAL_CALL emu_glVertexAttrib4s(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, index, x, y, z, w );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib4s)(index, x, y, z, w);
}

static void REGAL_CALL emu_glVertexAttrib4sv(GLuint index, const GLshort *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, index, v );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib4sv)(index, v);
}

static void REGAL_CALL emu_glVertexAttrib4ubv(GLuint index, const GLubyte *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, index, v );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib4ubv)(index, v);
}

static void REGAL_CALL emu_glVertexAttrib4usv(GLuint index, const GLushort *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, index, v );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib4usv)(index, v);
}

static void REGAL_CALL emu_glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glVertexAttribPointer( index, size, type, normalized, stride, pointer );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glVertexAttribPointer( index, size, type, normalized, stride, pointer );
      }
      #endif
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->RestoreVao( _context );
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        return _context->vao->AttribPointer(*_context, index, size, type, normalized, stride, pointer );
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glVertexAttribPointer)(index, size, type, normalized, stride, pointer);
      break;
    }

  }

}

// GL_VERSION_2_1

static void REGAL_CALL emu_glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGlslProgram( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glUniformMatrix2x3fv)(location, count, transpose, value);
}

static void REGAL_CALL emu_glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGlslProgram( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glUniformMatrix2x4fv)(location, count, transpose, value);
}

static void REGAL_CALL emu_glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGlslProgram( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glUniformMatrix3x2fv)(location, count, transpose, value);
}

static void REGAL_CALL emu_glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGlslProgram( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glUniformMatrix3x4fv)(location, count, transpose, value);
}

static void REGAL_CALL emu_glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGlslProgram( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glUniformMatrix4x2fv)(location, count, transpose, value);
}

static void REGAL_CALL emu_glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGlslProgram( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glUniformMatrix4x3fv)(location, count, transpose, value);
}

// GL_VERSION_3_0

static void REGAL_CALL emu_glClampColor(GLenum target, GLenum clamp)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glClampColor( target, clamp );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glClampColor)(target, clamp);
}

static void REGAL_CALL emu_glColorMaski(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glColorMaski( index, r, g, b, a );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glColorMaski)(index, r, g, b, a);
}

static void REGAL_CALL emu_glDisablei(GLenum cap, GLuint index)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa) break;
      #endif
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glDisablei( cap, index );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glDisablei( cap, index );
      }
      #endif
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        if( ! _context->ppa->Disablei( _context, cap, index ) ) {
          _context->dispatcher.emulation.glDisablei( cap, index );
        }
        return;
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->DisableIndexed( cap, index );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glDisablei)(cap, index);
      break;
    }

  }

}

static void REGAL_CALL emu_glEnablei(GLenum cap, GLuint index)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa) break;
      #endif
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glEnablei( cap, index );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glEnablei( cap, index );
      }
      #endif
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        if( ! _context->ppa->Enablei( _context, cap, index ) ) {
          _context->dispatcher.emulation.glEnablei( cap, index );
        }
        return;
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->EnableIndexed( cap, index );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glEnablei)(cap, index);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetBooleani_v(GLenum target, GLuint index, GLboolean *data)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        if( ! _context->ppa->glGeti_v( _context, target, index, data ) ) {
          _context->dispatcher.emulation.glGetBooleani_v( target, index, data );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetBooleani_v)(target, index, data);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetTexParameterIiv(GLenum target, GLenum pname, GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
      #if REGAL_EMU_TEXSTO
      if (_context->texsto) break;
      #endif
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
      #if REGAL_EMU_TEXSTO
      if (_context->texsto)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 9;
        RegalAssert(_context);
        if ( !_context->texsto->GetTexParameterv( _context, target, pname, params ) ) {
           _context->dispatcher.emulation.glGetTexParameterIiv( target, pname, params );
        }
        return;
      }
      #endif
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        if ( !_context->so->GetTexParameterv( *_context, target, pname, params ) ) {
           _context->dispatcher.emulation.glGetTexParameterIiv( target, pname, params );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetTexParameterIiv)(target, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetTexParameterIuiv(GLenum target, GLenum pname, GLuint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
      #if REGAL_EMU_TEXSTO
      if (_context->texsto) break;
      #endif
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
      #if REGAL_EMU_TEXSTO
      if (_context->texsto)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 9;
        RegalAssert(_context);
        if ( !_context->texsto->GetTexParameterv( _context, target, pname, params ) ) {
           _context->dispatcher.emulation.glGetTexParameterIuiv( target, pname, params );
        }
        return;
      }
      #endif
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        if ( !_context->so->GetTexParameterv( *_context, target, pname, params ) ) {
           _context->dispatcher.emulation.glGetTexParameterIuiv( target, pname, params );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetTexParameterIuiv)(target, pname, params);
      break;
    }

  }

}

static GLboolean REGAL_CALL emu_glIsEnabledi(GLenum target, GLuint index)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        {
          GLboolean enabled;
          if( ! _context->ppa->glIsEnabledi( _context, enabled, target, index ) )
            return _context->dispatcher.emulation.glIsEnabledi( target, index );
          return enabled;
        }
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      return _next->call(&_next->glIsEnabledi)(target, index);
    }

  }

}

static void REGAL_CALL emu_glTexParameterIiv(GLenum target, GLenum pname, const GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        if ( !_context->so->TexParameterv( *_context, target, pname, params ) ) {
           _context->dispatcher.emulation.glTexParameterIiv( target, pname, params );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexParameterIiv)(target, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexParameterIuiv(GLenum target, GLenum pname, const GLuint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        if ( !_context->so->TexParameterv( *_context, target, pname, params ) ) {
           _context->dispatcher.emulation.glTexParameterIuiv( target, pname, params );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexParameterIuiv)(target, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glUniform1ui(GLint location, GLuint v0)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGlslProgram( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glUniform1ui)(location, v0);
}

static void REGAL_CALL emu_glUniform1uiv(GLint location, GLsizei count, const GLuint *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGlslProgram( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glUniform1uiv)(location, count, value);
}

static void REGAL_CALL emu_glUniform2ui(GLint location, GLuint v0, GLuint v1)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGlslProgram( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glUniform2ui)(location, v0, v1);
}

static void REGAL_CALL emu_glUniform2uiv(GLint location, GLsizei count, const GLuint *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGlslProgram( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glUniform2uiv)(location, count, value);
}

static void REGAL_CALL emu_glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGlslProgram( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glUniform3ui)(location, v0, v1, v2);
}

static void REGAL_CALL emu_glUniform3uiv(GLint location, GLsizei count, const GLuint *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGlslProgram( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glUniform3uiv)(location, count, value);
}

static void REGAL_CALL emu_glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGlslProgram( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glUniform4ui)(location, v0, v1, v2, v3);
}

static void REGAL_CALL emu_glUniform4uiv(GLint location, GLsizei count, const GLuint *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGlslProgram( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glUniform4uiv)(location, count, value);
}

static void REGAL_CALL emu_glVertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glVertexAttribIPointer( index, size, type, stride, pointer );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glVertexAttribIPointer( index, size, type, stride, pointer );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttribIPointer)(index, size, type, stride, pointer);
}

// GL_VERSION_3_1

static void REGAL_CALL emu_glDrawArraysInstanced(GLenum mode, GLint start, GLsizei count, GLsizei primcount)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->PreDraw( _context );
      }
      #endif
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        _context->so->PreDraw( *_context );
      }
      #endif
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->Restore( _context );
      }
      #endif
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        // _context->vao->Validate(*_context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glDrawArraysInstanced)(mode, start, count, primcount);
}

static void REGAL_CALL emu_glDrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->PreDraw( _context );
      }
      #endif
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        _context->so->PreDraw( *_context );
      }
      #endif
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->Restore( _context );
      }
      #endif
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        // _context->vao->Validate(*_context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glDrawElementsInstanced)(mode, count, type, indices, primcount);
}

static void REGAL_CALL emu_glPrimitiveRestartIndex(GLuint index)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glPrimitiveRestartIndex( index );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glPrimitiveRestartIndex( index );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glPrimitiveRestartIndex)(index);
}

static void REGAL_CALL emu_glTexBuffer(GLenum target, GLenum internalformat, GLuint buffer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreTexture( _context );
        _context->dsa->RestoreActiveTexture( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glTexBuffer)(target, internalformat, buffer);
}

// GL_VERSION_3_2

static void REGAL_CALL emu_glFramebufferTexture(GLenum target, GLenum attachment, GLuint texture, GLint level)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreFramebuffer( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glFramebufferTexture)(target, attachment, texture, level);
}

// GL_VERSION_3_3

static void REGAL_CALL emu_glVertexAttribDivisor(GLuint index, GLuint divisor)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glVertexAttribDivisor( index, divisor );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glVertexAttribDivisor( index, divisor );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttribDivisor)(index, divisor);
}

// GL_VERSION_4_0

static void REGAL_CALL emu_glBlendEquationSeparatei(GLuint buf, GLenum modeRGB, GLenum modeAlpha)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glBlendEquationSeparatei( buf, modeRGB, modeAlpha );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glBlendEquationSeparatei)(buf, modeRGB, modeAlpha);
}

static void REGAL_CALL emu_glBlendEquationi(GLuint buf, GLenum mode)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glBlendEquationi( buf, mode );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glBlendEquationi)(buf, mode);
}

static void REGAL_CALL emu_glBlendFuncSeparatei(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glBlendFuncSeparatei( buf, srcRGB, dstRGB, srcAlpha, dstAlpha );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glBlendFuncSeparatei)(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
}

static void REGAL_CALL emu_glBlendFunci(GLuint buf, GLenum src, GLenum dst)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glBlendFunci( buf, src, dst );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glBlendFunci)(buf, src, dst);
}

// GL_3DFX_tbuffer

// GL_AMD_debug_output

// GL_AMD_draw_buffers_blend

// GL_AMD_interleaved_elements

// GL_AMD_multi_draw_indirect

static void REGAL_CALL emu_glMultiDrawArraysIndirectAMD(GLenum mode, const GLvoid *indirect, GLsizei primcount, GLsizei stride)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->PreDraw( _context );
      }
      #endif
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        _context->so->PreDraw( *_context );
      }
      #endif
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->Restore( _context );
      }
      #endif
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        // _context->vao->Validate(*_context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glMultiDrawArraysIndirectAMD)(mode, indirect, primcount, stride);
}

static void REGAL_CALL emu_glMultiDrawElementsIndirectAMD(GLenum mode, GLenum type, const GLvoid *indirect, GLsizei primcount, GLsizei stride)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->PreDraw( _context );
      }
      #endif
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        _context->so->PreDraw( *_context );
      }
      #endif
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->Restore( _context );
      }
      #endif
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        // _context->vao->Validate(*_context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glMultiDrawElementsIndirectAMD)(mode, type, indirect, primcount, stride);
}

// GL_AMD_name_gen_delete

// GL_AMD_performance_monitor

// GL_AMD_sample_positions

// GL_AMD_sparse_texture

// GL_AMD_stencil_operation_extended

// GL_AMD_vertex_shader_tessellator

// GL_ANGLE_framebuffer_blit

static void REGAL_CALL emu_glBlitFramebufferANGLE(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2())
        {
          Warning("Regal does not support glBlitFramebufferANGLE for ES 2.0 - skipping.");
          #if REGAL_BREAK
          Break::Filter();
          #endif
          return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glBlitFramebufferANGLE)(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
      break;
    }

  }

}

// GL_ANGLE_framebuffer_multisample

// GL_ANGLE_instanced_arrays

// GL_ANGLE_timer_query

// GL_ANGLE_translated_shader_source

// GL_APPLE_copy_texture_levels

// GL_APPLE_element_array

static void REGAL_CALL emu_glDrawElementArrayAPPLE(GLenum mode, GLint first, GLsizei count)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->PreDraw( _context );
      }
      #endif
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        _context->so->PreDraw( *_context );
      }
      #endif
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->Restore( _context );
      }
      #endif
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        // _context->vao->Validate(*_context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glDrawElementArrayAPPLE)(mode, first, count);
}

static void REGAL_CALL emu_glDrawRangeElementArrayAPPLE(GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->PreDraw( _context );
      }
      #endif
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        _context->so->PreDraw( *_context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glDrawRangeElementArrayAPPLE)(mode, start, end, first, count);
}

static void REGAL_CALL emu_glMultiDrawElementArrayAPPLE(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->PreDraw( _context );
      }
      #endif
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        _context->so->PreDraw( *_context );
      }
      #endif
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->Restore( _context );
      }
      #endif
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        // _context->vao->Validate(*_context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glMultiDrawElementArrayAPPLE)(mode, first, count, primcount);
}

static void REGAL_CALL emu_glMultiDrawRangeElementArrayAPPLE(GLenum mode, GLuint start, GLuint end, const GLint *first, const GLsizei *count, GLsizei primcount)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->PreDraw( _context );
      }
      #endif
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        _context->so->PreDraw( *_context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glMultiDrawRangeElementArrayAPPLE)(mode, start, end, first, count, primcount);
}

// GL_APPLE_fence

// GL_APPLE_flush_buffer_range

// GL_APPLE_flush_render

// GL_APPLE_framebuffer_multisample

// GL_APPLE_object_purgeable

// GL_APPLE_sync

// GL_APPLE_texture_range

// GL_APPLE_vertex_array_object

static void REGAL_CALL emu_glBindVertexArrayAPPLE(GLuint array)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->glBindVertexArray( _context, array );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glBindVertexArrayAPPLE)(array);
}

static void REGAL_CALL emu_glDeleteVertexArraysAPPLE(GLsizei n, const GLuint *arrays)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DeleteVaos( _context, n, arrays );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glDeleteVertexArraysAPPLE)(n, arrays);
}

// GL_APPLE_vertex_array_range

// GL_APPLE_vertex_program_evaluators

// GL_ARB_ES2_compatibility

static void REGAL_CALL emu_glClearDepthf(GLclampf d)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glClearDepth( d );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glClearDepthf)(d);
}

static void REGAL_CALL emu_glDepthRangef(GLclampf n, GLclampf f)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glDepthRange( n, f );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glDepthRangef)(n, f);
}

static void REGAL_CALL emu_glShaderBinary(GLsizei count, const GLuint *shaders, GLenum binaryformat, const GLvoid *binary, GLsizei length)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
      #if REGAL_EMU_BIN
      if (_context->bin) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
      #if REGAL_EMU_BIN
      if (_context->bin)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 11;
        _context->bin->ShaderBinary( _context, count, shaders, binaryformat, binary, length );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glShaderBinary)(count, shaders, binaryformat, binary, length);
      break;
    }

  }

}

// GL_ARB_base_instance

static void REGAL_CALL emu_glDrawElementsInstancedBaseVertexBaseInstance(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount, GLint basevertex, GLuint baseinstance)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        if( ! _context->bv->glDrawElementsInstancedBaseVertexBaseInstance( *_context, mode, count, type, indices, primcount, basevertex, baseinstance ) ) {
          _context->dispatcher.emulation.glDrawElementsInstancedBaseVertexBaseInstance( mode, count, type, indices, primcount, basevertex, baseinstance );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glDrawElementsInstancedBaseVertexBaseInstance)(mode, count, type, indices, primcount, basevertex, baseinstance);
      break;
    }

  }

}

// GL_ARB_bindless_texture

// GL_ARB_blend_func_extended

// GL_ARB_buffer_storage

// GL_ARB_cl_event

// GL_ARB_clear_buffer_object

// GL_ARB_clear_texture

// GL_ARB_color_buffer_float

// GL_ARB_compute_shader

// GL_ARB_compute_variable_group_size

// GL_ARB_copy_buffer

static void REGAL_CALL emu_glCopyBufferSubData(GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreBuffer( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glCopyBufferSubData)(readtarget, writetarget, readoffset, writeoffset, size);
}

// GL_ARB_copy_image

// GL_ARB_debug_output

// GL_ARB_draw_buffers

static void REGAL_CALL emu_glDrawBuffersARB(GLsizei n, const GLenum *bufs)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa) break;
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        if( !_context->isES2() ) {
          _context->ppa->glDrawBuffers( n, bufs );
          _context->dispatcher.emulation.glDrawBuffers( n, bufs );
        }
        return;
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (!_context->info->gl_arb_draw_buffers)
        {
          DispatchTableGL &_table = _context->dispatcher.emulation;
          _context->emuLevel++;
          _table.call(&_table.glDrawBuffers)(n, bufs);
          return;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glDrawBuffersARB)(n, bufs);
      break;
    }

  }

}

// GL_ARB_draw_buffers_blend

// GL_ARB_draw_elements_base_vertex

static void REGAL_CALL emu_glDrawElementsBaseVertex(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLint basevertex)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv) break;
      #endif
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->PreDraw( _context );
      }
      #endif
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        _context->so->PreDraw( *_context );
      }
      #endif
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->Restore( _context );
      }
      #endif
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        // _context->vao->Validate(*_context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        if( ! _context->bv->glDrawElementsBaseVertex( *_context, mode, count, type, indices, basevertex ) ) {
          _context->dispatcher.emulation.glDrawElementsBaseVertex( mode, count, type, indices, basevertex );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glDrawElementsBaseVertex)(mode, count, type, indices, basevertex);
      break;
    }

  }

}

static void REGAL_CALL emu_glDrawElementsInstancedBaseVertex(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount, GLint basevertex)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv) break;
      #endif
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->PreDraw( _context );
      }
      #endif
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        _context->so->PreDraw( *_context );
      }
      #endif
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->Restore( _context );
      }
      #endif
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        // _context->vao->Validate(*_context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        if( ! _context->bv->glDrawElementsInstancedBaseVertex( *_context, mode, count, type, indices, primcount, basevertex ) ) {
          _context->dispatcher.emulation.glDrawElementsInstancedBaseVertex( mode, count, type, indices, primcount, basevertex );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glDrawElementsInstancedBaseVertex)(mode, count, type, indices, primcount, basevertex);
      break;
    }

  }

}

static void REGAL_CALL emu_glDrawRangeElementsBaseVertex(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices, GLint basevertex)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv) break;
      #endif
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->PreDraw( _context );
      }
      #endif
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        _context->so->PreDraw( *_context );
      }
      #endif
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        if( ! _context->bv->glDrawRangeElementsBaseVertex( *_context, mode, start, end, count, type, indices, basevertex ) ) {
          _context->dispatcher.emulation.glDrawRangeElementsBaseVertex( mode, start, end, count, type, indices, basevertex );
        }
        return;
      }
      #endif
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (REGAL_FORCE_ES2_PROFILE || !_context->info->gl_arb_draw_elements_base_vertex)
        {
          if (basevertex==0)
          {
            DispatchTableGL *_next = _context->dispatcher.emulation.next();
            RegalAssert(_next);
            return _next->call(&_next->glDrawElements)(mode, count, type, indices);
          }
          else
          {
            Warning("Regal does not support glDrawRangeElementsBaseVertex (GL_ARB_draw_elements_base_vertex extension not available) for basevertex!=0 for ES 2.0 - skipping.");
            return;
          }
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glDrawRangeElementsBaseVertex)(mode, start, end, count, type, indices, basevertex);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiDrawElementsBaseVertex(GLenum mode, const GLsizei *count, GLenum type, const GLvoid * const *indices, GLsizei primcount, const GLint *basevertex)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv) break;
      #endif
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->PreDraw( _context );
      }
      #endif
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        _context->so->PreDraw( *_context );
      }
      #endif
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->Restore( _context );
      }
      #endif
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        // _context->vao->Validate(*_context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        if( ! _context->bv->glMultiDrawElementsBaseVertex( *_context, mode, count, type, indices, primcount, basevertex ) ) {
          _context->dispatcher.emulation.glMultiDrawElementsBaseVertex( mode, count, type, indices, primcount, basevertex );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiDrawElementsBaseVertex)(mode, count, type, indices, primcount, basevertex);
      break;
    }

  }

}

// GL_ARB_draw_indirect

static void REGAL_CALL emu_glDrawArraysIndirect(GLenum mode, const GLvoid *indirect)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->PreDraw( _context );
      }
      #endif
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        _context->so->PreDraw( *_context );
      }
      #endif
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->Restore( _context );
      }
      #endif
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        // _context->vao->Validate(*_context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glDrawArraysIndirect)(mode, indirect);
}

static void REGAL_CALL emu_glDrawElementsIndirect(GLenum mode, GLenum type, const GLvoid *indirect)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->PreDraw( _context );
      }
      #endif
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        _context->so->PreDraw( *_context );
      }
      #endif
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->Restore( _context );
      }
      #endif
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        // _context->vao->Validate(*_context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glDrawElementsIndirect)(mode, type, indirect);
}

// GL_ARB_draw_instanced

static void REGAL_CALL emu_glDrawArraysInstancedARB(GLenum mode, GLint start, GLsizei count, GLsizei primcount)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->PreDraw( _context );
      }
      #endif
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        _context->so->PreDraw( *_context );
      }
      #endif
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->Restore( _context );
      }
      #endif
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        // _context->vao->Validate(*_context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glDrawArraysInstancedARB)(mode, start, count, primcount);
}

static void REGAL_CALL emu_glDrawElementsInstancedARB(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->PreDraw( _context );
      }
      #endif
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        _context->so->PreDraw( *_context );
      }
      #endif
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->Restore( _context );
      }
      #endif
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        // _context->vao->Validate(*_context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glDrawElementsInstancedARB)(mode, count, type, indices, primcount);
}

// GL_ARB_framebuffer_no_attachments

// GL_ARB_framebuffer_object

static void REGAL_CALL emu_glBindFramebuffer(GLenum target, GLuint framebuffer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        if (!_context->dsa->ShadowFramebuffer( target, framebuffer ) ) {
            _dispatch.call(&_dispatch.glBindFramebuffer)( target, framebuffer );
        }
        return;
      }
      #endif
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2())
        {
          const bool hasFBBlit = _context->info->gl_ext_framebuffer_blit || _context->info->gl_nv_framebuffer_blit || _context->info->gl_version_major >= 3;
          if (!hasFBBlit && (target==GL_DRAW_FRAMEBUFFER || target==GL_READ_FRAMEBUFFER)) target = GL_FRAMEBUFFER;
        }
        if (_context->filt->BindFramebuffer(*_context, target, framebuffer))
        {
          #if REGAL_BREAK
          Break::Filter();
          #endif
          return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glBindFramebuffer)(target, framebuffer);
      break;
    }

  }

}

static void REGAL_CALL emu_glBindRenderbuffer(GLenum target, GLuint renderbuffer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        if (!_context->dsa->ShadowRenderbuffer( target, renderbuffer ) ) {
            _dispatch.call(&_dispatch.glBindRenderbuffer)( target, renderbuffer );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glBindRenderbuffer)(target, renderbuffer);
      break;
    }

  }

}

static void REGAL_CALL emu_glBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2())
        {
          DispatchTableGL *_next = _context->dispatcher.emulation.next();
          RegalAssert(_next);
          if (_context->info->gl_nv_framebuffer_blit)  return _next->call(&_next->glBlitFramebufferNV)(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
          if (_context->info->gl_ext_framebuffer_blit) return _next->call(&_next->glBlitFramebufferEXT)(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glBlitFramebuffer)(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
      break;
    }

  }

}

static void REGAL_CALL emu_glDeleteFramebuffers(GLsizei n, const GLuint *framebuffers)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DeleteFramebuffers( _context, n, framebuffers );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glDeleteFramebuffers)(n, framebuffers);
}

static void REGAL_CALL emu_glDeleteRenderbuffers(GLsizei n, const GLuint *renderbuffers)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DeleteRenderbuffers( _context, n, renderbuffers );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glDeleteRenderbuffers)(n, renderbuffers);
}

static void REGAL_CALL emu_glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreFramebuffer( _context );
      }
      #endif
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        DispatchTableGL *_next = _context->dispatcher.emulation.next();
        RegalAssert(_next);
        if (_context->filt->FramebufferAttachmentSupported(*_context, attachment))
          _next->call(&_next->glFramebufferRenderbuffer)(target, attachment, renderbuffertarget, renderbuffer);
        return;
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glFramebufferRenderbuffer)(target, attachment, renderbuffertarget, renderbuffer);
      break;
    }

  }

}

static void REGAL_CALL emu_glFramebufferTexture1D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
      #if REGAL_EMU_OBJ
      if (_context->obj) break;
      #endif
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreFramebuffer( _context );
      }
      #endif
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
      #if REGAL_EMU_OBJ
      if (_context->obj)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 15;
        _dispatch.call(&_dispatch.glFramebufferTexture1D)(target, attachment, textarget, _context->obj->textureNames.ToDriverName(texture), level);
        return;
      }
      #endif
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        DispatchTableGL *_next = _context->dispatcher.emulation.next();
        RegalAssert(_next);
        if (_context->filt->FramebufferAttachmentSupported(*_context, attachment))
          _next->call(&_next->glFramebufferTexture1D)(target, attachment, textarget, texture, level);
        return;
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glFramebufferTexture1D)(target, attachment, textarget, texture, level);
      break;
    }

  }

}

static void REGAL_CALL emu_glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
      #if REGAL_EMU_OBJ
      if (_context->obj) break;
      #endif
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreFramebuffer( _context );
      }
      #endif
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
      #if REGAL_EMU_OBJ
      if (_context->obj)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 15;
        _dispatch.call(&_dispatch.glFramebufferTexture2D)(target, attachment, textarget, _context->obj->textureNames.ToDriverName(texture), level);
        return;
      }
      #endif
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->filt->FramebufferTexture2D(*_context, target, attachment, textarget, texture, level))
        {
          #if REGAL_BREAK
          Break::Filter();
          #endif
          return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glFramebufferTexture2D)(target, attachment, textarget, texture, level);
      break;
    }

  }

}

static void REGAL_CALL emu_glFramebufferTexture3D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint layer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreFramebuffer( _context );
      }
      #endif
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        DispatchTableGL *_next = _context->dispatcher.emulation.next();
        RegalAssert(_next);
        if (_context->filt->FramebufferAttachmentSupported(*_context, attachment))
          _next->call(&_next->glFramebufferTexture3D)(target, attachment, textarget, texture, level, layer);
        return;
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glFramebufferTexture3D)(target, attachment, textarget, texture, level, layer);
      break;
    }

  }

}

static void REGAL_CALL emu_glFramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreFramebuffer( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glFramebufferTextureLayer)(target, attachment, texture, level, layer);
}

static void REGAL_CALL emu_glGenerateMipmap(GLenum target)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreTexture( _context );
        _context->dsa->RestoreActiveTexture( _context );
      }
      #endif
    case 3 :
    case 2 :
      #if REGAL_EMU_TEXC
      if (_context->texc)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 1;
        _context->texc->ShadowGenerateMipmap( target );
      }
      #endif
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->filt->GenerateMipmap(*_context, target))
        {
          #if REGAL_BREAK
          Break::Filter();
          #endif
          return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGenerateMipmap)(target);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
      #if REGAL_EMU_OBJ
      if (_context->obj) break;
      #endif
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
      #if REGAL_EMU_OBJ
      if (_context->obj)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 15;
        _dispatch.call(&_dispatch.glGetFramebufferAttachmentParameteriv)(target, attachment, pname, params);
        if (pname == GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME)
        {
          GLint attachType = GL_RENDERBUFFER;
          _dispatch.call(&_dispatch.glGetFramebufferAttachmentParameteriv)(target, attachment, GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE, &attachType);
          if (attachType == GL_TEXTURE)
            *params = _context->obj->textureNames.ToAppName(*params);
        }
        return;
      }
      #endif
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        DispatchTableGL *_next = _context->dispatcher.emulation.next();
        RegalAssert(_next);
        if (!_context->filt->FramebufferAttachmentSupported(*_context, attachment))
          *params = 0;
        else
          _next->call(&_next->glGetFramebufferAttachmentParameteriv)(target, attachment, pname, params);
        return;
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetFramebufferAttachmentParameteriv)(target, attachment, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreRenderbuffer( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glGetRenderbufferParameteriv)(target, pname, params);
}

static void REGAL_CALL emu_glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreRenderbuffer( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glRenderbufferStorage)(target, internalformat, width, height);
}

static void REGAL_CALL emu_glRenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreRenderbuffer( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glRenderbufferStorageMultisample)(target, samples, internalformat, width, height);
}

// GL_ARB_geometry_shader4

static void REGAL_CALL emu_glFramebufferTextureARB(GLenum target, GLenum attachment, GLuint texture, GLint level)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreFramebuffer( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glFramebufferTextureARB)(target, attachment, texture, level);
}

static void REGAL_CALL emu_glFramebufferTextureFaceARB(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreFramebuffer( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glFramebufferTextureFaceARB)(target, attachment, texture, level, face);
}

static void REGAL_CALL emu_glFramebufferTextureLayerARB(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreFramebuffer( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glFramebufferTextureLayerARB)(target, attachment, texture, level, layer);
}

// GL_ARB_get_program_binary

// GL_ARB_gpu_shader_fp64

static void REGAL_CALL emu_glUniform1d(GLint location, GLdouble x)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGlslProgram( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glUniform1d)(location, x);
}

static void REGAL_CALL emu_glUniform1dv(GLint location, GLsizei count, const GLdouble *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGlslProgram( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glUniform1dv)(location, count, value);
}

static void REGAL_CALL emu_glUniform2d(GLint location, GLdouble x, GLdouble y)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGlslProgram( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glUniform2d)(location, x, y);
}

static void REGAL_CALL emu_glUniform2dv(GLint location, GLsizei count, const GLdouble *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGlslProgram( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glUniform2dv)(location, count, value);
}

static void REGAL_CALL emu_glUniform3d(GLint location, GLdouble x, GLdouble y, GLdouble z)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGlslProgram( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glUniform3d)(location, x, y, z);
}

static void REGAL_CALL emu_glUniform3dv(GLint location, GLsizei count, const GLdouble *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGlslProgram( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glUniform3dv)(location, count, value);
}

static void REGAL_CALL emu_glUniform4d(GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGlslProgram( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glUniform4d)(location, x, y, z, w);
}

static void REGAL_CALL emu_glUniform4dv(GLint location, GLsizei count, const GLdouble *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGlslProgram( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glUniform4dv)(location, count, value);
}

static void REGAL_CALL emu_glUniformMatrix2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGlslProgram( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glUniformMatrix2dv)(location, count, transpose, value);
}

static void REGAL_CALL emu_glUniformMatrix2x3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGlslProgram( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glUniformMatrix2x3dv)(location, count, transpose, value);
}

static void REGAL_CALL emu_glUniformMatrix2x4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGlslProgram( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glUniformMatrix2x4dv)(location, count, transpose, value);
}

static void REGAL_CALL emu_glUniformMatrix3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGlslProgram( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glUniformMatrix3dv)(location, count, transpose, value);
}

static void REGAL_CALL emu_glUniformMatrix3x2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGlslProgram( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glUniformMatrix3x2dv)(location, count, transpose, value);
}

static void REGAL_CALL emu_glUniformMatrix3x4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGlslProgram( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glUniformMatrix3x4dv)(location, count, transpose, value);
}

static void REGAL_CALL emu_glUniformMatrix4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGlslProgram( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glUniformMatrix4dv)(location, count, transpose, value);
}

static void REGAL_CALL emu_glUniformMatrix4x2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGlslProgram( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glUniformMatrix4x2dv)(location, count, transpose, value);
}

static void REGAL_CALL emu_glUniformMatrix4x3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreGlslProgram( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glUniformMatrix4x3dv)(location, count, transpose, value);
}

// GL_ARB_imaging

static void REGAL_CALL emu_glColorTableParameterfv(GLenum target, GLenum pname, const GLfloat *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glColorTableParameterv( target, pname, params );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glColorTableParameterfv)(target, pname, params);
}

static void REGAL_CALL emu_glColorTableParameteriv(GLenum target, GLenum pname, const GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glColorTableParameterv( target, pname, params );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glColorTableParameteriv)(target, pname, params);
}

static void REGAL_CALL emu_glConvolutionParameterf(GLenum target, GLenum pname, GLfloat params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glConvolutionParameter( target, pname, params );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glConvolutionParameterf)(target, pname, params);
}

static void REGAL_CALL emu_glConvolutionParameterfv(GLenum target, GLenum pname, const GLfloat *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glConvolutionParameterv( target, pname, params );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glConvolutionParameterfv)(target, pname, params);
}

static void REGAL_CALL emu_glConvolutionParameteri(GLenum target, GLenum pname, GLint params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glConvolutionParameter( target, pname, params );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glConvolutionParameteri)(target, pname, params);
}

static void REGAL_CALL emu_glConvolutionParameteriv(GLenum target, GLenum pname, const GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glConvolutionParameterv( target, pname, params );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glConvolutionParameteriv)(target, pname, params);
}

static void REGAL_CALL emu_glGetColorTableParameterfv(GLenum target, GLenum pname, GLfloat *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        if( ! _context->ppa->glGetColorTableParameterv( _context, target, pname, params ) ) {
          _context->dispatcher.emulation.glGetColorTableParameterfv( target, pname, params );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetColorTableParameterfv)(target, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetColorTableParameteriv(GLenum target, GLenum pname, GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        if( ! _context->ppa->glGetColorTableParameterv( _context, target, pname, params ) ) {
          _context->dispatcher.emulation.glGetColorTableParameteriv( target, pname, params );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetColorTableParameteriv)(target, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetConvolutionParameterfv(GLenum target, GLenum pname, GLfloat *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        if( ! _context->ppa->glGetConvolutionParameterv( _context, target, pname, params ) ) {
          _context->dispatcher.emulation.glGetConvolutionParameterfv( target, pname, params );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetConvolutionParameterfv)(target, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetConvolutionParameteriv(GLenum target, GLenum pname, GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        if( ! _context->ppa->glGetConvolutionParameterv( _context, target, pname, params ) ) {
          _context->dispatcher.emulation.glGetConvolutionParameteriv( target, pname, params );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetConvolutionParameteriv)(target, pname, params);
      break;
    }

  }

}

// GL_ARB_indirect_parameters

// GL_ARB_instanced_arrays

// GL_ARB_internalformat_query

// GL_ARB_internalformat_query2

// GL_ARB_invalidate_subdata

// GL_ARB_map_buffer_range

static void REGAL_CALL emu_glFlushMappedBufferRange(GLenum target, GLintptr offset, GLsizeiptr length)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreBuffer( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glFlushMappedBufferRange)(target, offset, length);
}

static GLvoid *REGAL_CALL emu_glMapBufferRange(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreBuffer( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  return _next->call(& _next->glMapBufferRange)(target, offset, length, access);
}

// GL_ARB_matrix_palette

// GL_ARB_multi_bind

static void REGAL_CALL emu_glBindVertexBuffers(GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizei *strides)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glBindVertexBuffers( first, count, buffers, offsets, strides );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glBindVertexBuffers)(first, count, buffers, offsets, strides);
}

// GL_ARB_multi_draw_indirect

static void REGAL_CALL emu_glMultiDrawArraysIndirect(GLenum mode, const GLvoid *indirect, GLsizei primcount, GLsizei stride)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->PreDraw( _context );
      }
      #endif
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        _context->so->PreDraw( *_context );
      }
      #endif
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->Restore( _context );
      }
      #endif
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        // _context->vao->Validate(*_context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glMultiDrawArraysIndirect)(mode, indirect, primcount, stride);
}

static void REGAL_CALL emu_glMultiDrawElementsIndirect(GLenum mode, GLenum type, const GLvoid *indirect, GLsizei primcount, GLsizei stride)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->PreDraw( _context );
      }
      #endif
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        _context->so->PreDraw( *_context );
      }
      #endif
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->Restore( _context );
      }
      #endif
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        // _context->vao->Validate(*_context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glMultiDrawElementsIndirect)(mode, type, indirect, primcount, stride);
}

// GL_ARB_multisample

// GL_ARB_multitexture

static void REGAL_CALL emu_glActiveTextureARB(GLenum texture)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glActiveTexture( texture );
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
      #if REGAL_EMU_XFER
      if (_context->xfer)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 10;
        _context->xfer->ShadowActiveTexture( texture );
      }
      #endif
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->ShadowActiveTexture( texture );
      }
      #endif
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so) break;
      #endif
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 3 :
    case 2 :
      #if REGAL_EMU_TEXC
      if (_context->texc)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 1;
        _context->texc->ShadowActiveTexture( texture );
      }
      #endif
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        if ( !_context->so->ActiveTexture( *_context, texture ) ) {
           _context->dispatcher.emulation.glActiveTexture( texture );
        }
        return;
      }
      #endif
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        if( false == _context->dsa->ShadowActiveTexture( texture ) ) {
            _dispatch.call(&_dispatch.glActiveTexture)( texture );
        }
        return;
      }
      #endif
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (!_context->info->gl_arb_multitexture)
        {
          DispatchTableGL *_next = _context->dispatcher.emulation.next();
          RegalAssert(_next);
          _next->call(&_next->glActiveTexture)(texture);
          return;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glActiveTextureARB)(texture);
      break;
    }

  }

}

static void REGAL_CALL emu_glClientActiveTextureARB(GLenum texture)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glClientActiveTexture( texture );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glClientActiveTexture( texture );
      }
      #endif
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->ShadowClientActiveTexture( texture );
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        _context->vao->ClientActiveTexture(*_context, texture );
      }
      #endif
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        if (!_context->dsa->ShadowClientActiveTexture( texture )) {
          _dispatch.call(&_dispatch.glClientActiveTexture)( texture );
        }
        return;
      }
      #endif
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (!_context->info->gl_arb_multitexture)
        {
          DispatchTableGL &_table = _context->dispatcher.emulation;
          _context->emuLevel++;
          _table.call(&_table.glClientActiveTexture)(texture);
          return;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glClientActiveTextureARB)(texture);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord1dARB(GLenum target, GLdouble s)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<1>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), s );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord1dARB)(target, s);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord1dvARB(GLenum target, const GLdouble *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<1>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord1dvARB)(target, v);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord1fARB(GLenum target, GLfloat s)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<1>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), s );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord1fARB)(target, s);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord1fvARB(GLenum target, const GLfloat *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<1>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord1fvARB)(target, v);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord1iARB(GLenum target, GLint s)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<1>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), s );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord1iARB)(target, s);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord1ivARB(GLenum target, const GLint *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<1>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord1ivARB)(target, v);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord1sARB(GLenum target, GLshort s)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<1>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), s );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord1sARB)(target, s);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord1svARB(GLenum target, const GLshort *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<1>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord1svARB)(target, v);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord2dARB(GLenum target, GLdouble s, GLdouble t)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<2>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), s, t );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord2dARB)(target, s, t);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord2dvARB(GLenum target, const GLdouble *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<2>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord2dvARB)(target, v);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord2fARB(GLenum target, GLfloat s, GLfloat t)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<2>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), s, t );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord2fARB)(target, s, t);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord2fvARB(GLenum target, const GLfloat *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<2>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord2fvARB)(target, v);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord2iARB(GLenum target, GLint s, GLint t)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<2>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), s, t );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord2iARB)(target, s, t);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord2ivARB(GLenum target, const GLint *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<2>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord2ivARB)(target, v);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord2sARB(GLenum target, GLshort s, GLshort t)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<2>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), s, t );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord2sARB)(target, s, t);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord2svARB(GLenum target, const GLshort *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<2>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord2svARB)(target, v);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord3dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), s, t, r );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord3dARB)(target, s, t, r);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord3dvARB(GLenum target, const GLdouble *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord3dvARB)(target, v);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord3fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), s, t, r );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord3fARB)(target, s, t, r);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord3fvARB(GLenum target, const GLfloat *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord3fvARB)(target, v);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord3iARB(GLenum target, GLint s, GLint t, GLint r)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), s, t, r );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord3iARB)(target, s, t, r);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord3ivARB(GLenum target, const GLint *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord3ivARB)(target, v);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord3sARB(GLenum target, GLshort s, GLshort t, GLshort r)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), s, t, r );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord3sARB)(target, s, t, r);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord3svARB(GLenum target, const GLshort *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord3svARB)(target, v);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord4dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), s, t, r, q );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord4dARB)(target, s, t, r, q);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord4dvARB(GLenum target, const GLdouble *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord4dvARB)(target, v);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord4fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), s, t, r, q );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord4fARB)(target, s, t, r, q);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord4fvARB(GLenum target, const GLfloat *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord4fvARB)(target, v);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord4iARB(GLenum target, GLint s, GLint t, GLint r, GLint q)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), s, t, r, q );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord4iARB)(target, s, t, r, q);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord4ivARB(GLenum target, const GLint *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord4ivARB)(target, v);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord4sARB(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), s, t, r, q );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord4sARB)(target, s, t, r, q);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoord4svARB(GLenum target, const GLshort *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, _context->iff->AttrIndex( RFF2A_TexCoord, target - GL_TEXTURE0 ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoord4svARB)(target, v);
      break;
    }

  }

}

// GL_ARB_occlusion_query

// GL_ARB_point_parameters

// GL_ARB_program_interface_query

// GL_ARB_provoking_vertex

static void REGAL_CALL emu_glProvokingVertex(GLenum mode)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glProvokingVertex( mode );
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
      #if REGAL_EMU_QUADS
      if (_context->quads)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 5;
        _context->quads->glProvokingVertex( mode );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glProvokingVertex)(mode);
}

// GL_ARB_robustness

// GL_ARB_sample_shading

static void REGAL_CALL emu_glMinSampleShading(GLclampf value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glMinSampleShading( value );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glMinSampleShading)(value);
}

// GL_ARB_sampler_objects

static void REGAL_CALL emu_glBindSampler(GLuint unit, GLuint sampler)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        _context->so->BindSampler( unit, sampler );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glBindSampler)(unit, sampler);
      break;
    }

  }

}

static void REGAL_CALL emu_glDeleteSamplers(GLsizei count, const GLuint *samplers)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        _context->so->DeleteSamplers( count, samplers );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glDeleteSamplers)(count, samplers);
      break;
    }

  }

}

static void REGAL_CALL emu_glGenSamplers(GLsizei count, GLuint *samplers)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so) break;
      #endif
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        _context->so->GenSamplers( count, samplers );
        return;
      }
      #endif
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2())
        {
          Warning("Regal does not support glGenSamplers for ES 2.0 - skipping.");
          #if REGAL_BREAK
          Break::Filter();
          #endif
          return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGenSamplers)(count, samplers);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetSamplerParameterIiv(GLuint sampler, GLenum pname, GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        if ( !_context->so->GetSamplerParameterv( *_context, sampler, pname, params )) {
           _context->dispatcher.emulation.glGetSamplerParameterIiv( sampler, pname, params );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetSamplerParameterIiv)(sampler, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetSamplerParameterIuiv(GLuint sampler, GLenum pname, GLuint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        if ( !_context->so->GetSamplerParameterv( *_context, sampler, pname, params )) {
           _context->dispatcher.emulation.glGetSamplerParameterIuiv( sampler, pname, params );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetSamplerParameterIuiv)(sampler, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetSamplerParameterfv(GLuint sampler, GLenum pname, GLfloat *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        if ( !_context->so->GetSamplerParameterv( *_context, sampler, pname, params )) {
           _context->dispatcher.emulation.glGetSamplerParameterfv( sampler, pname, params );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetSamplerParameterfv)(sampler, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetSamplerParameteriv(GLuint sampler, GLenum pname, GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        if ( !_context->so->GetSamplerParameterv( *_context, sampler, pname, params )) {
           _context->dispatcher.emulation.glGetSamplerParameteriv( sampler, pname, params );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetSamplerParameteriv)(sampler, pname, params);
      break;
    }

  }

}

static GLboolean REGAL_CALL emu_glIsSampler(GLuint sampler)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        return _context->so->IsSampler( sampler );
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      return _next->call(&_next->glIsSampler)(sampler);
    }

  }

}

static void REGAL_CALL emu_glSamplerParameterIiv(GLuint sampler, GLenum pname, const GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        if ( !_context->so->SamplerParameterv( *_context, sampler, pname, params )) {
           _context->dispatcher.emulation.glSamplerParameterIiv( sampler, pname, params );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glSamplerParameterIiv)(sampler, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glSamplerParameterIuiv(GLuint sampler, GLenum pname, const GLuint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        if ( !_context->so->SamplerParameterv( *_context, sampler, pname, params )) {
           _context->dispatcher.emulation.glSamplerParameterIuiv( sampler, pname, params );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glSamplerParameterIuiv)(sampler, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glSamplerParameterf(GLuint sampler, GLenum pname, GLfloat param)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        if ( !_context->so->SamplerParameter( *_context, sampler, pname, param )) {
           _context->dispatcher.emulation.glSamplerParameterf( sampler, pname, param );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glSamplerParameterf)(sampler, pname, param);
      break;
    }

  }

}

static void REGAL_CALL emu_glSamplerParameterfv(GLuint sampler, GLenum pname, const GLfloat *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        if ( !_context->so->SamplerParameterv( *_context, sampler, pname, params )) {
           _context->dispatcher.emulation.glSamplerParameterfv( sampler, pname, params );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glSamplerParameterfv)(sampler, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glSamplerParameteri(GLuint sampler, GLenum pname, GLint param)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        if ( !_context->so->SamplerParameter( *_context, sampler, pname, param )) {
           _context->dispatcher.emulation.glSamplerParameteri( sampler, pname, param );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glSamplerParameteri)(sampler, pname, param);
      break;
    }

  }

}

static void REGAL_CALL emu_glSamplerParameteriv(GLuint sampler, GLenum pname, const GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        if ( !_context->so->SamplerParameterv( *_context, sampler, pname, params )) {
           _context->dispatcher.emulation.glSamplerParameteriv( sampler, pname, params );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glSamplerParameteriv)(sampler, pname, params);
      break;
    }

  }

}

// GL_ARB_separate_shader_objects

static void REGAL_CALL emu_glBindProgramPipeline(GLuint pipeline)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        if( ! _context->iff->ShadowBindProgramPipeline( pipeline ) ) {
            _context->dispatcher.emulation.glBindProgramPipeline( pipeline );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glBindProgramPipeline)(pipeline);
      break;
    }

  }

}

// GL_ARB_shader_atomic_counters

// GL_ARB_shader_image_load_store

// GL_ARB_shader_objects

static void REGAL_CALL emu_glAttachObjectARB(GLhandleARB containerObj, GLhandleARB obj)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || !_context->info->gl_arb_shader_objects)
        {
          DispatchTableGL *_next = _context->dispatcher.emulation.next();
          RegalAssert(_next);
          _next->call(&_next->glAttachShader)(containerObj, obj);
          return;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glAttachObjectARB)(containerObj, obj);
      break;
    }

  }

}

static void REGAL_CALL emu_glCompileShaderARB(GLhandleARB shaderObj)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || !_context->info->gl_arb_shader_objects)
        {
          DispatchTableGL *_next = _context->dispatcher.emulation.next();
          RegalAssert(_next);
          _next->call(&_next->glCompileShader)(shaderObj);
          return;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glCompileShaderARB)(shaderObj);
      break;
    }

  }

}

static GLhandleARB REGAL_CALL emu_glCreateProgramObjectARB(void)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || !_context->info->gl_arb_shader_objects)
        {
          DispatchTableGL *_next = _context->dispatcher.emulation.next();
          RegalAssert(_next);
          return _next->call(&_next->glCreateProgram)();
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      return _next->call(&_next->glCreateProgramObjectARB)();
    }

  }

}

static GLhandleARB REGAL_CALL emu_glCreateShaderObjectARB(GLenum shaderType)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        return _context->iff->CreateShader( _context, shaderType );
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      return _next->call(&_next->glCreateShaderObjectARB)(shaderType);
    }

  }

}

static void REGAL_CALL emu_glGetInfoLogARB(GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *infoLog)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || !_context->info->gl_arb_shader_objects)
        {
          DispatchTableGL *_next = _context->dispatcher.emulation.next();
          RegalAssert(_next);
          if (_next->call(&_next->glIsProgram)(obj))
            _next->call(&_next->glGetProgramInfoLog)(obj, maxLength, length, infoLog);
          else
            _next->call(&_next->glGetShaderInfoLog)(obj, maxLength, length, infoLog);
          return;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetInfoLogARB)(obj, maxLength, length, infoLog);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetObjectParameterivARB(GLhandleARB obj, GLenum pname, GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || !_context->info->gl_arb_shader_objects)
        {
          DispatchTableGL *_next = _context->dispatcher.emulation.next();
          RegalAssert(_next);
          if (_next->call(&_next->glIsProgram)(obj))
            _next->call(&_next->glGetProgramiv)(obj, pname, params);
          else
            _next->call(&_next->glGetShaderiv)(obj, pname, params);
          return;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetObjectParameterivARB)(obj, pname, params);
      break;
    }

  }

}

static GLint REGAL_CALL emu_glGetUniformLocationARB(GLhandleARB programObj, const GLcharARB *name)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || !_context->info->gl_arb_shader_objects)
        {
          DispatchTableGL *_next = _context->dispatcher.emulation.next();
          RegalAssert(_next);
          return _next->call(&_next->glGetUniformLocation)(programObj, name);
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      return _next->call(&_next->glGetUniformLocationARB)(programObj, name);
    }

  }

}

static void REGAL_CALL emu_glLinkProgramARB(GLhandleARB programObj)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->LinkProgram( _context, programObj );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glLinkProgramARB)(programObj);
      break;
    }

  }

}

static void REGAL_CALL emu_glShaderSourceARB(GLhandleARB shaderObj, GLsizei count, const GLcharARB ** const string, const GLint *length)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->ShaderSource( _context, shaderObj, count, string, length );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glShaderSourceARB)(shaderObj, count, string, length);
      break;
    }

  }

}

static void REGAL_CALL emu_glUniform1iARB(GLint location, GLint v0)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || !_context->info->gl_arb_shader_objects)
        {
          DispatchTableGL *_next = _context->dispatcher.emulation.next();
          RegalAssert(_next);
          _next->call(&_next->glUniform1i)(location, v0);
          return;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glUniform1iARB)(location, v0);
      break;
    }

  }

}

// GL_ARB_shader_storage_buffer_object

// GL_ARB_shader_subroutine

// GL_ARB_shading_language_include

// GL_ARB_sparse_texture

// GL_ARB_sync

static void REGAL_CALL emu_glGetInteger64v(GLenum pname, GLint64 *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so) break;
      #endif
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao) break;
      #endif
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        if ( !_context->so->Get( pname, params ) ) {
           _context->dispatcher.emulation.glGetInteger64v( pname, params );
        }
        return;
      }
      #endif
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        if( !_context->vao->Get( pname, params ) ) {
           _context->dispatcher.emulation.glGetInteger64v( pname, params );
        }
        return;
      }
      #endif
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->filt->Get(*_context, pname, params))
        {
          #if REGAL_BREAK
          Break::Filter();
          #endif
          return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetInteger64v)(pname, params);
      break;
    }

  }

}

// GL_ARB_tessellation_shader

// GL_ARB_texture_buffer_object

// GL_ARB_texture_buffer_range

// GL_ARB_texture_compression

static void REGAL_CALL emu_glCompressedTexImage2DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
      #if REGAL_EMU_XFER
      if (_context->xfer) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
      #if REGAL_EMU_XFER
      if (_context->xfer)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 10;
        _context->xfer->CompressedTexImage2D( _context, target, level, internalformat, width, height, border, imageSize, data );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glCompressedTexImage2DARB)(target, level, internalformat, width, height, border, imageSize, data);
      break;
    }

  }

}

static void REGAL_CALL emu_glCompressedTexSubImage2DARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
      #if REGAL_EMU_XFER
      if (_context->xfer) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
      #if REGAL_EMU_XFER
      if (_context->xfer)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 10;
        _context->xfer->CompressedTexSubImage2D( _context, target, level, xoffset, yoffset, width, height, format, imageSize, data );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glCompressedTexSubImage2DARB)(target, level, xoffset, yoffset, width, height, format, imageSize, data);
      break;
    }

  }

}

// GL_ARB_texture_multisample

static void REGAL_CALL emu_glTexImage2DMultisample(GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->ShadowTexInfo( target, internalformat );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glTexImage2DMultisample)(target, samples, internalformat, width, height, fixedsamplelocations);
}

static void REGAL_CALL emu_glTexImage3DMultisample(GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->ShadowTexInfo( target, internalformat );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glTexImage3DMultisample)(target, samples, internalformat, width, height, depth, fixedsamplelocations);
}

// GL_ARB_texture_storage

static void REGAL_CALL emu_glTexStorage1D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
      #if REGAL_EMU_TEXSTO
      if (_context->texsto) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
      #if REGAL_EMU_TEXSTO
      if (_context->texsto)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 9;
        _context->texsto->TextureStorage( _context, target, levels, internalformat, width );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexStorage1D)(target, levels, internalformat, width);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
      #if REGAL_EMU_TEXSTO
      if (_context->texsto) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
      #if REGAL_EMU_TEXSTO
      if (_context->texsto)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 9;
        _context->texsto->TextureStorage( _context, target, levels, internalformat, width, height );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexStorage2D)(target, levels, internalformat, width, height);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexStorage3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
      #if REGAL_EMU_TEXSTO
      if (_context->texsto) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
      #if REGAL_EMU_TEXSTO
      if (_context->texsto)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 9;
        _context->texsto->TextureStorage( _context, target, levels, internalformat, width, height, depth );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexStorage3D)(target, levels, internalformat, width, height, depth);
      break;
    }

  }

}

static void REGAL_CALL emu_glTextureStorage1DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaTexture( _context, target, texture );
        _dispatch.call(&_dispatch.glTexStorage1D)( target, levels, internalformat, width );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTextureStorage1DEXT)(texture, target, levels, internalformat, width);
      break;
    }

  }

}

static void REGAL_CALL emu_glTextureStorage2DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaTexture( _context, target, texture );
        _dispatch.call(&_dispatch.glTexStorage2D)( target, levels, internalformat, width, height );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTextureStorage2DEXT)(texture, target, levels, internalformat, width, height);
      break;
    }

  }

}

static void REGAL_CALL emu_glTextureStorage3DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaTexture( _context, target, texture );
        _dispatch.call(&_dispatch.glTexStorage3D)( target, levels, internalformat, width, height, depth );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTextureStorage3DEXT)(texture, target, levels, internalformat, width, height, depth);
      break;
    }

  }

}

// GL_ARB_texture_storage_multisample

// GL_ARB_texture_view

// GL_ARB_timer_query

// GL_ARB_transform_feedback2

// GL_ARB_transform_feedback3

// GL_ARB_transform_feedback_instanced

// GL_ARB_transpose_matrix

static void REGAL_CALL emu_glLoadTransposeMatrixdARB(const GLdouble *m)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->LoadTransposeMatrix( m );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glLoadTransposeMatrixdARB)(m);
      break;
    }

  }

}

static void REGAL_CALL emu_glLoadTransposeMatrixfARB(const GLfloat *m)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->LoadTransposeMatrix( m );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glLoadTransposeMatrixfARB)(m);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultTransposeMatrixdARB(const GLdouble *m)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->MultTransposeMatrix( m );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultTransposeMatrixdARB)(m);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultTransposeMatrixfARB(const GLfloat *m)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->MultTransposeMatrix( m );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultTransposeMatrixfARB)(m);
      break;
    }

  }

}

// GL_ARB_uniform_buffer_object

static void REGAL_CALL emu_glGetIntegeri_v(GLenum target, GLuint index, GLint *data)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        if( ! _context->ppa->glGeti_v( _context, target, index, data ) ) {
          _context->dispatcher.emulation.glGetIntegeri_v( target, index, data );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetIntegeri_v)(target, index, data);
      break;
    }

  }

}

// GL_ARB_vertex_array_object

static void REGAL_CALL emu_glBindVertexArray(GLuint array)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
      #if REGAL_EMU_OBJ
      if (_context->obj) break;
      #endif
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glBindVertexArray( array );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glBindVertexArray( array );
      }
      #endif
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->glBindVertexArray( _context, array );
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
      #if REGAL_EMU_OBJ
      if (_context->obj)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 15;
        _context->obj->BindVertexArray(*_context, array);
        return;
      }
      #endif
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        if (!_context->dsa->ShadowVao( array )) {
            _dispatch.call(&_dispatch.glBindVertexArray)( array );
        }
        return;
      }
      #endif
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        _context->vao->BindVertexArray(*_context, array );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glBindVertexArray)(array);
      break;
    }

  }

}

static void REGAL_CALL emu_glDeleteVertexArrays(GLsizei n, const GLuint *arrays)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
      #if REGAL_EMU_OBJ
      if (_context->obj) break;
      #endif
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glDeleteVertexArrays( n, arrays );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DeleteVaos( _context, n, arrays );
      }
      #endif
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
      #if REGAL_EMU_OBJ
      if (_context->obj)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 15;
        _context->obj->DeleteVertexArrays(*_context, n, arrays);
        return;
      }
      #endif
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->glDeleteVertexArrays( _context, n, arrays );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        _context->vao->DeleteVertexArrays( n, arrays );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glDeleteVertexArrays)(n, arrays);
      break;
    }

  }

}

static void REGAL_CALL emu_glGenVertexArrays(GLsizei n, GLuint *arrays)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
      #if REGAL_EMU_OBJ
      if (_context->obj) break;
      #endif
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
      #if REGAL_EMU_OBJ
      if (_context->obj)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 15;
        _context->obj->GenVertexArrays(*_context, n, arrays);
        return;
      }
      #endif
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        _context->vao->GenVertexArrays( n, arrays );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGenVertexArrays)(n, arrays);
      break;
    }

  }

}

static GLboolean REGAL_CALL emu_glIsVertexArray(GLuint array)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
      #if REGAL_EMU_OBJ
      if (_context->obj) break;
      #endif
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
      #if REGAL_EMU_OBJ
      if (_context->obj)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 15;
        return _context->obj->IsVertexArray(*_context, array);
      }
      #endif
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        return _context->iff->IsVertexArray( _context, array );
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        return _context->vao->IsVertexArray( array );
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      return _next->call(&_next->glIsVertexArray)(array);
    }

  }

}

// GL_ARB_vertex_attrib_64bit

static void REGAL_CALL emu_glVertexAttribLPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glVertexAttribLPointer( index, size, type, stride, pointer );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glVertexAttribLPointer( index, size, type, stride, pointer );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttribLPointer)(index, size, type, stride, pointer);
}

// GL_ARB_vertex_attrib_binding

static void REGAL_CALL emu_glBindVertexBuffer(GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glBindVertexBuffer( bindingindex, buffer, offset, stride );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glBindVertexBuffer( bindingindex, buffer, offset, stride );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glBindVertexBuffer)(bindingindex, buffer, offset, stride);
}

static void REGAL_CALL emu_glVertexAttribBinding(GLuint attribindex, GLuint bindingindex)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glVertexAttribBinding( attribindex, bindingindex );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glVertexAttribBinding( attribindex, bindingindex );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttribBinding)(attribindex, bindingindex);
}

static void REGAL_CALL emu_glVertexAttribFormat(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glVertexAttribFormat( attribindex, size, type, normalized, relativeoffset );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glVertexAttribFormat( attribindex, size, type, normalized, relativeoffset );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttribFormat)(attribindex, size, type, normalized, relativeoffset);
}

static void REGAL_CALL emu_glVertexAttribIFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glVertexAttribIFormat( attribindex, size, type, relativeoffset );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glVertexAttribIFormat( attribindex, size, type, relativeoffset );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttribIFormat)(attribindex, size, type, relativeoffset);
}

static void REGAL_CALL emu_glVertexAttribLFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glVertexAttribLFormat( attribindex, size, type, relativeoffset );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glVertexAttribLFormat( attribindex, size, type, relativeoffset );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttribLFormat)(attribindex, size, type, relativeoffset);
}

static void REGAL_CALL emu_glVertexBindingDivisor(GLuint bindingindex, GLuint divisor)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glVertexBindingDivisor( bindingindex, divisor );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glVertexBindingDivisor( bindingindex, divisor );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexBindingDivisor)(bindingindex, divisor);
}

// GL_ARB_vertex_blend

// GL_ARB_vertex_buffer_object

static void REGAL_CALL emu_glBindBufferARB(GLenum target, GLuint buffer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
      #if REGAL_EMU_OBJ
      if (_context->obj) break;
      #endif
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        _context->vao->ShadowBufferBinding( target, buffer );
      }
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
      #if REGAL_EMU_OBJ
      if (_context->obj)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 15;
        _context->obj->BindBuffer(*_context, target, buffer);
        return;
      }
      #endif
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        if (!_context->dsa->ShadowBuffer( target, buffer ) ) {
            _dispatch.call(&_dispatch.glBindBuffer)(target, buffer);
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glBindBufferARB)(target, buffer);
      break;
    }

  }

}

static void REGAL_CALL emu_glBufferDataARB(GLenum target, GLsizeiptrARB size, const GLvoid *data, GLenum usage)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2())
        {
          DispatchTableGL *_next = _context->dispatcher.emulation.next();
          RegalAssert(_next);
          _next->call(&_next->glBufferData)(target, size, data, usage);
          return;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glBufferDataARB)(target, size, data, usage);
      break;
    }

  }

}

static void REGAL_CALL emu_glDeleteBuffersARB(GLsizei n, const GLuint *buffers)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
      #if REGAL_EMU_OBJ
      if (_context->obj) break;
      #endif
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DeleteBuffers( _context, n, buffers );
      }
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
      #if REGAL_EMU_OBJ
      if (_context->obj)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 15;
        _context->obj->DeleteBuffers(*_context, n, buffers);
        return;
      }
      #endif
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->glDeleteBuffers( _context, n, buffers );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glDeleteBuffersARB)(n, buffers);
      break;
    }

  }

}

static void REGAL_CALL emu_glGenBuffersARB(GLsizei n, GLuint *buffers)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
      #if REGAL_EMU_OBJ
      if (_context->obj) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
      #if REGAL_EMU_OBJ
      if (_context->obj)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 15;
        _context->obj->GenBuffers(*_context, n, buffers);
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGenBuffersARB)(n, buffers);
      break;
    }

  }

}

static GLboolean REGAL_CALL emu_glIsBufferARB(GLuint buffer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
      #if REGAL_EMU_OBJ
      if (_context->obj) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
      #if REGAL_EMU_OBJ
      if (_context->obj)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 15;
        return _context->obj->IsBuffer(*_context, buffer);
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      return _next->call(&_next->glIsBufferARB)(buffer);
    }

  }

}

static GLvoid *REGAL_CALL emu_glMapBufferARB(GLenum target, GLenum access)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreBuffer( _context );
      }
      #endif
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2())
        {
          DispatchTableGL *_next = _context->dispatcher.emulation.next();
          RegalAssert(_next);
          return _next->call(&_next->glMapBufferOES)(target, access);
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      return _next->call(&_next->glMapBufferARB)(target, access);
    }

  }

}

static GLboolean REGAL_CALL emu_glUnmapBufferARB(GLenum target)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreBuffer( _context );
      }
      #endif
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2())
        {
          DispatchTableGL *_next = _context->dispatcher.emulation.next();
          RegalAssert(_next);
          return _next->call(&_next->glUnmapBufferOES)(target);
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      return _next->call(&_next->glUnmapBufferARB)(target);
    }

  }

}

// GL_ARB_vertex_program

static void REGAL_CALL emu_glBindProgramARB(GLenum target, GLuint program)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        if (!_context->dsa->ShadowAsmProgram( target, program ) ) {
            _dispatch.call(&_dispatch.glBindProgramARB)( target, program );
        }
        return;
      }
      #endif
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2())
        {
          Warning("Regal does not support glBindProgramARB (GL_ARB_vertex_program) for ES 2.0 context - skipping.");
          return;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glBindProgramARB)(target, program);
      break;
    }

  }

}

static void REGAL_CALL emu_glDeleteProgramsARB(GLsizei n, const GLuint *programs)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DeleteAsmPrograms( _context, n, programs );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glDeleteProgramsARB)(n, programs);
}

static void REGAL_CALL emu_glDisableVertexAttribArrayARB(GLuint index)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->RestoreVao( _context );
        _context->iff->DisableArray( _context, index );
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        return _context->vao->DisableVertexAttribArray(*_context, index );
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glDisableVertexAttribArrayARB)(index);
      break;
    }

  }

}

static void REGAL_CALL emu_glEnableVertexAttribArrayARB(GLuint index)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->RestoreVao( _context );
        _context->iff->EnableArray( _context, index );
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        return _context->vao->EnableVertexAttribArray(*_context, index );
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glEnableVertexAttribArrayARB)(index);
      break;
    }

  }

}

static void REGAL_CALL emu_glGenProgramsARB(GLsizei n, GLuint *programs)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2())
        {
          Warning("Regal does not support glGenProgramsARB (GL_ARB_vertex_program) for ES 2.0 context - skipping.");
          return;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGenProgramsARB)(n, programs);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetProgramEnvParameterdvARB(GLenum target, GLuint index, GLdouble *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreAsmProgram( _context, target );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glGetProgramEnvParameterdvARB)(target, index, params);
}

static void REGAL_CALL emu_glGetProgramEnvParameterfvARB(GLenum target, GLuint index, GLfloat *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreAsmProgram( _context, target );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glGetProgramEnvParameterfvARB)(target, index, params);
}

static void REGAL_CALL emu_glGetProgramLocalParameterdvARB(GLenum target, GLuint index, GLdouble *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreAsmProgram( _context, target );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glGetProgramLocalParameterdvARB)(target, index, params);
}

static void REGAL_CALL emu_glGetProgramLocalParameterfvARB(GLenum target, GLuint index, GLfloat *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreAsmProgram( _context, target );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glGetProgramLocalParameterfvARB)(target, index, params);
}

static void REGAL_CALL emu_glGetProgramivARB(GLenum target, GLenum pname, GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2())
        {
          Warning("Regal does not support glGetProgramivARB (GL_ARB_vertex_program) for ES 2.0 context - skipping.");
          return;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetProgramivARB)(target, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetVertexAttribPointervARB(GLuint index, GLenum pname, GLvoid **pointer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->RestoreVao( _context );
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        _context->vao->GetAttrib( index, pname, pointer );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetVertexAttribPointervARB)(index, pname, pointer);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetVertexAttribdvARB(GLuint index, GLenum pname, GLdouble *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->RestoreVao( _context );
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        _context->vao->GetAttrib( index, pname, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetVertexAttribdvARB)(index, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetVertexAttribfvARB(GLuint index, GLenum pname, GLfloat *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->RestoreVao( _context );
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        _context->vao->GetAttrib( index, pname, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetVertexAttribfvARB)(index, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetVertexAttribivARB(GLuint index, GLenum pname, GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->RestoreVao( _context );
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        _context->vao->GetAttrib( index, pname, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetVertexAttribivARB)(index, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glProgramEnvParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreAsmProgram( _context, target );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glProgramEnvParameter4dARB)(target, index, x, y, z, w);
}

static void REGAL_CALL emu_glProgramEnvParameter4dvARB(GLenum target, GLuint index, const GLdouble *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreAsmProgram( _context, target );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glProgramEnvParameter4dvARB)(target, index, params);
}

static void REGAL_CALL emu_glProgramEnvParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreAsmProgram( _context, target );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glProgramEnvParameter4fARB)(target, index, x, y, z, w);
}

static void REGAL_CALL emu_glProgramEnvParameter4fvARB(GLenum target, GLuint index, const GLfloat *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreAsmProgram( _context, target );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glProgramEnvParameter4fvARB)(target, index, params);
}

static void REGAL_CALL emu_glProgramLocalParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreAsmProgram( _context, target );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glProgramLocalParameter4dARB)(target, index, x, y, z, w);
}

static void REGAL_CALL emu_glProgramLocalParameter4dvARB(GLenum target, GLuint index, const GLdouble *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreAsmProgram( _context, target );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glProgramLocalParameter4dvARB)(target, index, params);
}

static void REGAL_CALL emu_glProgramLocalParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreAsmProgram( _context, target );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glProgramLocalParameter4fARB)(target, index, x, y, z, w);
}

static void REGAL_CALL emu_glProgramLocalParameter4fvARB(GLenum target, GLuint index, const GLfloat *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreAsmProgram( _context, target );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glProgramLocalParameter4fvARB)(target, index, params);
}

static void REGAL_CALL emu_glProgramStringARB(GLenum target, GLenum format, GLsizei len, const GLvoid *string)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2())
        {
          Warning("Regal does not support glProgramStringARB (GL_ARB_vertex_program) for ES 2.0 context - skipping.");
          return;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glProgramStringARB)(target, format, len, string);
      break;
    }

  }

}

static void REGAL_CALL emu_glVertexAttrib1dARB(GLuint index, GLdouble x)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<1>( _context, index, x );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib1dARB)(index, x);
}

static void REGAL_CALL emu_glVertexAttrib1dvARB(GLuint index, const GLdouble *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<1>( _context, index, v );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib1dvARB)(index, v);
}

static void REGAL_CALL emu_glVertexAttrib1fARB(GLuint index, GLfloat x)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<1>( _context, index, x );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib1fARB)(index, x);
}

static void REGAL_CALL emu_glVertexAttrib1fvARB(GLuint index, const GLfloat *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<1>( _context, index, v );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib1fvARB)(index, v);
}

static void REGAL_CALL emu_glVertexAttrib1sARB(GLuint index, GLshort x)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<1>( _context, index, x );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib1sARB)(index, x);
}

static void REGAL_CALL emu_glVertexAttrib1svARB(GLuint index, const GLshort *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<1>( _context, index, v );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib1svARB)(index, v);
}

static void REGAL_CALL emu_glVertexAttrib2dARB(GLuint index, GLdouble x, GLdouble y)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<2>( _context, index, x, y );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib2dARB)(index, x, y);
}

static void REGAL_CALL emu_glVertexAttrib2dvARB(GLuint index, const GLdouble *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<2>( _context, index, v );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib2dvARB)(index, v);
}

static void REGAL_CALL emu_glVertexAttrib2fARB(GLuint index, GLfloat x, GLfloat y)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<2>( _context, index, x, y );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib2fARB)(index, x, y);
}

static void REGAL_CALL emu_glVertexAttrib2fvARB(GLuint index, const GLfloat *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<2>( _context, index, v );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib2fvARB)(index, v);
}

static void REGAL_CALL emu_glVertexAttrib2sARB(GLuint index, GLshort x, GLshort y)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<2>( _context, index, x, y );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib2sARB)(index, x, y);
}

static void REGAL_CALL emu_glVertexAttrib2svARB(GLuint index, const GLshort *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<2>( _context, index, v );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib2svARB)(index, v);
}

static void REGAL_CALL emu_glVertexAttrib3dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, index, x, y, z );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib3dARB)(index, x, y, z);
}

static void REGAL_CALL emu_glVertexAttrib3dvARB(GLuint index, const GLdouble *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, index, v );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib3dvARB)(index, v);
}

static void REGAL_CALL emu_glVertexAttrib3fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, index, x, y, z );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib3fARB)(index, x, y, z);
}

static void REGAL_CALL emu_glVertexAttrib3fvARB(GLuint index, const GLfloat *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, index, v );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib3fvARB)(index, v);
}

static void REGAL_CALL emu_glVertexAttrib3sARB(GLuint index, GLshort x, GLshort y, GLshort z)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, index, x, y, z );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib3sARB)(index, x, y, z);
}

static void REGAL_CALL emu_glVertexAttrib3svARB(GLuint index, const GLshort *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, index, v );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib3svARB)(index, v);
}

static void REGAL_CALL emu_glVertexAttrib4NbvARB(GLuint index, const GLbyte *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<4>( _context, index, v );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib4NbvARB)(index, v);
}

static void REGAL_CALL emu_glVertexAttrib4NivARB(GLuint index, const GLint *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<4>( _context, index, v );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib4NivARB)(index, v);
}

static void REGAL_CALL emu_glVertexAttrib4NsvARB(GLuint index, const GLshort *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<4>( _context, index, v );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib4NsvARB)(index, v);
}

static void REGAL_CALL emu_glVertexAttrib4NubARB(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<4>( _context, index, x, y, z, w );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib4NubARB)(index, x, y, z, w);
}

static void REGAL_CALL emu_glVertexAttrib4NubvARB(GLuint index, const GLubyte *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<4>( _context, index, v );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib4NubvARB)(index, v);
}

static void REGAL_CALL emu_glVertexAttrib4NusvARB(GLuint index, const GLushort *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<4>( _context, index, v );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib4NusvARB)(index, v);
}

static void REGAL_CALL emu_glVertexAttrib4bvARB(GLuint index, const GLbyte *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, index, v );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib4bvARB)(index, v);
}

static void REGAL_CALL emu_glVertexAttrib4dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, index, x, y, z, w );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib4dARB)(index, x, y, z, w);
}

static void REGAL_CALL emu_glVertexAttrib4dvARB(GLuint index, const GLdouble *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, index, v );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib4dvARB)(index, v);
}

static void REGAL_CALL emu_glVertexAttrib4fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, index, x, y, z, w );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib4fARB)(index, x, y, z, w);
}

static void REGAL_CALL emu_glVertexAttrib4fvARB(GLuint index, const GLfloat *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, index, v );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib4fvARB)(index, v);
}

static void REGAL_CALL emu_glVertexAttrib4ivARB(GLuint index, const GLint *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, index, v );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib4ivARB)(index, v);
}

static void REGAL_CALL emu_glVertexAttrib4sARB(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, index, x, y, z, w );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib4sARB)(index, x, y, z, w);
}

static void REGAL_CALL emu_glVertexAttrib4svARB(GLuint index, const GLshort *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, index, v );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib4svARB)(index, v);
}

static void REGAL_CALL emu_glVertexAttrib4ubvARB(GLuint index, const GLubyte *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, index, v );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib4ubvARB)(index, v);
}

static void REGAL_CALL emu_glVertexAttrib4usvARB(GLuint index, const GLushort *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<4>( _context, index, v );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glVertexAttrib4usvARB)(index, v);
}

static void REGAL_CALL emu_glVertexAttribPointerARB(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->RestoreVao( _context );
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        return _context->vao->AttribPointer(*_context, index, size, type, normalized, stride, pointer );
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glVertexAttribPointerARB)(index, size, type, normalized, stride, pointer);
      break;
    }

  }

}

// GL_ARB_vertex_shader

static void REGAL_CALL emu_glBindAttribLocationARB(GLhandleARB programObj, GLuint index, const GLcharARB *name)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2() || !_context->info->gl_arb_shader_objects)
        {
          DispatchTableGL *_next = _context->dispatcher.emulation.next();
          RegalAssert(_next);
          _next->call(&_next->glBindAttribLocation)(programObj, index, name);
          return;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glBindAttribLocationARB)(programObj, index, name);
      break;
    }

  }

}

// GL_ARB_vertex_type_2_10_10_10_rev

// GL_ARB_viewport_array

static void REGAL_CALL emu_glDepthRangeArrayv(GLuint first, GLsizei count, const GLclampd *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glDepthRangeArrayv( first, count, v );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glDepthRangeArrayv)(first, count, v);
}

static void REGAL_CALL emu_glDepthRangeIndexed(GLuint index, GLclampd n, GLclampd f)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glDepthRangeIndexed( index, n, f );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glDepthRangeIndexed)(index, n, f);
}

static void REGAL_CALL emu_glGetDoublei_v(GLenum target, GLuint index, GLdouble *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa) break;
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        if( ! _context->ppa->glGeti_v( _context, target, index, v ) ) {
          _context->dispatcher.emulation.glGetDoublei_v( target, index, v );
        }
        return;
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        if ( ! _context->dsa->GetIndexedv( _context, target, index, v ) ) {
          _dispatch.call(&_dispatch.glGetDoublei_v)(target, index, v);
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetDoublei_v)(target, index, v);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetFloati_v(GLenum target, GLuint index, GLfloat *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa) break;
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        if( ! _context->ppa->glGeti_v( _context, target, index, v ) ) {
          _context->dispatcher.emulation.glGetFloati_v( target, index, v );
        }
        return;
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        if ( ! _context->dsa->GetIndexedv( _context, target, index, v ) ) {
          _dispatch.call(&_dispatch.glGetFloati_v)(target, index, v);
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetFloati_v)(target, index, v);
      break;
    }

  }

}

static void REGAL_CALL emu_glScissorArrayv(GLuint first, GLsizei count, const GLint *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glScissorArrayv( first, count, v );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glScissorArrayv)(first, count, v);
}

static void REGAL_CALL emu_glScissorIndexed(GLuint index, GLint left, GLint bottom, GLint width, GLint height)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glScissorIndexed( index, left, bottom, width, height );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glScissorIndexed)(index, left, bottom, width, height);
}

static void REGAL_CALL emu_glScissorIndexedv(GLuint index, const GLint *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glScissorIndexedv( index, v );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glScissorIndexedv)(index, v);
}

static void REGAL_CALL emu_glViewportArrayv(GLuint first, GLsizei count, const GLfloat *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glViewportArrayv( first, count, v );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glViewportArrayv)(first, count, v);
}

static void REGAL_CALL emu_glViewportIndexedf(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glViewportIndexedf( index, x, y, w, h );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glViewportIndexedf)(index, x, y, w, h);
}

static void REGAL_CALL emu_glViewportIndexedfv(GLuint index, const GLfloat *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glViewportIndexedfv( index, v );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glViewportIndexedfv)(index, v);
}

// GL_ARB_window_pos

// GL_ATI_draw_buffers

static void REGAL_CALL emu_glDrawBuffersATI(GLsizei n, const GLenum *bufs)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (!_context->info->gl_ati_draw_buffers)
        {
          DispatchTableGL &_table = _context->dispatcher.emulation;
          _context->emuLevel++;
          _table.call(&_table.glDrawBuffers)(n, bufs);
          return;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glDrawBuffersATI)(n, bufs);
      break;
    }

  }

}

// GL_ATI_element_array

static void REGAL_CALL emu_glDrawElementArrayATI(GLenum mode, GLsizei count)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->PreDraw( _context );
      }
      #endif
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        _context->so->PreDraw( *_context );
      }
      #endif
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->Restore( _context );
      }
      #endif
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        // _context->vao->Validate(*_context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glDrawElementArrayATI)(mode, count);
}

static void REGAL_CALL emu_glDrawRangeElementArrayATI(GLenum mode, GLuint start, GLuint end, GLsizei count)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->PreDraw( _context );
      }
      #endif
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        _context->so->PreDraw( *_context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glDrawRangeElementArrayATI)(mode, start, end, count);
}

// GL_ATI_envmap_bumpmap

// GL_ATI_fragment_shader

// GL_ATI_map_object_buffer

// GL_ATI_pn_triangles

// GL_ATI_separate_stencil

// GL_ATI_vertex_array_object

// GL_ATI_vertex_attrib_array_object

// GL_ATI_vertex_streams

// GL_EXT_bindable_uniform

// GL_EXT_blend_color

static void REGAL_CALL emu_glBlendColorEXT(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2())
        {
          DispatchTableGL *_next = _context->dispatcher.emulation.next();
          RegalAssert(_next);
          _next->call(&_next->glBlendColor)(red, green, blue, alpha);
          return;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glBlendColorEXT)(red, green, blue, alpha);
      break;
    }

  }

}

// GL_EXT_blend_equation_separate

// GL_EXT_blend_func_separate

// GL_EXT_blend_minmax

static void REGAL_CALL emu_glBlendEquationEXT(GLenum mode)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2())
        {
          DispatchTableGL *_next = _context->dispatcher.emulation.next();
          RegalAssert(_next);
          _next->call(&_next->glBlendEquation)(mode);
          return;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glBlendEquationEXT)(mode);
      break;
    }

  }

}

// GL_EXT_color_subtable

// GL_EXT_compiled_vertex_array

// GL_EXT_convolution

// GL_EXT_coordinate_frame

// GL_EXT_copy_texture

// GL_EXT_cull_vertex

// GL_EXT_debug_label

// GL_EXT_debug_marker

// GL_EXT_depth_bounds_test

// GL_EXT_direct_state_access

static void REGAL_CALL emu_glBindMultiTextureEXT(GLenum texunit, GLenum target, GLuint texture)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->ShadowMultiTexBinding( texunit, target, texture );
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaActiveTexture( _context, texunit );
        _context->dsa->ShadowDsaTexture( target, texture );
        _dispatch.call(&_dispatch.glBindTexture)( target, texture );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glBindMultiTextureEXT)(texunit, target, texture);
      break;
    }

  }

}

static GLenum REGAL_CALL emu_glCheckNamedFramebufferStatusEXT(GLuint framebuffer, GLenum target)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaFramebuffer( _context, GL_FRAMEBUFFER, framebuffer);
        return _dispatch.call(&_dispatch.glCheckFramebufferStatus)( target );
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      return _next->call(&_next->glCheckNamedFramebufferStatusEXT)(framebuffer, target);
    }

  }

}

static void REGAL_CALL emu_glClientAttribDefaultEXT(GLbitfield mask)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca) break;
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glClientAttribDefaultEXT( *_context, mask );
        return;
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->ClientAttribDefault( _context, mask );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glClientAttribDefaultEXT)(mask);
      break;
    }

  }

}

static void REGAL_CALL emu_glCompressedMultiTexImage1DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaActiveTexture( _context, texunit );
        _dispatch.call(&_dispatch.glCompressedTexImage1D)( target, level, internalformat, width, border, imageSize, data );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glCompressedMultiTexImage1DEXT)(texunit, target, level, internalformat, width, border, imageSize, data);
      break;
    }

  }

}

static void REGAL_CALL emu_glCompressedMultiTexImage2DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *bits)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaActiveTexture( _context, texunit );
        _dispatch.call(&_dispatch.glCompressedTexImage2D)( target, level, internalformat, width, height, border, imageSize, bits );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glCompressedMultiTexImage2DEXT)(texunit, target, level, internalformat, width, height, border, imageSize, bits);
      break;
    }

  }

}

static void REGAL_CALL emu_glCompressedMultiTexImage3DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *bits)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaActiveTexture( _context, texunit );
        _dispatch.call(&_dispatch.glCompressedTexImage3D)( target, level, internalformat, width, height, depth, border, imageSize, bits );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glCompressedMultiTexImage3DEXT)(texunit, target, level, internalformat, width, height, depth, border, imageSize, bits);
      break;
    }

  }

}

static void REGAL_CALL emu_glCompressedMultiTexSubImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaActiveTexture( _context, texunit );
        _dispatch.call(&_dispatch.glCompressedTexSubImage1D)( target, level, xoffset, width, format, imageSize, data );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glCompressedMultiTexSubImage1DEXT)(texunit, target, level, xoffset, width, format, imageSize, data);
      break;
    }

  }

}

static void REGAL_CALL emu_glCompressedMultiTexSubImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaActiveTexture( _context, texunit );
        _dispatch.call(&_dispatch.glCompressedTexSubImage2D)( target, level, xoffset, yoffset, width, height, format, imageSize, data );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glCompressedMultiTexSubImage2DEXT)(texunit, target, level, xoffset, yoffset, width, height, format, imageSize, data);
      break;
    }

  }

}

static void REGAL_CALL emu_glCompressedMultiTexSubImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaActiveTexture( _context, texunit );
        _dispatch.call(&_dispatch.glCompressedTexSubImage3D)( target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glCompressedMultiTexSubImage3DEXT)(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
      break;
    }

  }

}

static void REGAL_CALL emu_glCompressedTextureImage1DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *bits)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaTexture( _context, target, texture );
        _dispatch.call(&_dispatch.glCompressedTexImage1D)( target, level, internalformat, width, border, imageSize, bits );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glCompressedTextureImage1DEXT)(texture, target, level, internalformat, width, border, imageSize, bits);
      break;
    }

  }

}

static void REGAL_CALL emu_glCompressedTextureImage2DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *bits)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaTexture( _context, target, texture );
        _dispatch.call(&_dispatch.glCompressedTexImage2D)( target, level, internalformat, width, height, border, imageSize, bits );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glCompressedTextureImage2DEXT)(texture, target, level, internalformat, width, height, border, imageSize, bits);
      break;
    }

  }

}

static void REGAL_CALL emu_glCompressedTextureImage3DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *bits)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaTexture( _context, target, texture );
        _dispatch.call(&_dispatch.glCompressedTexImage3D)( target, level, internalformat, width, height, depth, border, imageSize, bits );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glCompressedTextureImage3DEXT)(texture, target, level, internalformat, width, height, depth, border, imageSize, bits);
      break;
    }

  }

}

static void REGAL_CALL emu_glCompressedTextureSubImage1DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *bits)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaTexture( _context, target, texture );
        _dispatch.call(&_dispatch.glCompressedTexSubImage1D)( target, level, xoffset, width, format, imageSize, bits );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glCompressedTextureSubImage1DEXT)(texture, target, level, xoffset, width, format, imageSize, bits);
      break;
    }

  }

}

static void REGAL_CALL emu_glCompressedTextureSubImage2DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *bits)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaTexture( _context, target, texture );
        _dispatch.call(&_dispatch.glCompressedTexSubImage2D)( target, level, xoffset, yoffset, width, height, format, imageSize, bits );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glCompressedTextureSubImage2DEXT)(texture, target, level, xoffset, yoffset, width, height, format, imageSize, bits);
      break;
    }

  }

}

static void REGAL_CALL emu_glCompressedTextureSubImage3DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *bits)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaTexture( _context, target, texture );
        _dispatch.call(&_dispatch.glCompressedTexSubImage3D)( target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glCompressedTextureSubImage3DEXT)(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits);
      break;
    }

  }

}

static void REGAL_CALL emu_glCopyMultiTexImage1DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaActiveTexture( _context, texunit );
        _dispatch.call(&_dispatch.glCopyTexImage1D)( target, level, internalformat, x, y, width, border );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glCopyMultiTexImage1DEXT)(texunit, target, level, internalformat, x, y, width, border);
      break;
    }

  }

}

static void REGAL_CALL emu_glCopyMultiTexImage2DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaActiveTexture( _context, texunit );
        _dispatch.call(&_dispatch.glCopyTexImage2D)( target, level, internalformat, x, y, width, height, border );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glCopyMultiTexImage2DEXT)(texunit, target, level, internalformat, x, y, width, height, border);
      break;
    }

  }

}

static void REGAL_CALL emu_glCopyMultiTexSubImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaActiveTexture( _context, texunit );
        _dispatch.call(&_dispatch.glCopyTexSubImage1D)( target, level, xoffset, x, y, width );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glCopyMultiTexSubImage1DEXT)(texunit, target, level, xoffset, x, y, width);
      break;
    }

  }

}

static void REGAL_CALL emu_glCopyMultiTexSubImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaActiveTexture( _context, texunit );
        _dispatch.call(&_dispatch.glCopyTexSubImage2D)( target, level, xoffset, yoffset, x, y, width, height );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glCopyMultiTexSubImage2DEXT)(texunit, target, level, xoffset, yoffset, x, y, width, height);
      break;
    }

  }

}

static void REGAL_CALL emu_glCopyMultiTexSubImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaActiveTexture( _context, texunit );
        _dispatch.call(&_dispatch.glCopyTexSubImage3D)( target, level, xoffset, yoffset, zoffset, x, y, width, height );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glCopyMultiTexSubImage3DEXT)(texunit, target, level, xoffset, yoffset, zoffset, x, y, width, height);
      break;
    }

  }

}

static void REGAL_CALL emu_glCopyTextureImage1DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaTexture( _context, target, texture );
        _dispatch.call(&_dispatch.glCopyTexImage1D)( target, level, internalformat, x, y, width, border );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glCopyTextureImage1DEXT)(texture, target, level, internalformat, x, y, width, border);
      break;
    }

  }

}

static void REGAL_CALL emu_glCopyTextureImage2DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaTexture( _context, target, texture );
        _dispatch.call(&_dispatch.glCopyTexImage2D)( target, level, internalformat, x, y, width, height, border );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glCopyTextureImage2DEXT)(texture, target, level, internalformat, x, y, width, height, border);
      break;
    }

  }

}

static void REGAL_CALL emu_glCopyTextureSubImage1DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaTexture( _context, target, texture );
        _dispatch.call(&_dispatch.glCopyTexSubImage1D)( target, level, xoffset, x, y, width );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glCopyTextureSubImage1DEXT)(texture, target, level, xoffset, x, y, width);
      break;
    }

  }

}

static void REGAL_CALL emu_glCopyTextureSubImage2DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaTexture( _context, target, texture );
        _dispatch.call(&_dispatch.glCopyTexSubImage2D)( target, level, xoffset, yoffset, x, y, width, height );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glCopyTextureSubImage2DEXT)(texture, target, level, xoffset, yoffset, x, y, width, height);
      break;
    }

  }

}

static void REGAL_CALL emu_glCopyTextureSubImage3DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaTexture( _context, target, texture );
        _dispatch.call(&_dispatch.glCopyTexSubImage3D)( target, level, xoffset, yoffset, zoffset, x, y, width, height );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glCopyTextureSubImage3DEXT)(texture, target, level, xoffset, yoffset, zoffset, x, y, width, height);
      break;
    }

  }

}

static void REGAL_CALL emu_glDisableClientStateIndexedEXT(GLenum array, GLuint index)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glDisableClientStateIndexedEXT( array, index );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glDisableClientStateIndexedEXT( array, index );
      }
      #endif
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaClientActiveTexture( _context, index + GL_TEXTURE0 );
        _dispatch.call(&_dispatch.glDisableClientState)( array );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glDisableClientStateIndexedEXT)(array, index);
      break;
    }

  }

}

static void REGAL_CALL emu_glDisableClientStateiEXT(GLenum array, GLuint index)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glDisableClientStateiEXT( array, index );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glDisableClientStateiEXT( array, index );
      }
      #endif
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaClientActiveTexture( _context, index + GL_TEXTURE0 );
        _dispatch.call(&_dispatch.glDisableClientState)( array );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glDisableClientStateiEXT)(array, index);
      break;
    }

  }

}

static void REGAL_CALL emu_glDisableVertexArrayAttribEXT(GLuint vaobj, GLenum array)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glDisableVertexArrayAttribEXT( vaobj, array );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glDisableVertexArrayAttribEXT( vaobj, array );
      }
      #endif
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaVao( _context, vaobj );
        _dispatch.call(&_dispatch.glDisableVertexAttribArray)( array );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glDisableVertexArrayAttribEXT)(vaobj, array);
      break;
    }

  }

}

static void REGAL_CALL emu_glDisableVertexArrayEXT(GLuint vaobj, GLenum array)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glDisableVertexArrayEXT( vaobj, array );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glDisableVertexArrayEXT( vaobj, array );
      }
      #endif
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaVao( _context, vaobj );
        if ( array >= GL_TEXTURE0 && array <= GL_TEXTURE31) {
          _context->dsa->DsaClientActiveTexture( _context, array );
          _dispatch.call(&_dispatch.glDisableClientState)( GL_TEXTURE_COORD_ARRAY );
        } else {
          _dispatch.call(&_dispatch.glDisableClientState)( array );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glDisableVertexArrayEXT)(vaobj, array);
      break;
    }

  }

}

static void REGAL_CALL emu_glEnableClientStateIndexedEXT(GLenum array, GLuint index)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glEnableClientStateIndexedEXT( array, index );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glEnableClientStateIndexedEXT( array, index );
      }
      #endif
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaClientActiveTexture( _context, index + GL_TEXTURE0 );
        _dispatch.call(&_dispatch.glEnableClientState)( array );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glEnableClientStateIndexedEXT)(array, index);
      break;
    }

  }

}

static void REGAL_CALL emu_glEnableClientStateiEXT(GLenum array, GLuint index)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glEnableClientStateiEXT( array, index );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glEnableClientStateiEXT( array, index );
      }
      #endif
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaClientActiveTexture( _context, index + GL_TEXTURE0 );
        _dispatch.call(&_dispatch.glEnableClientState)( array );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glEnableClientStateiEXT)(array, index);
      break;
    }

  }

}

static void REGAL_CALL emu_glEnableVertexArrayAttribEXT(GLuint vaobj, GLenum array)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glEnableVertexArrayAttribEXT( vaobj, array );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glEnableVertexArrayAttribEXT( vaobj, array );
      }
      #endif
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaVao( _context, vaobj );
        _dispatch.call(&_dispatch.glEnableVertexAttribArray)( array );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glEnableVertexArrayAttribEXT)(vaobj, array);
      break;
    }

  }

}

static void REGAL_CALL emu_glEnableVertexArrayEXT(GLuint vaobj, GLenum array)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glEnableVertexArrayEXT( vaobj, array );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glEnableVertexArrayEXT( vaobj, array );
      }
      #endif
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaVao( _context, vaobj );
        if ( array >= GL_TEXTURE0 && array <= GL_TEXTURE31) {
          _context->dsa->DsaClientActiveTexture( _context, array );
          _dispatch.call(&_dispatch.glEnableClientState)( GL_TEXTURE_COORD_ARRAY );
        } else {
          _dispatch.call(&_dispatch.glEnableClientState)( array );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glEnableVertexArrayEXT)(vaobj, array);
      break;
    }

  }

}

static void REGAL_CALL emu_glFlushMappedNamedBufferRangeEXT(GLuint buffer, GLintptr offset, GLsizeiptr length)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaBuffer( _context, buffer);
        _dispatch.call(&_dispatch.glFlushMappedBufferRange)( GL_ARRAY_BUFFER, offset, length );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glFlushMappedNamedBufferRangeEXT)(buffer, offset, length);
      break;
    }

  }

}

static void REGAL_CALL emu_glFramebufferDrawBufferEXT(GLuint framebuffer, GLenum mode)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaFramebuffer( _context, GL_FRAMEBUFFER, framebuffer);
        _dispatch.call(&_dispatch.glDrawBuffer)( mode );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glFramebufferDrawBufferEXT)(framebuffer, mode);
      break;
    }

  }

}

static void REGAL_CALL emu_glFramebufferDrawBuffersEXT(GLuint framebuffer, GLsizei n, const GLenum *bufs)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaFramebuffer( _context, GL_FRAMEBUFFER, framebuffer);
        _dispatch.call(&_dispatch.glDrawBuffers)( n, bufs );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glFramebufferDrawBuffersEXT)(framebuffer, n, bufs);
      break;
    }

  }

}

static void REGAL_CALL emu_glFramebufferReadBufferEXT(GLuint framebuffer, GLenum mode)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaFramebuffer( _context, GL_FRAMEBUFFER, framebuffer);
        _dispatch.call(&_dispatch.glReadBuffer)( mode );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glFramebufferReadBufferEXT)(framebuffer, mode);
      break;
    }

  }

}

static void REGAL_CALL emu_glGenerateMultiTexMipmapEXT(GLenum texunit, GLenum target)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaActiveTexture( _context, texunit );
        _dispatch.call(&_dispatch.glGenerateMipmap)( target );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGenerateMultiTexMipmapEXT)(texunit, target);
      break;
    }

  }

}

static void REGAL_CALL emu_glGenerateTextureMipmapEXT(GLuint texture, GLenum target)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaTexture( _context, target, texture );
        _dispatch.call(&_dispatch.glGenerateMipmap)( target );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGenerateTextureMipmapEXT)(texture, target);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetCompressedMultiTexImageEXT(GLenum texunit, GLenum target, GLint lod, GLvoid *img)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaActiveTexture( _context, texunit );
        _dispatch.call(&_dispatch.glGetCompressedTexImage)( target, lod, img );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetCompressedMultiTexImageEXT)(texunit, target, lod, img);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetCompressedTextureImageEXT(GLuint texture, GLenum target, GLint lod, GLvoid *img)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaTexture( _context, target, texture );
        _dispatch.call(&_dispatch.glGetCompressedTexImage)( target, lod, img );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetCompressedTextureImageEXT)(texture, target, lod, img);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetDoubleIndexedvEXT(GLenum target, GLuint index, GLdouble *data)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        if ( ! _context->dsa->GetIndexedv( _context, target, index, data ) ) {
          _dispatch.call(&_dispatch.glGetDoubleIndexedvEXT)(target, index, data);
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetDoubleIndexedvEXT)(target, index, data);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetDoublei_vEXT(GLenum target, GLuint index, GLdouble *data)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa) break;
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        if( ! _context->ppa->glGeti_v( _context, target, index, data ) ) {
          _context->dispatcher.emulation.glGetDoublei_vEXT( target, index, data );
        }
        return;
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        if ( ! _context->dsa->GetIndexedv( _context, target, index, data ) ) {
          _dispatch.call(&_dispatch.glGetDoublei_vEXT)(target, index, data);
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetDoublei_vEXT)(target, index, data);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetFloatIndexedvEXT(GLenum target, GLuint index, GLfloat *data)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        if ( ! _context->dsa->GetIndexedv( _context, target, index, data ) ) {
          _dispatch.call(&_dispatch.glGetFloatIndexedvEXT)(target, index, data);
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetFloatIndexedvEXT)(target, index, data);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetFloati_vEXT(GLenum target, GLuint index, GLfloat *data)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa) break;
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        if( ! _context->ppa->glGeti_v( _context, target, index, data ) ) {
          _context->dispatcher.emulation.glGetFloati_vEXT( target, index, data );
        }
        return;
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        if ( ! _context->dsa->GetIndexedv( _context, target, index, data ) ) {
          _dispatch.call(&_dispatch.glGetFloati_vEXT)(target, index, data);
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetFloati_vEXT)(target, index, data);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetFramebufferParameterivEXT(GLuint framebuffer, GLenum pname, GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaFramebuffer( _context, GL_FRAMEBUFFER, framebuffer );
        _dispatch.call(&_dispatch.glGetIntegerv)(pname, params);
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetFramebufferParameterivEXT)(framebuffer, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetMultiTexEnvfvEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa) break;
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        if( ! _context->ppa->glGetMultiTexEnvv( _context, texunit, target, pname, params ) ) {
          _context->dispatcher.emulation.glGetMultiTexEnvfvEXT( texunit, target, pname, params );
        }
        return;
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaActiveTexture( _context, texunit );
        _dispatch.call(&_dispatch.glGetTexEnvfv)( target, pname, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetMultiTexEnvfvEXT)(texunit, target, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetMultiTexEnvivEXT(GLenum texunit, GLenum target, GLenum pname, GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa) break;
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        if( ! _context->ppa->glGetMultiTexEnvv( _context, texunit, target, pname, params ) ) {
          _context->dispatcher.emulation.glGetMultiTexEnvivEXT( texunit, target, pname, params );
        }
        return;
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaActiveTexture( _context, texunit );
        _dispatch.call(&_dispatch.glGetTexEnviv)( target, pname, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetMultiTexEnvivEXT)(texunit, target, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetMultiTexGendvEXT(GLenum texunit, GLenum coord, GLenum pname, GLdouble *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->RestoreVao( _context );
        if ( ! _context->iff->GetMultiTexGenv( _context, texunit, coord, pname, params ) ) {
            _context->dispatcher.emulation.glGetMultiTexGendvEXT( texunit, coord, pname, params );
        }
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaActiveTexture( _context, texunit );
        _dispatch.call(&_dispatch.glGetTexGendv)( coord, pname, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetMultiTexGendvEXT)(texunit, coord, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetMultiTexGenfvEXT(GLenum texunit, GLenum coord, GLenum pname, GLfloat *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->RestoreVao( _context );
        if ( ! _context->iff->GetMultiTexGenv( _context, texunit, coord, pname, params ) ) {
            _context->dispatcher.emulation.glGetMultiTexGenfvEXT( texunit, coord, pname, params );
        }
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaActiveTexture( _context, texunit );
        _dispatch.call(&_dispatch.glGetTexGenfv)( coord, pname, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetMultiTexGenfvEXT)(texunit, coord, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetMultiTexGenivEXT(GLenum texunit, GLenum coord, GLenum pname, GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->RestoreVao( _context );
        if ( ! _context->iff->GetMultiTexGenv( _context, texunit, coord, pname, params ) ) {
            _context->dispatcher.emulation.glGetMultiTexGenivEXT( texunit, coord, pname, params );
        }
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaActiveTexture( _context, texunit );
        _dispatch.call(&_dispatch.glGetTexGeniv)( coord, pname, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetMultiTexGenivEXT)(texunit, coord, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetMultiTexImageEXT(GLenum texunit, GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaActiveTexture( _context, texunit );
        _dispatch.call(&_dispatch.glGetTexImage)( target, level, format, type, pixels );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetMultiTexImageEXT)(texunit, target, level, format, type, pixels);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetMultiTexLevelParameterfvEXT(GLenum texunit, GLenum target, GLint level, GLenum pname, GLfloat *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaActiveTexture( _context, texunit );
        _dispatch.call(&_dispatch.glGetTexLevelParameterfv)( target, level, pname, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetMultiTexLevelParameterfvEXT)(texunit, target, level, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetMultiTexLevelParameterivEXT(GLenum texunit, GLenum target, GLint level, GLenum pname, GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaActiveTexture( _context, texunit );
        _dispatch.call(&_dispatch.glGetTexLevelParameteriv)( target, level, pname, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetMultiTexLevelParameterivEXT)(texunit, target, level, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetMultiTexParameterIivEXT(GLenum texunit, GLenum target, GLenum pname, GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaActiveTexture( _context, texunit );
        _dispatch.call(&_dispatch.glGetTexParameterIiv)( target, pname, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetMultiTexParameterIivEXT)(texunit, target, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetMultiTexParameterIuivEXT(GLenum texunit, GLenum target, GLenum pname, GLuint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaActiveTexture( _context, texunit );
        _dispatch.call(&_dispatch.glGetTexParameterIuiv)( target, pname, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetMultiTexParameterIuivEXT)(texunit, target, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetMultiTexParameterfvEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaActiveTexture( _context, texunit );
        _dispatch.call(&_dispatch.glGetTexParameterfv)( target, pname, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetMultiTexParameterfvEXT)(texunit, target, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetMultiTexParameterivEXT(GLenum texunit, GLenum target, GLenum pname, GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaActiveTexture( _context, texunit );
        _dispatch.call(&_dispatch.glGetTexParameteriv)( target, pname, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetMultiTexParameterivEXT)(texunit, target, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetNamedBufferParameterivEXT(GLuint buffer, GLenum pname, GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaBuffer( _context, buffer);
        _dispatch.call(&_dispatch.glGetBufferParameteriv)( GL_ARRAY_BUFFER, pname, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetNamedBufferParameterivEXT)(buffer, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetNamedBufferPointervEXT(GLuint buffer, GLenum pname, GLvoid **params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaBuffer( _context, buffer);
        _dispatch.call(&_dispatch.glGetBufferPointerv)( GL_ARRAY_BUFFER, pname, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetNamedBufferPointervEXT)(buffer, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetNamedBufferSubDataEXT(GLuint buffer, GLintptr offset, GLsizeiptr size, GLvoid *data)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaBuffer( _context, buffer);
        _dispatch.call(&_dispatch.glGetBufferSubData)( GL_ARRAY_BUFFER, offset, size, data );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetNamedBufferSubDataEXT)(buffer, offset, size, data);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetNamedFramebufferAttachmentParameterivEXT(GLuint framebuffer, GLenum attachment, GLenum pname, GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaFramebuffer( _context, GL_FRAMEBUFFER, framebuffer);
        _dispatch.call(&_dispatch.glGetFramebufferAttachmentParameteriv)( GL_FRAMEBUFFER, attachment, pname, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetNamedFramebufferAttachmentParameterivEXT)(framebuffer, attachment, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetNamedProgramLocalParameterIivEXT(GLuint program, GLenum target, GLuint index, GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaAsmProgram( _context, target, program);
        _dispatch.call(&_dispatch.glGetProgramLocalParameterIivNV)( target, index, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetNamedProgramLocalParameterIivEXT)(program, target, index, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetNamedProgramLocalParameterIuivEXT(GLuint program, GLenum target, GLuint index, GLuint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaAsmProgram( _context, target, program);
        _dispatch.call(&_dispatch.glGetProgramLocalParameterIuivNV)( target, index, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetNamedProgramLocalParameterIuivEXT)(program, target, index, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetNamedProgramLocalParameterdvEXT(GLuint program, GLenum target, GLuint index, GLdouble *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaAsmProgram( _context, target, program);
        _dispatch.call(&_dispatch.glGetProgramLocalParameterdvARB)( target, index, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetNamedProgramLocalParameterdvEXT)(program, target, index, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetNamedProgramLocalParameterfvEXT(GLuint program, GLenum target, GLuint index, GLfloat *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaAsmProgram( _context, target, program);
        _dispatch.call(&_dispatch.glGetProgramLocalParameterfvARB)( target, index, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetNamedProgramLocalParameterfvEXT)(program, target, index, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetNamedProgramStringEXT(GLuint program, GLenum target, GLenum pname, GLvoid *string)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaAsmProgram( _context, target, program);
        _dispatch.call(&_dispatch.glGetProgramStringARB)( target, pname, string );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetNamedProgramStringEXT)(program, target, pname, string);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetNamedProgramivEXT(GLuint program, GLenum target, GLenum pname, GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaAsmProgram( _context, target, program);
        _dispatch.call(&_dispatch.glGetProgramivARB)( target, pname, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetNamedProgramivEXT)(program, target, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetNamedRenderbufferParameterivEXT(GLuint renderbuffer, GLenum pname, GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaRenderbuffer( _context, GL_RENDERBUFFER, renderbuffer);
        _dispatch.call(&_dispatch.glGetRenderbufferParameteriv)( GL_RENDERBUFFER, pname, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetNamedRenderbufferParameterivEXT)(renderbuffer, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetPointerIndexedvEXT(GLenum target, GLuint index, GLvoid **data)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        // if ( ! _context->dsa->GetIndexedv( _context, target, index, data ) ) {
        //     _dispatch.call(&_dispatch.glGetPointerIndexedvEXT)(target, index, data);
        // }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetPointerIndexedvEXT)(target, index, data);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetTextureImageEXT(GLuint texture, GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaTexture( _context, target, texture );
        _dispatch.call(&_dispatch.glGetTexImage)( target, level, format, type, pixels );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetTextureImageEXT)(texture, target, level, format, type, pixels);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetTextureLevelParameterfvEXT(GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaTexture( _context, target, texture );
        _dispatch.call(&_dispatch.glGetTexLevelParameterfv)( target, level, pname, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetTextureLevelParameterfvEXT)(texture, target, level, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetTextureLevelParameterivEXT(GLuint texture, GLenum target, GLint level, GLenum pname, GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaTexture( _context, target, texture );
        _dispatch.call(&_dispatch.glGetTexLevelParameteriv)( target, level, pname, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetTextureLevelParameterivEXT)(texture, target, level, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetTextureParameterIivEXT(GLuint texture, GLenum target, GLenum pname, GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaTexture( _context, target, texture );
        _dispatch.call(&_dispatch.glGetTexParameterIiv)( target, pname, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetTextureParameterIivEXT)(texture, target, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetTextureParameterIuivEXT(GLuint texture, GLenum target, GLenum pname, GLuint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaTexture( _context, target, texture );
        _dispatch.call(&_dispatch.glGetTexParameterIuiv)( target, pname, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetTextureParameterIuivEXT)(texture, target, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetTextureParameterfvEXT(GLuint texture, GLenum target, GLenum pname, GLfloat *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaTexture( _context, target, texture );
        _dispatch.call(&_dispatch.glGetTexParameterfv)( target, pname, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetTextureParameterfvEXT)(texture, target, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetTextureParameterivEXT(GLuint texture, GLenum target, GLenum pname, GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaTexture( _context, target, texture );
        _dispatch.call(&_dispatch.glGetTexParameteriv)( target, pname, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetTextureParameterivEXT)(texture, target, pname, params);
      break;
    }

  }

}

static GLvoid *REGAL_CALL emu_glMapNamedBufferEXT(GLuint buffer, GLenum access)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaBuffer( _context, buffer);
        return _dispatch.call(&_dispatch.glMapBuffer)( GL_ARRAY_BUFFER, access );
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      return _next->call(&_next->glMapNamedBufferEXT)(buffer, access);
    }

  }

}

static GLvoid *REGAL_CALL emu_glMapNamedBufferRangeEXT(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaBuffer( _context, buffer);
        return _dispatch.call(&_dispatch.glMapBufferRange)( GL_ARRAY_BUFFER, offset, length, access );
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      return _next->call(&_next->glMapNamedBufferRangeEXT)(buffer, offset, length, access);
    }

  }

}

static void REGAL_CALL emu_glMatrixFrustumEXT(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->MatrixFrustum( mode, left, right, bottom, top, zNear, zFar );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaMatrixMode( _context, mode );
        _dispatch.call(&_dispatch.glFrustum)(left, right, bottom, top, zNear, zFar);
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMatrixFrustumEXT)(mode, left, right, bottom, top, zNear, zFar);
      break;
    }

  }

}

static void REGAL_CALL emu_glMatrixLoadIdentityEXT(GLenum mode)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->MatrixLoadIdentity( mode );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaMatrixMode( _context, mode );
        _dispatch.call(&_dispatch.glLoadIdentity)();
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMatrixLoadIdentityEXT)(mode);
      break;
    }

  }

}

static void REGAL_CALL emu_glMatrixLoadTransposedEXT(GLenum mode, const GLdouble *m)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->MatrixLoadTranspose( mode, m );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaMatrixMode( _context, mode );
        _dispatch.call(&_dispatch.glLoadTransposeMatrixd)(m);
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMatrixLoadTransposedEXT)(mode, m);
      break;
    }

  }

}

static void REGAL_CALL emu_glMatrixLoadTransposefEXT(GLenum mode, const GLfloat *m)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->MatrixLoadTranspose( mode, m );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaMatrixMode( _context, mode );
        _dispatch.call(&_dispatch.glLoadTransposeMatrixf)(m);
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMatrixLoadTransposefEXT)(mode, m);
      break;
    }

  }

}

static void REGAL_CALL emu_glMatrixLoaddEXT(GLenum mode, const GLdouble *m)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->MatrixLoad( mode, m );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaMatrixMode( _context, mode );
        _dispatch.call(&_dispatch.glLoadMatrixd)(m);
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMatrixLoaddEXT)(mode, m);
      break;
    }

  }

}

static void REGAL_CALL emu_glMatrixLoadfEXT(GLenum mode, const GLfloat *m)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->MatrixLoad( mode, m );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaMatrixMode( _context, mode );
        _dispatch.call(&_dispatch.glLoadMatrixf)(m);
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMatrixLoadfEXT)(mode, m);
      break;
    }

  }

}

static void REGAL_CALL emu_glMatrixMultTransposedEXT(GLenum mode, const GLdouble *m)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->MatrixMultTranspose( mode, m );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaMatrixMode( _context, mode );
        _dispatch.call(&_dispatch.glMultTransposeMatrixd)(m);
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMatrixMultTransposedEXT)(mode, m);
      break;
    }

  }

}

static void REGAL_CALL emu_glMatrixMultTransposefEXT(GLenum mode, const GLfloat *m)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->MatrixMultTranspose( mode, m );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaMatrixMode( _context, mode );
        _dispatch.call(&_dispatch.glMultTransposeMatrixf)(m);
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMatrixMultTransposefEXT)(mode, m);
      break;
    }

  }

}

static void REGAL_CALL emu_glMatrixMultdEXT(GLenum mode, const GLdouble *m)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->MatrixMult( mode, m );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaMatrixMode( _context, mode );
        _dispatch.call(&_dispatch.glMultMatrixd)(m);
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMatrixMultdEXT)(mode, m);
      break;
    }

  }

}

static void REGAL_CALL emu_glMatrixMultfEXT(GLenum mode, const GLfloat *m)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->MatrixMult( mode, m );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaMatrixMode( _context, mode );
        _dispatch.call(&_dispatch.glMultMatrixf)(m);
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMatrixMultfEXT)(mode, m);
      break;
    }

  }

}

static void REGAL_CALL emu_glMatrixOrthoEXT(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->MatrixOrtho( mode, left, right, bottom, top, zNear, zFar );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaMatrixMode( _context, mode );
        _dispatch.call(&_dispatch.glOrtho)(left, right, bottom, top, zNear, zFar);
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMatrixOrthoEXT)(mode, left, right, bottom, top, zNear, zFar);
      break;
    }

  }

}

static void REGAL_CALL emu_glMatrixPopEXT(GLenum mode)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->MatrixPop( mode );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaMatrixMode( _context, mode );
        _dispatch.call(&_dispatch.glPopMatrix)();
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMatrixPopEXT)(mode);
      break;
    }

  }

}

static void REGAL_CALL emu_glMatrixPushEXT(GLenum mode)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->MatrixPush( mode );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaMatrixMode( _context, mode );
        _dispatch.call(&_dispatch.glPushMatrix)();
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMatrixPushEXT)(mode);
      break;
    }

  }

}

static void REGAL_CALL emu_glMatrixRotatedEXT(GLenum mode, GLdouble angle, GLdouble x, GLdouble y, GLdouble z)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->MatrixRotate( mode, angle, x, y, z );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaMatrixMode( _context, mode );
        _dispatch.call(&_dispatch.glRotated)(angle, x, y, z);
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMatrixRotatedEXT)(mode, angle, x, y, z);
      break;
    }

  }

}

static void REGAL_CALL emu_glMatrixRotatefEXT(GLenum mode, GLfloat angle, GLfloat x, GLfloat y, GLfloat z)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->MatrixRotate( mode, angle, x, y, z );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaMatrixMode( _context, mode );
        _dispatch.call(&_dispatch.glRotatef)(angle, x, y, z);
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMatrixRotatefEXT)(mode, angle, x, y, z);
      break;
    }

  }

}

static void REGAL_CALL emu_glMatrixScaledEXT(GLenum mode, GLdouble x, GLdouble y, GLdouble z)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->MatrixScale( mode, x, y, z );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaMatrixMode( _context, mode );
        _dispatch.call(&_dispatch.glScaled)(x, y, z);
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMatrixScaledEXT)(mode, x, y, z);
      break;
    }

  }

}

static void REGAL_CALL emu_glMatrixScalefEXT(GLenum mode, GLfloat x, GLfloat y, GLfloat z)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->MatrixScale( mode, x, y, z );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaMatrixMode( _context, mode );
        _dispatch.call(&_dispatch.glScalef)(x, y, z);
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMatrixScalefEXT)(mode, x, y, z);
      break;
    }

  }

}

static void REGAL_CALL emu_glMatrixTranslatedEXT(GLenum mode, GLdouble x, GLdouble y, GLdouble z)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->MatrixTranslate( mode, x, y, z );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaMatrixMode( _context, mode );
        _dispatch.call(&_dispatch.glTranslated)(x, y, z);
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMatrixTranslatedEXT)(mode, x, y, z);
      break;
    }

  }

}

static void REGAL_CALL emu_glMatrixTranslatefEXT(GLenum mode, GLfloat x, GLfloat y, GLfloat z)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->MatrixTranslate( mode, x, y, z );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaMatrixMode( _context, mode );
        _dispatch.call(&_dispatch.glTranslatef)(x, y, z);
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMatrixTranslatefEXT)(mode, x, y, z);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexBufferEXT(GLenum texunit, GLenum target, GLenum internalformat, GLuint buffer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaActiveTexture( _context, texunit );
        _dispatch.call(&_dispatch.glTexBuffer)( target, internalformat, buffer );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexBufferEXT)(texunit, target, internalformat, buffer);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexCoordPointerEXT(GLenum texunit, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glMultiTexCoordPointerEXT( texunit, size, type, stride, pointer );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glMultiTexCoordPointerEXT( texunit, size, type, stride, pointer );
      }
      #endif
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaClientActiveTexture( _context, texunit );
        _dispatch.call(&_dispatch.glTexCoordPointer)( size, type, stride, pointer );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexCoordPointerEXT)(texunit, size, type, stride, pointer);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexEnvfEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat param)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glMultiTexEnv( texunit, target, pname, param );
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->TexEnv( texunit, target, pname, param );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaActiveTexture( _context, texunit );
        _dispatch.call(&_dispatch.glTexEnvf)( target, pname, param );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexEnvfEXT)(texunit, target, pname, param);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexEnvfvEXT(GLenum texunit, GLenum target, GLenum pname, const GLfloat *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glMultiTexEnvv( texunit, target, pname, params );
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->TexEnv( texunit, target, pname, params );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaActiveTexture( _context, texunit );
        _dispatch.call(&_dispatch.glTexEnvfv)( target, pname, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexEnvfvEXT)(texunit, target, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexEnviEXT(GLenum texunit, GLenum target, GLenum pname, GLint param)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glMultiTexEnv( texunit, target, pname, param );
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->TexEnv( texunit, target, pname, param );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaActiveTexture( _context, texunit );
        _dispatch.call(&_dispatch.glTexEnvi)( target, pname, param );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexEnviEXT)(texunit, target, pname, param);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexEnvivEXT(GLenum texunit, GLenum target, GLenum pname, const GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        _context->ppa->glMultiTexEnvv( texunit, target, pname, params );
      }
      #endif
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->TexEnv( texunit, target, pname, params );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaActiveTexture( _context, texunit );
        _dispatch.call(&_dispatch.glTexEnviv)( target, pname, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexEnvivEXT)(texunit, target, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexGendEXT(GLenum texunit, GLenum coord, GLenum pname, GLdouble param)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaActiveTexture( _context, texunit );
        _dispatch.call(&_dispatch.glTexGend)( coord, pname, param );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexGendEXT)(texunit, coord, pname, param);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexGendvEXT(GLenum texunit, GLenum coord, GLenum pname, const GLdouble *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaActiveTexture( _context, texunit );
        _dispatch.call(&_dispatch.glTexGendv)( coord, pname, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexGendvEXT)(texunit, coord, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexGenfEXT(GLenum texunit, GLenum coord, GLenum pname, GLfloat param)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaActiveTexture( _context, texunit );
        _dispatch.call(&_dispatch.glTexGenf)( coord, pname, param );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexGenfEXT)(texunit, coord, pname, param);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexGenfvEXT(GLenum texunit, GLenum coord, GLenum pname, const GLfloat *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaActiveTexture( _context, texunit );
        _dispatch.call(&_dispatch.glTexGenfv)( coord, pname, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexGenfvEXT)(texunit, coord, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexGeniEXT(GLenum texunit, GLenum coord, GLenum pname, GLint param)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaActiveTexture( _context, texunit );
        _dispatch.call(&_dispatch.glTexGeni)( coord, pname, param );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexGeniEXT)(texunit, coord, pname, param);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexGenivEXT(GLenum texunit, GLenum coord, GLenum pname, const GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaActiveTexture( _context, texunit );
        _dispatch.call(&_dispatch.glTexGeniv)( coord, pname, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexGenivEXT)(texunit, coord, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->ShadowMultiTexInfo( texunit, target, internalformat );
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaActiveTexture( _context, texunit );
        _dispatch.call(&_dispatch.glTexImage1D)( target, level, internalformat, width, border, format, type, pixels );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexImage1DEXT)(texunit, target, level, internalformat, width, border, format, type, pixels);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->ShadowMultiTexInfo( texunit, target, internalformat );
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaActiveTexture( _context, texunit );
        _dispatch.call(&_dispatch.glTexImage2D)( target, level, internalformat, width, height, border, format, type, pixels );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexImage2DEXT)(texunit, target, level, internalformat, width, height, border, format, type, pixels);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->ShadowMultiTexInfo( texunit, target, internalformat );
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaActiveTexture( _context, texunit );
        _dispatch.call(&_dispatch.glTexImage3D)( target, level, internalformat, width, height, depth, border, format, type, pixels );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexImage3DEXT)(texunit, target, level, internalformat, width, height, depth, border, format, type, pixels);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexParameterIivEXT(GLenum texunit, GLenum target, GLenum pname, const GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaActiveTexture( _context, texunit );
        _dispatch.call(&_dispatch.glTexParameterIiv)( target, pname, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexParameterIivEXT)(texunit, target, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexParameterIuivEXT(GLenum texunit, GLenum target, GLenum pname, const GLuint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaActiveTexture( _context, texunit );
        _dispatch.call(&_dispatch.glTexParameterIuiv)( target, pname, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexParameterIuivEXT)(texunit, target, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexParameterfEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat param)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaActiveTexture( _context, texunit );
        _dispatch.call(&_dispatch.glTexParameterf)( target, pname, param );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexParameterfEXT)(texunit, target, pname, param);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexParameterfvEXT(GLenum texunit, GLenum target, GLenum pname, const GLfloat *param)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaActiveTexture( _context, texunit );
        _dispatch.call(&_dispatch.glTexParameterfv)( target, pname, param );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexParameterfvEXT)(texunit, target, pname, param);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexParameteriEXT(GLenum texunit, GLenum target, GLenum pname, GLint param)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaActiveTexture( _context, texunit );
        _dispatch.call(&_dispatch.glTexParameteri)( target, pname, param );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexParameteriEXT)(texunit, target, pname, param);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexParameterivEXT(GLenum texunit, GLenum target, GLenum pname, const GLint *param)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaActiveTexture( _context, texunit );
        _dispatch.call(&_dispatch.glTexParameteriv)( target, pname, param );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexParameterivEXT)(texunit, target, pname, param);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexRenderbufferEXT(GLenum texunit, GLenum target, GLuint renderbuffer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaActiveTexture( _context, texunit );
        _dispatch.call(&_dispatch.glTexRenderbufferNV)( target, renderbuffer );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexRenderbufferEXT)(texunit, target, renderbuffer);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexSubImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaActiveTexture( _context, texunit );
        _dispatch.call(&_dispatch.glTexSubImage1D)( target, level, xoffset, width, format, type, pixels );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexSubImage1DEXT)(texunit, target, level, xoffset, width, format, type, pixels);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexSubImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaActiveTexture( _context, texunit );
        _dispatch.call(&_dispatch.glTexSubImage2D)( target, level, xoffset, yoffset, width, height, format, type, pixels );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexSubImage2DEXT)(texunit, target, level, xoffset, yoffset, width, height, format, type, pixels);
      break;
    }

  }

}

static void REGAL_CALL emu_glMultiTexSubImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaActiveTexture( _context, texunit );
        _dispatch.call(&_dispatch.glTexSubImage3D)( target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glMultiTexSubImage3DEXT)(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
      break;
    }

  }

}

static void REGAL_CALL emu_glNamedBufferDataEXT(GLuint buffer, GLsizeiptr size, const GLvoid *data, GLenum usage)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaBuffer( _context, buffer);
        _dispatch.call(&_dispatch.glBufferData)( GL_ARRAY_BUFFER, size, data, usage );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glNamedBufferDataEXT)(buffer, size, data, usage);
      break;
    }

  }

}

static void REGAL_CALL emu_glNamedBufferSubDataEXT(GLuint buffer, GLintptr offset, GLsizeiptr size, const GLvoid *data)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaBuffer( _context, buffer);
        _dispatch.call(&_dispatch.glBufferSubData)( GL_ARRAY_BUFFER, offset, size, data );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glNamedBufferSubDataEXT)(buffer, offset, size, data);
      break;
    }

  }

}

static void REGAL_CALL emu_glNamedCopyBufferSubDataEXT(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaBuffer( _context, readBuffer);
        _dispatch.call(&_dispatch.glCopyBufferSubData)( GL_ARRAY_BUFFER, writeBuffer, readOffset, writeOffset, size );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glNamedCopyBufferSubDataEXT)(readBuffer, writeBuffer, readOffset, writeOffset, size);
      break;
    }

  }

}

static void REGAL_CALL emu_glNamedFramebufferRenderbufferEXT(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaFramebuffer( _context, GL_FRAMEBUFFER, framebuffer);
        _dispatch.call(&_dispatch.glFramebufferRenderbuffer)( GL_FRAMEBUFFER, attachment, renderbuffertarget, renderbuffer );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glNamedFramebufferRenderbufferEXT)(framebuffer, attachment, renderbuffertarget, renderbuffer);
      break;
    }

  }

}

static void REGAL_CALL emu_glNamedFramebufferTexture1DEXT(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaFramebuffer( _context, GL_FRAMEBUFFER, framebuffer);
        _dispatch.call(&_dispatch.glFramebufferTexture1D)( GL_FRAMEBUFFER, attachment, textarget, texture, level );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glNamedFramebufferTexture1DEXT)(framebuffer, attachment, textarget, texture, level);
      break;
    }

  }

}

static void REGAL_CALL emu_glNamedFramebufferTexture2DEXT(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaFramebuffer( _context, GL_FRAMEBUFFER, framebuffer);
        _dispatch.call(&_dispatch.glFramebufferTexture2D)( GL_FRAMEBUFFER, attachment, textarget, texture, level );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glNamedFramebufferTexture2DEXT)(framebuffer, attachment, textarget, texture, level);
      break;
    }

  }

}

static void REGAL_CALL emu_glNamedFramebufferTexture3DEXT(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaFramebuffer( _context, GL_FRAMEBUFFER, framebuffer);
        _dispatch.call(&_dispatch.glFramebufferTexture3D)( GL_FRAMEBUFFER, attachment, textarget, texture, level, zoffset );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glNamedFramebufferTexture3DEXT)(framebuffer, attachment, textarget, texture, level, zoffset);
      break;
    }

  }

}

static void REGAL_CALL emu_glNamedFramebufferTextureEXT(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaFramebuffer( _context, GL_FRAMEBUFFER, framebuffer);
        _dispatch.call(&_dispatch.glFramebufferTexture)( GL_FRAMEBUFFER, attachment, texture, level );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glNamedFramebufferTextureEXT)(framebuffer, attachment, texture, level);
      break;
    }

  }

}

static void REGAL_CALL emu_glNamedFramebufferTextureFaceEXT(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLenum face)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaFramebuffer( _context, GL_FRAMEBUFFER, framebuffer);
        _dispatch.call(&_dispatch.glFramebufferTextureFaceARB)( GL_FRAMEBUFFER, attachment, texture, level, face );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glNamedFramebufferTextureFaceEXT)(framebuffer, attachment, texture, level, face);
      break;
    }

  }

}

static void REGAL_CALL emu_glNamedFramebufferTextureLayerEXT(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaFramebuffer( _context, GL_FRAMEBUFFER, framebuffer);
        _dispatch.call(&_dispatch.glFramebufferTextureLayer)( GL_FRAMEBUFFER, attachment, texture, level, layer );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glNamedFramebufferTextureLayerEXT)(framebuffer, attachment, texture, level, layer);
      break;
    }

  }

}

static void REGAL_CALL emu_glNamedProgramLocalParameter4dEXT(GLuint program, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaAsmProgram( _context, target, program);
        _dispatch.call(&_dispatch.glProgramLocalParameter4dARB)( target, index, x, y, z, w );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glNamedProgramLocalParameter4dEXT)(program, target, index, x, y, z, w);
      break;
    }

  }

}

static void REGAL_CALL emu_glNamedProgramLocalParameter4dvEXT(GLuint program, GLenum target, GLuint index, const GLdouble *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaAsmProgram( _context, target, program);
        _dispatch.call(&_dispatch.glProgramLocalParameter4dvARB)( target, index, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glNamedProgramLocalParameter4dvEXT)(program, target, index, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glNamedProgramLocalParameter4fEXT(GLuint program, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaAsmProgram( _context, target, program);
        _dispatch.call(&_dispatch.glProgramLocalParameter4fARB)( target, index, x, y, z, w );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glNamedProgramLocalParameter4fEXT)(program, target, index, x, y, z, w);
      break;
    }

  }

}

static void REGAL_CALL emu_glNamedProgramLocalParameter4fvEXT(GLuint program, GLenum target, GLuint index, const GLfloat *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaAsmProgram( _context, target, program);
        _dispatch.call(&_dispatch.glProgramLocalParameter4fvARB)( target, index, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glNamedProgramLocalParameter4fvEXT)(program, target, index, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glNamedProgramLocalParameterI4iEXT(GLuint program, GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaAsmProgram( _context, target, program);
        _dispatch.call(&_dispatch.glProgramLocalParameterI4iNV)( target, index, x, y, z, w );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glNamedProgramLocalParameterI4iEXT)(program, target, index, x, y, z, w);
      break;
    }

  }

}

static void REGAL_CALL emu_glNamedProgramLocalParameterI4ivEXT(GLuint program, GLenum target, GLuint index, const GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaAsmProgram( _context, target, program);
        _dispatch.call(&_dispatch.glProgramLocalParameterI4ivNV)( target, index, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glNamedProgramLocalParameterI4ivEXT)(program, target, index, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glNamedProgramLocalParameterI4uiEXT(GLuint program, GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaAsmProgram( _context, target, program);
        _dispatch.call(&_dispatch.glProgramLocalParameterI4uiNV)( target, index, x, y, z, w );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glNamedProgramLocalParameterI4uiEXT)(program, target, index, x, y, z, w);
      break;
    }

  }

}

static void REGAL_CALL emu_glNamedProgramLocalParameterI4uivEXT(GLuint program, GLenum target, GLuint index, const GLuint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaAsmProgram( _context, target, program);
        _dispatch.call(&_dispatch.glProgramLocalParameterI4uivNV)( target, index, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glNamedProgramLocalParameterI4uivEXT)(program, target, index, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glNamedProgramLocalParameters4fvEXT(GLuint program, GLenum target, GLuint index, GLsizei count, const GLfloat *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaAsmProgram( _context, target, program);
        _dispatch.call(&_dispatch.glProgramLocalParameters4fvEXT)( target, index, count, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glNamedProgramLocalParameters4fvEXT)(program, target, index, count, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glNamedProgramLocalParametersI4ivEXT(GLuint program, GLenum target, GLuint index, GLsizei count, const GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaAsmProgram( _context, target, program);
        _dispatch.call(&_dispatch.glProgramLocalParametersI4ivNV)( target, index, count, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glNamedProgramLocalParametersI4ivEXT)(program, target, index, count, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glNamedProgramLocalParametersI4uivEXT(GLuint program, GLenum target, GLuint index, GLsizei count, const GLuint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaAsmProgram( _context, target, program);
        _dispatch.call(&_dispatch.glProgramLocalParametersI4uivNV)( target, index, count, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glNamedProgramLocalParametersI4uivEXT)(program, target, index, count, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glNamedProgramStringEXT(GLuint program, GLenum target, GLenum format, GLsizei len, const GLvoid *string)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaAsmProgram( _context, target, program);
        _dispatch.call(&_dispatch.glProgramStringARB)( target, format, len, string );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glNamedProgramStringEXT)(program, target, format, len, string);
      break;
    }

  }

}

static void REGAL_CALL emu_glNamedRenderbufferStorageEXT(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaRenderbuffer( _context, GL_RENDERBUFFER, renderbuffer);
        _dispatch.call(&_dispatch.glRenderbufferStorage)( GL_RENDERBUFFER, internalformat, width, height );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glNamedRenderbufferStorageEXT)(renderbuffer, internalformat, width, height);
      break;
    }

  }

}

static void REGAL_CALL emu_glNamedRenderbufferStorageMultisampleCoverageEXT(GLuint renderbuffer, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaRenderbuffer( _context, GL_RENDERBUFFER, renderbuffer);
        _dispatch.call(&_dispatch.glRenderbufferStorageMultisampleCoverageNV)( GL_RENDERBUFFER, coverageSamples, colorSamples, internalformat, width, height );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glNamedRenderbufferStorageMultisampleCoverageEXT)(renderbuffer, coverageSamples, colorSamples, internalformat, width, height);
      break;
    }

  }

}

static void REGAL_CALL emu_glNamedRenderbufferStorageMultisampleEXT(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaRenderbuffer( _context, GL_RENDERBUFFER, renderbuffer);
        _dispatch.call(&_dispatch.glRenderbufferStorageMultisample)( GL_RENDERBUFFER, samples, internalformat, width, height );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glNamedRenderbufferStorageMultisampleEXT)(renderbuffer, samples, internalformat, width, height);
      break;
    }

  }

}

static void REGAL_CALL emu_glProgramUniform1dEXT(GLuint program, GLint location, GLdouble x)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaGlslProgram( _context, program);
        _dispatch.call(&_dispatch.glUniform1d)( location, x );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glProgramUniform1dEXT)(program, location, x);
      break;
    }

  }

}

static void REGAL_CALL emu_glProgramUniform1dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaGlslProgram( _context, program);
        _dispatch.call(&_dispatch.glUniform1dv)( location, count, value );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glProgramUniform1dvEXT)(program, location, count, value);
      break;
    }

  }

}

static void REGAL_CALL emu_glProgramUniform1fEXT(GLuint program, GLint location, GLfloat v0)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaGlslProgram( _context, program);
        _dispatch.call(&_dispatch.glUniform1f)( location, v0 );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glProgramUniform1fEXT)(program, location, v0);
      break;
    }

  }

}

static void REGAL_CALL emu_glProgramUniform1fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaGlslProgram( _context, program);
        _dispatch.call(&_dispatch.glUniform1fv)( location, count, value );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glProgramUniform1fvEXT)(program, location, count, value);
      break;
    }

  }

}

static void REGAL_CALL emu_glProgramUniform1iEXT(GLuint program, GLint location, GLint v0)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaGlslProgram( _context, program);
        _dispatch.call(&_dispatch.glUniform1i)( location, v0 );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glProgramUniform1iEXT)(program, location, v0);
      break;
    }

  }

}

static void REGAL_CALL emu_glProgramUniform1ivEXT(GLuint program, GLint location, GLsizei count, const GLint *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaGlslProgram( _context, program);
        _dispatch.call(&_dispatch.glUniform1iv)( location, count, value );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glProgramUniform1ivEXT)(program, location, count, value);
      break;
    }

  }

}

static void REGAL_CALL emu_glProgramUniform1uiEXT(GLuint program, GLint location, GLuint v0)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaGlslProgram( _context, program);
        _dispatch.call(&_dispatch.glUniform1ui)( location, v0 );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glProgramUniform1uiEXT)(program, location, v0);
      break;
    }

  }

}

static void REGAL_CALL emu_glProgramUniform1uivEXT(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaGlslProgram( _context, program);
        _dispatch.call(&_dispatch.glUniform1uiv)( location, count, value );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glProgramUniform1uivEXT)(program, location, count, value);
      break;
    }

  }

}

static void REGAL_CALL emu_glProgramUniform2dEXT(GLuint program, GLint location, GLdouble x, GLdouble y)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaGlslProgram( _context, program);
        _dispatch.call(&_dispatch.glUniform2d)( location, x, y );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glProgramUniform2dEXT)(program, location, x, y);
      break;
    }

  }

}

static void REGAL_CALL emu_glProgramUniform2dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaGlslProgram( _context, program);
        _dispatch.call(&_dispatch.glUniform2dv)( location, count, value );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glProgramUniform2dvEXT)(program, location, count, value);
      break;
    }

  }

}

static void REGAL_CALL emu_glProgramUniform2fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaGlslProgram( _context, program);
        _dispatch.call(&_dispatch.glUniform2f)( location, v0, v1 );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glProgramUniform2fEXT)(program, location, v0, v1);
      break;
    }

  }

}

static void REGAL_CALL emu_glProgramUniform2fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaGlslProgram( _context, program);
        _dispatch.call(&_dispatch.glUniform2fv)( location, count, value );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glProgramUniform2fvEXT)(program, location, count, value);
      break;
    }

  }

}

static void REGAL_CALL emu_glProgramUniform2iEXT(GLuint program, GLint location, GLint v0, GLint v1)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaGlslProgram( _context, program);
        _dispatch.call(&_dispatch.glUniform2i)( location, v0, v1 );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glProgramUniform2iEXT)(program, location, v0, v1);
      break;
    }

  }

}

static void REGAL_CALL emu_glProgramUniform2ivEXT(GLuint program, GLint location, GLsizei count, const GLint *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaGlslProgram( _context, program);
        _dispatch.call(&_dispatch.glUniform2iv)( location, count, value );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glProgramUniform2ivEXT)(program, location, count, value);
      break;
    }

  }

}

static void REGAL_CALL emu_glProgramUniform2uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaGlslProgram( _context, program);
        _dispatch.call(&_dispatch.glUniform2ui)( location, v0, v1 );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glProgramUniform2uiEXT)(program, location, v0, v1);
      break;
    }

  }

}

static void REGAL_CALL emu_glProgramUniform2uivEXT(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaGlslProgram( _context, program);
        _dispatch.call(&_dispatch.glUniform2uiv)( location, count, value );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glProgramUniform2uivEXT)(program, location, count, value);
      break;
    }

  }

}

static void REGAL_CALL emu_glProgramUniform3dEXT(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaGlslProgram( _context, program);
        _dispatch.call(&_dispatch.glUniform3d)( location, x, y, z );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glProgramUniform3dEXT)(program, location, x, y, z);
      break;
    }

  }

}

static void REGAL_CALL emu_glProgramUniform3dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaGlslProgram( _context, program);
        _dispatch.call(&_dispatch.glUniform3dv)( location, count, value );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glProgramUniform3dvEXT)(program, location, count, value);
      break;
    }

  }

}

static void REGAL_CALL emu_glProgramUniform3fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaGlslProgram( _context, program);
        _dispatch.call(&_dispatch.glUniform3f)( location, v0, v1, v2 );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glProgramUniform3fEXT)(program, location, v0, v1, v2);
      break;
    }

  }

}

static void REGAL_CALL emu_glProgramUniform3fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaGlslProgram( _context, program);
        _dispatch.call(&_dispatch.glUniform3fv)( location, count, value );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glProgramUniform3fvEXT)(program, location, count, value);
      break;
    }

  }

}

static void REGAL_CALL emu_glProgramUniform3iEXT(GLuint program, GLint location, GLint v0, GLint v1, GLint v2)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaGlslProgram( _context, program);
        _dispatch.call(&_dispatch.glUniform3i)( location, v0, v1, v2 );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glProgramUniform3iEXT)(program, location, v0, v1, v2);
      break;
    }

  }

}

static void REGAL_CALL emu_glProgramUniform3ivEXT(GLuint program, GLint location, GLsizei count, const GLint *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaGlslProgram( _context, program);
        _dispatch.call(&_dispatch.glUniform3iv)( location, count, value );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glProgramUniform3ivEXT)(program, location, count, value);
      break;
    }

  }

}

static void REGAL_CALL emu_glProgramUniform3uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaGlslProgram( _context, program);
        _dispatch.call(&_dispatch.glUniform3ui)( location, v0, v1, v2 );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glProgramUniform3uiEXT)(program, location, v0, v1, v2);
      break;
    }

  }

}

static void REGAL_CALL emu_glProgramUniform3uivEXT(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaGlslProgram( _context, program);
        _dispatch.call(&_dispatch.glUniform3uiv)( location, count, value );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glProgramUniform3uivEXT)(program, location, count, value);
      break;
    }

  }

}

static void REGAL_CALL emu_glProgramUniform4dEXT(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaGlslProgram( _context, program);
        _dispatch.call(&_dispatch.glUniform4d)( location, x, y, z, w );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glProgramUniform4dEXT)(program, location, x, y, z, w);
      break;
    }

  }

}

static void REGAL_CALL emu_glProgramUniform4dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaGlslProgram( _context, program);
        _dispatch.call(&_dispatch.glUniform4dv)( location, count, value );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glProgramUniform4dvEXT)(program, location, count, value);
      break;
    }

  }

}

static void REGAL_CALL emu_glProgramUniform4fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaGlslProgram( _context, program);
        _dispatch.call(&_dispatch.glUniform4f)( location, v0, v1, v2, v3 );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glProgramUniform4fEXT)(program, location, v0, v1, v2, v3);
      break;
    }

  }

}

static void REGAL_CALL emu_glProgramUniform4fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaGlslProgram( _context, program);
        _dispatch.call(&_dispatch.glUniform4fv)( location, count, value );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glProgramUniform4fvEXT)(program, location, count, value);
      break;
    }

  }

}

static void REGAL_CALL emu_glProgramUniform4iEXT(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaGlslProgram( _context, program);
        _dispatch.call(&_dispatch.glUniform4i)( location, v0, v1, v2, v3 );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glProgramUniform4iEXT)(program, location, v0, v1, v2, v3);
      break;
    }

  }

}

static void REGAL_CALL emu_glProgramUniform4ivEXT(GLuint program, GLint location, GLsizei count, const GLint *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaGlslProgram( _context, program);
        _dispatch.call(&_dispatch.glUniform4iv)( location, count, value );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glProgramUniform4ivEXT)(program, location, count, value);
      break;
    }

  }

}

static void REGAL_CALL emu_glProgramUniform4uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaGlslProgram( _context, program);
        _dispatch.call(&_dispatch.glUniform4ui)( location, v0, v1, v2, v3 );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glProgramUniform4uiEXT)(program, location, v0, v1, v2, v3);
      break;
    }

  }

}

static void REGAL_CALL emu_glProgramUniform4uivEXT(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaGlslProgram( _context, program);
        _dispatch.call(&_dispatch.glUniform4uiv)( location, count, value );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glProgramUniform4uivEXT)(program, location, count, value);
      break;
    }

  }

}

static void REGAL_CALL emu_glProgramUniformMatrix2dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaGlslProgram( _context, program);
        _dispatch.call(&_dispatch.glUniformMatrix2dv)( location, count, transpose, value );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glProgramUniformMatrix2dvEXT)(program, location, count, transpose, value);
      break;
    }

  }

}

static void REGAL_CALL emu_glProgramUniformMatrix2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaGlslProgram( _context, program);
        _dispatch.call(&_dispatch.glUniformMatrix2fv)( location, count, transpose, value );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glProgramUniformMatrix2fvEXT)(program, location, count, transpose, value);
      break;
    }

  }

}

static void REGAL_CALL emu_glProgramUniformMatrix2x3dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaGlslProgram( _context, program);
        _dispatch.call(&_dispatch.glUniformMatrix2x3dv)( location, count, transpose, value );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glProgramUniformMatrix2x3dvEXT)(program, location, count, transpose, value);
      break;
    }

  }

}

static void REGAL_CALL emu_glProgramUniformMatrix2x3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaGlslProgram( _context, program);
        _dispatch.call(&_dispatch.glUniformMatrix2x3fv)( location, count, transpose, value );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glProgramUniformMatrix2x3fvEXT)(program, location, count, transpose, value);
      break;
    }

  }

}

static void REGAL_CALL emu_glProgramUniformMatrix2x4dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaGlslProgram( _context, program);
        _dispatch.call(&_dispatch.glUniformMatrix2x4dv)( location, count, transpose, value );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glProgramUniformMatrix2x4dvEXT)(program, location, count, transpose, value);
      break;
    }

  }

}

static void REGAL_CALL emu_glProgramUniformMatrix2x4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaGlslProgram( _context, program);
        _dispatch.call(&_dispatch.glUniformMatrix2x4fv)( location, count, transpose, value );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glProgramUniformMatrix2x4fvEXT)(program, location, count, transpose, value);
      break;
    }

  }

}

static void REGAL_CALL emu_glProgramUniformMatrix3dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaGlslProgram( _context, program);
        _dispatch.call(&_dispatch.glUniformMatrix3dv)( location, count, transpose, value );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glProgramUniformMatrix3dvEXT)(program, location, count, transpose, value);
      break;
    }

  }

}

static void REGAL_CALL emu_glProgramUniformMatrix3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaGlslProgram( _context, program);
        _dispatch.call(&_dispatch.glUniformMatrix3fv)( location, count, transpose, value );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glProgramUniformMatrix3fvEXT)(program, location, count, transpose, value);
      break;
    }

  }

}

static void REGAL_CALL emu_glProgramUniformMatrix3x2dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaGlslProgram( _context, program);
        _dispatch.call(&_dispatch.glUniformMatrix3x2dv)( location, count, transpose, value );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glProgramUniformMatrix3x2dvEXT)(program, location, count, transpose, value);
      break;
    }

  }

}

static void REGAL_CALL emu_glProgramUniformMatrix3x2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaGlslProgram( _context, program);
        _dispatch.call(&_dispatch.glUniformMatrix3x2fv)( location, count, transpose, value );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glProgramUniformMatrix3x2fvEXT)(program, location, count, transpose, value);
      break;
    }

  }

}

static void REGAL_CALL emu_glProgramUniformMatrix3x4dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaGlslProgram( _context, program);
        _dispatch.call(&_dispatch.glUniformMatrix3x4dv)( location, count, transpose, value );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glProgramUniformMatrix3x4dvEXT)(program, location, count, transpose, value);
      break;
    }

  }

}

static void REGAL_CALL emu_glProgramUniformMatrix3x4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaGlslProgram( _context, program);
        _dispatch.call(&_dispatch.glUniformMatrix3x4fv)( location, count, transpose, value );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glProgramUniformMatrix3x4fvEXT)(program, location, count, transpose, value);
      break;
    }

  }

}

static void REGAL_CALL emu_glProgramUniformMatrix4dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaGlslProgram( _context, program);
        _dispatch.call(&_dispatch.glUniformMatrix4dv)( location, count, transpose, value );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glProgramUniformMatrix4dvEXT)(program, location, count, transpose, value);
      break;
    }

  }

}

static void REGAL_CALL emu_glProgramUniformMatrix4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaGlslProgram( _context, program);
        _dispatch.call(&_dispatch.glUniformMatrix4fv)( location, count, transpose, value );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glProgramUniformMatrix4fvEXT)(program, location, count, transpose, value);
      break;
    }

  }

}

static void REGAL_CALL emu_glProgramUniformMatrix4x2dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaGlslProgram( _context, program);
        _dispatch.call(&_dispatch.glUniformMatrix4x2dv)( location, count, transpose, value );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glProgramUniformMatrix4x2dvEXT)(program, location, count, transpose, value);
      break;
    }

  }

}

static void REGAL_CALL emu_glProgramUniformMatrix4x2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaGlslProgram( _context, program);
        _dispatch.call(&_dispatch.glUniformMatrix4x2fv)( location, count, transpose, value );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glProgramUniformMatrix4x2fvEXT)(program, location, count, transpose, value);
      break;
    }

  }

}

static void REGAL_CALL emu_glProgramUniformMatrix4x3dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaGlslProgram( _context, program);
        _dispatch.call(&_dispatch.glUniformMatrix4x3dv)( location, count, transpose, value );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glProgramUniformMatrix4x3dvEXT)(program, location, count, transpose, value);
      break;
    }

  }

}

static void REGAL_CALL emu_glProgramUniformMatrix4x3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaGlslProgram( _context, program);
        _dispatch.call(&_dispatch.glUniformMatrix4x3fv)( location, count, transpose, value );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glProgramUniformMatrix4x3fvEXT)(program, location, count, transpose, value);
      break;
    }

  }

}

static void REGAL_CALL emu_glPushClientAttribDefaultEXT(GLbitfield mask)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca) break;
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glPushClientAttribDefaultEXT( *_context, mask );
        return;
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        DispatchTableGL &tbl = _context->dispatcher.emulation;
        tbl.call(&tbl.glPushClientAttrib)(mask);
        _context->dsa->ClientAttribDefault(_context, mask);
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glPushClientAttribDefaultEXT)(mask);
      break;
    }

  }

}

static void REGAL_CALL emu_glTextureBufferEXT(GLuint texture, GLenum target, GLenum internalformat, GLuint buffer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaTexture( _context, target, texture );
        _dispatch.call(&_dispatch.glTexBuffer)( target, internalformat, buffer );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTextureBufferEXT)(texture, target, internalformat, buffer);
      break;
    }

  }

}

static void REGAL_CALL emu_glTextureImage1DEXT(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->ShadowTextureInfo( texture, target, internalformat );
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaTexture( _context, target, texture );
        _dispatch.call(&_dispatch.glTexImage1D)( target, level, internalformat, width, border, format, type, pixels );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTextureImage1DEXT)(texture, target, level, internalformat, width, border, format, type, pixels);
      break;
    }

  }

}

static void REGAL_CALL emu_glTextureImage2DEXT(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->ShadowTextureInfo( texture, target, internalformat );
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaTexture( _context, target, texture );
        _dispatch.call(&_dispatch.glTexImage2D)( target, level, internalformat, width, height, border, format, type, pixels );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTextureImage2DEXT)(texture, target, level, internalformat, width, height, border, format, type, pixels);
      break;
    }

  }

}

static void REGAL_CALL emu_glTextureImage3DEXT(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->ShadowTextureInfo( texture, target, internalformat );
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaTexture( _context, target, texture );
        _dispatch.call(&_dispatch.glTexImage3D)( target, level, internalformat, width, height, depth, border, format, type, pixels );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTextureImage3DEXT)(texture, target, level, internalformat, width, height, depth, border, format, type, pixels);
      break;
    }

  }

}

static void REGAL_CALL emu_glTextureParameterIivEXT(GLuint texture, GLenum target, GLenum pname, const GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaTexture( _context, target, texture );
        _dispatch.call(&_dispatch.glTexParameterIiv)( target, pname, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTextureParameterIivEXT)(texture, target, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glTextureParameterIuivEXT(GLuint texture, GLenum target, GLenum pname, const GLuint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaTexture( _context, target, texture );
        _dispatch.call(&_dispatch.glTexParameterIuiv)( target, pname, params );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTextureParameterIuivEXT)(texture, target, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glTextureParameterfEXT(GLuint texture, GLenum target, GLenum pname, GLfloat param)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaTexture( _context, target, texture );
        _dispatch.call(&_dispatch.glTexParameterf)( target, pname, param );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTextureParameterfEXT)(texture, target, pname, param);
      break;
    }

  }

}

static void REGAL_CALL emu_glTextureParameterfvEXT(GLuint texture, GLenum target, GLenum pname, const GLfloat *param)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaTexture( _context, target, texture );
        _dispatch.call(&_dispatch.glTexParameterfv)( target, pname, param );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTextureParameterfvEXT)(texture, target, pname, param);
      break;
    }

  }

}

static void REGAL_CALL emu_glTextureParameteriEXT(GLuint texture, GLenum target, GLenum pname, GLint param)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaTexture( _context, target, texture );
        _dispatch.call(&_dispatch.glTexParameteri)( target, pname, param );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTextureParameteriEXT)(texture, target, pname, param);
      break;
    }

  }

}

static void REGAL_CALL emu_glTextureParameterivEXT(GLuint texture, GLenum target, GLenum pname, const GLint *param)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaTexture( _context, target, texture );
        _dispatch.call(&_dispatch.glTexParameteriv)( target, pname, param );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTextureParameterivEXT)(texture, target, pname, param);
      break;
    }

  }

}

static void REGAL_CALL emu_glTextureRenderbufferEXT(GLuint texture, GLenum target, GLuint renderbuffer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaTexture( _context, target, texture );
        _dispatch.call(&_dispatch.glTexRenderbufferNV)( target, renderbuffer );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTextureRenderbufferEXT)(texture, target, renderbuffer);
      break;
    }

  }

}

static void REGAL_CALL emu_glTextureSubImage1DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaTexture( _context, target, texture );
        _dispatch.call(&_dispatch.glTexSubImage1D)( target, level, xoffset, width, format, type, pixels );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTextureSubImage1DEXT)(texture, target, level, xoffset, width, format, type, pixels);
      break;
    }

  }

}

static void REGAL_CALL emu_glTextureSubImage2DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaTexture( _context, target, texture );
        _dispatch.call(&_dispatch.glTexSubImage2D)( target, level, xoffset, yoffset, width, height, format, type, pixels );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTextureSubImage2DEXT)(texture, target, level, xoffset, yoffset, width, height, format, type, pixels);
      break;
    }

  }

}

static void REGAL_CALL emu_glTextureSubImage3DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaTexture( _context, target, texture );
        _dispatch.call(&_dispatch.glTexSubImage3D)( target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTextureSubImage3DEXT)(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
      break;
    }

  }

}

static GLboolean REGAL_CALL emu_glUnmapNamedBufferEXT(GLuint buffer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaBuffer( _context, buffer);
        return _dispatch.call(&_dispatch.glUnmapBuffer)( GL_ARRAY_BUFFER );
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      return _next->call(&_next->glUnmapNamedBufferEXT)(buffer);
    }

  }

}

static void REGAL_CALL emu_glVertexArrayColorOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, const GLintptr offset)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glVertexArrayColorOffsetEXT( vaobj, buffer, size, type, stride, offset );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glVertexArrayColorOffsetEXT( vaobj, buffer, size, type, stride, offset );
      }
      #endif
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaVao( _context, vaobj );_context->dsa->DsaBuffer( _context, buffer );
        _dispatch.call(&_dispatch.glColorPointer)( size, type, stride, reinterpret_cast<const GLvoid *>(offset) );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glVertexArrayColorOffsetEXT)(vaobj, buffer, size, type, stride, offset);
      break;
    }

  }

}

static void REGAL_CALL emu_glVertexArrayEdgeFlagOffsetEXT(GLuint vaobj, GLuint buffer, GLsizei stride, const GLintptr offset)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glVertexArrayEdgeFlagOffsetEXT( vaobj, buffer, stride, offset );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glVertexArrayEdgeFlagOffsetEXT( vaobj, buffer, stride, offset );
      }
      #endif
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaVao( _context, vaobj );_context->dsa->DsaBuffer( _context, buffer );
        _dispatch.call(&_dispatch.glEdgeFlagPointer)( stride, reinterpret_cast<const GLvoid *>(offset) );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glVertexArrayEdgeFlagOffsetEXT)(vaobj, buffer, stride, offset);
      break;
    }

  }

}

static void REGAL_CALL emu_glVertexArrayFogCoordOffsetEXT(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, const GLintptr offset)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glVertexArrayFogCoordOffsetEXT( vaobj, buffer, type, stride, offset );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glVertexArrayFogCoordOffsetEXT( vaobj, buffer, type, stride, offset );
      }
      #endif
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaVao( _context, vaobj );_context->dsa->DsaBuffer( _context, buffer );
        _dispatch.call(&_dispatch.glFogCoordPointer)( type, stride, reinterpret_cast<const GLvoid *>(offset) );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glVertexArrayFogCoordOffsetEXT)(vaobj, buffer, type, stride, offset);
      break;
    }

  }

}

static void REGAL_CALL emu_glVertexArrayIndexOffsetEXT(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, const GLintptr offset)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glVertexArrayIndexOffsetEXT( vaobj, buffer, type, stride, offset );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glVertexArrayIndexOffsetEXT( vaobj, buffer, type, stride, offset );
      }
      #endif
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaVao( _context, vaobj );_context->dsa->DsaBuffer( _context, buffer );
        _dispatch.call(&_dispatch.glIndexPointer)( type, stride, reinterpret_cast<const GLvoid *>(offset) );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glVertexArrayIndexOffsetEXT)(vaobj, buffer, type, stride, offset);
      break;
    }

  }

}

static void REGAL_CALL emu_glVertexArrayMultiTexCoordOffsetEXT(GLuint vaobj, GLuint buffer, GLenum texunit, GLint size, GLenum type, GLsizei stride, const GLintptr offset)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glVertexArrayMultiTexCoordOffsetEXT( vaobj, buffer, texunit, size, type, stride, offset );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glVertexArrayMultiTexCoordOffsetEXT( vaobj, buffer, texunit, size, type, stride, offset );
      }
      #endif
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaVao( _context, vaobj );_context->dsa->DsaBuffer( _context, buffer );
        _dispatch.call(&_dispatch.glMultiTexCoordPointerEXT)( texunit, size, type, stride, reinterpret_cast<const GLvoid *>(offset) );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glVertexArrayMultiTexCoordOffsetEXT)(vaobj, buffer, texunit, size, type, stride, offset);
      break;
    }

  }

}

static void REGAL_CALL emu_glVertexArrayNormalOffsetEXT(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, const GLintptr offset)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glVertexArrayNormalOffsetEXT( vaobj, buffer, type, stride, offset );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glVertexArrayNormalOffsetEXT( vaobj, buffer, type, stride, offset );
      }
      #endif
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaVao( _context, vaobj );_context->dsa->DsaBuffer( _context, buffer );
        _dispatch.call(&_dispatch.glNormalPointer)( type, stride, reinterpret_cast<const GLvoid *>(offset) );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glVertexArrayNormalOffsetEXT)(vaobj, buffer, type, stride, offset);
      break;
    }

  }

}

static void REGAL_CALL emu_glVertexArraySecondaryColorOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, const GLintptr offset)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glVertexArraySecondaryColorOffsetEXT( vaobj, buffer, size, type, stride, offset );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glVertexArraySecondaryColorOffsetEXT( vaobj, buffer, size, type, stride, offset );
      }
      #endif
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaVao( _context, vaobj );_context->dsa->DsaBuffer( _context, buffer );
        _dispatch.call(&_dispatch.glSecondaryColorPointer)( size, type, stride, reinterpret_cast<const GLvoid *>(offset) );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glVertexArraySecondaryColorOffsetEXT)(vaobj, buffer, size, type, stride, offset);
      break;
    }

  }

}

static void REGAL_CALL emu_glVertexArrayTexCoordOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, const GLintptr offset)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glVertexArrayTexCoordOffsetEXT( vaobj, buffer, size, type, stride, offset );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glVertexArrayTexCoordOffsetEXT( vaobj, buffer, size, type, stride, offset );
      }
      #endif
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaVao( _context, vaobj );_context->dsa->DsaBuffer( _context, buffer );
        _dispatch.call(&_dispatch.glTexCoordPointer)( size, type, stride, reinterpret_cast<const GLvoid *>(offset) );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glVertexArrayTexCoordOffsetEXT)(vaobj, buffer, size, type, stride, offset);
      break;
    }

  }

}

static void REGAL_CALL emu_glVertexArrayVertexAttribIOffsetEXT(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, const GLintptr offset)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glVertexArrayVertexAttribIOffsetEXT( vaobj, buffer, index, size, type, stride, offset );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glVertexArrayVertexAttribIOffsetEXT( vaobj, buffer, index, size, type, stride, offset );
      }
      #endif
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaVao( _context, vaobj );_context->dsa->DsaBuffer( _context, buffer );
        _dispatch.call(&_dispatch.glVertexAttribIPointer)( index, size, type, stride, reinterpret_cast<const GLvoid *>(offset) );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glVertexArrayVertexAttribIOffsetEXT)(vaobj, buffer, index, size, type, stride, offset);
      break;
    }

  }

}

static void REGAL_CALL emu_glVertexArrayVertexAttribOffsetEXT(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLintptr offset)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glVertexArrayVertexAttribOffsetEXT( vaobj, buffer, index, size, type, normalized, stride, offset );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glVertexArrayVertexAttribOffsetEXT( vaobj, buffer, index, size, type, normalized, stride, offset );
      }
      #endif
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaVao( _context, vaobj );_context->dsa->DsaBuffer( _context, buffer );
        _dispatch.call(&_dispatch.glVertexAttribPointer)( index, size, type, normalized, stride, reinterpret_cast<const GLvoid *>(offset) );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glVertexArrayVertexAttribOffsetEXT)(vaobj, buffer, index, size, type, normalized, stride, offset);
      break;
    }

  }

}

static void REGAL_CALL emu_glVertexArrayVertexOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, const GLintptr offset)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glVertexArrayVertexOffsetEXT( vaobj, buffer, size, type, stride, offset );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glVertexArrayVertexOffsetEXT( vaobj, buffer, size, type, stride, offset );
      }
      #endif
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaVao( _context, vaobj );_context->dsa->DsaBuffer( _context, buffer );
        _dispatch.call(&_dispatch.glVertexPointer)( size, type, stride, reinterpret_cast<const GLvoid *>(offset) );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glVertexArrayVertexOffsetEXT)(vaobj, buffer, size, type, stride, offset);
      break;
    }

  }

}

// GL_EXT_discard_framebuffer

// GL_EXT_disjoint_timer_query

// GL_EXT_draw_buffers2

static void REGAL_CALL emu_glColorMaskIndexedEXT(GLuint buf, GLboolean r, GLboolean g, GLboolean b, GLboolean a)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (REGAL_FORCE_ES2_PROFILE || !_context->info->gl_ext_draw_buffers2)
        {
          if (!buf)  {
            DispatchTableGL *_next = _context->dispatcher.emulation.next();
            RegalAssert(_next);
            _next->call(&_next->glColorMask)(r, g, b, a);
          }
          return;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glColorMaskIndexedEXT)(buf, r, g, b, a);
      break;
    }

  }

}

static void REGAL_CALL emu_glDisableIndexedEXT(GLenum target, GLuint index)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glDisableIndexedEXT( target, index );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glDisableIndexedEXT( target, index );
      }
      #endif
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->DisableIndexed( target, index );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaActiveTexture( _context, index + GL_TEXTURE0 );
        _dispatch.call(&_dispatch.glDisable)( target );
        return;
      }
      #endif
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (target==GL_BLEND && (REGAL_FORCE_ES2_PROFILE || !_context->info->gl_ext_draw_buffers2))
        {
          if (!index)  {
            DispatchTableGL *_next = _context->dispatcher.emulation.next();
            RegalAssert(_next);
            _next->call(&_next->glDisable)(target);
          }
          return;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glDisableIndexedEXT)(target, index);
      break;
    }

  }

}

static void REGAL_CALL emu_glEnableIndexedEXT(GLenum target, GLuint index)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
      #if REGAL_EMU_PPCA
      if (_context->ppca)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 12;
        _context->ppca->glEnableIndexedEXT( target, index );
      }
      #endif
    case 12 :
    case 11 :
    case 10 :
    case 9 :
      #if REGAL_EMU_BASEVERTEX
      if (_context->bv)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 8;
        _context->bv->glEnableIndexedEXT( target, index );
      }
      #endif
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->EnableIndexed( target, index );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DsaActiveTexture( _context, index + GL_TEXTURE0 );
        _dispatch.call(&_dispatch.glEnable)( target );
        return;
      }
      #endif
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (target==GL_BLEND && (REGAL_FORCE_ES2_PROFILE || !_context->info->gl_ext_draw_buffers2))
        {
          if (!index)  {
            DispatchTableGL *_next = _context->dispatcher.emulation.next();
            RegalAssert(_next);
            _next->call(&_next->glEnable)(target);
          }
          return;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glEnableIndexedEXT)(target, index);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetBooleanIndexedvEXT(GLenum value, GLuint index, GLboolean *data)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (REGAL_FORCE_ES2_PROFILE || !_context->info->gl_ext_draw_buffers2)
        {
          if (!index)  {
            DispatchTableGL *_next = _context->dispatcher.emulation.next();
            RegalAssert(_next);
            _next->call(&_next->glGetBooleanv)(value,data);
          }
          return;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetBooleanIndexedvEXT)(value, index, data);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetIntegerIndexedvEXT(GLenum value, GLuint index, GLint *data)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (REGAL_FORCE_ES2_PROFILE || !_context->info->gl_ext_draw_buffers2)
        {
          if (!index)  {
            DispatchTableGL *_next = _context->dispatcher.emulation.next();
            RegalAssert(_next);
            _next->call(&_next->glGetIntegerv)(value,data);
          }
          return;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetIntegerIndexedvEXT)(value, index, data);
      break;
    }

  }

}

static GLboolean REGAL_CALL emu_glIsEnabledIndexedEXT(GLenum target, GLuint index)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        GLboolean ret;
        ret = _context->dsa->IsEnabledIndexed( _context, target, index );
        return ret;
      }
      #endif
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (target==GL_BLEND && !_context->info->gl_ext_draw_buffers2)
        {
          if (!index)  {
            DispatchTableGL *_next = _context->dispatcher.emulation.next();
            RegalAssert(_next);
            return _next->call(&_next->glIsEnabled)(target);
          }
          return GL_FALSE;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      return _next->call(&_next->glIsEnabledIndexedEXT)(target, index);
    }

  }

}

// GL_EXT_draw_instanced

static void REGAL_CALL emu_glDrawArraysInstancedEXT(GLenum mode, GLint start, GLsizei count, GLsizei primcount)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->PreDraw( _context );
      }
      #endif
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        _context->so->PreDraw( *_context );
      }
      #endif
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->Restore( _context );
      }
      #endif
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        // _context->vao->Validate(*_context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glDrawArraysInstancedEXT)(mode, start, count, primcount);
}

static void REGAL_CALL emu_glDrawElementsInstancedEXT(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->PreDraw( _context );
      }
      #endif
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        _context->so->PreDraw( *_context );
      }
      #endif
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->Restore( _context );
      }
      #endif
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        // _context->vao->Validate(*_context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glDrawElementsInstancedEXT)(mode, count, type, indices, primcount);
}

// GL_EXT_draw_range_elements

static void REGAL_CALL emu_glDrawRangeElementsEXT(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->PreDraw( _context );
      }
      #endif
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        _context->so->PreDraw( *_context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glDrawRangeElementsEXT)(mode, start, end, count, type, indices);
}

// GL_EXT_fog_coord

static void REGAL_CALL emu_glFogCoordPointerEXT(GLenum type, GLsizei stride, const GLvoid *pointer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->FogCoordPointer( _context, type, stride, pointer );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        _context->vao->FogCoordPointer(*_context, type, stride, pointer );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glFogCoordPointerEXT)(type, stride, pointer);
      break;
    }

  }

}

// GL_EXT_fragment_lighting

// GL_EXT_framebuffer_blit

static void REGAL_CALL emu_glBlitFramebufferEXT(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (!_context->info->gl_ext_framebuffer_blit)
        {
          DispatchTableGL &_table = _context->dispatcher.emulation;
          _context->emuLevel++;
          _table.call(&_table.glBlitFramebuffer)(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
          return;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glBlitFramebufferEXT)(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
      break;
    }

  }

}

// GL_EXT_framebuffer_multisample

static void REGAL_CALL emu_glRenderbufferStorageMultisampleEXT(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreRenderbuffer( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glRenderbufferStorageMultisampleEXT)(target, samples, internalformat, width, height);
}

// GL_EXT_framebuffer_object

static void REGAL_CALL emu_glBindFramebufferEXT(GLenum target, GLuint framebuffer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        if (!_context->dsa->ShadowFramebuffer( target, framebuffer ) ) {
            _dispatch.call(&_dispatch.glBindFramebuffer)( target, framebuffer );
        }
        return;
      }
      #endif
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (!_context->info->gl_ext_framebuffer_object)
        {
          DispatchTableGL &_table = _context->dispatcher.emulation;
          _context->emuLevel++;
          _table.call(&_table.glBindFramebuffer)(target, framebuffer);
          return;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glBindFramebufferEXT)(target, framebuffer);
      break;
    }

  }

}

static void REGAL_CALL emu_glBindRenderbufferEXT(GLenum target, GLuint renderbuffer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        if (!_context->dsa->ShadowRenderbuffer( target, renderbuffer ) ) {
            _dispatch.call(&_dispatch.glBindRenderbuffer)( target, renderbuffer );
        }
        return;
      }
      #endif
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (!_context->info->gl_ext_framebuffer_object)
        {
          DispatchTableGL &_table = _context->dispatcher.emulation;
          _context->emuLevel++;
          _table.call(&_table.glBindRenderbuffer)(target, renderbuffer);
          return;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glBindRenderbufferEXT)(target, renderbuffer);
      break;
    }

  }

}

static GLenum REGAL_CALL emu_glCheckFramebufferStatusEXT(GLenum target)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (!_context->info->gl_ext_framebuffer_object)
        {
          DispatchTableGL &_table = _context->dispatcher.emulation;
          _context->emuLevel++;
          return _table.call(&_table.glCheckFramebufferStatus)(target);
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      return _next->call(&_next->glCheckFramebufferStatusEXT)(target);
    }

  }

}

static void REGAL_CALL emu_glDeleteFramebuffersEXT(GLsizei n, const GLuint *framebuffers)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DeleteFramebuffers( _context, n, framebuffers );
      }
      #endif
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (!_context->info->gl_ext_framebuffer_object)
        {
          DispatchTableGL &_table = _context->dispatcher.emulation;
          _context->emuLevel++;
          _table.call(&_table.glDeleteFramebuffers)(n, framebuffers);
          return;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glDeleteFramebuffersEXT)(n, framebuffers);
      break;
    }

  }

}

static void REGAL_CALL emu_glDeleteRenderbuffersEXT(GLsizei n, const GLuint *renderbuffers)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DeleteRenderbuffers( _context, n, renderbuffers );
      }
      #endif
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (!_context->info->gl_ext_framebuffer_object)
        {
          DispatchTableGL &_table = _context->dispatcher.emulation;
          _context->emuLevel++;
          _table.call(&_table.glDeleteRenderbuffers)(n, renderbuffers);
          return;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glDeleteRenderbuffersEXT)(n, renderbuffers);
      break;
    }

  }

}

static void REGAL_CALL emu_glFramebufferRenderbufferEXT(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreFramebuffer( _context );
      }
      #endif
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (!_context->info->gl_ext_framebuffer_object)
        {
          DispatchTableGL &_table = _context->dispatcher.emulation;
          _context->emuLevel++;
          _table.call(&_table.glFramebufferRenderbuffer)(target, attachment, renderbuffertarget, renderbuffer);
          return;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glFramebufferRenderbufferEXT)(target, attachment, renderbuffertarget, renderbuffer);
      break;
    }

  }

}

static void REGAL_CALL emu_glFramebufferTexture1DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
      #if REGAL_EMU_OBJ
      if (_context->obj) break;
      #endif
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreFramebuffer( _context );
      }
      #endif
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
      #if REGAL_EMU_OBJ
      if (_context->obj)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 15;
        _dispatch.call(&_dispatch.glFramebufferTexture1DEXT)(target, attachment, textarget, _context->obj->textureNames.ToDriverName(texture), level);
        return;
      }
      #endif
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (!_context->info->gl_ext_framebuffer_object)
        {
          DispatchTableGL &_table = _context->dispatcher.emulation;
          _context->emuLevel++;
          _table.call(&_table.glFramebufferTexture1D)(target, attachment, textarget, texture, level);
          return;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glFramebufferTexture1DEXT)(target, attachment, textarget, texture, level);
      break;
    }

  }

}

static void REGAL_CALL emu_glFramebufferTexture2DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
      #if REGAL_EMU_OBJ
      if (_context->obj) break;
      #endif
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreFramebuffer( _context );
      }
      #endif
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
      #if REGAL_EMU_OBJ
      if (_context->obj)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 15;
        _dispatch.call(&_dispatch.glFramebufferTexture2DEXT)(target, attachment, textarget, _context->obj->textureNames.ToDriverName(texture), level);
        return;
      }
      #endif
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (!_context->info->gl_ext_framebuffer_object)
        {
          DispatchTableGL &_table = _context->dispatcher.emulation;
          _context->emuLevel++;
          _table.call(&_table.glFramebufferTexture2D)(target, attachment, textarget, texture, level);
          return;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glFramebufferTexture2DEXT)(target, attachment, textarget, texture, level);
      break;
    }

  }

}

static void REGAL_CALL emu_glFramebufferTexture3DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
      #if REGAL_EMU_OBJ
      if (_context->obj) break;
      #endif
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreFramebuffer( _context );
      }
      #endif
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
      #if REGAL_EMU_OBJ
      if (_context->obj)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 15;
        _dispatch.call(&_dispatch.glFramebufferTexture3DEXT)(target, attachment, textarget, _context->obj->textureNames.ToDriverName(texture), level, zoffset);
        return;
      }
      #endif
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (!_context->info->gl_ext_framebuffer_object)
        {
          DispatchTableGL &_table = _context->dispatcher.emulation;
          _context->emuLevel++;
          _table.call(&_table.glFramebufferTexture3D)(target, attachment, textarget, texture, level, zoffset);
          return;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glFramebufferTexture3DEXT)(target, attachment, textarget, texture, level, zoffset);
      break;
    }

  }

}

static void REGAL_CALL emu_glGenFramebuffersEXT(GLsizei n, GLuint *framebuffers)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (!_context->info->gl_ext_framebuffer_object)
        {
          DispatchTableGL &_table = _context->dispatcher.emulation;
          _context->emuLevel++;
          _table.call(&_table.glGenFramebuffers)(n, framebuffers);
          return;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGenFramebuffersEXT)(n, framebuffers);
      break;
    }

  }

}

static void REGAL_CALL emu_glGenRenderbuffersEXT(GLsizei n, GLuint *renderbuffers)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (!_context->info->gl_ext_framebuffer_object)
        {
          DispatchTableGL &_table = _context->dispatcher.emulation;
          _context->emuLevel++;
          _table.call(&_table.glGenRenderbuffers)(n, renderbuffers);
          return;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGenRenderbuffersEXT)(n, renderbuffers);
      break;
    }

  }

}

static void REGAL_CALL emu_glGenerateMipmapEXT(GLenum target)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreTexture( _context );
        _context->dsa->RestoreActiveTexture( _context );
      }
      #endif
    case 3 :
    case 2 :
      #if REGAL_EMU_TEXC
      if (_context->texc)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 1;
        _context->texc->ShadowGenerateMipmap( target );
      }
      #endif
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (!_context->info->gl_ext_framebuffer_object)
        {
          DispatchTableGL &_table = _context->dispatcher.emulation;
          _context->emuLevel++;
          _table.call(&_table.glGenerateMipmap)(target);
          return;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGenerateMipmapEXT)(target);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetFramebufferAttachmentParameterivEXT(GLenum target, GLenum attachment, GLenum pname, GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
      #if REGAL_EMU_OBJ
      if (_context->obj) break;
      #endif
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
      #if REGAL_EMU_OBJ
      if (_context->obj)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 15;
        _dispatch.call(&_dispatch.glGetFramebufferAttachmentParameterivEXT)(target, attachment, pname, params);
        if (pname == GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME)
        {
          GLint attachType = GL_RENDERBUFFER;
          _dispatch.call(&_dispatch.glGetFramebufferAttachmentParameterivEXT)(target, attachment, GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE, &attachType);
          if (attachType == GL_TEXTURE)
            *params = _context->obj->textureNames.ToAppName(*params);
        }
        return;
      }
      #endif
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (!_context->info->gl_ext_framebuffer_object)
        {
          DispatchTableGL &_table = _context->dispatcher.emulation;
          _context->emuLevel++;
          _table.call(&_table.glGetFramebufferAttachmentParameteriv)(target, attachment, pname, params);
          return;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetFramebufferAttachmentParameterivEXT)(target, attachment, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetRenderbufferParameterivEXT(GLenum target, GLenum pname, GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreRenderbuffer( _context );
      }
      #endif
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (!_context->info->gl_ext_framebuffer_object)
        {
          DispatchTableGL &_table = _context->dispatcher.emulation;
          _context->emuLevel++;
          _table.call(&_table.glGetRenderbufferParameteriv)(target, pname, params);
          return;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetRenderbufferParameterivEXT)(target, pname, params);
      break;
    }

  }

}

static GLboolean REGAL_CALL emu_glIsFramebufferEXT(GLuint framebuffer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (!_context->info->gl_ext_framebuffer_object)
        {
          DispatchTableGL &_table = _context->dispatcher.emulation;
          _context->emuLevel++;
          return _table.call(&_table.glIsFramebuffer)(framebuffer);
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      return _next->call(&_next->glIsFramebufferEXT)(framebuffer);
    }

  }

}

static GLboolean REGAL_CALL emu_glIsRenderbufferEXT(GLuint renderbuffer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (!_context->info->gl_ext_framebuffer_object)
        {
          DispatchTableGL &_table = _context->dispatcher.emulation;
          _context->emuLevel++;
          return _table.call(&_table.glIsRenderbuffer)(renderbuffer);
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      return _next->call(&_next->glIsRenderbufferEXT)(renderbuffer);
    }

  }

}

static void REGAL_CALL emu_glRenderbufferStorageEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreRenderbuffer( _context );
      }
      #endif
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (!_context->info->gl_ext_framebuffer_object)
        {
          DispatchTableGL &_table = _context->dispatcher.emulation;
          _context->emuLevel++;
          _table.call(&_table.glRenderbufferStorage)(target, internalformat, width, height);
          return;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glRenderbufferStorageEXT)(target, internalformat, width, height);
      break;
    }

  }

}

// GL_EXT_geometry_shader4

static void REGAL_CALL emu_glFramebufferTextureEXT(GLenum target, GLenum attachment, GLuint texture, GLint level)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreFramebuffer( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glFramebufferTextureEXT)(target, attachment, texture, level);
}

static void REGAL_CALL emu_glFramebufferTextureFaceEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreFramebuffer( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glFramebufferTextureFaceEXT)(target, attachment, texture, level, face);
}

// GL_EXT_gpu_program_parameters

// GL_EXT_gpu_shader4

// GL_EXT_histogram

// GL_EXT_index_func

// GL_EXT_index_material

// GL_EXT_light_texture

// GL_EXT_map_buffer_range

static void REGAL_CALL emu_glFlushMappedBufferRangeEXT(GLenum target, GLintptr offset, GLsizeiptr length)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreBuffer( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glFlushMappedBufferRangeEXT)(target, offset, length);
}

static GLvoid *REGAL_CALL emu_glMapBufferRangeEXT(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreBuffer( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  return _next->call(& _next->glMapBufferRangeEXT)(target, offset, length, access);
}

// GL_EXT_multi_draw_arrays

static void REGAL_CALL emu_glMultiDrawArraysEXT(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->PreDraw( _context );
      }
      #endif
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        _context->so->PreDraw( *_context );
      }
      #endif
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->Restore( _context );
      }
      #endif
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        // _context->vao->Validate(*_context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glMultiDrawArraysEXT)(mode, first, count, primcount);
}

static void REGAL_CALL emu_glMultiDrawElementsEXT(GLenum mode, const GLsizei *count, GLenum type, const GLvoid **indices, GLsizei primcount)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->PreDraw( _context );
      }
      #endif
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        _context->so->PreDraw( *_context );
      }
      #endif
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->Restore( _context );
      }
      #endif
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        // _context->vao->Validate(*_context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glMultiDrawElementsEXT)(mode, count, type, indices, primcount);
}

// GL_EXT_multisample

// GL_EXT_multisampled_render_to_texture

static void REGAL_CALL emu_glFramebufferTexture2DMultisampleEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
      #if REGAL_EMU_OBJ
      if (_context->obj) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
      #if REGAL_EMU_OBJ
      if (_context->obj)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 15;
        _dispatch.call(&_dispatch.glFramebufferTexture2DMultisampleEXT)(target, attachment, textarget, _context->obj->textureNames.ToDriverName(texture), level, samples);
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glFramebufferTexture2DMultisampleEXT)(target, attachment, textarget, texture, level, samples);
      break;
    }

  }

}

// GL_EXT_multiview_draw_buffers

static void REGAL_CALL emu_glGetIntegeri_vEXT(GLenum target, GLuint index, GLint *data)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        if( ! _context->ppa->glGeti_v( _context, target, index, data ) ) {
          _context->dispatcher.emulation.glGetIntegeri_vEXT( target, index, data );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetIntegeri_vEXT)(target, index, data);
      break;
    }

  }

}

// GL_EXT_occlusion_query_boolean

// GL_EXT_paletted_texture

// GL_EXT_pixel_transform

// GL_EXT_point_parameters

// GL_EXT_polygon_offset

// GL_EXT_provoking_vertex

static void REGAL_CALL emu_glProvokingVertexEXT(GLenum mode)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
      #if REGAL_EMU_QUADS
      if (_context->quads)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 5;
        _context->quads->glProvokingVertex( mode );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glProvokingVertexEXT)(mode);
}

// GL_EXT_robustness

// GL_EXT_scene_marker

// GL_EXT_secondary_color

static void REGAL_CALL emu_glSecondaryColor3bEXT(GLbyte red, GLbyte green, GLbyte blue)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<3>( _context, _context->iff->AttrIndex( RFF2A_SecondaryColor ), red, green, blue );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glSecondaryColor3bEXT)(red, green, blue);
      break;
    }

  }

}

static void REGAL_CALL emu_glSecondaryColor3bvEXT(const GLbyte *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<3>( _context, _context->iff->AttrIndex( RFF2A_SecondaryColor ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glSecondaryColor3bvEXT)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glSecondaryColor3dEXT(GLdouble red, GLdouble green, GLdouble blue)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, _context->iff->AttrIndex( RFF2A_SecondaryColor ), red, green, blue );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glSecondaryColor3dEXT)(red, green, blue);
      break;
    }

  }

}

static void REGAL_CALL emu_glSecondaryColor3dvEXT(const GLdouble *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, _context->iff->AttrIndex( RFF2A_SecondaryColor ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glSecondaryColor3dvEXT)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glSecondaryColor3fEXT(GLfloat red, GLfloat green, GLfloat blue)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, _context->iff->AttrIndex( RFF2A_SecondaryColor ), red, green, blue );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glSecondaryColor3fEXT)(red, green, blue);
      break;
    }

  }

}

static void REGAL_CALL emu_glSecondaryColor3fvEXT(const GLfloat *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->Attr<3>( _context, _context->iff->AttrIndex( RFF2A_SecondaryColor ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glSecondaryColor3fvEXT)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glSecondaryColor3iEXT(GLint red, GLint green, GLint blue)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<3>( _context, _context->iff->AttrIndex( RFF2A_SecondaryColor ), red, green, blue );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glSecondaryColor3iEXT)(red, green, blue);
      break;
    }

  }

}

static void REGAL_CALL emu_glSecondaryColor3ivEXT(const GLint *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<3>( _context, _context->iff->AttrIndex( RFF2A_SecondaryColor ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glSecondaryColor3ivEXT)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glSecondaryColor3sEXT(GLshort red, GLshort green, GLshort blue)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<3>( _context, _context->iff->AttrIndex( RFF2A_SecondaryColor ), red, green, blue );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glSecondaryColor3sEXT)(red, green, blue);
      break;
    }

  }

}

static void REGAL_CALL emu_glSecondaryColor3svEXT(const GLshort *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<3>( _context, _context->iff->AttrIndex( RFF2A_SecondaryColor ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glSecondaryColor3svEXT)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glSecondaryColor3ubEXT(GLubyte red, GLubyte green, GLubyte blue)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<3>( _context, _context->iff->AttrIndex( RFF2A_SecondaryColor ), red, green, blue );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glSecondaryColor3ubEXT)(red, green, blue);
      break;
    }

  }

}

static void REGAL_CALL emu_glSecondaryColor3ubvEXT(const GLubyte *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<3>( _context, _context->iff->AttrIndex( RFF2A_SecondaryColor ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glSecondaryColor3ubvEXT)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glSecondaryColor3uiEXT(GLuint red, GLuint green, GLuint blue)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<3>( _context, _context->iff->AttrIndex( RFF2A_SecondaryColor ), red, green, blue );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glSecondaryColor3uiEXT)(red, green, blue);
      break;
    }

  }

}

static void REGAL_CALL emu_glSecondaryColor3uivEXT(const GLuint *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<3>( _context, _context->iff->AttrIndex( RFF2A_SecondaryColor ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glSecondaryColor3uivEXT)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glSecondaryColor3usEXT(GLushort red, GLushort green, GLushort blue)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<3>( _context, _context->iff->AttrIndex( RFF2A_SecondaryColor ), red, green, blue );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glSecondaryColor3usEXT)(red, green, blue);
      break;
    }

  }

}

static void REGAL_CALL emu_glSecondaryColor3usvEXT(const GLushort *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->AttrN<3>( _context, _context->iff->AttrIndex( RFF2A_SecondaryColor ), v );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glSecondaryColor3usvEXT)(v);
      break;
    }

  }

}

static void REGAL_CALL emu_glSecondaryColorPointerEXT(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->SecondaryColorPointer( _context, size, type, stride, pointer );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        _context->vao->SecondaryColorPointer(*_context, size, type, stride, pointer );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glSecondaryColorPointerEXT)(size, type, stride, pointer);
      break;
    }

  }

}

// GL_EXT_separate_shader_objects

// GL_EXT_shader_image_load_store

// GL_EXT_stencil_clear_tag

// GL_EXT_stencil_two_side

// GL_EXT_subtexture

static void REGAL_CALL emu_glTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
      #if REGAL_EMU_XFER
      if (_context->xfer) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
      #if REGAL_EMU_XFER
      if (_context->xfer)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 10;
        _context->xfer->TexSubImage2D( _context, target, level, xoffset, yoffset, width, height, format, type, pixels );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexSubImage2DEXT)(target, level, xoffset, yoffset, width, height, format, type, pixels);
      break;
    }

  }

}

// GL_EXT_texture3D

static void REGAL_CALL emu_glTexImage3DEXT(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->ShadowTexInfo( target, internalformat );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glTexImage3DEXT)(target, level, internalformat, width, height, depth, border, format, type, pixels);
}

// GL_EXT_texture_array

static void REGAL_CALL emu_glFramebufferTextureLayerEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreFramebuffer( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glFramebufferTextureLayerEXT)(target, attachment, texture, level, layer);
}

// GL_EXT_texture_buffer_object

// GL_EXT_texture_integer

static void REGAL_CALL emu_glTexParameterIivEXT(GLenum target, GLenum pname, const GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        if ( !_context->so->TexParameterv( *_context, target, pname, params ) ) {
           _context->dispatcher.emulation.glTexParameterIiv( target, pname, params );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexParameterIivEXT)(target, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexParameterIuivEXT(GLenum target, GLenum pname, const GLuint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        if ( !_context->so->TexParameterv( *_context, target, pname, params ) ) {
           _context->dispatcher.emulation.glTexParameterIuiv( target, pname, params );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexParameterIuivEXT)(target, pname, params);
      break;
    }

  }

}

// GL_EXT_texture_object

static void REGAL_CALL emu_glBindTextureEXT(GLenum target, GLuint texture)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->ShadowTexBinding( target, texture );
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa) break;
      #endif
    case 3 :
    case 2 :
      #if REGAL_EMU_TEXC
      if (_context->texc)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 1;
        _context->texc->ShadowBindTexture( target, texture );
      }
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        if (!_context->dsa->ShadowTexture( target, texture )) {
            _dispatch.call(&_dispatch.glBindTexture)( target, texture );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glBindTextureEXT)(target, texture);
      break;
    }

  }

}

static void REGAL_CALL emu_glDeleteTexturesEXT(GLsizei n, const GLuint *textures)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DeleteTextures( _context, n, textures );
      }
      #endif
    case 3 :
    case 2 :
      #if REGAL_EMU_TEXC
      if (_context->texc)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 1;
        _context->texc->ShadowDeleteTextures( n, textures );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glDeleteTexturesEXT)(n, textures);
}

static void REGAL_CALL emu_glGenTexturesEXT(GLsizei n, GLuint *textures)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
      #if REGAL_EMU_TEXC
      if (_context->texc) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
      #if REGAL_EMU_TEXC
      if (_context->texc)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 1;

        _context->dispatcher.emulation.glGenTextures( n, textures );
        _context->texc->ShadowGenTextures( n, textures );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGenTexturesEXT)(n, textures);
      break;
    }

  }

}

// GL_EXT_texture_perturb_normal

// GL_EXT_texture_storage

static void REGAL_CALL emu_glTexStorage1DEXT(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
      #if REGAL_EMU_TEXSTO
      if (_context->texsto) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
      #if REGAL_EMU_TEXSTO
      if (_context->texsto)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 9;
        _context->texsto->TextureStorage( _context, target, levels, internalformat, width );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexStorage1DEXT)(target, levels, internalformat, width);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexStorage2DEXT(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
      #if REGAL_EMU_TEXSTO
      if (_context->texsto) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
      #if REGAL_EMU_TEXSTO
      if (_context->texsto)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 9;
        _context->texsto->TextureStorage( _context, target, levels, internalformat, width, height );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexStorage2DEXT)(target, levels, internalformat, width, height);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexStorage3DEXT(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
      #if REGAL_EMU_TEXSTO
      if (_context->texsto) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
      #if REGAL_EMU_TEXSTO
      if (_context->texsto)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 9;
        _context->texsto->TextureStorage( _context, target, levels, internalformat, width, height, depth );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexStorage3DEXT)(target, levels, internalformat, width, height, depth);
      break;
    }

  }

}

// GL_EXT_timer_query

// GL_EXT_transform_feedback

// GL_EXT_vertex_array

static void REGAL_CALL emu_glColorPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->ColorPointer( _context, size, type, stride, pointer );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        _context->vao->ColorPointer(*_context, size, type, stride, pointer );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glColorPointerEXT)(size, type, stride, count, pointer);
      break;
    }

  }

}

static void REGAL_CALL emu_glDrawArraysEXT(GLenum mode, GLint first, GLsizei count)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->PreDraw( _context );
      }
      #endif
    case 6 :
      #if REGAL_EMU_QUADS
      if (_context->quads) break;
      #endif
    case 5 :
      #if REGAL_EMU_SO
      if (_context->so)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 4;
        RegalAssert(_context);
        _context->so->PreDraw( *_context );
      }
      #endif
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->Restore( _context );
      }
      #endif
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        // _context->vao->Validate(*_context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
      #if REGAL_EMU_QUADS
      if (_context->quads)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 5;

        if ( ! _context->quads->glDrawArrays( _context, mode, first, count ) ) {
          DispatchTableGL *_next = _context->dispatcher.emulation.next();
          RegalAssert(_next);
          return _next->call(&_next->glDrawArrays)( mode, first, count );
        }

        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glDrawArraysEXT)(mode, first, count);
      break;
    }

  }

}

static void REGAL_CALL emu_glEdgeFlagPointerEXT(GLsizei stride, GLsizei count, const GLboolean *pointer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->EdgeFlagPointer( _context, stride, pointer );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glEdgeFlagPointerEXT)(stride, count, pointer);
      break;
    }

  }

}

static void REGAL_CALL emu_glNormalPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->NormalPointer( _context, type, stride, pointer );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        _context->vao->NormalPointer(*_context, type, stride, pointer );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glNormalPointerEXT)(type, stride, count, pointer);
      break;
    }

  }

}

static void REGAL_CALL emu_glTexCoordPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->TexCoordPointer( _context, size, type, stride, pointer );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        _context->vao->TexCoordPointer(*_context, size, type, stride, pointer );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glTexCoordPointerEXT)(size, type, stride, count, pointer);
      break;
    }

  }

}

static void REGAL_CALL emu_glVertexPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff) break;
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->VertexPointer( _context, size, type, stride, pointer );
        return;
      }
      #endif
    case 6 :
    case 5 :
    case 4 :
    case 3 :
      #if REGAL_EMU_VAO
      if (_context->vao)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 2;
        _context->vao->VertexPointer(*_context, size, type, stride, pointer );
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glVertexPointerEXT)(size, type, stride, count, pointer);
      break;
    }

  }

}

// GL_EXT_vertex_attrib_64bit

// GL_EXT_vertex_shader

// GL_EXT_vertex_weighting

// GL_EXT_x11_sync_object

// GL_GREMEDY_frame_terminator

// GL_GREMEDY_string_marker

// GL_HP_image_transform

// GL_IBM_multimode_draw_arrays

// GL_IBM_vertex_array_lists

// GL_IMG_multisampled_render_to_texture

// GL_INGR_blend_func_separate

// GL_INTEL_map_texture

// GL_INTEL_parallel_arrays

// GL_INTEL_texture_scissor

// GL_KHR_debug

// GL_KTX_buffer_region

// GL_MESA_resize_buffers

// GL_MESA_window_pos

// GL_NVX_conditional_render

// GL_NV_bindless_texture

// GL_NV_blend_equation_advanced

// GL_NV_conditional_render

// GL_NV_copy_buffer

// GL_NV_copy_image

// GL_NV_coverage_sample

// GL_NV_depth_buffer_float

// GL_NV_draw_buffers

static void REGAL_CALL emu_glDrawBuffersNV(GLsizei n, const GLenum *bufs)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        if( !_context->isES2() ) {
          _context->ppa->glDrawBuffers( n, bufs );
          _context->dispatcher.emulation.glDrawBuffers( n, bufs );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glDrawBuffersNV)(n, bufs);
      break;
    }

  }

}

// GL_NV_draw_texture

// GL_NV_evaluators

// GL_NV_explicit_multisample

static void REGAL_CALL emu_glTexRenderbufferNV(GLenum target, GLuint renderbuffer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreTexture( _context );
        _context->dsa->RestoreActiveTexture( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glTexRenderbufferNV)(target, renderbuffer);
}

// GL_NV_fence

// GL_NV_fragment_program

// GL_NV_framebuffer_blit

// GL_NV_framebuffer_multisample_coverage

static void REGAL_CALL emu_glRenderbufferStorageMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreRenderbuffer( _context );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glRenderbufferStorageMultisampleCoverageNV)(target, coverageSamples, colorSamples, internalformat, width, height);
}

// GL_NV_geometry_program4

// GL_NV_gpu_program4

static void REGAL_CALL emu_glGetProgramEnvParameterIivNV(GLenum target, GLuint index, GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreAsmProgram( _context, target );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glGetProgramEnvParameterIivNV)(target, index, params);
}

static void REGAL_CALL emu_glGetProgramEnvParameterIuivNV(GLenum target, GLuint index, GLuint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreAsmProgram( _context, target );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glGetProgramEnvParameterIuivNV)(target, index, params);
}

static void REGAL_CALL emu_glGetProgramLocalParameterIivNV(GLenum target, GLuint index, GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreAsmProgram( _context, target );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glGetProgramLocalParameterIivNV)(target, index, params);
}

static void REGAL_CALL emu_glGetProgramLocalParameterIuivNV(GLenum target, GLuint index, GLuint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreAsmProgram( _context, target );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glGetProgramLocalParameterIuivNV)(target, index, params);
}

static void REGAL_CALL emu_glProgramEnvParameterI4iNV(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreAsmProgram( _context, target );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glProgramEnvParameterI4iNV)(target, index, x, y, z, w);
}

static void REGAL_CALL emu_glProgramEnvParameterI4ivNV(GLenum target, GLuint index, const GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreAsmProgram( _context, target );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glProgramEnvParameterI4ivNV)(target, index, params);
}

static void REGAL_CALL emu_glProgramEnvParameterI4uiNV(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreAsmProgram( _context, target );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glProgramEnvParameterI4uiNV)(target, index, x, y, z, w);
}

static void REGAL_CALL emu_glProgramEnvParameterI4uivNV(GLenum target, GLuint index, const GLuint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreAsmProgram( _context, target );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glProgramEnvParameterI4uivNV)(target, index, params);
}

static void REGAL_CALL emu_glProgramEnvParametersI4ivNV(GLenum target, GLuint index, GLsizei count, const GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreAsmProgram( _context, target );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glProgramEnvParametersI4ivNV)(target, index, count, params);
}

static void REGAL_CALL emu_glProgramEnvParametersI4uivNV(GLenum target, GLuint index, GLsizei count, const GLuint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreAsmProgram( _context, target );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glProgramEnvParametersI4uivNV)(target, index, count, params);
}

static void REGAL_CALL emu_glProgramLocalParameterI4iNV(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreAsmProgram( _context, target );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glProgramLocalParameterI4iNV)(target, index, x, y, z, w);
}

static void REGAL_CALL emu_glProgramLocalParameterI4ivNV(GLenum target, GLuint index, const GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreAsmProgram( _context, target );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glProgramLocalParameterI4ivNV)(target, index, params);
}

static void REGAL_CALL emu_glProgramLocalParameterI4uiNV(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreAsmProgram( _context, target );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glProgramLocalParameterI4uiNV)(target, index, x, y, z, w);
}

static void REGAL_CALL emu_glProgramLocalParameterI4uivNV(GLenum target, GLuint index, const GLuint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreAsmProgram( _context, target );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glProgramLocalParameterI4uivNV)(target, index, params);
}

static void REGAL_CALL emu_glProgramLocalParametersI4ivNV(GLenum target, GLuint index, GLsizei count, const GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreAsmProgram( _context, target );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glProgramLocalParametersI4ivNV)(target, index, count, params);
}

static void REGAL_CALL emu_glProgramLocalParametersI4uivNV(GLenum target, GLuint index, GLsizei count, const GLuint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->RestoreAsmProgram( _context, target );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glProgramLocalParametersI4uivNV)(target, index, count, params);
}

// GL_NV_gpu_shader5

// GL_NV_half_float

// GL_NV_non_square_matrices

// GL_NV_occlusion_query

// GL_NV_parameter_buffer_object

// GL_NV_path_rendering

// GL_NV_pixel_data_range

// GL_NV_point_sprite

// GL_NV_present_video

// GL_NV_primitive_restart

// GL_NV_read_buffer

// GL_NV_register_combiners

// GL_NV_register_combiners2

// GL_NV_shader_buffer_load

// GL_NV_texture_barrier

// GL_NV_texture_multisample

static void REGAL_CALL emu_glTexImage2DMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->ShadowTexInfo( target, internalFormat );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glTexImage2DMultisampleCoverageNV)(target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
}

static void REGAL_CALL emu_glTexImage3DMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->ShadowTexInfo( target, internalFormat );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glTexImage3DMultisampleCoverageNV)(target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
}

// GL_NV_transform_feedback

// GL_NV_transform_feedback2

// GL_NV_vdpau_interop

// GL_NV_vertex_array_range

// GL_NV_vertex_attrib_integer_64bit

// GL_NV_vertex_buffer_unified_memory

// GL_NV_vertex_program

static void REGAL_CALL emu_glDeleteProgramsNV(GLsizei n, const GLuint *programs)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DeleteAsmPrograms( _context, n, programs );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glDeleteProgramsNV)(n, programs);
}

// GL_NV_video_capture

// GL_OES_blend_equation_separate

// GL_OES_blend_func_separate

// GL_OES_blend_subtract

// GL_OES_framebuffer_object

static void REGAL_CALL emu_glBindFramebufferOES(GLenum target, GLuint framebuffer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt) break;
      #endif
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
    case 3 :
    case 2 :
    case 1 :
      #if REGAL_EMU_FILTER
      if (_context->filt)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 0;
        if (_context->isES2())
        {
          const bool hasFBBlit = _context->info->gl_ext_framebuffer_blit || _context->info->gl_nv_framebuffer_blit || _context->info->gl_version_major >= 3;
          if (!hasFBBlit && (target==GL_DRAW_FRAMEBUFFER || target==GL_READ_FRAMEBUFFER)) target = GL_FRAMEBUFFER;
        }
        if (_context->filt->BindFramebuffer(*_context, target, framebuffer))
        {
          #if REGAL_BREAK
          Break::Filter();
          #endif
          return ;
        }
      }
      #endif
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glBindFramebufferOES)(target, framebuffer);
      break;
    }

  }

}

static void REGAL_CALL emu_glDeleteFramebuffersOES(GLsizei n, const GLuint *framebuffers)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DeleteFramebuffers( _context, n, framebuffers );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glDeleteFramebuffersOES)(n, framebuffers);
}

static void REGAL_CALL emu_glDeleteRenderbuffersOES(GLsizei n, const GLuint *renderbuffers)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DeleteRenderbuffers( _context, n, renderbuffers );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glDeleteRenderbuffersOES)(n, renderbuffers);
}

static void REGAL_CALL emu_glFramebufferTexture2DOES(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
      #if REGAL_EMU_OBJ
      if (_context->obj) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
      #if REGAL_EMU_OBJ
      if (_context->obj)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 15;
        _dispatch.call(&_dispatch.glFramebufferTexture2DOES)(target, attachment, textarget, _context->obj->textureNames.ToDriverName(texture), level);
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glFramebufferTexture2DOES)(target, attachment, textarget, texture, level);
      break;
    }

  }

}

// GL_OES_get_program_binary

// GL_OES_mapbuffer

// GL_OES_matrix_palette

// GL_OES_single_precision

// GL_OES_texture_3D

static void REGAL_CALL emu_glFramebufferTexture3DOES(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
      #if REGAL_EMU_OBJ
      if (_context->obj) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
      #if REGAL_EMU_OBJ
      if (_context->obj)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 15;
        _dispatch.call(&_dispatch.glFramebufferTexture3DOES)(target, attachment, textarget, _context->obj->textureNames.ToDriverName(texture), level, zoffset);
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glFramebufferTexture3DOES)(target, attachment, textarget, texture, level, zoffset);
      break;
    }

  }

}

// GL_OES_texture_cube_map

// GL_OES_vertex_array_object

static void REGAL_CALL emu_glBindVertexArrayOES(GLuint array)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->glBindVertexArray( _context, array );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glBindVertexArrayOES)(array);
}

static void REGAL_CALL emu_glDeleteVertexArraysOES(GLsizei n, const GLuint *arrays)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
    case 6 :
    case 5 :
    case 4 :
      #if REGAL_EMU_DSA
      if (_context->dsa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 3;
        _context->dsa->DeleteVaos( _context, n, arrays );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glDeleteVertexArraysOES)(n, arrays);
}

// GL_PGI_misc_hints

// GL_QCOM_alpha_test

// GL_QCOM_driver_control

// GL_QCOM_extended_get

// GL_QCOM_extended_get2

// GL_QCOM_tiled_rendering

// GL_REGAL_ES1_0_compatibility

static void REGAL_CALL emu_glFogxv(GLenum pname, const GLfixed *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glFogxv)(pname, params);
}

static void REGAL_CALL emu_glLightModelxv(GLenum pname, const GLfixed *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glLightModelxv)(pname, params);
}

static void REGAL_CALL emu_glLightxv(GLenum light, GLenum pname, const GLfixed *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glLightxv)(light, pname, params);
}

static void REGAL_CALL emu_glLoadMatrixx(const GLfixed *m)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glLoadMatrixx)(m);
}

static void REGAL_CALL emu_glMaterialxv(GLenum face, GLenum pname, const GLfixed *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glMaterialxv)(face, pname, params);
}

static void REGAL_CALL emu_glMultMatrixx(const GLfixed *m)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glMultMatrixx)(m);
}

static void REGAL_CALL emu_glTexEnvxv(GLenum target, GLenum pname, const GLfixed *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glTexEnvxv)(target, pname, params);
}

// GL_REGAL_ES1_1_compatibility

static void REGAL_CALL emu_glClipPlanef(GLenum plane, const GLfloat *equation)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glClipPlanef)(plane, equation);
}

static void REGAL_CALL emu_glClipPlanex(GLenum plane, const GLfixed *equation)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glClipPlanex)(plane, equation);
}

static void REGAL_CALL emu_glGetClipPlanef(GLenum pname, GLfloat *eqn)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glGetClipPlanef)(pname, eqn);
}

static void REGAL_CALL emu_glGetClipPlanex(GLenum pname, GLfixed *eqn)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glGetClipPlanex)(pname, eqn);
}

static void REGAL_CALL emu_glGetFixedv(GLenum pname, GLfixed *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glGetFixedv)(pname, params);
}

static void REGAL_CALL emu_glGetLightxv(GLenum light, GLenum pname, GLfixed *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        if( ! _context->ppa->glGetLightv( _context, light, pname, params ) ) {
          _context->dispatcher.emulation.glGetLightxv( light, pname, params );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetLightxv)(light, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetMaterialxv(GLenum face, GLenum pname, GLfixed *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa) break;
      #endif
    case 1 :
    default:
      break;
  }

  // impl
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
      #if REGAL_EMU_PPA
      if (_context->ppa)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 13;
        if( ! _context->ppa->glGetMaterialv( _context, face, pname, params ) ) {
          _context->dispatcher.emulation.glGetMaterialxv( face, pname, params );
        }
        return;
      }
      #endif
    case 1 :
    default:
    {
      DispatchTableGL *_next = _dispatch.next();
      RegalAssert(_next);
      _next->call(&_next->glGetMaterialxv)(face, pname, params);
      break;
    }

  }

}

static void REGAL_CALL emu_glGetTexEnvxv(GLenum env, GLenum pname, GLfixed *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glGetTexEnvxv)(env, pname, params);
}

static void REGAL_CALL emu_glGetTexParameterxv(GLenum target, GLenum pname, GLfixed *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glGetTexParameterxv)(target, pname, params);
}

static void REGAL_CALL emu_glPointParameterx(GLenum pname, GLfixed param)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glPointParameterx)(pname, param);
}

static void REGAL_CALL emu_glPointParameterxv(GLenum pname, const GLfixed *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glPointParameterxv)(pname, params);
}

static void REGAL_CALL emu_glTexParameterxv(GLenum target, GLenum pname, const GLfixed *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glTexParameterxv)(target, pname, params);
}

// GL_REGAL_log

// GL_SGIS_detail_texture

// GL_SGIS_fog_function

// GL_SGIS_multisample

// GL_SGIS_pixel_texture

// GL_SGIS_point_parameters

// GL_SGIS_sharpen_texture

// GL_SGIS_texture4D

static void REGAL_CALL emu_glTexImage4DSGIS(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  DispatchTableGL &_dispatch = _context->dispatcher.emulation;

  // prefix
  switch( _context->emuLevel )
  {
    case 16 :
    case 15 :
    case 14 :
    case 13 :
    case 12 :
    case 11 :
    case 10 :
    case 9 :
    case 8 :
    case 7 :
      #if REGAL_EMU_IFF
      if (_context->iff)
      {
        Push<int> pushLevel(_context->emuLevel);
        _context->emuLevel = 6;
        _context->iff->ShadowTexInfo( target, internalformat );
      }
      #endif
    case 1 :
    default:
      break;
  }

  DispatchTableGL *_next = _dispatch.next();
  RegalAssert(_next);
  _next->call(& _next->glTexImage4DSGIS)(target, level, internalformat, width, height, depth, size4d, border, format, type, pixels);
}

// GL_SGIS_texture_color_mask

// GL_SGIS_texture_filter4

// GL_SGIX_async

// GL_SGIX_flush_raster

// GL_SGIX_fog_texture

// GL_SGIX_fragment_lighting

// GL_SGIX_framezoom

// GL_SGIX_igloo_interface

// GL_SGIX_instruments

// GL_SGIX_list_priority

// GL_SGIX_pixel_texture

// GL_SGIX_polynomial_ffd

// GL_SGIX_reference_plane

// GL_SGIX_sprite

// GL_SGIX_tag_sample_buffer

// GL_SGI_color_table

// GL_SUNX_constant_data

// GL_SUN_global_alpha

// GL_SUN_mesh_array

// GL_SUN_read_video_pixels

// GL_SUN_triangle_list

// GL_SUN_vertex

// GL_WIN_swap_hint

void InitDispatchTableEmu(DispatchTableGL &tbl)
{

// GL_VERSION_1_0

   tbl.glAccum = emu_glAccum;
   tbl.glAlphaFunc = emu_glAlphaFunc;
   tbl.glBegin = emu_glBegin;
   tbl.glBitmap = emu_glBitmap;
   tbl.glBlendFunc = emu_glBlendFunc;
   tbl.glCallList = emu_glCallList;
   tbl.glClearAccum = emu_glClearAccum;
   tbl.glClearColor = emu_glClearColor;
   tbl.glClearDepth = emu_glClearDepth;
   tbl.glClearIndex = emu_glClearIndex;
   tbl.glClearStencil = emu_glClearStencil;
   tbl.glClipPlane = emu_glClipPlane;
   tbl.glColor3b = emu_glColor3b;
   tbl.glColor3bv = emu_glColor3bv;
   tbl.glColor3d = emu_glColor3d;
   tbl.glColor3dv = emu_glColor3dv;
   tbl.glColor3f = emu_glColor3f;
   tbl.glColor3fv = emu_glColor3fv;
   tbl.glColor3i = emu_glColor3i;
   tbl.glColor3iv = emu_glColor3iv;
   tbl.glColor3s = emu_glColor3s;
   tbl.glColor3sv = emu_glColor3sv;
   tbl.glColor3ub = emu_glColor3ub;
   tbl.glColor3ubv = emu_glColor3ubv;
   tbl.glColor3ui = emu_glColor3ui;
   tbl.glColor3uiv = emu_glColor3uiv;
   tbl.glColor3us = emu_glColor3us;
   tbl.glColor3usv = emu_glColor3usv;
   tbl.glColor4b = emu_glColor4b;
   tbl.glColor4bv = emu_glColor4bv;
   tbl.glColor4d = emu_glColor4d;
   tbl.glColor4dv = emu_glColor4dv;
   tbl.glColor4f = emu_glColor4f;
   tbl.glColor4fv = emu_glColor4fv;
   tbl.glColor4i = emu_glColor4i;
   tbl.glColor4iv = emu_glColor4iv;
   tbl.glColor4s = emu_glColor4s;
   tbl.glColor4sv = emu_glColor4sv;
   tbl.glColor4ub = emu_glColor4ub;
   tbl.glColor4ubv = emu_glColor4ubv;
   tbl.glColor4ui = emu_glColor4ui;
   tbl.glColor4uiv = emu_glColor4uiv;
   tbl.glColor4us = emu_glColor4us;
   tbl.glColor4usv = emu_glColor4usv;
   tbl.glColorMask = emu_glColorMask;
   tbl.glColorMaterial = emu_glColorMaterial;
   tbl.glCopyPixels = emu_glCopyPixels;
   tbl.glCullFace = emu_glCullFace;
   tbl.glDeleteLists = emu_glDeleteLists;
   tbl.glDepthFunc = emu_glDepthFunc;
   tbl.glDepthMask = emu_glDepthMask;
   tbl.glDepthRange = emu_glDepthRange;
   tbl.glDisable = emu_glDisable;
   tbl.glDrawBuffer = emu_glDrawBuffer;
   tbl.glDrawPixels = emu_glDrawPixels;
   tbl.glEdgeFlag = emu_glEdgeFlag;
   tbl.glEnable = emu_glEnable;
   tbl.glEnd = emu_glEnd;
   tbl.glEndList = emu_glEndList;
   tbl.glEvalCoord1d = emu_glEvalCoord1d;
   tbl.glEvalCoord1dv = emu_glEvalCoord1dv;
   tbl.glEvalCoord1f = emu_glEvalCoord1f;
   tbl.glEvalCoord1fv = emu_glEvalCoord1fv;
   tbl.glEvalCoord2d = emu_glEvalCoord2d;
   tbl.glEvalCoord2dv = emu_glEvalCoord2dv;
   tbl.glEvalCoord2f = emu_glEvalCoord2f;
   tbl.glEvalCoord2fv = emu_glEvalCoord2fv;
   tbl.glEvalMesh1 = emu_glEvalMesh1;
   tbl.glEvalMesh2 = emu_glEvalMesh2;
   tbl.glEvalPoint1 = emu_glEvalPoint1;
   tbl.glEvalPoint2 = emu_glEvalPoint2;
   tbl.glFogf = emu_glFogf;
   tbl.glFogfv = emu_glFogfv;
   tbl.glFogi = emu_glFogi;
   tbl.glFogiv = emu_glFogiv;
   tbl.glFrontFace = emu_glFrontFace;
   tbl.glFrustum = emu_glFrustum;
   tbl.glGenLists = emu_glGenLists;
   tbl.glGetBooleanv = emu_glGetBooleanv;
   tbl.glGetDoublev = emu_glGetDoublev;
   tbl.glGetFloatv = emu_glGetFloatv;
   tbl.glGetIntegerv = emu_glGetIntegerv;
   tbl.glGetLightfv = emu_glGetLightfv;
   tbl.glGetLightiv = emu_glGetLightiv;
   tbl.glGetMaterialfv = emu_glGetMaterialfv;
   tbl.glGetMaterialiv = emu_glGetMaterialiv;
   tbl.glGetPolygonStipple = emu_glGetPolygonStipple;
   tbl.glGetTexEnvfv = emu_glGetTexEnvfv;
   tbl.glGetTexEnviv = emu_glGetTexEnviv;
   tbl.glGetTexGendv = emu_glGetTexGendv;
   tbl.glGetTexGenfv = emu_glGetTexGenfv;
   tbl.glGetTexGeniv = emu_glGetTexGeniv;
   tbl.glGetTexImage = emu_glGetTexImage;
   tbl.glGetTexLevelParameterfv = emu_glGetTexLevelParameterfv;
   tbl.glGetTexLevelParameteriv = emu_glGetTexLevelParameteriv;
   tbl.glGetTexParameterfv = emu_glGetTexParameterfv;
   tbl.glGetTexParameteriv = emu_glGetTexParameteriv;
   tbl.glHint = emu_glHint;
   tbl.glIndexMask = emu_glIndexMask;
   tbl.glIsEnabled = emu_glIsEnabled;
   tbl.glLightModelf = emu_glLightModelf;
   tbl.glLightModelfv = emu_glLightModelfv;
   tbl.glLightModeli = emu_glLightModeli;
   tbl.glLightModeliv = emu_glLightModeliv;
   tbl.glLightf = emu_glLightf;
   tbl.glLightfv = emu_glLightfv;
   tbl.glLighti = emu_glLighti;
   tbl.glLightiv = emu_glLightiv;
   tbl.glLineStipple = emu_glLineStipple;
   tbl.glLineWidth = emu_glLineWidth;
   tbl.glListBase = emu_glListBase;
   tbl.glLoadIdentity = emu_glLoadIdentity;
   tbl.glLoadMatrixd = emu_glLoadMatrixd;
   tbl.glLoadMatrixf = emu_glLoadMatrixf;
   tbl.glLogicOp = emu_glLogicOp;
   tbl.glMap1d = emu_glMap1d;
   tbl.glMap1f = emu_glMap1f;
   tbl.glMap2d = emu_glMap2d;
   tbl.glMap2f = emu_glMap2f;
   tbl.glMapGrid1d = emu_glMapGrid1d;
   tbl.glMapGrid1f = emu_glMapGrid1f;
   tbl.glMapGrid2d = emu_glMapGrid2d;
   tbl.glMapGrid2f = emu_glMapGrid2f;
   tbl.glMaterialf = emu_glMaterialf;
   tbl.glMaterialfv = emu_glMaterialfv;
   tbl.glMateriali = emu_glMateriali;
   tbl.glMaterialiv = emu_glMaterialiv;
   tbl.glMatrixMode = emu_glMatrixMode;
   tbl.glMultMatrixd = emu_glMultMatrixd;
   tbl.glMultMatrixf = emu_glMultMatrixf;
   tbl.glNewList = emu_glNewList;
   tbl.glNormal3b = emu_glNormal3b;
   tbl.glNormal3bv = emu_glNormal3bv;
   tbl.glNormal3d = emu_glNormal3d;
   tbl.glNormal3dv = emu_glNormal3dv;
   tbl.glNormal3f = emu_glNormal3f;
   tbl.glNormal3fv = emu_glNormal3fv;
   tbl.glNormal3i = emu_glNormal3i;
   tbl.glNormal3iv = emu_glNormal3iv;
   tbl.glNormal3s = emu_glNormal3s;
   tbl.glNormal3sv = emu_glNormal3sv;
   tbl.glOrtho = emu_glOrtho;
   tbl.glPixelStoref = emu_glPixelStoref;
   tbl.glPixelStorei = emu_glPixelStorei;
   tbl.glPixelTransferf = emu_glPixelTransferf;
   tbl.glPixelTransferi = emu_glPixelTransferi;
   tbl.glPixelZoom = emu_glPixelZoom;
   tbl.glPointSize = emu_glPointSize;
   tbl.glPolygonMode = emu_glPolygonMode;
   tbl.glPolygonStipple = emu_glPolygonStipple;
   tbl.glPopAttrib = emu_glPopAttrib;
   tbl.glPopMatrix = emu_glPopMatrix;
   tbl.glPushAttrib = emu_glPushAttrib;
   tbl.glPushMatrix = emu_glPushMatrix;
   tbl.glRasterPos2d = emu_glRasterPos2d;
   tbl.glRasterPos2dv = emu_glRasterPos2dv;
   tbl.glRasterPos2f = emu_glRasterPos2f;
   tbl.glRasterPos2fv = emu_glRasterPos2fv;
   tbl.glRasterPos2i = emu_glRasterPos2i;
   tbl.glRasterPos2iv = emu_glRasterPos2iv;
   tbl.glRasterPos2s = emu_glRasterPos2s;
   tbl.glRasterPos2sv = emu_glRasterPos2sv;
   tbl.glRasterPos3d = emu_glRasterPos3d;
   tbl.glRasterPos3dv = emu_glRasterPos3dv;
   tbl.glRasterPos3f = emu_glRasterPos3f;
   tbl.glRasterPos3fv = emu_glRasterPos3fv;
   tbl.glRasterPos3i = emu_glRasterPos3i;
   tbl.glRasterPos3iv = emu_glRasterPos3iv;
   tbl.glRasterPos3s = emu_glRasterPos3s;
   tbl.glRasterPos3sv = emu_glRasterPos3sv;
   tbl.glRasterPos4d = emu_glRasterPos4d;
   tbl.glRasterPos4dv = emu_glRasterPos4dv;
   tbl.glRasterPos4f = emu_glRasterPos4f;
   tbl.glRasterPos4fv = emu_glRasterPos4fv;
   tbl.glRasterPos4i = emu_glRasterPos4i;
   tbl.glRasterPos4iv = emu_glRasterPos4iv;
   tbl.glRasterPos4s = emu_glRasterPos4s;
   tbl.glRasterPos4sv = emu_glRasterPos4sv;
   tbl.glReadBuffer = emu_glReadBuffer;
   tbl.glRectd = emu_glRectd;
   tbl.glRectdv = emu_glRectdv;
   tbl.glRectf = emu_glRectf;
   tbl.glRectfv = emu_glRectfv;
   tbl.glRecti = emu_glRecti;
   tbl.glRectiv = emu_glRectiv;
   tbl.glRects = emu_glRects;
   tbl.glRectsv = emu_glRectsv;
   tbl.glRenderMode = emu_glRenderMode;
   tbl.glRotated = emu_glRotated;
   tbl.glRotatef = emu_glRotatef;
   tbl.glScaled = emu_glScaled;
   tbl.glScalef = emu_glScalef;
   tbl.glScissor = emu_glScissor;
   tbl.glShadeModel = emu_glShadeModel;
   tbl.glStencilFunc = emu_glStencilFunc;
   tbl.glStencilMask = emu_glStencilMask;
   tbl.glStencilOp = emu_glStencilOp;
   tbl.glTexCoord1d = emu_glTexCoord1d;
   tbl.glTexCoord1dv = emu_glTexCoord1dv;
   tbl.glTexCoord1f = emu_glTexCoord1f;
   tbl.glTexCoord1fv = emu_glTexCoord1fv;
   tbl.glTexCoord1i = emu_glTexCoord1i;
   tbl.glTexCoord1iv = emu_glTexCoord1iv;
   tbl.glTexCoord1s = emu_glTexCoord1s;
   tbl.glTexCoord1sv = emu_glTexCoord1sv;
   tbl.glTexCoord2d = emu_glTexCoord2d;
   tbl.glTexCoord2dv = emu_glTexCoord2dv;
   tbl.glTexCoord2f = emu_glTexCoord2f;
   tbl.glTexCoord2fv = emu_glTexCoord2fv;
   tbl.glTexCoord2i = emu_glTexCoord2i;
   tbl.glTexCoord2iv = emu_glTexCoord2iv;
   tbl.glTexCoord2s = emu_glTexCoord2s;
   tbl.glTexCoord2sv = emu_glTexCoord2sv;
   tbl.glTexCoord3d = emu_glTexCoord3d;
   tbl.glTexCoord3dv = emu_glTexCoord3dv;
   tbl.glTexCoord3f = emu_glTexCoord3f;
   tbl.glTexCoord3fv = emu_glTexCoord3fv;
   tbl.glTexCoord3i = emu_glTexCoord3i;
   tbl.glTexCoord3iv = emu_glTexCoord3iv;
   tbl.glTexCoord3s = emu_glTexCoord3s;
   tbl.glTexCoord3sv = emu_glTexCoord3sv;
   tbl.glTexCoord4d = emu_glTexCoord4d;
   tbl.glTexCoord4dv = emu_glTexCoord4dv;
   tbl.glTexCoord4f = emu_glTexCoord4f;
   tbl.glTexCoord4fv = emu_glTexCoord4fv;
   tbl.glTexCoord4i = emu_glTexCoord4i;
   tbl.glTexCoord4iv = emu_glTexCoord4iv;
   tbl.glTexCoord4s = emu_glTexCoord4s;
   tbl.glTexCoord4sv = emu_glTexCoord4sv;
   tbl.glTexEnvf = emu_glTexEnvf;
   tbl.glTexEnvfv = emu_glTexEnvfv;
   tbl.glTexEnvi = emu_glTexEnvi;
   tbl.glTexEnviv = emu_glTexEnviv;
   tbl.glTexGend = emu_glTexGend;
   tbl.glTexGendv = emu_glTexGendv;
   tbl.glTexGenf = emu_glTexGenf;
   tbl.glTexGenfv = emu_glTexGenfv;
   tbl.glTexGeni = emu_glTexGeni;
   tbl.glTexGeniv = emu_glTexGeniv;
   tbl.glTexImage1D = emu_glTexImage1D;
   tbl.glTexImage2D = emu_glTexImage2D;
   tbl.glTexParameterf = emu_glTexParameterf;
   tbl.glTexParameterfv = emu_glTexParameterfv;
   tbl.glTexParameteri = emu_glTexParameteri;
   tbl.glTexParameteriv = emu_glTexParameteriv;
   tbl.glTranslated = emu_glTranslated;
   tbl.glTranslatef = emu_glTranslatef;
   tbl.glVertex2d = emu_glVertex2d;
   tbl.glVertex2dv = emu_glVertex2dv;
   tbl.glVertex2f = emu_glVertex2f;
   tbl.glVertex2fv = emu_glVertex2fv;
   tbl.glVertex2i = emu_glVertex2i;
   tbl.glVertex2iv = emu_glVertex2iv;
   tbl.glVertex2s = emu_glVertex2s;
   tbl.glVertex2sv = emu_glVertex2sv;
   tbl.glVertex3d = emu_glVertex3d;
   tbl.glVertex3dv = emu_glVertex3dv;
   tbl.glVertex3f = emu_glVertex3f;
   tbl.glVertex3fv = emu_glVertex3fv;
   tbl.glVertex3i = emu_glVertex3i;
   tbl.glVertex3iv = emu_glVertex3iv;
   tbl.glVertex3s = emu_glVertex3s;
   tbl.glVertex3sv = emu_glVertex3sv;
   tbl.glVertex4d = emu_glVertex4d;
   tbl.glVertex4dv = emu_glVertex4dv;
   tbl.glVertex4f = emu_glVertex4f;
   tbl.glVertex4fv = emu_glVertex4fv;
   tbl.glVertex4i = emu_glVertex4i;
   tbl.glVertex4iv = emu_glVertex4iv;
   tbl.glVertex4s = emu_glVertex4s;
   tbl.glVertex4sv = emu_glVertex4sv;
   tbl.glViewport = emu_glViewport;

// GL_VERSION_1_1

   tbl.glBindTexture = emu_glBindTexture;
   tbl.glColorPointer = emu_glColorPointer;
   tbl.glCopyTexImage2D = emu_glCopyTexImage2D;
   tbl.glDeleteTextures = emu_glDeleteTextures;
   tbl.glDisableClientState = emu_glDisableClientState;
   tbl.glDrawArrays = emu_glDrawArrays;
   tbl.glDrawElements = emu_glDrawElements;
   tbl.glEdgeFlagPointer = emu_glEdgeFlagPointer;
   tbl.glEnableClientState = emu_glEnableClientState;
   tbl.glGenTextures = emu_glGenTextures;
   tbl.glIndexPointer = emu_glIndexPointer;
   tbl.glInterleavedArrays = emu_glInterleavedArrays;
   tbl.glIsTexture = emu_glIsTexture;
   tbl.glNormalPointer = emu_glNormalPointer;
   tbl.glPolygonOffset = emu_glPolygonOffset;
   tbl.glPopClientAttrib = emu_glPopClientAttrib;
   tbl.glPushClientAttrib = emu_glPushClientAttrib;
   tbl.glTexCoordPointer = emu_glTexCoordPointer;
   tbl.glTexSubImage2D = emu_glTexSubImage2D;
   tbl.glVertexPointer = emu_glVertexPointer;

// GL_VERSION_1_2

   tbl.glBlendColor = emu_glBlendColor;
   tbl.glBlendEquation = emu_glBlendEquation;
   tbl.glDrawRangeElements = emu_glDrawRangeElements;
   tbl.glTexImage3D = emu_glTexImage3D;

// GL_VERSION_1_3

   tbl.glActiveTexture = emu_glActiveTexture;
   tbl.glClientActiveTexture = emu_glClientActiveTexture;
   tbl.glCompressedTexImage2D = emu_glCompressedTexImage2D;
   tbl.glCompressedTexSubImage2D = emu_glCompressedTexSubImage2D;
   tbl.glLoadTransposeMatrixd = emu_glLoadTransposeMatrixd;
   tbl.glLoadTransposeMatrixf = emu_glLoadTransposeMatrixf;
   tbl.glMultTransposeMatrixd = emu_glMultTransposeMatrixd;
   tbl.glMultTransposeMatrixf = emu_glMultTransposeMatrixf;
   tbl.glMultiTexCoord1d = emu_glMultiTexCoord1d;
   tbl.glMultiTexCoord1dv = emu_glMultiTexCoord1dv;
   tbl.glMultiTexCoord1f = emu_glMultiTexCoord1f;
   tbl.glMultiTexCoord1fv = emu_glMultiTexCoord1fv;
   tbl.glMultiTexCoord1i = emu_glMultiTexCoord1i;
   tbl.glMultiTexCoord1iv = emu_glMultiTexCoord1iv;
   tbl.glMultiTexCoord1s = emu_glMultiTexCoord1s;
   tbl.glMultiTexCoord1sv = emu_glMultiTexCoord1sv;
   tbl.glMultiTexCoord2d = emu_glMultiTexCoord2d;
   tbl.glMultiTexCoord2dv = emu_glMultiTexCoord2dv;
   tbl.glMultiTexCoord2f = emu_glMultiTexCoord2f;
   tbl.glMultiTexCoord2fv = emu_glMultiTexCoord2fv;
   tbl.glMultiTexCoord2i = emu_glMultiTexCoord2i;
   tbl.glMultiTexCoord2iv = emu_glMultiTexCoord2iv;
   tbl.glMultiTexCoord2s = emu_glMultiTexCoord2s;
   tbl.glMultiTexCoord2sv = emu_glMultiTexCoord2sv;
   tbl.glMultiTexCoord3d = emu_glMultiTexCoord3d;
   tbl.glMultiTexCoord3dv = emu_glMultiTexCoord3dv;
   tbl.glMultiTexCoord3f = emu_glMultiTexCoord3f;
   tbl.glMultiTexCoord3fv = emu_glMultiTexCoord3fv;
   tbl.glMultiTexCoord3i = emu_glMultiTexCoord3i;
   tbl.glMultiTexCoord3iv = emu_glMultiTexCoord3iv;
   tbl.glMultiTexCoord3s = emu_glMultiTexCoord3s;
   tbl.glMultiTexCoord3sv = emu_glMultiTexCoord3sv;
   tbl.glMultiTexCoord4d = emu_glMultiTexCoord4d;
   tbl.glMultiTexCoord4dv = emu_glMultiTexCoord4dv;
   tbl.glMultiTexCoord4f = emu_glMultiTexCoord4f;
   tbl.glMultiTexCoord4fv = emu_glMultiTexCoord4fv;
   tbl.glMultiTexCoord4i = emu_glMultiTexCoord4i;
   tbl.glMultiTexCoord4iv = emu_glMultiTexCoord4iv;
   tbl.glMultiTexCoord4s = emu_glMultiTexCoord4s;
   tbl.glMultiTexCoord4sv = emu_glMultiTexCoord4sv;
   tbl.glSampleCoverage = emu_glSampleCoverage;

// GL_VERSION_1_4

   tbl.glBlendFuncSeparate = emu_glBlendFuncSeparate;
   tbl.glFogCoordPointer = emu_glFogCoordPointer;
   tbl.glMultiDrawArrays = emu_glMultiDrawArrays;
   tbl.glMultiDrawElements = emu_glMultiDrawElements;
   tbl.glPointParameterf = emu_glPointParameterf;
   tbl.glPointParameterfv = emu_glPointParameterfv;
   tbl.glPointParameteri = emu_glPointParameteri;
   tbl.glPointParameteriv = emu_glPointParameteriv;
   tbl.glSecondaryColor3b = emu_glSecondaryColor3b;
   tbl.glSecondaryColor3bv = emu_glSecondaryColor3bv;
   tbl.glSecondaryColor3d = emu_glSecondaryColor3d;
   tbl.glSecondaryColor3dv = emu_glSecondaryColor3dv;
   tbl.glSecondaryColor3f = emu_glSecondaryColor3f;
   tbl.glSecondaryColor3fv = emu_glSecondaryColor3fv;
   tbl.glSecondaryColor3i = emu_glSecondaryColor3i;
   tbl.glSecondaryColor3iv = emu_glSecondaryColor3iv;
   tbl.glSecondaryColor3s = emu_glSecondaryColor3s;
   tbl.glSecondaryColor3sv = emu_glSecondaryColor3sv;
   tbl.glSecondaryColor3ub = emu_glSecondaryColor3ub;
   tbl.glSecondaryColor3ubv = emu_glSecondaryColor3ubv;
   tbl.glSecondaryColor3ui = emu_glSecondaryColor3ui;
   tbl.glSecondaryColor3uiv = emu_glSecondaryColor3uiv;
   tbl.glSecondaryColor3us = emu_glSecondaryColor3us;
   tbl.glSecondaryColor3usv = emu_glSecondaryColor3usv;
   tbl.glSecondaryColorPointer = emu_glSecondaryColorPointer;
   tbl.glWindowPos2d = emu_glWindowPos2d;
   tbl.glWindowPos2dv = emu_glWindowPos2dv;
   tbl.glWindowPos2f = emu_glWindowPos2f;
   tbl.glWindowPos2fv = emu_glWindowPos2fv;
   tbl.glWindowPos2i = emu_glWindowPos2i;
   tbl.glWindowPos2iv = emu_glWindowPos2iv;
   tbl.glWindowPos2s = emu_glWindowPos2s;
   tbl.glWindowPos2sv = emu_glWindowPos2sv;
   tbl.glWindowPos3d = emu_glWindowPos3d;
   tbl.glWindowPos3dv = emu_glWindowPos3dv;
   tbl.glWindowPos3f = emu_glWindowPos3f;
   tbl.glWindowPos3fv = emu_glWindowPos3fv;
   tbl.glWindowPos3i = emu_glWindowPos3i;
   tbl.glWindowPos3iv = emu_glWindowPos3iv;
   tbl.glWindowPos3s = emu_glWindowPos3s;
   tbl.glWindowPos3sv = emu_glWindowPos3sv;

// GL_VERSION_1_5

   tbl.glBindBuffer = emu_glBindBuffer;
   tbl.glBufferData = emu_glBufferData;
   tbl.glBufferSubData = emu_glBufferSubData;
   tbl.glDeleteBuffers = emu_glDeleteBuffers;
   tbl.glGenBuffers = emu_glGenBuffers;
   tbl.glGetBufferParameteriv = emu_glGetBufferParameteriv;
   tbl.glGetBufferPointerv = emu_glGetBufferPointerv;
   tbl.glGetBufferSubData = emu_glGetBufferSubData;
   tbl.glIsBuffer = emu_glIsBuffer;
   tbl.glMapBuffer = emu_glMapBuffer;
   tbl.glUnmapBuffer = emu_glUnmapBuffer;

// GL_VERSION_2_0

   tbl.glBlendEquationSeparate = emu_glBlendEquationSeparate;
   tbl.glCreateShader = emu_glCreateShader;
   tbl.glDeleteProgram = emu_glDeleteProgram;
   tbl.glDisableVertexAttribArray = emu_glDisableVertexAttribArray;
   tbl.glDrawBuffers = emu_glDrawBuffers;
   tbl.glEnableVertexAttribArray = emu_glEnableVertexAttribArray;
   tbl.glGetVertexAttribPointerv = emu_glGetVertexAttribPointerv;
   tbl.glGetVertexAttribdv = emu_glGetVertexAttribdv;
   tbl.glGetVertexAttribfv = emu_glGetVertexAttribfv;
   tbl.glGetVertexAttribiv = emu_glGetVertexAttribiv;
   tbl.glLinkProgram = emu_glLinkProgram;
   tbl.glShaderSource = emu_glShaderSource;
   tbl.glStencilFuncSeparate = emu_glStencilFuncSeparate;
   tbl.glStencilMaskSeparate = emu_glStencilMaskSeparate;
   tbl.glStencilOpSeparate = emu_glStencilOpSeparate;
   tbl.glUniform1f = emu_glUniform1f;
   tbl.glUniform1fv = emu_glUniform1fv;
   tbl.glUniform1i = emu_glUniform1i;
   tbl.glUniform1iv = emu_glUniform1iv;
   tbl.glUniform2f = emu_glUniform2f;
   tbl.glUniform2fv = emu_glUniform2fv;
   tbl.glUniform2i = emu_glUniform2i;
   tbl.glUniform2iv = emu_glUniform2iv;
   tbl.glUniform3f = emu_glUniform3f;
   tbl.glUniform3fv = emu_glUniform3fv;
   tbl.glUniform3i = emu_glUniform3i;
   tbl.glUniform3iv = emu_glUniform3iv;
   tbl.glUniform4f = emu_glUniform4f;
   tbl.glUniform4fv = emu_glUniform4fv;
   tbl.glUniform4i = emu_glUniform4i;
   tbl.glUniform4iv = emu_glUniform4iv;
   tbl.glUniformMatrix2fv = emu_glUniformMatrix2fv;
   tbl.glUniformMatrix3fv = emu_glUniformMatrix3fv;
   tbl.glUniformMatrix4fv = emu_glUniformMatrix4fv;
   tbl.glUseProgram = emu_glUseProgram;
   tbl.glVertexAttrib1d = emu_glVertexAttrib1d;
   tbl.glVertexAttrib1dv = emu_glVertexAttrib1dv;
   tbl.glVertexAttrib1f = emu_glVertexAttrib1f;
   tbl.glVertexAttrib1fv = emu_glVertexAttrib1fv;
   tbl.glVertexAttrib1s = emu_glVertexAttrib1s;
   tbl.glVertexAttrib1sv = emu_glVertexAttrib1sv;
   tbl.glVertexAttrib2d = emu_glVertexAttrib2d;
   tbl.glVertexAttrib2dv = emu_glVertexAttrib2dv;
   tbl.glVertexAttrib2f = emu_glVertexAttrib2f;
   tbl.glVertexAttrib2fv = emu_glVertexAttrib2fv;
   tbl.glVertexAttrib2s = emu_glVertexAttrib2s;
   tbl.glVertexAttrib2sv = emu_glVertexAttrib2sv;
   tbl.glVertexAttrib3d = emu_glVertexAttrib3d;
   tbl.glVertexAttrib3dv = emu_glVertexAttrib3dv;
   tbl.glVertexAttrib3f = emu_glVertexAttrib3f;
   tbl.glVertexAttrib3fv = emu_glVertexAttrib3fv;
   tbl.glVertexAttrib3s = emu_glVertexAttrib3s;
   tbl.glVertexAttrib3sv = emu_glVertexAttrib3sv;
   tbl.glVertexAttrib4Nbv = emu_glVertexAttrib4Nbv;
   tbl.glVertexAttrib4Niv = emu_glVertexAttrib4Niv;
   tbl.glVertexAttrib4Nsv = emu_glVertexAttrib4Nsv;
   tbl.glVertexAttrib4Nub = emu_glVertexAttrib4Nub;
   tbl.glVertexAttrib4Nubv = emu_glVertexAttrib4Nubv;
   tbl.glVertexAttrib4Nusv = emu_glVertexAttrib4Nusv;
   tbl.glVertexAttrib4bv = emu_glVertexAttrib4bv;
   tbl.glVertexAttrib4d = emu_glVertexAttrib4d;
   tbl.glVertexAttrib4dv = emu_glVertexAttrib4dv;
   tbl.glVertexAttrib4f = emu_glVertexAttrib4f;
   tbl.glVertexAttrib4fv = emu_glVertexAttrib4fv;
   tbl.glVertexAttrib4iv = emu_glVertexAttrib4iv;
   tbl.glVertexAttrib4s = emu_glVertexAttrib4s;
   tbl.glVertexAttrib4sv = emu_glVertexAttrib4sv;
   tbl.glVertexAttrib4ubv = emu_glVertexAttrib4ubv;
   tbl.glVertexAttrib4usv = emu_glVertexAttrib4usv;
   tbl.glVertexAttribPointer = emu_glVertexAttribPointer;

// GL_VERSION_2_1

   tbl.glUniformMatrix2x3fv = emu_glUniformMatrix2x3fv;
   tbl.glUniformMatrix2x4fv = emu_glUniformMatrix2x4fv;
   tbl.glUniformMatrix3x2fv = emu_glUniformMatrix3x2fv;
   tbl.glUniformMatrix3x4fv = emu_glUniformMatrix3x4fv;
   tbl.glUniformMatrix4x2fv = emu_glUniformMatrix4x2fv;
   tbl.glUniformMatrix4x3fv = emu_glUniformMatrix4x3fv;

// GL_VERSION_3_0

   tbl.glClampColor = emu_glClampColor;
   tbl.glColorMaski = emu_glColorMaski;
   tbl.glDisablei = emu_glDisablei;
   tbl.glEnablei = emu_glEnablei;
   tbl.glGetBooleani_v = emu_glGetBooleani_v;
   tbl.glGetTexParameterIiv = emu_glGetTexParameterIiv;
   tbl.glGetTexParameterIuiv = emu_glGetTexParameterIuiv;
   tbl.glIsEnabledi = emu_glIsEnabledi;
   tbl.glTexParameterIiv = emu_glTexParameterIiv;
   tbl.glTexParameterIuiv = emu_glTexParameterIuiv;
   tbl.glUniform1ui = emu_glUniform1ui;
   tbl.glUniform1uiv = emu_glUniform1uiv;
   tbl.glUniform2ui = emu_glUniform2ui;
   tbl.glUniform2uiv = emu_glUniform2uiv;
   tbl.glUniform3ui = emu_glUniform3ui;
   tbl.glUniform3uiv = emu_glUniform3uiv;
   tbl.glUniform4ui = emu_glUniform4ui;
   tbl.glUniform4uiv = emu_glUniform4uiv;
   tbl.glVertexAttribIPointer = emu_glVertexAttribIPointer;

// GL_VERSION_3_1

   tbl.glDrawArraysInstanced = emu_glDrawArraysInstanced;
   tbl.glDrawElementsInstanced = emu_glDrawElementsInstanced;
   tbl.glPrimitiveRestartIndex = emu_glPrimitiveRestartIndex;
   tbl.glTexBuffer = emu_glTexBuffer;

// GL_VERSION_3_2

   tbl.glFramebufferTexture = emu_glFramebufferTexture;

// GL_VERSION_3_3

   tbl.glVertexAttribDivisor = emu_glVertexAttribDivisor;

// GL_VERSION_4_0

   tbl.glBlendEquationSeparatei = emu_glBlendEquationSeparatei;
   tbl.glBlendEquationi = emu_glBlendEquationi;
   tbl.glBlendFuncSeparatei = emu_glBlendFuncSeparatei;
   tbl.glBlendFunci = emu_glBlendFunci;

// GL_AMD_multi_draw_indirect

   tbl.glMultiDrawArraysIndirectAMD = emu_glMultiDrawArraysIndirectAMD;
   tbl.glMultiDrawElementsIndirectAMD = emu_glMultiDrawElementsIndirectAMD;

// GL_ANGLE_framebuffer_blit

   tbl.glBlitFramebufferANGLE = emu_glBlitFramebufferANGLE;

// GL_APPLE_element_array

   tbl.glDrawElementArrayAPPLE = emu_glDrawElementArrayAPPLE;
   tbl.glDrawRangeElementArrayAPPLE = emu_glDrawRangeElementArrayAPPLE;
   tbl.glMultiDrawElementArrayAPPLE = emu_glMultiDrawElementArrayAPPLE;
   tbl.glMultiDrawRangeElementArrayAPPLE = emu_glMultiDrawRangeElementArrayAPPLE;

// GL_APPLE_vertex_array_object

   tbl.glBindVertexArrayAPPLE = emu_glBindVertexArrayAPPLE;
   tbl.glDeleteVertexArraysAPPLE = emu_glDeleteVertexArraysAPPLE;

// GL_ARB_ES2_compatibility

   tbl.glClearDepthf = emu_glClearDepthf;
   tbl.glDepthRangef = emu_glDepthRangef;
   tbl.glShaderBinary = emu_glShaderBinary;

// GL_ARB_base_instance

   tbl.glDrawElementsInstancedBaseVertexBaseInstance = emu_glDrawElementsInstancedBaseVertexBaseInstance;

// GL_ARB_copy_buffer

   tbl.glCopyBufferSubData = emu_glCopyBufferSubData;

// GL_ARB_draw_buffers

   tbl.glDrawBuffersARB = emu_glDrawBuffersARB;

// GL_ARB_draw_elements_base_vertex

   tbl.glDrawElementsBaseVertex = emu_glDrawElementsBaseVertex;
   tbl.glDrawElementsInstancedBaseVertex = emu_glDrawElementsInstancedBaseVertex;
   tbl.glDrawRangeElementsBaseVertex = emu_glDrawRangeElementsBaseVertex;
   tbl.glMultiDrawElementsBaseVertex = emu_glMultiDrawElementsBaseVertex;

// GL_ARB_draw_indirect

   tbl.glDrawArraysIndirect = emu_glDrawArraysIndirect;
   tbl.glDrawElementsIndirect = emu_glDrawElementsIndirect;

// GL_ARB_draw_instanced

   tbl.glDrawArraysInstancedARB = emu_glDrawArraysInstancedARB;
   tbl.glDrawElementsInstancedARB = emu_glDrawElementsInstancedARB;

// GL_ARB_framebuffer_object

   tbl.glBindFramebuffer = emu_glBindFramebuffer;
   tbl.glBindRenderbuffer = emu_glBindRenderbuffer;
   tbl.glBlitFramebuffer = emu_glBlitFramebuffer;
   tbl.glDeleteFramebuffers = emu_glDeleteFramebuffers;
   tbl.glDeleteRenderbuffers = emu_glDeleteRenderbuffers;
   tbl.glFramebufferRenderbuffer = emu_glFramebufferRenderbuffer;
   tbl.glFramebufferTexture1D = emu_glFramebufferTexture1D;
   tbl.glFramebufferTexture2D = emu_glFramebufferTexture2D;
   tbl.glFramebufferTexture3D = emu_glFramebufferTexture3D;
   tbl.glFramebufferTextureLayer = emu_glFramebufferTextureLayer;
   tbl.glGenerateMipmap = emu_glGenerateMipmap;
   tbl.glGetFramebufferAttachmentParameteriv = emu_glGetFramebufferAttachmentParameteriv;
   tbl.glGetRenderbufferParameteriv = emu_glGetRenderbufferParameteriv;
   tbl.glRenderbufferStorage = emu_glRenderbufferStorage;
   tbl.glRenderbufferStorageMultisample = emu_glRenderbufferStorageMultisample;

// GL_ARB_geometry_shader4

   tbl.glFramebufferTextureARB = emu_glFramebufferTextureARB;
   tbl.glFramebufferTextureFaceARB = emu_glFramebufferTextureFaceARB;
   tbl.glFramebufferTextureLayerARB = emu_glFramebufferTextureLayerARB;

// GL_ARB_gpu_shader_fp64

   tbl.glUniform1d = emu_glUniform1d;
   tbl.glUniform1dv = emu_glUniform1dv;
   tbl.glUniform2d = emu_glUniform2d;
   tbl.glUniform2dv = emu_glUniform2dv;
   tbl.glUniform3d = emu_glUniform3d;
   tbl.glUniform3dv = emu_glUniform3dv;
   tbl.glUniform4d = emu_glUniform4d;
   tbl.glUniform4dv = emu_glUniform4dv;
   tbl.glUniformMatrix2dv = emu_glUniformMatrix2dv;
   tbl.glUniformMatrix2x3dv = emu_glUniformMatrix2x3dv;
   tbl.glUniformMatrix2x4dv = emu_glUniformMatrix2x4dv;
   tbl.glUniformMatrix3dv = emu_glUniformMatrix3dv;
   tbl.glUniformMatrix3x2dv = emu_glUniformMatrix3x2dv;
   tbl.glUniformMatrix3x4dv = emu_glUniformMatrix3x4dv;
   tbl.glUniformMatrix4dv = emu_glUniformMatrix4dv;
   tbl.glUniformMatrix4x2dv = emu_glUniformMatrix4x2dv;
   tbl.glUniformMatrix4x3dv = emu_glUniformMatrix4x3dv;

// GL_ARB_imaging

   tbl.glColorTableParameterfv = emu_glColorTableParameterfv;
   tbl.glColorTableParameteriv = emu_glColorTableParameteriv;
   tbl.glConvolutionParameterf = emu_glConvolutionParameterf;
   tbl.glConvolutionParameterfv = emu_glConvolutionParameterfv;
   tbl.glConvolutionParameteri = emu_glConvolutionParameteri;
   tbl.glConvolutionParameteriv = emu_glConvolutionParameteriv;
   tbl.glGetColorTableParameterfv = emu_glGetColorTableParameterfv;
   tbl.glGetColorTableParameteriv = emu_glGetColorTableParameteriv;
   tbl.glGetConvolutionParameterfv = emu_glGetConvolutionParameterfv;
   tbl.glGetConvolutionParameteriv = emu_glGetConvolutionParameteriv;

// GL_ARB_map_buffer_range

   tbl.glFlushMappedBufferRange = emu_glFlushMappedBufferRange;
   tbl.glMapBufferRange = emu_glMapBufferRange;

// GL_ARB_multi_bind

   tbl.glBindVertexBuffers = emu_glBindVertexBuffers;

// GL_ARB_multi_draw_indirect

   tbl.glMultiDrawArraysIndirect = emu_glMultiDrawArraysIndirect;
   tbl.glMultiDrawElementsIndirect = emu_glMultiDrawElementsIndirect;

// GL_ARB_multitexture

   tbl.glActiveTextureARB = emu_glActiveTextureARB;
   tbl.glClientActiveTextureARB = emu_glClientActiveTextureARB;
   tbl.glMultiTexCoord1dARB = emu_glMultiTexCoord1dARB;
   tbl.glMultiTexCoord1dvARB = emu_glMultiTexCoord1dvARB;
   tbl.glMultiTexCoord1fARB = emu_glMultiTexCoord1fARB;
   tbl.glMultiTexCoord1fvARB = emu_glMultiTexCoord1fvARB;
   tbl.glMultiTexCoord1iARB = emu_glMultiTexCoord1iARB;
   tbl.glMultiTexCoord1ivARB = emu_glMultiTexCoord1ivARB;
   tbl.glMultiTexCoord1sARB = emu_glMultiTexCoord1sARB;
   tbl.glMultiTexCoord1svARB = emu_glMultiTexCoord1svARB;
   tbl.glMultiTexCoord2dARB = emu_glMultiTexCoord2dARB;
   tbl.glMultiTexCoord2dvARB = emu_glMultiTexCoord2dvARB;
   tbl.glMultiTexCoord2fARB = emu_glMultiTexCoord2fARB;
   tbl.glMultiTexCoord2fvARB = emu_glMultiTexCoord2fvARB;
   tbl.glMultiTexCoord2iARB = emu_glMultiTexCoord2iARB;
   tbl.glMultiTexCoord2ivARB = emu_glMultiTexCoord2ivARB;
   tbl.glMultiTexCoord2sARB = emu_glMultiTexCoord2sARB;
   tbl.glMultiTexCoord2svARB = emu_glMultiTexCoord2svARB;
   tbl.glMultiTexCoord3dARB = emu_glMultiTexCoord3dARB;
   tbl.glMultiTexCoord3dvARB = emu_glMultiTexCoord3dvARB;
   tbl.glMultiTexCoord3fARB = emu_glMultiTexCoord3fARB;
   tbl.glMultiTexCoord3fvARB = emu_glMultiTexCoord3fvARB;
   tbl.glMultiTexCoord3iARB = emu_glMultiTexCoord3iARB;
   tbl.glMultiTexCoord3ivARB = emu_glMultiTexCoord3ivARB;
   tbl.glMultiTexCoord3sARB = emu_glMultiTexCoord3sARB;
   tbl.glMultiTexCoord3svARB = emu_glMultiTexCoord3svARB;
   tbl.glMultiTexCoord4dARB = emu_glMultiTexCoord4dARB;
   tbl.glMultiTexCoord4dvARB = emu_glMultiTexCoord4dvARB;
   tbl.glMultiTexCoord4fARB = emu_glMultiTexCoord4fARB;
   tbl.glMultiTexCoord4fvARB = emu_glMultiTexCoord4fvARB;
   tbl.glMultiTexCoord4iARB = emu_glMultiTexCoord4iARB;
   tbl.glMultiTexCoord4ivARB = emu_glMultiTexCoord4ivARB;
   tbl.glMultiTexCoord4sARB = emu_glMultiTexCoord4sARB;
   tbl.glMultiTexCoord4svARB = emu_glMultiTexCoord4svARB;

// GL_ARB_provoking_vertex

   tbl.glProvokingVertex = emu_glProvokingVertex;

// GL_ARB_sample_shading

   tbl.glMinSampleShading = emu_glMinSampleShading;

// GL_ARB_sampler_objects

   tbl.glBindSampler = emu_glBindSampler;
   tbl.glDeleteSamplers = emu_glDeleteSamplers;
   tbl.glGenSamplers = emu_glGenSamplers;
   tbl.glGetSamplerParameterIiv = emu_glGetSamplerParameterIiv;
   tbl.glGetSamplerParameterIuiv = emu_glGetSamplerParameterIuiv;
   tbl.glGetSamplerParameterfv = emu_glGetSamplerParameterfv;
   tbl.glGetSamplerParameteriv = emu_glGetSamplerParameteriv;
   tbl.glIsSampler = emu_glIsSampler;
   tbl.glSamplerParameterIiv = emu_glSamplerParameterIiv;
   tbl.glSamplerParameterIuiv = emu_glSamplerParameterIuiv;
   tbl.glSamplerParameterf = emu_glSamplerParameterf;
   tbl.glSamplerParameterfv = emu_glSamplerParameterfv;
   tbl.glSamplerParameteri = emu_glSamplerParameteri;
   tbl.glSamplerParameteriv = emu_glSamplerParameteriv;

// GL_ARB_separate_shader_objects

   tbl.glBindProgramPipeline = emu_glBindProgramPipeline;

// GL_ARB_shader_objects

   tbl.glAttachObjectARB = emu_glAttachObjectARB;
   tbl.glCompileShaderARB = emu_glCompileShaderARB;
   tbl.glCreateProgramObjectARB = emu_glCreateProgramObjectARB;
   tbl.glCreateShaderObjectARB = emu_glCreateShaderObjectARB;
   tbl.glGetInfoLogARB = emu_glGetInfoLogARB;
   tbl.glGetObjectParameterivARB = emu_glGetObjectParameterivARB;
   tbl.glGetUniformLocationARB = emu_glGetUniformLocationARB;
   tbl.glLinkProgramARB = emu_glLinkProgramARB;
   tbl.glShaderSourceARB = emu_glShaderSourceARB;
   tbl.glUniform1iARB = emu_glUniform1iARB;

// GL_ARB_sync

   tbl.glGetInteger64v = emu_glGetInteger64v;

// GL_ARB_texture_compression

   tbl.glCompressedTexImage2DARB = emu_glCompressedTexImage2DARB;
   tbl.glCompressedTexSubImage2DARB = emu_glCompressedTexSubImage2DARB;

// GL_ARB_texture_multisample

   tbl.glTexImage2DMultisample = emu_glTexImage2DMultisample;
   tbl.glTexImage3DMultisample = emu_glTexImage3DMultisample;

// GL_ARB_texture_storage

   tbl.glTexStorage1D = emu_glTexStorage1D;
   tbl.glTexStorage2D = emu_glTexStorage2D;
   tbl.glTexStorage3D = emu_glTexStorage3D;
   tbl.glTextureStorage1DEXT = emu_glTextureStorage1DEXT;
   tbl.glTextureStorage2DEXT = emu_glTextureStorage2DEXT;
   tbl.glTextureStorage3DEXT = emu_glTextureStorage3DEXT;

// GL_ARB_transpose_matrix

   tbl.glLoadTransposeMatrixdARB = emu_glLoadTransposeMatrixdARB;
   tbl.glLoadTransposeMatrixfARB = emu_glLoadTransposeMatrixfARB;
   tbl.glMultTransposeMatrixdARB = emu_glMultTransposeMatrixdARB;
   tbl.glMultTransposeMatrixfARB = emu_glMultTransposeMatrixfARB;

// GL_ARB_uniform_buffer_object

   tbl.glGetIntegeri_v = emu_glGetIntegeri_v;

// GL_ARB_vertex_array_object

   tbl.glBindVertexArray = emu_glBindVertexArray;
   tbl.glDeleteVertexArrays = emu_glDeleteVertexArrays;
   tbl.glGenVertexArrays = emu_glGenVertexArrays;
   tbl.glIsVertexArray = emu_glIsVertexArray;

// GL_ARB_vertex_attrib_64bit

   tbl.glVertexAttribLPointer = emu_glVertexAttribLPointer;

// GL_ARB_vertex_attrib_binding

   tbl.glBindVertexBuffer = emu_glBindVertexBuffer;
   tbl.glVertexAttribBinding = emu_glVertexAttribBinding;
   tbl.glVertexAttribFormat = emu_glVertexAttribFormat;
   tbl.glVertexAttribIFormat = emu_glVertexAttribIFormat;
   tbl.glVertexAttribLFormat = emu_glVertexAttribLFormat;
   tbl.glVertexBindingDivisor = emu_glVertexBindingDivisor;

// GL_ARB_vertex_buffer_object

   tbl.glBindBufferARB = emu_glBindBufferARB;
   tbl.glBufferDataARB = emu_glBufferDataARB;
   tbl.glDeleteBuffersARB = emu_glDeleteBuffersARB;
   tbl.glGenBuffersARB = emu_glGenBuffersARB;
   tbl.glIsBufferARB = emu_glIsBufferARB;
   tbl.glMapBufferARB = emu_glMapBufferARB;
   tbl.glUnmapBufferARB = emu_glUnmapBufferARB;

// GL_ARB_vertex_program

   tbl.glBindProgramARB = emu_glBindProgramARB;
   tbl.glDeleteProgramsARB = emu_glDeleteProgramsARB;
   tbl.glDisableVertexAttribArrayARB = emu_glDisableVertexAttribArrayARB;
   tbl.glEnableVertexAttribArrayARB = emu_glEnableVertexAttribArrayARB;
   tbl.glGenProgramsARB = emu_glGenProgramsARB;
   tbl.glGetProgramEnvParameterdvARB = emu_glGetProgramEnvParameterdvARB;
   tbl.glGetProgramEnvParameterfvARB = emu_glGetProgramEnvParameterfvARB;
   tbl.glGetProgramLocalParameterdvARB = emu_glGetProgramLocalParameterdvARB;
   tbl.glGetProgramLocalParameterfvARB = emu_glGetProgramLocalParameterfvARB;
   tbl.glGetProgramivARB = emu_glGetProgramivARB;
   tbl.glGetVertexAttribPointervARB = emu_glGetVertexAttribPointervARB;
   tbl.glGetVertexAttribdvARB = emu_glGetVertexAttribdvARB;
   tbl.glGetVertexAttribfvARB = emu_glGetVertexAttribfvARB;
   tbl.glGetVertexAttribivARB = emu_glGetVertexAttribivARB;
   tbl.glProgramEnvParameter4dARB = emu_glProgramEnvParameter4dARB;
   tbl.glProgramEnvParameter4dvARB = emu_glProgramEnvParameter4dvARB;
   tbl.glProgramEnvParameter4fARB = emu_glProgramEnvParameter4fARB;
   tbl.glProgramEnvParameter4fvARB = emu_glProgramEnvParameter4fvARB;
   tbl.glProgramLocalParameter4dARB = emu_glProgramLocalParameter4dARB;
   tbl.glProgramLocalParameter4dvARB = emu_glProgramLocalParameter4dvARB;
   tbl.glProgramLocalParameter4fARB = emu_glProgramLocalParameter4fARB;
   tbl.glProgramLocalParameter4fvARB = emu_glProgramLocalParameter4fvARB;
   tbl.glProgramStringARB = emu_glProgramStringARB;
   tbl.glVertexAttrib1dARB = emu_glVertexAttrib1dARB;
   tbl.glVertexAttrib1dvARB = emu_glVertexAttrib1dvARB;
   tbl.glVertexAttrib1fARB = emu_glVertexAttrib1fARB;
   tbl.glVertexAttrib1fvARB = emu_glVertexAttrib1fvARB;
   tbl.glVertexAttrib1sARB = emu_glVertexAttrib1sARB;
   tbl.glVertexAttrib1svARB = emu_glVertexAttrib1svARB;
   tbl.glVertexAttrib2dARB = emu_glVertexAttrib2dARB;
   tbl.glVertexAttrib2dvARB = emu_glVertexAttrib2dvARB;
   tbl.glVertexAttrib2fARB = emu_glVertexAttrib2fARB;
   tbl.glVertexAttrib2fvARB = emu_glVertexAttrib2fvARB;
   tbl.glVertexAttrib2sARB = emu_glVertexAttrib2sARB;
   tbl.glVertexAttrib2svARB = emu_glVertexAttrib2svARB;
   tbl.glVertexAttrib3dARB = emu_glVertexAttrib3dARB;
   tbl.glVertexAttrib3dvARB = emu_glVertexAttrib3dvARB;
   tbl.glVertexAttrib3fARB = emu_glVertexAttrib3fARB;
   tbl.glVertexAttrib3fvARB = emu_glVertexAttrib3fvARB;
   tbl.glVertexAttrib3sARB = emu_glVertexAttrib3sARB;
   tbl.glVertexAttrib3svARB = emu_glVertexAttrib3svARB;
   tbl.glVertexAttrib4NbvARB = emu_glVertexAttrib4NbvARB;
   tbl.glVertexAttrib4NivARB = emu_glVertexAttrib4NivARB;
   tbl.glVertexAttrib4NsvARB = emu_glVertexAttrib4NsvARB;
   tbl.glVertexAttrib4NubARB = emu_glVertexAttrib4NubARB;
   tbl.glVertexAttrib4NubvARB = emu_glVertexAttrib4NubvARB;
   tbl.glVertexAttrib4NusvARB = emu_glVertexAttrib4NusvARB;
   tbl.glVertexAttrib4bvARB = emu_glVertexAttrib4bvARB;
   tbl.glVertexAttrib4dARB = emu_glVertexAttrib4dARB;
   tbl.glVertexAttrib4dvARB = emu_glVertexAttrib4dvARB;
   tbl.glVertexAttrib4fARB = emu_glVertexAttrib4fARB;
   tbl.glVertexAttrib4fvARB = emu_glVertexAttrib4fvARB;
   tbl.glVertexAttrib4ivARB = emu_glVertexAttrib4ivARB;
   tbl.glVertexAttrib4sARB = emu_glVertexAttrib4sARB;
   tbl.glVertexAttrib4svARB = emu_glVertexAttrib4svARB;
   tbl.glVertexAttrib4ubvARB = emu_glVertexAttrib4ubvARB;
   tbl.glVertexAttrib4usvARB = emu_glVertexAttrib4usvARB;
   tbl.glVertexAttribPointerARB = emu_glVertexAttribPointerARB;

// GL_ARB_vertex_shader

   tbl.glBindAttribLocationARB = emu_glBindAttribLocationARB;

// GL_ARB_viewport_array

   tbl.glDepthRangeArrayv = emu_glDepthRangeArrayv;
   tbl.glDepthRangeIndexed = emu_glDepthRangeIndexed;
   tbl.glGetDoublei_v = emu_glGetDoublei_v;
   tbl.glGetFloati_v = emu_glGetFloati_v;
   tbl.glScissorArrayv = emu_glScissorArrayv;
   tbl.glScissorIndexed = emu_glScissorIndexed;
   tbl.glScissorIndexedv = emu_glScissorIndexedv;
   tbl.glViewportArrayv = emu_glViewportArrayv;
   tbl.glViewportIndexedf = emu_glViewportIndexedf;
   tbl.glViewportIndexedfv = emu_glViewportIndexedfv;

// GL_ATI_draw_buffers

   tbl.glDrawBuffersATI = emu_glDrawBuffersATI;

// GL_ATI_element_array

   tbl.glDrawElementArrayATI = emu_glDrawElementArrayATI;
   tbl.glDrawRangeElementArrayATI = emu_glDrawRangeElementArrayATI;

// GL_EXT_blend_color

   tbl.glBlendColorEXT = emu_glBlendColorEXT;

// GL_EXT_blend_minmax

   tbl.glBlendEquationEXT = emu_glBlendEquationEXT;

// GL_EXT_direct_state_access

   tbl.glBindMultiTextureEXT = emu_glBindMultiTextureEXT;
   tbl.glCheckNamedFramebufferStatusEXT = emu_glCheckNamedFramebufferStatusEXT;
   tbl.glClientAttribDefaultEXT = emu_glClientAttribDefaultEXT;
   tbl.glCompressedMultiTexImage1DEXT = emu_glCompressedMultiTexImage1DEXT;
   tbl.glCompressedMultiTexImage2DEXT = emu_glCompressedMultiTexImage2DEXT;
   tbl.glCompressedMultiTexImage3DEXT = emu_glCompressedMultiTexImage3DEXT;
   tbl.glCompressedMultiTexSubImage1DEXT = emu_glCompressedMultiTexSubImage1DEXT;
   tbl.glCompressedMultiTexSubImage2DEXT = emu_glCompressedMultiTexSubImage2DEXT;
   tbl.glCompressedMultiTexSubImage3DEXT = emu_glCompressedMultiTexSubImage3DEXT;
   tbl.glCompressedTextureImage1DEXT = emu_glCompressedTextureImage1DEXT;
   tbl.glCompressedTextureImage2DEXT = emu_glCompressedTextureImage2DEXT;
   tbl.glCompressedTextureImage3DEXT = emu_glCompressedTextureImage3DEXT;
   tbl.glCompressedTextureSubImage1DEXT = emu_glCompressedTextureSubImage1DEXT;
   tbl.glCompressedTextureSubImage2DEXT = emu_glCompressedTextureSubImage2DEXT;
   tbl.glCompressedTextureSubImage3DEXT = emu_glCompressedTextureSubImage3DEXT;
   tbl.glCopyMultiTexImage1DEXT = emu_glCopyMultiTexImage1DEXT;
   tbl.glCopyMultiTexImage2DEXT = emu_glCopyMultiTexImage2DEXT;
   tbl.glCopyMultiTexSubImage1DEXT = emu_glCopyMultiTexSubImage1DEXT;
   tbl.glCopyMultiTexSubImage2DEXT = emu_glCopyMultiTexSubImage2DEXT;
   tbl.glCopyMultiTexSubImage3DEXT = emu_glCopyMultiTexSubImage3DEXT;
   tbl.glCopyTextureImage1DEXT = emu_glCopyTextureImage1DEXT;
   tbl.glCopyTextureImage2DEXT = emu_glCopyTextureImage2DEXT;
   tbl.glCopyTextureSubImage1DEXT = emu_glCopyTextureSubImage1DEXT;
   tbl.glCopyTextureSubImage2DEXT = emu_glCopyTextureSubImage2DEXT;
   tbl.glCopyTextureSubImage3DEXT = emu_glCopyTextureSubImage3DEXT;
   tbl.glDisableClientStateIndexedEXT = emu_glDisableClientStateIndexedEXT;
   tbl.glDisableClientStateiEXT = emu_glDisableClientStateiEXT;
   tbl.glDisableVertexArrayAttribEXT = emu_glDisableVertexArrayAttribEXT;
   tbl.glDisableVertexArrayEXT = emu_glDisableVertexArrayEXT;
   tbl.glEnableClientStateIndexedEXT = emu_glEnableClientStateIndexedEXT;
   tbl.glEnableClientStateiEXT = emu_glEnableClientStateiEXT;
   tbl.glEnableVertexArrayAttribEXT = emu_glEnableVertexArrayAttribEXT;
   tbl.glEnableVertexArrayEXT = emu_glEnableVertexArrayEXT;
   tbl.glFlushMappedNamedBufferRangeEXT = emu_glFlushMappedNamedBufferRangeEXT;
   tbl.glFramebufferDrawBufferEXT = emu_glFramebufferDrawBufferEXT;
   tbl.glFramebufferDrawBuffersEXT = emu_glFramebufferDrawBuffersEXT;
   tbl.glFramebufferReadBufferEXT = emu_glFramebufferReadBufferEXT;
   tbl.glGenerateMultiTexMipmapEXT = emu_glGenerateMultiTexMipmapEXT;
   tbl.glGenerateTextureMipmapEXT = emu_glGenerateTextureMipmapEXT;
   tbl.glGetCompressedMultiTexImageEXT = emu_glGetCompressedMultiTexImageEXT;
   tbl.glGetCompressedTextureImageEXT = emu_glGetCompressedTextureImageEXT;
   tbl.glGetDoubleIndexedvEXT = emu_glGetDoubleIndexedvEXT;
   tbl.glGetDoublei_vEXT = emu_glGetDoublei_vEXT;
   tbl.glGetFloatIndexedvEXT = emu_glGetFloatIndexedvEXT;
   tbl.glGetFloati_vEXT = emu_glGetFloati_vEXT;
   tbl.glGetFramebufferParameterivEXT = emu_glGetFramebufferParameterivEXT;
   tbl.glGetMultiTexEnvfvEXT = emu_glGetMultiTexEnvfvEXT;
   tbl.glGetMultiTexEnvivEXT = emu_glGetMultiTexEnvivEXT;
   tbl.glGetMultiTexGendvEXT = emu_glGetMultiTexGendvEXT;
   tbl.glGetMultiTexGenfvEXT = emu_glGetMultiTexGenfvEXT;
   tbl.glGetMultiTexGenivEXT = emu_glGetMultiTexGenivEXT;
   tbl.glGetMultiTexImageEXT = emu_glGetMultiTexImageEXT;
   tbl.glGetMultiTexLevelParameterfvEXT = emu_glGetMultiTexLevelParameterfvEXT;
   tbl.glGetMultiTexLevelParameterivEXT = emu_glGetMultiTexLevelParameterivEXT;
   tbl.glGetMultiTexParameterIivEXT = emu_glGetMultiTexParameterIivEXT;
   tbl.glGetMultiTexParameterIuivEXT = emu_glGetMultiTexParameterIuivEXT;
   tbl.glGetMultiTexParameterfvEXT = emu_glGetMultiTexParameterfvEXT;
   tbl.glGetMultiTexParameterivEXT = emu_glGetMultiTexParameterivEXT;
   tbl.glGetNamedBufferParameterivEXT = emu_glGetNamedBufferParameterivEXT;
   tbl.glGetNamedBufferPointervEXT = emu_glGetNamedBufferPointervEXT;
   tbl.glGetNamedBufferSubDataEXT = emu_glGetNamedBufferSubDataEXT;
   tbl.glGetNamedFramebufferAttachmentParameterivEXT = emu_glGetNamedFramebufferAttachmentParameterivEXT;
   tbl.glGetNamedProgramLocalParameterIivEXT = emu_glGetNamedProgramLocalParameterIivEXT;
   tbl.glGetNamedProgramLocalParameterIuivEXT = emu_glGetNamedProgramLocalParameterIuivEXT;
   tbl.glGetNamedProgramLocalParameterdvEXT = emu_glGetNamedProgramLocalParameterdvEXT;
   tbl.glGetNamedProgramLocalParameterfvEXT = emu_glGetNamedProgramLocalParameterfvEXT;
   tbl.glGetNamedProgramStringEXT = emu_glGetNamedProgramStringEXT;
   tbl.glGetNamedProgramivEXT = emu_glGetNamedProgramivEXT;
   tbl.glGetNamedRenderbufferParameterivEXT = emu_glGetNamedRenderbufferParameterivEXT;
   tbl.glGetPointerIndexedvEXT = emu_glGetPointerIndexedvEXT;
   tbl.glGetTextureImageEXT = emu_glGetTextureImageEXT;
   tbl.glGetTextureLevelParameterfvEXT = emu_glGetTextureLevelParameterfvEXT;
   tbl.glGetTextureLevelParameterivEXT = emu_glGetTextureLevelParameterivEXT;
   tbl.glGetTextureParameterIivEXT = emu_glGetTextureParameterIivEXT;
   tbl.glGetTextureParameterIuivEXT = emu_glGetTextureParameterIuivEXT;
   tbl.glGetTextureParameterfvEXT = emu_glGetTextureParameterfvEXT;
   tbl.glGetTextureParameterivEXT = emu_glGetTextureParameterivEXT;
   tbl.glMapNamedBufferEXT = emu_glMapNamedBufferEXT;
   tbl.glMapNamedBufferRangeEXT = emu_glMapNamedBufferRangeEXT;
   tbl.glMatrixFrustumEXT = emu_glMatrixFrustumEXT;
   tbl.glMatrixLoadIdentityEXT = emu_glMatrixLoadIdentityEXT;
   tbl.glMatrixLoadTransposedEXT = emu_glMatrixLoadTransposedEXT;
   tbl.glMatrixLoadTransposefEXT = emu_glMatrixLoadTransposefEXT;
   tbl.glMatrixLoaddEXT = emu_glMatrixLoaddEXT;
   tbl.glMatrixLoadfEXT = emu_glMatrixLoadfEXT;
   tbl.glMatrixMultTransposedEXT = emu_glMatrixMultTransposedEXT;
   tbl.glMatrixMultTransposefEXT = emu_glMatrixMultTransposefEXT;
   tbl.glMatrixMultdEXT = emu_glMatrixMultdEXT;
   tbl.glMatrixMultfEXT = emu_glMatrixMultfEXT;
   tbl.glMatrixOrthoEXT = emu_glMatrixOrthoEXT;
   tbl.glMatrixPopEXT = emu_glMatrixPopEXT;
   tbl.glMatrixPushEXT = emu_glMatrixPushEXT;
   tbl.glMatrixRotatedEXT = emu_glMatrixRotatedEXT;
   tbl.glMatrixRotatefEXT = emu_glMatrixRotatefEXT;
   tbl.glMatrixScaledEXT = emu_glMatrixScaledEXT;
   tbl.glMatrixScalefEXT = emu_glMatrixScalefEXT;
   tbl.glMatrixTranslatedEXT = emu_glMatrixTranslatedEXT;
   tbl.glMatrixTranslatefEXT = emu_glMatrixTranslatefEXT;
   tbl.glMultiTexBufferEXT = emu_glMultiTexBufferEXT;
   tbl.glMultiTexCoordPointerEXT = emu_glMultiTexCoordPointerEXT;
   tbl.glMultiTexEnvfEXT = emu_glMultiTexEnvfEXT;
   tbl.glMultiTexEnvfvEXT = emu_glMultiTexEnvfvEXT;
   tbl.glMultiTexEnviEXT = emu_glMultiTexEnviEXT;
   tbl.glMultiTexEnvivEXT = emu_glMultiTexEnvivEXT;
   tbl.glMultiTexGendEXT = emu_glMultiTexGendEXT;
   tbl.glMultiTexGendvEXT = emu_glMultiTexGendvEXT;
   tbl.glMultiTexGenfEXT = emu_glMultiTexGenfEXT;
   tbl.glMultiTexGenfvEXT = emu_glMultiTexGenfvEXT;
   tbl.glMultiTexGeniEXT = emu_glMultiTexGeniEXT;
   tbl.glMultiTexGenivEXT = emu_glMultiTexGenivEXT;
   tbl.glMultiTexImage1DEXT = emu_glMultiTexImage1DEXT;
   tbl.glMultiTexImage2DEXT = emu_glMultiTexImage2DEXT;
   tbl.glMultiTexImage3DEXT = emu_glMultiTexImage3DEXT;
   tbl.glMultiTexParameterIivEXT = emu_glMultiTexParameterIivEXT;
   tbl.glMultiTexParameterIuivEXT = emu_glMultiTexParameterIuivEXT;
   tbl.glMultiTexParameterfEXT = emu_glMultiTexParameterfEXT;
   tbl.glMultiTexParameterfvEXT = emu_glMultiTexParameterfvEXT;
   tbl.glMultiTexParameteriEXT = emu_glMultiTexParameteriEXT;
   tbl.glMultiTexParameterivEXT = emu_glMultiTexParameterivEXT;
   tbl.glMultiTexRenderbufferEXT = emu_glMultiTexRenderbufferEXT;
   tbl.glMultiTexSubImage1DEXT = emu_glMultiTexSubImage1DEXT;
   tbl.glMultiTexSubImage2DEXT = emu_glMultiTexSubImage2DEXT;
   tbl.glMultiTexSubImage3DEXT = emu_glMultiTexSubImage3DEXT;
   tbl.glNamedBufferDataEXT = emu_glNamedBufferDataEXT;
   tbl.glNamedBufferSubDataEXT = emu_glNamedBufferSubDataEXT;
   tbl.glNamedCopyBufferSubDataEXT = emu_glNamedCopyBufferSubDataEXT;
   tbl.glNamedFramebufferRenderbufferEXT = emu_glNamedFramebufferRenderbufferEXT;
   tbl.glNamedFramebufferTexture1DEXT = emu_glNamedFramebufferTexture1DEXT;
   tbl.glNamedFramebufferTexture2DEXT = emu_glNamedFramebufferTexture2DEXT;
   tbl.glNamedFramebufferTexture3DEXT = emu_glNamedFramebufferTexture3DEXT;
   tbl.glNamedFramebufferTextureEXT = emu_glNamedFramebufferTextureEXT;
   tbl.glNamedFramebufferTextureFaceEXT = emu_glNamedFramebufferTextureFaceEXT;
   tbl.glNamedFramebufferTextureLayerEXT = emu_glNamedFramebufferTextureLayerEXT;
   tbl.glNamedProgramLocalParameter4dEXT = emu_glNamedProgramLocalParameter4dEXT;
   tbl.glNamedProgramLocalParameter4dvEXT = emu_glNamedProgramLocalParameter4dvEXT;
   tbl.glNamedProgramLocalParameter4fEXT = emu_glNamedProgramLocalParameter4fEXT;
   tbl.glNamedProgramLocalParameter4fvEXT = emu_glNamedProgramLocalParameter4fvEXT;
   tbl.glNamedProgramLocalParameterI4iEXT = emu_glNamedProgramLocalParameterI4iEXT;
   tbl.glNamedProgramLocalParameterI4ivEXT = emu_glNamedProgramLocalParameterI4ivEXT;
   tbl.glNamedProgramLocalParameterI4uiEXT = emu_glNamedProgramLocalParameterI4uiEXT;
   tbl.glNamedProgramLocalParameterI4uivEXT = emu_glNamedProgramLocalParameterI4uivEXT;
   tbl.glNamedProgramLocalParameters4fvEXT = emu_glNamedProgramLocalParameters4fvEXT;
   tbl.glNamedProgramLocalParametersI4ivEXT = emu_glNamedProgramLocalParametersI4ivEXT;
   tbl.glNamedProgramLocalParametersI4uivEXT = emu_glNamedProgramLocalParametersI4uivEXT;
   tbl.glNamedProgramStringEXT = emu_glNamedProgramStringEXT;
   tbl.glNamedRenderbufferStorageEXT = emu_glNamedRenderbufferStorageEXT;
   tbl.glNamedRenderbufferStorageMultisampleCoverageEXT = emu_glNamedRenderbufferStorageMultisampleCoverageEXT;
   tbl.glNamedRenderbufferStorageMultisampleEXT = emu_glNamedRenderbufferStorageMultisampleEXT;
   tbl.glProgramUniform1dEXT = emu_glProgramUniform1dEXT;
   tbl.glProgramUniform1dvEXT = emu_glProgramUniform1dvEXT;
   tbl.glProgramUniform1fEXT = emu_glProgramUniform1fEXT;
   tbl.glProgramUniform1fvEXT = emu_glProgramUniform1fvEXT;
   tbl.glProgramUniform1iEXT = emu_glProgramUniform1iEXT;
   tbl.glProgramUniform1ivEXT = emu_glProgramUniform1ivEXT;
   tbl.glProgramUniform1uiEXT = emu_glProgramUniform1uiEXT;
   tbl.glProgramUniform1uivEXT = emu_glProgramUniform1uivEXT;
   tbl.glProgramUniform2dEXT = emu_glProgramUniform2dEXT;
   tbl.glProgramUniform2dvEXT = emu_glProgramUniform2dvEXT;
   tbl.glProgramUniform2fEXT = emu_glProgramUniform2fEXT;
   tbl.glProgramUniform2fvEXT = emu_glProgramUniform2fvEXT;
   tbl.glProgramUniform2iEXT = emu_glProgramUniform2iEXT;
   tbl.glProgramUniform2ivEXT = emu_glProgramUniform2ivEXT;
   tbl.glProgramUniform2uiEXT = emu_glProgramUniform2uiEXT;
   tbl.glProgramUniform2uivEXT = emu_glProgramUniform2uivEXT;
   tbl.glProgramUniform3dEXT = emu_glProgramUniform3dEXT;
   tbl.glProgramUniform3dvEXT = emu_glProgramUniform3dvEXT;
   tbl.glProgramUniform3fEXT = emu_glProgramUniform3fEXT;
   tbl.glProgramUniform3fvEXT = emu_glProgramUniform3fvEXT;
   tbl.glProgramUniform3iEXT = emu_glProgramUniform3iEXT;
   tbl.glProgramUniform3ivEXT = emu_glProgramUniform3ivEXT;
   tbl.glProgramUniform3uiEXT = emu_glProgramUniform3uiEXT;
   tbl.glProgramUniform3uivEXT = emu_glProgramUniform3uivEXT;
   tbl.glProgramUniform4dEXT = emu_glProgramUniform4dEXT;
   tbl.glProgramUniform4dvEXT = emu_glProgramUniform4dvEXT;
   tbl.glProgramUniform4fEXT = emu_glProgramUniform4fEXT;
   tbl.glProgramUniform4fvEXT = emu_glProgramUniform4fvEXT;
   tbl.glProgramUniform4iEXT = emu_glProgramUniform4iEXT;
   tbl.glProgramUniform4ivEXT = emu_glProgramUniform4ivEXT;
   tbl.glProgramUniform4uiEXT = emu_glProgramUniform4uiEXT;
   tbl.glProgramUniform4uivEXT = emu_glProgramUniform4uivEXT;
   tbl.glProgramUniformMatrix2dvEXT = emu_glProgramUniformMatrix2dvEXT;
   tbl.glProgramUniformMatrix2fvEXT = emu_glProgramUniformMatrix2fvEXT;
   tbl.glProgramUniformMatrix2x3dvEXT = emu_glProgramUniformMatrix2x3dvEXT;
   tbl.glProgramUniformMatrix2x3fvEXT = emu_glProgramUniformMatrix2x3fvEXT;
   tbl.glProgramUniformMatrix2x4dvEXT = emu_glProgramUniformMatrix2x4dvEXT;
   tbl.glProgramUniformMatrix2x4fvEXT = emu_glProgramUniformMatrix2x4fvEXT;
   tbl.glProgramUniformMatrix3dvEXT = emu_glProgramUniformMatrix3dvEXT;
   tbl.glProgramUniformMatrix3fvEXT = emu_glProgramUniformMatrix3fvEXT;
   tbl.glProgramUniformMatrix3x2dvEXT = emu_glProgramUniformMatrix3x2dvEXT;
   tbl.glProgramUniformMatrix3x2fvEXT = emu_glProgramUniformMatrix3x2fvEXT;
   tbl.glProgramUniformMatrix3x4dvEXT = emu_glProgramUniformMatrix3x4dvEXT;
   tbl.glProgramUniformMatrix3x4fvEXT = emu_glProgramUniformMatrix3x4fvEXT;
   tbl.glProgramUniformMatrix4dvEXT = emu_glProgramUniformMatrix4dvEXT;
   tbl.glProgramUniformMatrix4fvEXT = emu_glProgramUniformMatrix4fvEXT;
   tbl.glProgramUniformMatrix4x2dvEXT = emu_glProgramUniformMatrix4x2dvEXT;
   tbl.glProgramUniformMatrix4x2fvEXT = emu_glProgramUniformMatrix4x2fvEXT;
   tbl.glProgramUniformMatrix4x3dvEXT = emu_glProgramUniformMatrix4x3dvEXT;
   tbl.glProgramUniformMatrix4x3fvEXT = emu_glProgramUniformMatrix4x3fvEXT;
   tbl.glPushClientAttribDefaultEXT = emu_glPushClientAttribDefaultEXT;
   tbl.glTextureBufferEXT = emu_glTextureBufferEXT;
   tbl.glTextureImage1DEXT = emu_glTextureImage1DEXT;
   tbl.glTextureImage2DEXT = emu_glTextureImage2DEXT;
   tbl.glTextureImage3DEXT = emu_glTextureImage3DEXT;
   tbl.glTextureParameterIivEXT = emu_glTextureParameterIivEXT;
   tbl.glTextureParameterIuivEXT = emu_glTextureParameterIuivEXT;
   tbl.glTextureParameterfEXT = emu_glTextureParameterfEXT;
   tbl.glTextureParameterfvEXT = emu_glTextureParameterfvEXT;
   tbl.glTextureParameteriEXT = emu_glTextureParameteriEXT;
   tbl.glTextureParameterivEXT = emu_glTextureParameterivEXT;
   tbl.glTextureRenderbufferEXT = emu_glTextureRenderbufferEXT;
   tbl.glTextureSubImage1DEXT = emu_glTextureSubImage1DEXT;
   tbl.glTextureSubImage2DEXT = emu_glTextureSubImage2DEXT;
   tbl.glTextureSubImage3DEXT = emu_glTextureSubImage3DEXT;
   tbl.glUnmapNamedBufferEXT = emu_glUnmapNamedBufferEXT;
   tbl.glVertexArrayColorOffsetEXT = emu_glVertexArrayColorOffsetEXT;
   tbl.glVertexArrayEdgeFlagOffsetEXT = emu_glVertexArrayEdgeFlagOffsetEXT;
   tbl.glVertexArrayFogCoordOffsetEXT = emu_glVertexArrayFogCoordOffsetEXT;
   tbl.glVertexArrayIndexOffsetEXT = emu_glVertexArrayIndexOffsetEXT;
   tbl.glVertexArrayMultiTexCoordOffsetEXT = emu_glVertexArrayMultiTexCoordOffsetEXT;
   tbl.glVertexArrayNormalOffsetEXT = emu_glVertexArrayNormalOffsetEXT;
   tbl.glVertexArraySecondaryColorOffsetEXT = emu_glVertexArraySecondaryColorOffsetEXT;
   tbl.glVertexArrayTexCoordOffsetEXT = emu_glVertexArrayTexCoordOffsetEXT;
   tbl.glVertexArrayVertexAttribIOffsetEXT = emu_glVertexArrayVertexAttribIOffsetEXT;
   tbl.glVertexArrayVertexAttribOffsetEXT = emu_glVertexArrayVertexAttribOffsetEXT;
   tbl.glVertexArrayVertexOffsetEXT = emu_glVertexArrayVertexOffsetEXT;

// GL_EXT_draw_buffers2

   tbl.glColorMaskIndexedEXT = emu_glColorMaskIndexedEXT;
   tbl.glDisableIndexedEXT = emu_glDisableIndexedEXT;
   tbl.glEnableIndexedEXT = emu_glEnableIndexedEXT;
   tbl.glGetBooleanIndexedvEXT = emu_glGetBooleanIndexedvEXT;
   tbl.glGetIntegerIndexedvEXT = emu_glGetIntegerIndexedvEXT;
   tbl.glIsEnabledIndexedEXT = emu_glIsEnabledIndexedEXT;

// GL_EXT_draw_instanced

   tbl.glDrawArraysInstancedEXT = emu_glDrawArraysInstancedEXT;
   tbl.glDrawElementsInstancedEXT = emu_glDrawElementsInstancedEXT;

// GL_EXT_draw_range_elements

   tbl.glDrawRangeElementsEXT = emu_glDrawRangeElementsEXT;

// GL_EXT_fog_coord

   tbl.glFogCoordPointerEXT = emu_glFogCoordPointerEXT;

// GL_EXT_framebuffer_blit

   tbl.glBlitFramebufferEXT = emu_glBlitFramebufferEXT;

// GL_EXT_framebuffer_multisample

   tbl.glRenderbufferStorageMultisampleEXT = emu_glRenderbufferStorageMultisampleEXT;

// GL_EXT_framebuffer_object

   tbl.glBindFramebufferEXT = emu_glBindFramebufferEXT;
   tbl.glBindRenderbufferEXT = emu_glBindRenderbufferEXT;
   tbl.glCheckFramebufferStatusEXT = emu_glCheckFramebufferStatusEXT;
   tbl.glDeleteFramebuffersEXT = emu_glDeleteFramebuffersEXT;
   tbl.glDeleteRenderbuffersEXT = emu_glDeleteRenderbuffersEXT;
   tbl.glFramebufferRenderbufferEXT = emu_glFramebufferRenderbufferEXT;
   tbl.glFramebufferTexture1DEXT = emu_glFramebufferTexture1DEXT;
   tbl.glFramebufferTexture2DEXT = emu_glFramebufferTexture2DEXT;
   tbl.glFramebufferTexture3DEXT = emu_glFramebufferTexture3DEXT;
   tbl.glGenFramebuffersEXT = emu_glGenFramebuffersEXT;
   tbl.glGenRenderbuffersEXT = emu_glGenRenderbuffersEXT;
   tbl.glGenerateMipmapEXT = emu_glGenerateMipmapEXT;
   tbl.glGetFramebufferAttachmentParameterivEXT = emu_glGetFramebufferAttachmentParameterivEXT;
   tbl.glGetRenderbufferParameterivEXT = emu_glGetRenderbufferParameterivEXT;
   tbl.glIsFramebufferEXT = emu_glIsFramebufferEXT;
   tbl.glIsRenderbufferEXT = emu_glIsRenderbufferEXT;
   tbl.glRenderbufferStorageEXT = emu_glRenderbufferStorageEXT;

// GL_EXT_geometry_shader4

   tbl.glFramebufferTextureEXT = emu_glFramebufferTextureEXT;
   tbl.glFramebufferTextureFaceEXT = emu_glFramebufferTextureFaceEXT;

// GL_EXT_map_buffer_range

   tbl.glFlushMappedBufferRangeEXT = emu_glFlushMappedBufferRangeEXT;
   tbl.glMapBufferRangeEXT = emu_glMapBufferRangeEXT;

// GL_EXT_multi_draw_arrays

   tbl.glMultiDrawArraysEXT = emu_glMultiDrawArraysEXT;
   tbl.glMultiDrawElementsEXT = emu_glMultiDrawElementsEXT;

// GL_EXT_multisampled_render_to_texture

   tbl.glFramebufferTexture2DMultisampleEXT = emu_glFramebufferTexture2DMultisampleEXT;

// GL_EXT_multiview_draw_buffers

   tbl.glGetIntegeri_vEXT = emu_glGetIntegeri_vEXT;

// GL_EXT_provoking_vertex

   tbl.glProvokingVertexEXT = emu_glProvokingVertexEXT;

// GL_EXT_secondary_color

   tbl.glSecondaryColor3bEXT = emu_glSecondaryColor3bEXT;
   tbl.glSecondaryColor3bvEXT = emu_glSecondaryColor3bvEXT;
   tbl.glSecondaryColor3dEXT = emu_glSecondaryColor3dEXT;
   tbl.glSecondaryColor3dvEXT = emu_glSecondaryColor3dvEXT;
   tbl.glSecondaryColor3fEXT = emu_glSecondaryColor3fEXT;
   tbl.glSecondaryColor3fvEXT = emu_glSecondaryColor3fvEXT;
   tbl.glSecondaryColor3iEXT = emu_glSecondaryColor3iEXT;
   tbl.glSecondaryColor3ivEXT = emu_glSecondaryColor3ivEXT;
   tbl.glSecondaryColor3sEXT = emu_glSecondaryColor3sEXT;
   tbl.glSecondaryColor3svEXT = emu_glSecondaryColor3svEXT;
   tbl.glSecondaryColor3ubEXT = emu_glSecondaryColor3ubEXT;
   tbl.glSecondaryColor3ubvEXT = emu_glSecondaryColor3ubvEXT;
   tbl.glSecondaryColor3uiEXT = emu_glSecondaryColor3uiEXT;
   tbl.glSecondaryColor3uivEXT = emu_glSecondaryColor3uivEXT;
   tbl.glSecondaryColor3usEXT = emu_glSecondaryColor3usEXT;
   tbl.glSecondaryColor3usvEXT = emu_glSecondaryColor3usvEXT;
   tbl.glSecondaryColorPointerEXT = emu_glSecondaryColorPointerEXT;

// GL_EXT_subtexture

   tbl.glTexSubImage2DEXT = emu_glTexSubImage2DEXT;

// GL_EXT_texture3D

   tbl.glTexImage3DEXT = emu_glTexImage3DEXT;

// GL_EXT_texture_array

   tbl.glFramebufferTextureLayerEXT = emu_glFramebufferTextureLayerEXT;

// GL_EXT_texture_integer

   tbl.glTexParameterIivEXT = emu_glTexParameterIivEXT;
   tbl.glTexParameterIuivEXT = emu_glTexParameterIuivEXT;

// GL_EXT_texture_object

   tbl.glBindTextureEXT = emu_glBindTextureEXT;
   tbl.glDeleteTexturesEXT = emu_glDeleteTexturesEXT;
   tbl.glGenTexturesEXT = emu_glGenTexturesEXT;

// GL_EXT_texture_storage

   tbl.glTexStorage1DEXT = emu_glTexStorage1DEXT;
   tbl.glTexStorage2DEXT = emu_glTexStorage2DEXT;
   tbl.glTexStorage3DEXT = emu_glTexStorage3DEXT;

// GL_EXT_vertex_array

   tbl.glColorPointerEXT = emu_glColorPointerEXT;
   tbl.glDrawArraysEXT = emu_glDrawArraysEXT;
   tbl.glEdgeFlagPointerEXT = emu_glEdgeFlagPointerEXT;
   tbl.glNormalPointerEXT = emu_glNormalPointerEXT;
   tbl.glTexCoordPointerEXT = emu_glTexCoordPointerEXT;
   tbl.glVertexPointerEXT = emu_glVertexPointerEXT;

// GL_NV_draw_buffers

   tbl.glDrawBuffersNV = emu_glDrawBuffersNV;

// GL_NV_explicit_multisample

   tbl.glTexRenderbufferNV = emu_glTexRenderbufferNV;

// GL_NV_framebuffer_multisample_coverage

   tbl.glRenderbufferStorageMultisampleCoverageNV = emu_glRenderbufferStorageMultisampleCoverageNV;

// GL_NV_gpu_program4

   tbl.glGetProgramEnvParameterIivNV = emu_glGetProgramEnvParameterIivNV;
   tbl.glGetProgramEnvParameterIuivNV = emu_glGetProgramEnvParameterIuivNV;
   tbl.glGetProgramLocalParameterIivNV = emu_glGetProgramLocalParameterIivNV;
   tbl.glGetProgramLocalParameterIuivNV = emu_glGetProgramLocalParameterIuivNV;
   tbl.glProgramEnvParameterI4iNV = emu_glProgramEnvParameterI4iNV;
   tbl.glProgramEnvParameterI4ivNV = emu_glProgramEnvParameterI4ivNV;
   tbl.glProgramEnvParameterI4uiNV = emu_glProgramEnvParameterI4uiNV;
   tbl.glProgramEnvParameterI4uivNV = emu_glProgramEnvParameterI4uivNV;
   tbl.glProgramEnvParametersI4ivNV = emu_glProgramEnvParametersI4ivNV;
   tbl.glProgramEnvParametersI4uivNV = emu_glProgramEnvParametersI4uivNV;
   tbl.glProgramLocalParameterI4iNV = emu_glProgramLocalParameterI4iNV;
   tbl.glProgramLocalParameterI4ivNV = emu_glProgramLocalParameterI4ivNV;
   tbl.glProgramLocalParameterI4uiNV = emu_glProgramLocalParameterI4uiNV;
   tbl.glProgramLocalParameterI4uivNV = emu_glProgramLocalParameterI4uivNV;
   tbl.glProgramLocalParametersI4ivNV = emu_glProgramLocalParametersI4ivNV;
   tbl.glProgramLocalParametersI4uivNV = emu_glProgramLocalParametersI4uivNV;

// GL_NV_texture_multisample

   tbl.glTexImage2DMultisampleCoverageNV = emu_glTexImage2DMultisampleCoverageNV;
   tbl.glTexImage3DMultisampleCoverageNV = emu_glTexImage3DMultisampleCoverageNV;

// GL_NV_vertex_program

   tbl.glDeleteProgramsNV = emu_glDeleteProgramsNV;

// GL_OES_framebuffer_object

   tbl.glBindFramebufferOES = emu_glBindFramebufferOES;
   tbl.glDeleteFramebuffersOES = emu_glDeleteFramebuffersOES;
   tbl.glDeleteRenderbuffersOES = emu_glDeleteRenderbuffersOES;
   tbl.glFramebufferTexture2DOES = emu_glFramebufferTexture2DOES;

// GL_OES_texture_3D

   tbl.glFramebufferTexture3DOES = emu_glFramebufferTexture3DOES;

// GL_OES_vertex_array_object

   tbl.glBindVertexArrayOES = emu_glBindVertexArrayOES;
   tbl.glDeleteVertexArraysOES = emu_glDeleteVertexArraysOES;

// GL_REGAL_ES1_0_compatibility

   tbl.glFogxv = emu_glFogxv;
   tbl.glLightModelxv = emu_glLightModelxv;
   tbl.glLightxv = emu_glLightxv;
   tbl.glLoadMatrixx = emu_glLoadMatrixx;
   tbl.glMaterialxv = emu_glMaterialxv;
   tbl.glMultMatrixx = emu_glMultMatrixx;
   tbl.glTexEnvxv = emu_glTexEnvxv;

// GL_REGAL_ES1_1_compatibility

   tbl.glClipPlanef = emu_glClipPlanef;
   tbl.glClipPlanex = emu_glClipPlanex;
   tbl.glGetClipPlanef = emu_glGetClipPlanef;
   tbl.glGetClipPlanex = emu_glGetClipPlanex;
   tbl.glGetFixedv = emu_glGetFixedv;
   tbl.glGetLightxv = emu_glGetLightxv;
   tbl.glGetMaterialxv = emu_glGetMaterialxv;
   tbl.glGetTexEnvxv = emu_glGetTexEnvxv;
   tbl.glGetTexParameterxv = emu_glGetTexParameterxv;
   tbl.glPointParameterx = emu_glPointParameterx;
   tbl.glPointParameterxv = emu_glPointParameterxv;
   tbl.glTexParameterxv = emu_glTexParameterxv;

// GL_SGIS_texture4D

   tbl.glTexImage4DSGIS = emu_glTexImage4DSGIS;

}

REGAL_NAMESPACE_END

#endif
